{"source":"docs/svelte/01-introduction/01-overview.md","question":"What is Svelte and how does it differ from traditional JavaScript frameworks?","answer":"Svelte is a framework for building user interfaces on the web, but it takes a fundamentally different approach compared to traditional JavaScript frameworks like React or Vue. The key difference is that Svelte is a compiler rather than a traditional runtime library.\n\nSvelte uses a compiler to turn declarative components written in HTML, CSS, and JavaScript into lean, tightly optimized JavaScript code during the build process, rather than interpreting your component code at runtime in the browser. This approach results in smaller bundle sizes and better runtime performance since the framework \"disappears\" during the compilation step.\n\nFor example, a simple Svelte component looks like this:\n\n```svelte\n<script>\n  let count = 0;\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n\n<button on:click={increment}>\n  Clicked {count} times\n</button>\n\n<style>\n  button {\n    background: #ff3e00;\n    color: white;\n    border: none;\n    padding: 8px 12px;\n    border-radius: 4px;\n  }\n</style>\n```\n\nWhen compiled, Svelte generates optimized JavaScript that directly manipulates the DOM, without the overhead of a virtual DOM diffing algorithm that frameworks like React use. This results in smaller bundle sizes and potentially better performance, especially for initial page loads and on lower-powered devices."}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"How is a basic Svelte component structured, and what are the main sections?","answer":"A basic Svelte component is structured as a single `.svelte` file that contains three optional sections:\n\n1. `<script>` - Contains JavaScript that defines the component's behavior, state, and logic\n2. HTML markup - The template that defines the component's structure (no enclosing tag needed)\n3. `<style>` - Contains CSS that styles the component\n\nHere's an example of a complete Svelte component with all three sections:\n\n```svelte\n<script>\n  // JavaScript logic goes here\n  let name = 'world';\n  \n  function updateName() {\n    name = 'Svelte user';\n  }\n</script>\n\n<!-- HTML markup goes here (no enclosing tag needed) -->\n<h1>Hello {name}!</h1>\n<button on:click={updateName}>Change name</button>\n\n<style>\n  /* CSS styles go here */\n  h1 {\n    color: #ff3e00;\n  }\n  \n  button {\n    background: #ff3e00;\n    color: white;\n    border: none;\n    padding: 8px 12px;\n    border-radius: 4px;\n  }\n</style>\n```\n\nThe order of these sections doesn't matter - you could put the `<style>` section first and the `<script>` section last if you preferred. All three sections are optional, so you could have a component with just HTML, or just a `<script>` and HTML, etc.\n\nOne important feature to note is that styles in Svelte are scoped by default. This means that the CSS rules you define only apply to elements in that component, not to the rest of your application."}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"How does Svelte's reactivity system work and how is it different from other frameworks?","answer":"Svelte's reactivity system is one of its most distinctive features. Unlike frameworks like React that use immutable state and explicit state updater functions, Svelte uses a fine-grained reactivity system based on JavaScript's assignment operator.\n\nIn Svelte, reactivity is triggered by variable assignments. When you assign a new value to a variable that was declared in a component's `<script>` section, Svelte automatically updates the DOM to reflect that change.\n\nFor example:\n\n```svelte\n<script>\n  let count = 0;\n  \n  function increment() {\n    // This simple assignment is enough to trigger a UI update\n    count += 1;\n  }\n</script>\n\n<button on:click={increment}>\n  Clicked {count} times\n</button>\n```\n\nWhen the button is clicked, the `increment` function runs, which updates the `count` variable. Svelte's compiler automatically inserts the code needed to update the DOM when this happens.\n\nFor more complex reactivity, Svelte offers reactive declarations using the `$:` syntax, which creates variables that automatically recompute when their dependencies change:\n\n```svelte\n<script>\n  let width = 100;\n  let height = 200;\n  \n  // area will automatically update whenever width or height changes\n  $: area = width * height;\n  \n  // You can also run arbitrary statements reactively\n  $: if (area > 10000) {\n    console.log('That\\'s a big rectangle!');\n  }\n</script>\n\n<input type=\"number\" bind:value={width}>\n<input type=\"number\" bind:value={height}>\n\n<p>Area: {area}pxÂ²</p>\n```\n\nThis reactivity system is fundamentally different from frameworks like React, where you would need to call a `setState` function or use hooks like `useState` to trigger updates. Svelte's approach is more intuitive as it leverages the familiar assignment operator, and the compiler takes care of inserting the necessary code to update the DOM."}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"How do you handle events in Svelte components?","answer":"Svelte provides a straightforward way to handle DOM events using the `on:` directive. This directive attaches event listeners to elements in your component.\n\nThe basic syntax is `on:eventname={handlerFunction}`, where `eventname` is any valid DOM event (like `click`, `input`, `mouseover`, etc.) and `handlerFunction` is a function defined in your component's `<script>` section.\n\nHere's a simple example:\n\n```svelte\n<script>\n  function handleClick() {\n    alert('Button was clicked!');\n  }\n  \n  function handleMouseEnter() {\n    console.log('Mouse entered the button area');\n  }\n</script>\n\n<button \n  on:click={handleClick}\n  on:mouseenter={handleMouseEnter}\n>\n  Click me\n</button>\n```\n\nYou can also use inline functions:\n\n```svelte\n<button on:click={() => alert('Clicked!')}>\n  Click me\n</button>\n```\n\nFor events that need additional parameters, you can pass them to your handler function:\n\n```svelte\n<script>\n  let count = 0;\n  \n  function updateCount(amount) {\n    count += amount;\n  }\n</script>\n\n<button on:click={() => updateCount(1)}>Increment</button>\n<button on:click={() => updateCount(-1)}>Decrement</button>\n\n<p>Count: {count}</p>\n```\n\nSvelte also allows event modifiers using the `|` character after the event name:\n\n```svelte\n<script>\n  function handleClick() {\n    alert('Button was clicked!');\n  }\n</script>\n\n<!-- This will call preventDefault() on the click event -->\n<a href=\"https://example.com\" on:click|preventDefault={handleClick}>\n  Click me without navigating\n</a>\n\n<!-- This will only trigger once -->\n<button on:click|once={handleClick}>\n  Click me (I only work once)\n</button>\n```\n\nCommon event modifiers include:\n- `preventDefault` - calls `event.preventDefault()`\n- `stopPropagation` - calls `event.stopPropagation()`\n- `once` - removes the event listener after the first time it runs\n- `capture` - fires the event in the capture phase\n- `self` - only triggers if the event target is the element itself"}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"How do you define and use props in Svelte components?","answer":"In Svelte, props are values that are passed from a parent component to a child component. They are defined using the `export` keyword in the child component's `<script>` section.\n\nHere's how to define and use props in Svelte:\n\n**Child.svelte (Defining props):**\n```svelte\n<script>\n  // Define a prop called 'name' with a default value\n  export let name = 'world';\n  \n  // Define a prop called 'color' with no default value\n  export let color;\n  \n  // Define a prop with type validation (using JSDoc)\n  /** @type {number} */\n  export let count;\n</script>\n\n<p style=\"color: {color}\">Hello {name}!</p>\n<p>Count: {count}</p>\n```\n\n**Parent.svelte (Using the component with props):**\n```svelte\n<script>\n  import Child from './Child.svelte';\n  \n  let userName = 'Svelte Developer';\n</script>\n\n<!-- Pass static values -->\n<Child name=\"John\" color=\"blue\" count={42} />\n\n<!-- Pass dynamic values -->\n<Child name={userName} color=\"red\" count={100} />\n\n<!-- Shorthand for when the prop name matches the variable name -->\n<Child {userName} color=\"green\" count={200} />\n\n<!-- Using the default value for 'name' -->\n<Child color=\"purple\" count={0} />\n```\n\nProps can be of any JavaScript type: strings, numbers, booleans, arrays, objects, or even functions.\n\nYou can also spread an object of props using the `{...object}` syntax:\n\n```svelte\n<script>\n  import Child from './Child.svelte';\n  \n  const props = {\n    name: 'Spread Example',\n    color: 'orange',\n    count: 5\n  };\n</script>\n\n<Child {...props} />\n```\n\nFor more complex scenarios, you can use reactive declarations to compute values based on props:\n\n```svelte\n<script>\n  export let firstName;\n  export let lastName;\n  \n  // This will update whenever firstName or lastName changes\n  $: fullName = `${firstName} ${lastName}`;\n</script>\n\n<p>Hello, {fullName}!</p>\n```\n\nProps in Svelte flow downward from parent to child, creating a unidirectional data flow that makes your application's state management more predictable."}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"How does styling work in Svelte components and what makes it different from regular CSS?","answer":"Styling in Svelte components is handled through the `<style>` block, and it has several unique features that differentiate it from regular CSS:\n\n1. **Scoped by default**: CSS in a Svelte component is automatically scoped to that component. This means the styles only apply to elements within that component, preventing style leakage and conflicts with other components.\n\n```svelte\n<style>\n  /* This h1 style only affects h1 elements in this component */\n  h1 {\n    color: purple;\n    font-size: 2em;\n  }\n  \n  /* This won't affect buttons in other components */\n  button {\n    background: #ff3e00;\n    color: white;\n  }\n</style>\n\n<h1>Styled Heading</h1>\n<button>Styled Button</button>\n```\n\n2. **Global styles**: If you need to apply styles globally, you can use the `:global()` modifier:\n\n```svelte\n<style>\n  /* This will apply to all h1 elements in the application */\n  :global(h1) {\n    margin-top: 0;\n  }\n  \n  /* You can scope global styles to your component */\n  div :global(p) {\n    /* This applies to all p elements inside divs in this component */\n    margin: 0;\n  }\n</style>\n\n<div>\n  <p>This paragraph has no margin</p>\n</div>\n```\n\n3. **CSS variables**: You can use CSS variables to create dynamic styles:\n\n```svelte\n<script>\n  export let textColor = '#333';\n</script>\n\n<style>\n  p {\n    color: var(--text-color);\n  }\n</style>\n\n<p style=\"--text-color: {textColor}\">\n  This text color is controlled by a prop\n</p>\n```\n\n4. **Preprocessors**: Svelte supports CSS preprocessors like SCSS, Less, and PostCSS with the appropriate setup:\n\n```svelte\n<style lang=\"scss\">\n  $primary-color: #ff3e00;\n  \n  button {\n    background-color: $primary-color;\n    \n    &:hover {\n      background-color: darken($primary-color, 10%);\n    }\n  }\n</style>\n```\n\n5. **How scoping works**: Behind the scenes, Svelte's compiler adds unique class names to your component's elements and scopes the CSS rules to those classes. This is all done at build time, so there's no runtime cost.\n\nFor example, your component might be compiled to something like:\n\n```html\n<style>\n  h1.svelte-a1b2c3 {\n    color: purple;\n    font-size: 2em;\n  }\n</style>\n\n<h1 class=\"svelte-a1b2c3\">Styled Heading</h1>\n```\n\nThis approach provides the benefits of CSS-in-JS solutions (scoped styles, no conflicts) without the runtime overhead, since all the work is done at compile time."}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"How can you conditionally render content in Svelte templates?","answer":"Svelte provides several directives for conditionally rendering content in templates. The main ones are `{#if}`, `{:else if}`, and `{:else}`.\n\nHere's how to use these directives:\n\n1. **Basic if/else:**\n\n```svelte\n<script>\n  let user = { loggedIn: false };\n  \n  function toggle() {\n    user.loggedIn = !user.loggedIn;\n  }\n</script>\n\n{#if user.loggedIn}\n  <button on:click={toggle}>Log out</button>\n  <p>Welcome back!</p>\n{:else}\n  <button on:click={toggle}>Log in</button>\n  <p>Please log in to continue</p>\n{/if}\n```\n\n2. **Multiple conditions with else-if:**\n\n```svelte\n<script>\n  let x = 5;\n</script>\n\n{#if x > 10}\n  <p>x is greater than 10</p>\n{:else if x > 5}\n  <p>x is greater than 5</p>\n{:else if x > 0}\n  <p>x is greater than 0</p>\n{:else}\n  <p>x is negative or zero</p>\n{/if}\n```\n\n3. **Conditional rendering with complex expressions:**\n\n```svelte\n<script>\n  let user = { name: 'John', role: 'admin', verified: true };\n</script>\n\n{#if user.role === 'admin' && user.verified}\n  <div class=\"admin-panel\">\n    <h2>Admin Panel</h2>\n    <p>Welcome, {user.name}!</p>\n    <!-- Admin content here -->\n  </div>\n{:else if user.role === 'admin'}\n  <p>Please verify your account to access the admin panel.</p>\n{:else}\n  <p>You don't have permission to access this area.</p>\n{/if}\n```\n\n4. **Conditional rendering with functions:**\n\n```svelte\n<script>\n  let user = { permissions: ['read', 'write'] };\n  \n  function hasPermission(permission) {\n    return user.permissions.includes(permission);\n  }\n</script>\n\n{#if hasPermission('admin')}\n  <div class=\"admin-controls\">\n    <!-- Admin controls here -->\n  </div>\n{/if}\n\n{#if hasPermission('write')}\n  <button>Edit document</button>\n{:else if hasPermission('read')}\n  <p>You have read-only access</p>\n{:else}\n  <p>No access</p>\n{/if}\n```\n\n5. **Combining with other Svelte features:**\n\n```svelte\n<script>\n  let count = 0;\n  $: message = count > 10 ? \"Count is getting high!\" : \"Keep counting!\";\n</script>\n\n<button on:click={() => count++}>Increment: {count}</button>\n\n{#if count > 0}\n  <p>{message}</p>\n  \n  {#if count % 2 === 0}\n    <p>Count is even</p>\n  {:else}\n    <p>Count is odd</p>\n  {/if}\n{:else}\n  <p>Count is zero</p>\n{/if}\n```\n\nThe content inside these blocks can"}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What is the recommended way to start a new Svelte project according to the official documentation?","answer":"According to the official Svelte documentation, the recommended way to start a new Svelte project is to use SvelteKit, which is the official application framework developed by the Svelte team. SvelteKit is powered by Vite, a modern frontend build tool.\n\nYou can create a new SvelteKit project using the following commands:\n\n```bash\nnpx sv create myapp\ncd myapp\nnpm install\nnpm run dev\n```\n\nAfter running these commands, you'll have a new SvelteKit project set up and running in development mode. The documentation notes that you don't need to know Svelte in advance to get started, as you can initially ignore SvelteKit's advanced features and learn them later as you become more comfortable with Svelte itself."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"Besides SvelteKit, what other methods does the documentation suggest for using Svelte?","answer":"The documentation mentions several alternatives to SvelteKit for using Svelte:\n\n1. **Vite with Svelte plugin**: You can use Svelte directly with Vite by running `npm create vite@latest` and selecting the `svelte` option. This setup will generate HTML, JS, and CSS files in the `dist` directory when you run `npm run build`, using the vite-plugin-svelte.\n\n2. **Rollup with Svelte plugin**: There's a plugin available for Rollup at github.com/sveltejs/rollup-plugin-svelte.\n\n3. **Webpack with Svelte loader**: For Webpack users, there's svelte-loader available at github.com/sveltejs/svelte-loader.\n\n4. **Other build tools**: The documentation mentions that there are \"a few others\" available, which can be found at sveltesociety.dev/packages in the build-plugins category.\n\nDespite offering these alternatives, the documentation explicitly recommends Vite as the preferred build tool. It also notes that if you choose a direct Vite setup instead of SvelteKit, you'll likely need to select a routing library separately."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"If I choose to use Svelte with Vite directly instead of SvelteKit, what important consideration should I keep in mind according to the documentation?","answer":"According to the documentation, if you choose to use Svelte with Vite directly instead of SvelteKit, an important consideration is that you will most likely need to select and implement a routing library separately. The documentation states: \"In most cases, you will probably need to [choose a routing library](faq#Is-there-a-router) as well.\"\n\nThis is because SvelteKit provides built-in routing functionality as part of its framework, whereas using Svelte with Vite directly gives you just the component framework without any routing solution. For a complete application, especially one with multiple pages or views, routing is typically essential.\n\nThe documentation provides a link to the FAQ section that presumably contains information about available routing libraries that work well with Svelte, though the specific options aren't listed in the provided excerpt."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What editor support does the Svelte team officially maintain?","answer":"According to the documentation, the Svelte team officially maintains a Visual Studio Code extension. This is mentioned specifically in the \"Editor tooling\" section:\n\n\"The Svelte team maintains a [VS Code extension](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode)...\"\n\nThis extension (svelte.svelte-vscode) provides features like syntax highlighting, intellisense, and error checking specifically for Svelte files in VS Code. It's designed to make developing Svelte applications in VS Code more productive and easier.\n\nWhile the VS Code extension is the only editor tool directly maintained by the Svelte team, the documentation also mentions that there are integrations with various other editors and tools available, which can be found at sveltesociety.dev/resources in the editor support section."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"How can developers check their Svelte code from the command line?","answer":"According to the documentation, developers can check their Svelte code from the command line using the `sv check` command. This tool is part of the Svelte CLI (Command Line Interface).\n\nThe documentation provides a link to the GitHub repository for the CLI (github.com/sveltejs/cli) where developers can find more information about this tool.\n\nThe `sv check` command likely performs static analysis on Svelte components to identify potential issues, syntax errors, or other problems without having to run the application. This can be particularly useful in CI/CD pipelines or for quick validation during development."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"Where can developers seek help with Svelte according to the documentation?","answer":"According to the documentation, developers can seek help with Svelte in several places:\n\n1. **Discord chatroom**: The documentation specifically encourages users not to be shy about asking for help in the Svelte Discord chatroom, which can be accessed via a link provided in the documentation (/chat).\n\n2. **Stack Overflow**: The documentation mentions that answers can also be found on Stack Overflow, specifically for questions tagged with \"svelte\" (stackoverflow.com/questions/tagged/svelte).\n\nThese resources provide community support for Svelte developers, allowing them to ask questions, share knowledge, and solve problems with help from other Svelte users and contributors."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What is SvelteKit and how does it relate to Svelte?","answer":"Based on the documentation, SvelteKit is the official application framework developed by the Svelte team. It's built on top of Svelte and powered by Vite, a modern frontend build tool.\n\nSvelteKit extends Svelte by providing additional features needed for building complete applications, such as:\n- Routing\n- Server-side rendering\n- API endpoints\n- Build optimization\n\nThe relationship between Svelte and SvelteKit is similar to the relationship between React and Next.js or Vue and Nuxt - Svelte is the component framework, while SvelteKit is a more comprehensive application framework built on top of it.\n\nThe documentation recommends SvelteKit as the preferred way to start with Svelte development, even for beginners, noting: \"Don't worry if you don't know Svelte yet! You can ignore all the nice features SvelteKit brings on top for now and dive into it later.\" This suggests that SvelteKit is designed to be approachable even for those new to Svelte, with the ability to gradually learn and utilize its more advanced features over time."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What build tool does the Svelte team recommend for Svelte projects?","answer":"According to the documentation, the Svelte team explicitly recommends Vite as the preferred build tool for Svelte projects. This is stated clearly in the \"Alternatives to SvelteKit\" section:\n\n\"There are also plugins for [Rollup](https://github.com/sveltejs/rollup-plugin-svelte), [Webpack](https://github.com/sveltejs/svelte-loader) [and a few others](https://sveltesociety.dev/packages?category=build-plugins), but we recommend Vite.\"\n\nVite is a modern build tool created by Evan You (the creator of Vue.js) that offers extremely fast development server startup and hot module replacement (HMR) by leveraging native ES modules. SvelteKit, the official Svelte application framework, is also powered by Vite, further emphasizing the team's preference for this build tool.\n\nWhile the documentation acknowledges that Svelte can be used with other build tools like Rollup and Webpack through official plugins, Vite is presented as the optimal choice for Svelte development."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What command is used to create a new SvelteKit project?","answer":"According to the documentation, the command used to create a new SvelteKit project is:\n\n```bash\nnpx sv create myapp\n```\n\nThis command uses `npx` to run the Svelte CLI (`sv`) with the `create` command, followed by the name of your application (in this example, \"myapp\"). This will set up a new SvelteKit project in a directory with the name you specified.\n\nAfter running this command, you would then need to:\n\n```bash\ncd myapp\nnpm install\nnpm run dev\n```\n\nThese commands navigate into your new project directory, install the necessary dependencies, and start the development server, respectively.\n\nThe `sv create` command is the current method for creating new SvelteKit projects, though it's worth noting that in earlier versions of SvelteKit, the command was `npm create svelte@latest`."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"If I'm using Svelte with Vite directly (not SvelteKit), what directory will contain my built files when I run the build command?","answer":"According to the documentation, when using Svelte with Vite directly (not SvelteKit), running the build command (`npm run build`) will generate HTML, JS, and CSS files inside the `dist` directory. \n\nThe documentation states:\n\n\"With this, `npm run build` will generate HTML, JS and CSS files inside the `dist` directory using [vite-plugin-svelte](https://github.com/sveltejs/vite-plugin-svelte).\"\n\nThis is the standard output directory for Vite-based projects. These files in the `dist` directory represent your compiled and optimized application that is ready for deployment to a web server or hosting service."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What is the purpose of the `sv check` command mentioned in the documentation?","answer":"The `sv check` command mentioned in the documentation is a tool for checking Svelte code from the command line. While the documentation doesn't provide extensive details about its functionality, it states:\n\n\"You can also check your code from the command line using [sv check](https://github.com/sveltejs/cli).\"\n\nBased on this description and common practices in development tools, we can infer that `sv check` likely performs static analysis on Svelte components to:\n\n1. Validate syntax\n2. Check for potential errors or issues\n3. Enforce coding standards or best practices\n4. Verify type correctness (especially if using TypeScript)\n\nThis kind of command-line checking tool is particularly useful in:\n- Continuous Integration (CI) pipelines\n- Pre-commit hooks\n- Automated testing workflows\n- Situations where using the editor extension isn't practical\n\nThe command is part of the Svelte CLI (Command Line Interface), and the documentation links to the GitHub repository for more information."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What does the documentation suggest for developers who are new to both Svelte and SvelteKit?","answer":"The documentation provides an encouraging message for developers who are new to both Svelte and SvelteKit. It states:\n\n\"Don't worry if you don't know Svelte yet! You can ignore all the nice features SvelteKit brings on top for now and dive into it later.\"\n\nThis suggests that the Svelte team has designed SvelteKit to be accessible to beginners, allowing them to:\n\n1. Start with the basics of Svelte component development\n2. Gradually learn about SvelteKit's additional features as they become more comfortable\n3. Adopt a progressive learning approach rather than needing to understand everything at once\n\nThe documentation recommends using SvelteKit from the beginning even for newcomers, rather than suggesting they start with plain Svelte and migrate to SvelteKit later. This implies that the learning curve of starting directly with SvelteKit isn't considered steep enough to warrant avoiding it initially.\n\nThis approach allows beginners to have the proper infrastructure in place from the start while focusing on learning Svelte's core concepts before exploring the more advanced features that SvelteKit provides."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What are the steps to start a development server after creating a new SvelteKit project?","answer":"According to the documentation, after creating a new SvelteKit project, the steps to start a development server are:\n\n1. Navigate to your project directory:\n```bash\ncd myapp\n```\n(Where \"myapp\" is the name you gave to your project when running the create command)\n\n2. Install the necessary dependencies:\n```bash\nnpm install\n```\n\n3. Start the development server:\n```bash\nnpm run dev\n```\n\nAfter running these commands, your SvelteKit application should be running in development mode, typically accessible at http://localhost:5173 (the default Vite development server port, though this can vary).\n\nThe development server provides features like:\n- Hot Module Replacement (HMR) for instant updates as you modify your code\n- Error overlays to help identify and fix issues\n- Automatic page reloading when necessary\n\nThis development server is powered by Vite, which is known for its fast startup time and efficient hot module replacement."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"According to the documentation, what resources are available for Svelte editor integrations beyond VS Code?","answer":"According to the documentation, while the Svelte team officially maintains a VS Code extension, there are integrations available for various other editors and tools as well. The documentation states:\n\n\"...and there are integrations with various other [editors](https://sveltesociety.dev/resources#editor-support) and tools as well.\"\n\nThe documentation provides a link to the Svelte Society website, specifically to the resources section with the editor support anchor. While the exact list of supported editors isn't enumerated in the provided documentation excerpt, the link would presumably lead to information about integrations for editors such as:\n\n- JetBrains IDEs (WebStorm, IntelliJ, etc.)\n- Sublime Text\n- Atom\n- Vim/Neovim\n- Emacs\n- And potentially others\n\nThese integrations typically provide features like syntax highlighting, code completion, and error checking for Svelte files, similar to what the official VS Code extension offers, though the feature set may vary by editor."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"How does the documentation suggest creating a Svelte project with Vite directly, without using SvelteKit?","answer":"According to the documentation, to create a Svelte project with Vite directly (without using SvelteKit), you should:\n\n1. Run the Vite project creation command:\n```bash\nnpm create vite@latest\n```\n\n2. When prompted, select the `svelte` option from the available templates.\n\nThis will set up a basic Svelte project that uses Vite as its build tool, with the vite-plugin-svelte handling the Svelte-specific aspects of the build process.\n\nThe documentation notes that with this setup, running `npm run build` will generate HTML, JS, and CSS files inside the `dist` directory, which is the standard output location for Vite projects.\n\nIt's also important to note that the documentation points out a key consideration when choosing this approach: \"In most cases, you will probably need to [choose a routing library](faq#Is-there-a-router) as well.\" This is because, unlike SvelteKit which includes routing functionality, a basic Svelte + Vite setup doesn't include any routing solution out of the box."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What is the relationship between Vite and SvelteKit as described in the documentation?","answer":"According to the documentation, the relationship between Vite and SvelteKit is that SvelteKit is \"powered by Vite.\" The exact quote from the documentation is:\n\n\"We recommend using [SvelteKit](../kit), the official application framework from the Svelte team powered by [Vite](https://vite.dev/)...\"\n\nThis means that SvelteKit uses Vite as its underlying build tool and development server. Vite provides SvelteKit with:\n\n1. An extremely fast development server with hot module replacement (HMR)\n2. Efficient build optimization for production\n3. A plugin-based architecture that SvelteKit leverages\n4. Native ES modules support for faster development experience\n\nSvelteKit builds upon Vite by adding features specific to building full applications with Svelte, such as routing, server-side rendering, and other application framework features.\n\nThis relationship is similar to how other modern frameworks often leverage Vite - they use Vite's core build capabilities while adding their own framework-specific features on top."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What does the documentation suggest for checking Svelte code in continuous integration environments?","answer":"The documentation doesn't explicitly mention continuous integration (CI) environments, but it does provide information about command-line tools that would be relevant for CI scenarios.\n\nSpecifically, the documentation states:\n\n\"You can also check your code from the command line using [sv check](https://github.com/sveltejs/cli).\"\n\nThe `sv check` command would be the appropriate tool to use in CI environments for validating Svelte code. This command likely performs static analysis on Svelte components to identify potential issues, syntax errors, or other problems without having to run the application.\n\nIn a CI pipeline, you would typically:\n\n1. Install the Svelte CLI (if not already included in your project dependencies)\n2. Run `sv check` as part of your verification steps\n3. Configure the pipeline to fail if `sv check` returns errors\n\nWhile not explicitly stated in the documentation excerpt, this approach aligns with standard practices for incorporating static code analysis into CI workflows for other frameworks and languages."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What build plugins for Svelte does the documentation explicitly mention?","answer":"The documentation explicitly mentions three build plugins for Svelte:\n\n1. **vite-plugin-svelte**: This is mentioned in the context of using Svelte with Vite directly. The documentation states that when using this approach, \"`"}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"What are the three main sections of a Svelte component file and are they all required?","answer":"A Svelte component file (`.svelte`) consists of three main sections: script, markup, and styles. None of these sections are required - they are all optional. This means you can have a component with just markup, just styles, just script, or any combination of these.\n\n```svelte\n<script>\n  // Script section - for component logic\n</script>\n\n<!-- Markup section - for HTML structure -->\n\n<style>\n  /* Style section - for component-specific CSS */\n</style>\n```\n\nEach section serves a specific purpose: the script section contains JavaScript/TypeScript logic, the markup section contains HTML-like template code, and the style section contains CSS that is automatically scoped to the component."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"What is the difference between `<script>` and `<script module>` in Svelte 5?","answer":"The key difference between `<script>` and `<script module>` in Svelte 5 is when and how often the code inside them runs:\n\n- `<script>`: Contains instance-level logic that runs every time a component instance is created. Variables declared here can be referenced in the component's markup and are unique to each instance of the component.\n\n- `<script module>`: Contains module-level logic that runs only once when the module first evaluates, not for each component instance. This is useful for code that should run only once regardless of how many times the component is instantiated.\n\nVariables declared in a `<script module>` block can be referenced elsewhere in the component, but variables declared in the regular `<script>` block cannot be referenced in the `<script module>` block.\n\nExample:\n```svelte\n<script module>\n  let instanceCount = 0;\n  \n  // This can be imported by other components\n  export function getInstanceCount() {\n    return instanceCount;\n  }\n</script>\n\n<script>\n  instanceCount += 1;\n  console.log(`This component has been instantiated ${instanceCount} times`);\n</script>\n```\n\nNote that in Svelte 4, the module script was written as `<script context=\"module\">`, but in Svelte 5 it has been simplified to `<script module>`."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"How does CSS scoping work in Svelte components?","answer":"In Svelte, CSS declared within a component's `<style>` block is automatically scoped to that component. This means the styles will only affect elements within that specific component, not any other components or elements on the page.\n\nSvelte achieves this by:\n1. Adding a unique class to all elements in the component\n2. Transforming the CSS selectors to include this class\n\nFor example, if you write:\n\n```svelte\n<style>\n  p {\n    color: burlywood;\n  }\n</style>\n\n<p>This paragraph will be burlywood</p>\n```\n\nSvelte will transform this at compile time to something conceptually similar to:\n\n```html\n<style>\n  p.svelte-xyz123 {\n    color: burlywood;\n  }\n</style>\n\n<p class=\"svelte-xyz123\">This paragraph will be burlywood</p>\n```\n\nWhere `svelte-xyz123` is a unique identifier generated for that component. This ensures that styling remains encapsulated within the component and doesn't leak out to affect other parts of your application, which helps avoid CSS conflicts and makes components more self-contained and reusable.\n\nThis scoped styling is one of Svelte's key features that helps maintain clean separation between components without requiring additional tools or configuration."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"Can you export values from a `<script module>` block in Svelte, and if so, how are they used?","answer":"Yes, you can export values from a `<script module>` block in Svelte, and they become exports of the compiled module. This is useful for creating utilities or constants that other components might want to import.\n\nWhen you export from a `<script module>` block:\n- The exports become available to other modules that import your component\n- You can export functions, constants, or any JavaScript value\n- You cannot use `export default` since the component itself is already the default export\n\nExample:\n\n```svelte\n<!-- Counter.svelte -->\n<script module>\n  let count = 0;\n  \n  export function increment() {\n    count += 1;\n    return count;\n  }\n  \n  export function getCount() {\n    return count;\n  }\n  \n  export const MAX_COUNT = 100;\n</script>\n\n<script>\n  // Component instance code here\n</script>\n\n<button>Current count: {getCount()}</button>\n```\n\nThen in another component, you can import and use these exports:\n\n```svelte\n<!-- AnotherComponent.svelte -->\n<script>\n  import Counter, { increment, getCount, MAX_COUNT } from './Counter.svelte';\n  \n  function handleClick() {\n    increment();\n    console.log(`New count: ${getCount()}`);\n    console.log(`Maximum allowed: ${MAX_COUNT}`);\n  }\n</script>\n\n<button on:click={handleClick}>Increment Counter</button>\n<Counter />\n```\n\nNote that while you're exporting from the module script, the component itself is still the default export. This pattern is useful for creating shared state or utility functions that are associated with a specific component."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"What language options are available for the script section in Svelte components?","answer":"The script section in Svelte components supports both JavaScript and TypeScript. By default, the script section uses JavaScript:\n\n```svelte\n<script>\n  // This is JavaScript by default\n  let count = 0;\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n```\n\nTo use TypeScript instead, you need to add the `lang=\"ts\"` attribute to the script tag:\n\n```svelte\n<script lang=\"ts\">\n  // This is TypeScript\n  let count: number = 0;\n  \n  function increment(): void {\n    count += 1;\n  }\n  \n  interface User {\n    id: number;\n    name: string;\n    email: string;\n  }\n  \n  let user: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john@example.com'\n  };\n</script>\n```\n\nThe same applies to the module script:\n\n```svelte\n<script module lang=\"ts\">\n  // TypeScript in module script\n  export let totalInstances: number = 0;\n  \n  export function getTotalInstances(): number {\n    return totalInstances;\n  }\n</script>\n```\n\nUsing TypeScript provides benefits like static type checking, better IDE support, and improved code documentation through type annotations, which can help catch errors earlier in the development process."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"How do runes relate to the script section in Svelte 5 components?","answer":"In Svelte 5, runes are a new feature that can be used within the `<script>` section to declare component props and add reactivity to your component. Runes are special functions that start with `$` and are used to create and manage reactive state.\n\nThe documentation mentions runes briefly, noting that they can be used in addition to normal JavaScript in the script section. Runes are a key part of Svelte 5's new reactivity system.\n\nFor example, to create reactive state with runes:\n\n```svelte\n<script>\n  // Using the $state rune to create reactive state\n  let count = $state(0);\n  \n  function increment() {\n    count += 1;\n  }\n  \n  // Using the $derived rune for computed values\n  let doubled = $derived(count * 2);\n  \n  // Using the $props rune to declare component props\n  let { name = 'World', greeting = 'Hello' } = $props();\n</script>\n\n<button on:click={increment}>\n  Count: {count} (doubled: {doubled})\n</button>\n\n<p>{greeting}, {name}!</p>\n```\n\nRunes replace the reactive declarations ($ prefix) and props export statements from Svelte 4. They provide a more consistent and powerful way to handle reactivity in Svelte 5.\n\nWhile the provided documentation doesn't go into details about all available runes, the main ones in Svelte 5 include:\n- `$state()` - Creates reactive state\n- `$derived()` - Creates computed values\n- `$props()` - Declares component props\n- `$effect()` - Runs side effects when dependencies change\n\nRunes represent a significant evolution in Svelte's reactivity model in version 5."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"What are the limitations of variable access between `<script>` and `<script module>` blocks?","answer":"There are specific rules governing variable access between `<script>` and `<script module>` blocks in Svelte:\n\n1. Variables declared in a `<script module>` block CAN be referenced in the regular `<script>` block and in the component markup.\n\n2. Variables declared in the regular `<script>` block CANNOT be referenced in the `<script module>` block.\n\nThis one-way accessibility makes sense when you consider the execution timing:\n- `<script module>` runs once when the module is first evaluated\n- `<script>` runs every time a component instance is created\n\nSince the module script runs before any instances are created, it doesn't have access to instance-specific variables.\n\nExample demonstrating these limitations:\n\n```svelte\n<script module>\n  // Module-level variable\n  let counter = 0;\n  \n  // This function can access module-level variables\n  export function getTotalInstances() {\n    return counter;\n  }\n  \n  // This would cause an error - cannot access instance variable\n  // console.log(instanceName); // Error: instanceName is not defined\n</script>\n\n<script>\n  // Instance-level variable\n  let instanceName = `Instance ${counter + 1}`;\n  \n  // Can access module variables\n  counter += 1;\n  \n  console.log(`Created ${instanceName}`);\n  console.log(`Total instances: ${counter}`);\n</script>\n\n<p>This is {instanceName}</p>\n<p>Total instances created: {counter}</p>\n```\n\nThis one-way relationship ensures proper encapsulation and reflects the logical relationship between module-level code (run once) and instance-level code (run for each component instance)."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"What is the primary purpose of the `<script module>` section in Svelte components?","answer":"The primary purpose of the `<script module>` section in Svelte components is to contain code that should run once when the module first evaluates, rather than for each component instance. This serves several important use cases:\n\n1. **Shared State**: Maintaining state that persists across all instances of a component\n```svelte\n<script module>\n  // Shared counter across all instances of this component\n  let instanceCount = 0;\n</script>\n\n<script>\n  instanceCount += 1;\n  const myInstanceNumber = instanceCount;\n</script>\n\n<p>I am instance #{myInstanceNumber} of this component</p>\n<p>Total instances: {instanceCount}</p>\n```\n\n2. **Utility Functions**: Defining functions that don't need to be recreated for each instance\n```svelte\n<script module>\n  // Utility function defined once, shared by all instances\n  export function formatDate(date) {\n    return new Date(date).toLocaleDateString();\n  }\n  \n  // Expensive calculation done only once\n  const complexCalculation = Array(1000000)\n    .fill(0)\n    .reduce((a, b) => a + b, 0);\n</script>\n\n<script>\n  import { onMount } from 'svelte';\n  \n  let currentDate = new Date();\n  \n  onMount(() => {\n    console.log(`Using result from complex calculation: ${complexCalculation}`);\n  });\n</script>\n\n<p>Today is {formatDate(currentDate)}</p>\n```\n\n3. **Exporting Values**: Creating exports that can be imported by other components\n```svelte\n<script module>\n  // These become exports of the module\n  export const MIN_VALUE = 0;\n  export const MAX_VALUE = 100;\n  \n  export function validateValue(value) {\n    return value >= MIN_VALUE && value <= MAX_VALUE;\n  }\n</script>\n```\n\n4. **Singleton Patterns**: Implementing singleton patterns where you want only one instance of something regardless of how many component instances exist\n```svelte\n<script module>\n  // Singleton logger instance\n  class Logger {\n    log(message) {\n      console.log(`[${new Date().toISOString()}] ${message}`);\n    }\n  }\n  \n  export const logger = new Logger();\n</script>\n\n<script>\n  import { onMount } from 'svelte';\n  \n  onMount(() => {\n    logger.log(`Component instance mounted`);\n  });\n</script>\n```\n\nThe `<script module>` section helps optimize performance by ensuring certain code runs only once regardless of how many component instances are created, and provides a way to share functionality between component instances."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"How does component instantiation work in relation to the script sections in Svelte?","answer":"Component instantiation in Svelte follows a specific sequence in relation to the script sections:\n\n1. When a Svelte file is first imported or loaded, the `<script module>` block executes once. This happens before any component instances are created.\n\n2. Each time a component instance is created:\n   - The regular `<script>` block executes\n   - Variables and logic defined in this block are initialized for that specific instance\n   - Each instance gets its own independent copy of these variables\n\nThis sequence explains why you can track instance counts as shown in the documentation example:\n\n```svelte\n<script module>\n  let total = 0;  // This variable is shared across all instances\n</script>\n\n<script>\n  total += 1;  // Each time a component is instantiated, this increments the shared counter\n  console.log(`instantiated ${total} times`);  // Logs the current instance count\n</script>\n```\n\nIf you create three instances of this component, the console would show:\n```\ninstantiated 1 times\ninstantiated 2 times\ninstantiated 3 times\n```\n\nThis behavior is useful for:\n- Tracking how many instances of a component exist\n- Sharing resources between instances\n- Implementing singleton patterns\n- Creating instance IDs or managing instance-specific resources\n\nUnderstanding this instantiation model is crucial for properly structuring components, especially when you need to share state or logic between multiple instances of the same component."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"What happens if you try to use `export default` in a `<script module>` block?","answer":"You cannot use `export default` in a `<script module>` block in Svelte. As the documentation explicitly states: \"You cannot `export default`, since the default export is the component itself.\"\n\nWhen you create a Svelte component, the component class itself is automatically set as the default export of the module. This means that when you import a Svelte component without specifying a named import, you get the component:\n\n```javascript\nimport MyComponent from './MyComponent.svelte';\n```\n\nIf you tried to add your own default export in the module script:\n\n```svelte\n<script module>\n  // This would cause an error\n  export default function someFunction() {\n    // ...\n  }\n</script>\n```\n\nIt would result in a compilation error because you'd be attempting to create a second default export, which is not allowed in JavaScript modules.\n\nInstead, you should use named exports for any functions, constants, or other values you want to export from the module script:\n\n```svelte\n<script module>\n  // This is the correct way to export from a module script\n  export function someFunction() {\n    // ...\n  }\n  \n  export const SOME_CONSTANT = 42;\n</script>\n```\n\nThese named exports can then be imported alongside the component:\n\n```javascript\nimport MyComponent, { someFunction, SOME_CONSTANT } from './MyComponent.svelte';\n```\n\nThis restriction ensures that the component itself remains the primary export of the file, while still allowing you to export additional utilities or values that are related to the component."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"How has the syntax for module-level scripts changed from Svelte 4 to Svelte 5?","answer":"The syntax for module-level scripts has been simplified in Svelte 5. The documentation notes this change with a \"LEGACY\" callout:\n\nIn Svelte 4, module-level scripts were declared using:\n```svelte\n<script context=\"module\">\n  // module-level code here\n</script>\n```\n\nIn Svelte 5, this has been simplified to:\n```svelte\n<script module>\n  // module-level code"}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"What are .svelte.js and .svelte.ts files in Svelte 5, and how do they differ from regular JavaScript or TypeScript files?","answer":"In Svelte 5, `.svelte.js` and `.svelte.ts` files are special JavaScript and TypeScript modules that allow you to use Svelte's runes system outside of traditional `.svelte` component files. Unlike regular `.js` or `.ts` files, these special files can contain reactive declarations and other Svelte rune features.\n\nThe key difference is that while they behave like any other JavaScript or TypeScript module (they can export functions, classes, variables, etc.), they also have access to Svelte's reactivity system through runes. This makes them ideal for creating reusable reactive logic or sharing reactive state across your application.\n\nThis is a new concept introduced in Svelte 5 that didn't exist in previous versions, allowing developers to separate reactive logic from component UI code."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"What is the primary purpose of using .svelte.js and .svelte.ts files in a Svelte 5 application?","answer":"The primary purpose of `.svelte.js` and `.svelte.ts` files in Svelte 5 is to create and share reusable reactive logic and state across your application, independent of UI components.\n\nThese files allow you to:\n1. Extract complex reactive logic from components for better organization\n2. Create reactive utilities that can be imported by multiple components\n3. Establish shared reactive state that persists across component lifecycles\n4. Separate business logic from presentation concerns\n5. Build reactive stores or custom reactive primitives\n\nFor example, you might create a `counter.svelte.js` file that manages counter state and logic:\n\n```javascript\n// counter.svelte.js\nimport { $state, $derived } from 'svelte';\n\nexport function createCounter(initialValue = 0) {\n  const count = $state(initialValue);\n  const doubled = $derived(count * 2);\n  \n  function increment() {\n    count++;\n  }\n  \n  function decrement() {\n    count--;\n  }\n  \n  return {\n    get count() { return count; },\n    get doubled() { return doubled; },\n    increment,\n    decrement\n  };\n}\n```\n\nThis can then be imported and used across multiple components in your application."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"How would you create a simple reactive counter using a .svelte.js file and then use it in a Svelte component?","answer":"Here's how to create a simple reactive counter using a `.svelte.js` file and then use it in a Svelte component:\n\nFirst, create the counter logic in a file named `counter.svelte.js`:\n\n```javascript\n// counter.svelte.js\nimport { $state } from 'svelte';\n\nexport function createCounter(initial = 0) {\n  const count = $state(initial);\n  \n  function increment() {\n    count++;\n  }\n  \n  function decrement() {\n    count--;\n  }\n  \n  function reset() {\n    count = initial;\n  }\n  \n  return {\n    get count() { return count; },\n    increment,\n    decrement,\n    reset\n  };\n}\n```\n\nThen, use this counter in a Svelte component:\n\n```svelte\n<!-- Counter.svelte -->\n<script>\n  import { createCounter } from './counter.svelte.js';\n  \n  const counter = createCounter(10);\n</script>\n\n<div>\n  <h2>Counter: {counter.count}</h2>\n  <button on:click={counter.increment}>+</button>\n  <button on:click={counter.decrement}>-</button>\n  <button on:click={counter.reset}>Reset</button>\n</div>\n```\n\nThe component will reactively update whenever the counter value changes, even though the reactive state is defined in a separate `.svelte.js` file. This demonstrates how Svelte 5's runes system allows you to extract and reuse reactive logic."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"How can you share reactive state between multiple components using a .svelte.js file?","answer":"You can share reactive state between multiple components by creating a singleton instance of your reactive state in a `.svelte.js` file. Here's how to implement this pattern:\n\n```javascript\n// store.svelte.js\nimport { $state, $derived } from 'svelte';\n\n// Create reactive state\nconst count = $state(0);\nconst doubleCount = $derived(count * 2);\nconst isPositive = $derived(count > 0);\n\n// Export functions to manipulate the state\nexport function increment() {\n  count++;\n}\n\nexport function decrement() {\n  count--;\n}\n\nexport function reset() {\n  count = 0;\n}\n\n// Export getters to access the state\nexport function getCount() {\n  return count;\n}\n\nexport function getDoubleCount() {\n  return doubleCount;\n}\n\nexport function getIsPositive() {\n  return isPositive;\n}\n```\n\nNow you can use this shared state in multiple components:\n\n```svelte\n<!-- ComponentA.svelte -->\n<script>\n  import { getCount, increment } from './store.svelte.js';\n</script>\n\n<div>\n  <h2>Component A</h2>\n  <p>Count: {getCount()}</p>\n  <button on:click={increment}>Increment</button>\n</div>\n```\n\n```svelte\n<!-- ComponentB.svelte -->\n<script>\n  import { getCount, getDoubleCount, decrement, reset } from './store.svelte.js';\n</script>\n\n<div>\n  <h2>Component B</h2>\n  <p>Count: {getCount()}</p>\n  <p>Double Count: {getDoubleCount()}</p>\n  <button on:click={decrement}>Decrement</button>\n  <button on:click={reset}>Reset</button>\n</div>\n```\n\nWhen one component changes the state by calling `increment()` or `decrement()`, both components will reactively update since they're accessing the same shared state. This pattern is similar to using stores in previous Svelte versions but uses the new runes system."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"What are the advantages of using .svelte.js files over traditional JavaScript modules for managing state in Svelte 5?","answer":"Using `.svelte.js` files over traditional JavaScript modules for state management in Svelte 5 offers several key advantages:\n\n1. **Built-in reactivity**: `.svelte.js` files can use Svelte's runes system (`$state`, `$derived`, etc.), providing fine-grained reactivity without needing to implement custom reactivity solutions.\n\n2. **No boilerplate**: Unlike traditional reactive patterns that might require event emitters, subscriptions, or proxies, Svelte's runes provide reactivity with minimal code.\n\n3. **Performance**: Svelte's reactivity system is optimized for performance, with precise updates that only trigger when needed.\n\n4. **Type safety**: When using `.svelte.ts` files, you get TypeScript support for your reactive state.\n\n5. **Integration with Svelte's reactivity system**: The state from `.svelte.js` files seamlessly integrates with Svelte's component reactivity system.\n\n6. **Simpler mental model**: Developers can use the same reactivity patterns across both components and utility files.\n\nCompare a traditional JavaScript module approach:\n\n```javascript\n// traditional.js\nlet count = 0;\nconst listeners = new Set();\n\nexport function getCount() {\n  return count;\n}\n\nexport function increment() {\n  count++;\n  notifyListeners();\n}\n\nexport function subscribe(listener) {\n  listeners.add(listener);\n  return () => listeners.delete(listener);\n}\n\nfunction notifyListeners() {\n  listeners.forEach(listener => listener(count));\n}\n```\n\nWith a `.svelte.js` approach:\n\n```javascript\n// counter.svelte.js\nimport { $state } from 'svelte';\n\nconst count = $state(0);\n\nexport function getCount() {\n  return count;\n}\n\nexport function increment() {\n  count++;\n}\n```\n\nThe `.svelte.js` version is more concise, and Svelte automatically handles the reactivity and updates."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"How can you create a custom reactive store similar to Svelte's built-in stores using a .svelte.js file?","answer":"You can create a custom reactive store similar to Svelte's built-in stores using a `.svelte.js` file. Here's an implementation that mimics the behavior of Svelte's writable store:\n\n```javascript\n// customStore.svelte.js\nimport { $state, $effect } from 'svelte';\n\nexport function createStore(initialValue) {\n  // Internal state\n  const value = $state(initialValue);\n  \n  // Subscriber management\n  const subscribers = $state([]);\n  \n  // Notify subscribers when value changes\n  $effect(() => {\n    subscribers.forEach(subscriber => subscriber(value));\n  });\n  \n  // Store interface\n  function set(newValue) {\n    value = newValue;\n  }\n  \n  function update(fn) {\n    value = fn(value);\n  }\n  \n  function subscribe(subscriber) {\n    subscribers.push(subscriber);\n    \n    // Immediately call the subscriber with current value\n    subscriber(value);\n    \n    // Return unsubscribe function\n    return () => {\n      const index = subscribers.indexOf(subscriber);\n      if (index !== -1) {\n        subscribers.splice(index, 1);\n      }\n    };\n  }\n  \n  // Return the store interface\n  return {\n    set,\n    update,\n    subscribe\n  };\n}\n```\n\nYou can then use this custom store in your Svelte components:\n\n```svelte\n<!-- UsingCustomStore.svelte -->\n<script>\n  import { createStore } from './customStore.svelte.js';\n  import { onDestroy } from 'svelte';\n  \n  // Create a store\n  const countStore = createStore(0);\n  \n  // Local component state\n  let count = 0;\n  \n  // Subscribe to the store\n  const unsubscribe = countStore.subscribe(value => {\n    count = value;\n  });\n  \n  // Clean up subscription when component is destroyed\n  onDestroy(unsubscribe);\n  \n  function increment() {\n    countStore.update(n => n + 1);\n  }\n  \n  function decrement() {\n    countStore.update(n => n - 1);\n  }\n  \n  function reset() {\n    countStore.set(0);\n  }\n</script>\n\n<div>\n  <h2>Count: {count}</h2>\n  <button on:click={increment}>+</button>\n  <button on:click={decrement}>-</button>\n  <button on:click={reset}>Reset</button>\n</div>\n```\n\nThis custom store implementation provides the same interface as Svelte's built-in stores but is built using Svelte 5's runes system in a `.svelte.js` file."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"What is the significance of the runes system in .svelte.js and .svelte.ts files, and how does it differ from Svelte's reactivity system in previous versions?","answer":"The runes system in `.svelte.js` and `.svelte.ts` files represents a significant evolution in Svelte's reactivity model. Here's the significance and how it differs from previous versions:\n\n**Significance of runes in .svelte.js/.svelte.ts files:**\n\n1. **Universal reactivity**: Runes allow Svelte's reactivity system to work outside of component files, enabling reactive logic in standard JavaScript/TypeScript modules.\n\n2. **Explicit reactivity markers**: The `$` prefix in runes like `$state`, `$derived`, and `$effect` makes reactive declarations explicit and clear.\n\n3. **Portable reactivity**: Reactive logic can be extracted, composed, and reused across an application.\n\n4. **Framework-agnostic potential**: The runes system is designed with the potential to be used outside of Svelte.\n\n**Differences from previous Svelte versions:**\n\n1. **Syntax**: Previous versions used `let count = 0;` for reactive variables and `$: doubled = count * 2;` for reactive declarations. Svelte 5 uses `const count = $state(0);` and `const doubled = $derived(count * 2);`.\n\n2. **Scope**: In Svelte 4 and earlier, reactivity was limited to `.svelte` component files. Svelte 5 extends this to `.svelte.js` and `.svelte.ts` files.\n\n3. **Explicitness**: The reactivity system in previous versions was implicit (any assigned variable became reactive), while runes make reactivity explicit.\n\n4. **Lifecycle management**: Previous versions tied reactivity to component lifecycle. With runes, reactive state can exist independently.\n\n5. **Composition**: Runes facilitate better composition of reactive logic through regular JavaScript functions and modules.\n\nHere's a comparison of the same logic in Svelte 4 vs. Svelte 5:\n\n**Svelte 4 (only in .svelte files):**\n```svelte\n<script>\n  let count = 0;\n  $: doubled = count * 2;\n  $: if (count > 10) {\n    console.log('Count is greater than 10');\n  }\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n```\n\n**Svelte 5 (can be in .svelte.js/.svelte.ts files):**\n```javascript\n// counter.svelte.js\nimport { $state, $derived, $effect } from 'svelte';\n\nexport function createCounter() {\n  const count = $state(0);\n  const doubled = $derived(count * 2);\n  \n  $effect(() => {\n    if (count > 10) {\n      console.log('Count is greater than 10');\n    }\n  });\n  \n  function increment() {\n    count += 1;\n  }\n  \n  return { count, doubled, increment };\n}\n```\n\nThe runes system makes Svelte's reactivity more flexible, composable, and explicit, while extending it beyond component boundaries."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"How would you implement a form validation system using .svelte.ts files with TypeScript type safety?","answer":"Here's how to implement a type-safe form validation system using `.svelte.ts` files with Svelte 5's runes:\n\n```typescript\n// formValidation.svelte.ts\nimport { $state, $derived, $effect } from 'svelte';\n\n// Define types for our validation system\ntype ValidationRule<T> = (value: T) => string | null;\ntype FieldState<T> = {\n  value: T;\n  touched: boolean;\n  errors: string[];\n  isValid: boolean;\n};\n\nexport function createField<T>(\n  initialValue: T,\n  rules: ValidationRule<T>[] = []\n) {\n  // Create reactive state\n  const value = $state<T>(initialValue);\n  const touched = $state(false);\n  const errors = $state<string[]>([]);\n  \n  // Validate function\n  function validate() {\n    const newErrors = rules\n      .map(rule => rule(value))\n      .filter((error): error is string => error !== null);\n    \n    errors = newErrors;\n    return newErrors.length === 0;\n  }\n  \n  // Run validation whenever value changes\n  $effect(() => {\n    if (touched) {\n      validate();\n    }\n  });\n  \n  // Derived state for validity\n  const isValid = $derived(errors.length === 0);\n  \n  // Field methods\n  function setValue(newValue: T) {\n    value = newValue;\n  }\n  \n  function setTouched(isTouched: boolean = true) {\n    touched = isTouched;\n    if (isTouched) {\n      validate();\n    }\n  }\n  \n  function reset() {\n    value = initialValue;\n    touched = false;\n    errors = [];\n  }\n  \n  // Return the field state and methods\n  return {\n    get value() { return value; },\n    get touched() { return touched; },\n    get errors() { return errors; },\n    get isValid() { return isValid; },\n    setValue,\n    setTouched,\n    validate,\n    reset\n  };\n}\n\n// Create a form with multiple fields\nexport function createForm<T extends Record<string, any>>(\n  initialValues: T,\n  validationRules: {\n    [K in keyof T]?: ValidationRule<T[K]>[];\n  } = {}\n) {\n  // Create fields for each form value\n  const fields = $state(\n    Object.entries(initialValues).reduce((acc, [key, value]) => {\n      const fieldKey = key as keyof T;\n      acc[fieldKey] = createField(\n        value,\n        validationRules[fieldKey] || []\n      );\n      return acc;\n    }, {} as Record<keyof T, ReturnType<typeof createField<any>>>)\n  );\n  \n  // Get form values\n  const values = $derived(\n    Object.entries(fields).reduce((acc, [key, field]) => {\n      acc[key as keyof T] = field.value;\n      return acc;\n    }, {} as T)\n  );\n  \n  // Check if the entire form is valid\n  const isValid = $derived(\n    Object.values(fields).every(field => field.isValid)\n  );\n  \n  // Validate all fields\n  function validate() {\n    return Object.values(fields).every(field => {\n      field.setTouched();\n      return field.validate();\n    });\n  }\n  \n  // Reset the entire form\n  function reset() {\n    Object.values(fields).forEach(field => field.reset());\n  }\n  \n  return {\n    fields,\n    get values() { return values; },\n    get isValid() { return isValid; },\n    validate,\n    reset\n  };\n}\n\n// Common validation rules\nexport const required = <T>(message: string = 'This field is required'): ValidationRule<T> => \n  (value: T) => {\n    if (value === undefined || value === null || value === '') {\n      return message;\n    }\n    return null;\n  };\n\nexport const minLength = (min: number, message?: string): ValidationRule<string> =>\n  (value: string) => {\n    if (value.length < min) {\n      return message || `Minimum length is ${min} characters`;\n    }\n    return null;\n  };\n\nexport const email = (message: string = 'Invalid email address'): ValidationRule<string> =>\n  (value: string) => {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(value)) {\n      return message;\n    }\n    return null;\n  };\n```\n\nNow, you can use this validation system in a Svelte component:\n\n```svelte\n<!-- RegistrationForm.svelte -->\n<script lang=\"ts\">\n  import { createForm, required, minLength, email } from './formValidation.svelte.ts';\n  \n  // Define form with validation rules\n  const form = createForm(\n    {\n      name: '',\n      email: '',\n      password: ''\n    },\n    {\n      name: [required('Name is required')],\n      email: [required('Email is required'), email()],\n      password: [required('Password is required'), minLength(8)]\n    }\n  );\n  \n  let submitted = false;\n  \n  function handleSubmit() {\n    if (form.validate()) {\n      // Form is valid, handle submission\n      console.log('Form submitted:', form.values);\n      submitted = true;\n    } else {\n      // Form is invalid\n      console.log('Form has errors');\n    }\n  }\n</script>\n\n<form on:submit|preventDefault={handleSubmit}>\n  {#if submitted}\n    <div class=\"success\">Registration successful!</div>\n  {:else}\n    <div class=\"form-group\">\n      <label for=\"name\">Name</label>\n      <input\n        id=\"name\"\n        type=\"text\"\n        value={form.fields.name.value}\n        on:input={(e) => form.fields.name.setValue(e.currentTarget.value)}\n        on:blur={() => form.fields.name.setTouched()}\n        class:invalid={form.fields.name.touched && !form.fields.name.isValid}\n      />\n      {#if form.fields.name.touched && form.fields.name.errors.length > 0}\n        <div class=\"error\">{form.fields.name.errors[0]}</div>\n      {/if}\n    </div>\n    \n    <div class=\"form-group\">\n      <label for=\"email\">Email</label>\n      <input\n        id=\"email\"\n        type=\"email\"\n        value={form.fields.email.value}\n        on:input={(e) => form.fields.email.setValue(e.currentTarget.value)}\n        on:blur={() => form.fields.email.setTouched()}\n        class:invalid={form.fields.email.touched && !form.fields.email.isValid}\n      />\n      {#if form.fields.email.touched && form.fields.email.errors.length > 0}\n        <div class=\"error\">{form.fields.email.errors[0]}</div>\n      {/if}\n    </div>\n    \n    <div class=\"form-group\">\n      <label for=\"password\">Password</label>\n      <input\n        id=\"password\"\n        type=\"password\"\n        value={form.fields.password.value}\n        on:input={(e) => form.fields.password.setValue(e.currentTarget.value)}\n        on:blur={() => form.fields.password.setTouched()}\n        class:invalid={form.fields.password.touched && !form.fields.password.isValid}\n      />\n      {#if form.fields.password.touched && form.fields.password.errors.length > 0}\n        <div class=\"error\">{form.fields.password.errors[0]}</div>\n      {/if}\n    </div>\n    \n    <button type=\"submit\" disabled={!form.isValid}>Register</button>\n  {/if}\n</form>\n\n<style>\n  .form-group {\n    margin-bottom: 1rem;\n  }\n  \n  label {\n    display: block;\n    margin-bottom: 0.5rem;\n  }\n  \n  input {\n    width: 100%;\n    padding: 0.5rem;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n  \n  input.invalid {\n    border-color: red;\n  }\n  \n  .error {\n    color: red;\n    font-size: 0.8rem;\n    margin-top: 0.25rem;\n  }\n  \n  .success {\n    color: green;\n    padding: 1rem;\n    background-color: #e8f5e9;\n    border-radius: 4px;\n  }\n</style>\n```\n\nThis implementation demonstrates how to create a type-safe form validation system using `.svelte.ts` files. The system leverages Svelte 5's runes for reactivity while providing TypeScript type safety."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"How can you implement a theme manager with dark/light mode using a .svelte.js file that can be used across your entire application?","answer":"Here's how to implement a theme manager with dark/light mode using a `.svelte.js` file that can be used across your entire application:\n\n```javascript\n// themeManager.svelte.js\nimport { $state, $effect } from 'svelte';\n\n// Define theme types and constants\nconst THEME_STORAGE_KEY = 'app-theme';\nconst DARK = 'dark';\nconst LIGHT = 'light';\nconst SYSTEM = 'system';\n\n// Initialize theme state\nconst theme = $state(getInitialTheme());\nconst systemTheme = $state(getSystemTheme());\nconst effectiveTheme = $state(calculateEffectiveTheme());\n\n// Determine initial theme from localStorage or system preference\nfunction getInitialTheme() {\n  if (typeof window === 'undefined') return SYSTEM;\n  \n  const savedTheme = localStorage.getItem(THEME_STORAGE_KEY);\n  return savedTheme === DARK || savedTheme === LIGHT ? savedTheme : SYSTEM;\n}\n\n// Get system theme preference\nfunction getSystemTheme() {\n  if (typeof window === 'undefined') return LIGHT;\n  \n  return window.matchMedia('(prefers-color-scheme: dark)').matches ? DARK : LIGHT;\n}\n\n// Calculate the effective theme (resolving SYSTEM to actual DARK or LIGHT)\nfunction calculateEffectiveTheme() {\n  return theme === SYSTEM ? systemTheme : theme;\n}\n\n// Listen for system theme changes\nif (typeof window !== 'undefined') {\n  const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n  mediaQuery.addEventListener('change', (e) => {\n    systemTheme = e.matches ? DARK : LIGHT;\n  });\n}\n\n// Save theme to localStorage when it changes\n$effect(() => {\n  if (typeof window !== 'undefined') {\n    localStorage.setItem(THEME_STORAGE_KEY, theme);\n  }\n});\n\n// Update effective theme when theme or systemTheme changes\n$effect(() => {\n  effectiveTheme = calculateEffectiveTheme();\n});\n\n// Apply theme to document when effectiveTheme changes\n$effect(() => {\n  if (typeof document !== 'undefined') {\n    if (effectiveTheme === DARK) {\n      document.documentElement.classList.add(DARK);\n    } else {\n      document.documentElement.classList.remove(DARK);\n    }\n  }\n});\n\n// Public API\nexport function getTheme() {\n  return theme;\n}\n\nexport function getEffectiveTheme() {\n  return effectiveTheme;\n}\n\nexport function setTheme(newTheme) {\n  if (newTheme === DARK || newTheme === LIGHT || newTheme === SYSTEM) {\n    theme = newTheme;\n  } else {\n    console.error(`Invalid theme: ${newTheme}. Must be 'dark', 'light', or 'system'`);\n  }\n}\n\nexport function toggleTheme() {\n  theme = effectiveTheme === DARK ? LIGHT : DARK;\n}\n\nexport function isDarkTheme() {\n  return effectiveTheme === DARK;\n}\n\nexport function isLightTheme() {\n  return effectiveTheme === LIGHT;\n}\n\nexport const THEMES = {\n  DARK,\n  LIGHT,\n  SYSTEM\n};\n```\n\nNow you can use this theme manager in your Svelte components:\n\n```svelte\n<!-- ThemeToggle.svelte -->\n<script>\n  import { getTheme, setTheme, toggleTheme, isDarkTheme, THEMES } from './themeManager.svelte.js';\n</script>\n\n<div class=\"theme-controls\">\n  <button on:click={toggleTheme}>\n    {isDarkTheme() ? 'âï¸ Light Mode' : 'ð Dark Mode'}\n  </button>\n  \n  <div class=\"theme-selector\">\n    <label>\n      <input \n        type=\"radio\" \n        name=\"theme\" \n        value={THEMES.LIGHT} \n        checked={getTheme() === THEMES.LIGHT}\n        on:change={() => setTheme(THEMES.LIGHT)} \n      />\n      Light\n    </label>\n    \n    <label>\n      <input \n        type=\"radio\" \n        name=\"theme\" \n        value={THEMES.DARK} \n        checked={getTheme() === THEMES.DARK}\n        on:change={() => setTheme(THEMES.DARK)} \n      />\n      Dark\n    </label>\n    \n    <label>\n      <input \n        type=\"radio\" \n        name=\"theme\" \n        value={THEMES.SYSTEM} \n        checked={getTheme() === THEMES.SYSTEM}\n        on:change={() => setTheme(THEMES.SYSTEM)} \n      />\n      System\n    </label>\n  </div>\n</div>\n\n<style>\n  .theme-controls {\n    padding: 1rem;\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    border-radius: 4px;\n    border: 1px solid var(--border-color, #ccc);\n    background-color: var(--button-bg, #f0f0f0);\n    cursor: pointer;\n  }\n  \n  .theme-selector {\n    display: flex;\n    gap: 1rem;\n  }\n  \n  label {\n    display: flex;\n    align-items: center;\n    gap: 0.25rem;\n    cursor: pointer;\n  }\n</style>\n```\n\nTo set up your CSS for theme support, add this to your global CSS file:\n\n```css\n/* global.css */\n:root {\n  --text-color: #333;\n  --background-color: #fff;\n  --primary-color: #3498db;\n  --secondary-color: #2ecc71;\n  --border-color: #ddd;\n  --button-bg: #f0f0f0;\n}\n\n.dark {\n  --text-color: #f0f0f0;\n  --background-color: #121212;\n  --primary-color: #90caf9;\n  --secondary-color: #81c784;\n  --border-color: #444;\n  --button-bg: #2a2a2a;\n}\n\nbody {\n  color: var(--text-color);\n  background-color: var(--background-color);\n  transition: color 0.3s ease, background-color 0.3s ease;\n}\n```\n\nAnd in your root layout component, apply the theme on initial load:\n\n```svelte\n<!-- App.svelte or Layout.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  import { getEffectiveTheme } from './themeManager.svelte.js';\n  import './global.css';\n  \n  onMount(() => {\n    // The theme manager's $effect will handle this automatically,\n    // but we include this for clarity\n    if (getEffectiveTheme() === 'dark') {\n      document.documentElement.classList.add('dark');\n    } else {\n      document.documentElement.classList.remove('dark');\n    }\n  });\n</script>\n\n<div class=\"app\">\n  <slot />\n</div>\n```\n\nThis implementation provides a complete theme management system that:\n1. Persists the user's theme preference in localStorage\n2. Supports a system theme option that follows the user's OS preference\n3. Reactively updates the theme throughout the application\n4. Provides a simple API for components to interact with the theme\n5. Handles theme changes with CSS variables for smooth transitions\n\nAll the reactive logic is contained in the `.svelte.js` file, making it easy to reuse across your application."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"How would you implement a reactive data fetching hook using a .svelte.js file?","answer":"Here's how to implement a reactive data fetching hook using a `.svelte.js` file:\n\n```javascript\n// useFetch.svelte.js\nimport { $state, $derived, $effect } from 'svelte';\n\nexport function useFetch(initialUrl, options = {}) {\n  // State variables\n  const url = $state(initialUrl);\n  const fetchOptions = $state(options);\n  const data = $state(null);\n  const error = $state(null);\n  const isLoading = $state(false);\n  \n  // Track if the component is mounted\n  let isMounted = true;\n  \n  // Derived state for request state\n  const isSuccess = $derived(!!data && !error);\n  const isError = $derived(!!error);\n  \n  // Function to set a new URL\n  function setUrl(newUrl) {\n    url = newUrl;\n  }\n  \n  // Function to set new fetch options\n  function setOptions(newOptions) {\n    fetchOptions = { ...fetchOptions, ...newOptions };\n  }\n  \n  // Function to manually trigger a fetch\n  async function refetch() {\n    isLoading = true;\n    error = null;\n    \n    try {\n      const response = await fetch(url, fetchOptions);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! Status: ${response.status}`);\n      }\n      \n      const result = await response.json();\n      \n      // Only update state if component is still mounted\n      if (isMounted) {\n        data = result;\n        isLoading = false;\n      }\n    } catch (err) {\n      // Only update state if component is still mounted\n      if (isMounted) {\n        error = err.message || 'An error occurred';\n        isLoading = false;\n      }\n    }\n  }\n  \n  // Effect to fetch data when url or options change\n  $effect(() => {\n    refetch();\n  });\n  \n  // Function to cleanup when component unm"}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you define component props in Svelte 5, and how does this differ from Svelte 4?","answer":"In Svelte 5, props are defined using the new `$props()` rune, which is a significant change from Svelte 4's `export let` syntax. The `$props()` rune returns an object containing all the props passed to the component, which you can then destructure.\n\n```svelte\n<script>\n  // Svelte 5 syntax\n  let { foo, bar, baz } = $props();\n  \n  // Values are immediately available\n  console.log({ foo, bar, baz });\n</script>\n```\n\nIn Svelte 4, the same would be written as:\n\n```svelte\n<script>\n  // Svelte 4 syntax\n  export let foo;\n  export let bar;\n  export let baz;\n</script>\n```\n\nThe new approach with `$props()` is part of Svelte 5's runes system, which provides a more explicit way to handle component state and reactivity. One advantage is that props are immediately available in the component, making them accessible for logging or using in other initializations right away."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you specify default values for props in Svelte 5?","answer":"In Svelte 5, you can specify default values for props using standard JavaScript destructuring assignment with default values when you destructure the object returned by `$props()`. The default value will be used if the component's consumer doesn't specify the prop or if the passed value is `undefined` at some point.\n\n```svelte\n<script>\n  // Setting a default value for 'foo'\n  let { foo = 'optional default initial value', bar = 42, baz = true } = $props();\n  \n  // Now if foo isn't provided, it will be 'optional default initial value'\n  console.log(foo); // Will show the default if not provided\n</script>\n```\n\nThis syntax is more aligned with standard JavaScript patterns compared to Svelte 4's approach, where you would write:\n\n```svelte\n<script>\n  // Svelte 4 approach\n  export let foo = 'optional default initial value';\n</script>\n```\n\nThe functionality is similar, but the syntax follows JavaScript's standard destructuring patterns in Svelte 5."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How can you collect all props that weren't explicitly destructured in Svelte 5?","answer":"In Svelte 5, you can use JavaScript's rest syntax within the destructuring of the `$props()` object to collect all properties that weren't explicitly named. This is useful when you want to pass through additional props to child components or HTML elements.\n\n```svelte\n<script>\n  // Explicitly destructure 'a', 'b', 'c', and collect everything else\n  let { a, b, c, ...everythingElse } = $props();\n  \n  console.log(a, b, c);\n  console.log(everythingElse); // Contains all other props\n</script>\n\n<!-- You can then spread these additional props to an element or component -->\n<div {...everythingElse}>\n  <!-- content -->\n</div>\n\n<!-- Or to a child component -->\n<ChildComponent {...everythingElse} />\n```\n\nThis pattern is particularly useful for creating wrapper components that need to forward most properties to an underlying element or component while handling a few specific ones themselves."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you handle reserved JavaScript words as prop names in Svelte 5?","answer":"In Svelte 5, you can use reserved JavaScript words as prop names by leveraging JavaScript's destructuring assignment with renaming. This allows you to accept props with names that would otherwise cause syntax errors if used directly as variable names.\n\n```svelte\n<script>\n  // Rename 'class' to 'className' during destructuring\n  let { class: className, for: htmlFor, if: condition } = $props();\n  \n  // Now you can use 'className' instead of 'class' in your component\n  console.log(className); // Contains the value of the 'class' prop\n</script>\n\n<!-- You can use the renamed variable in your template -->\n<div class={className}>\n  <label for={htmlFor}>Label</label>\n  {#if condition}\n    <p>Conditional content</p>\n  {/if}\n</div>\n```\n\nThis approach is particularly useful when working with HTML attributes that are reserved words in JavaScript, like `class`, `for`, or control flow keywords like `if`, `while`, etc."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you type props in Svelte 5 when using TypeScript?","answer":"In Svelte 5, you can type props by defining an interface or type and then applying it to the destructured object from `$props()`. This provides type checking for the props your component receives.\n\n```svelte\n<script lang=\"ts\">\n  // Define an interface for your props\n  interface Props {\n    required: string;\n    optional?: number;\n    defaulted: boolean;\n    [key: string]: unknown; // Allow additional props of any type\n  }\n\n  // Apply the type to the destructured props\n  let { \n    required, \n    optional, \n    defaulted = false, \n    ...rest \n  }: Props = $props();\n  \n  // TypeScript will now enforce these types\n  required.toLowerCase(); // OK - required is a string\n  optional?.toFixed(2);   // OK - optional is a number or undefined\n  // @ts-expect-error - This would cause a type error\n  required.toFixed(2);    // Error: Property 'toFixed' does not exist on type 'string'\n</script>\n```\n\nThe `[key: string]: unknown;` index signature allows for additional properties beyond those explicitly defined, which is useful when you want to forward props to child elements or components."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How can you document props in Svelte 5 when using JavaScript (not TypeScript)?","answer":"In Svelte 5, when using JavaScript without TypeScript, you can document and type your props using JSDoc comments. This provides IDE hints and some type checking through tools like VSCode's JavaScript type checking.\n\n```svelte\n<script>\n  /** \n   * @type {{ \n   *   x: string,\n   *   y?: number\n   * }} \n   */\n  let { x, y } = $props();\n\n  // Alternatively, you can use @typedef for more detailed documentation:\n  \n  /**\n   * @typedef {Object} MyProps\n   * @property {string} name - The name of the user\n   * @property {number} [age] - The age of the user (optional)\n   * @property {boolean} [isAdmin=false] - Whether the user is an admin (defaults to false)\n   */\n\n  /** @type {MyProps} */\n  let { name, age, isAdmin = false } = $props();\n  \n  // Now your IDE can provide hints based on these types\n  console.log(name.toLowerCase()); // IDE knows 'name' is a string\n</script>\n```\n\nThis approach doesn't provide the same level of compile-time checking as TypeScript, but it does improve developer experience with better autocomplete and inline documentation in IDEs that support JSDoc."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you define readonly properties that can be accessed from outside a Svelte 5 component?","answer":"In Svelte 5, you can export constants, functions, or classes using the `export` keyword to make them accessible as readonly properties from outside the component. These exports become part of the component's public API but cannot be modified from outside.\n\n```svelte\n<script>\n  // Export a constant\n  export const VERSION = '1.0.0';\n  \n  // Export a function\n  export function greet(name) {\n    alert(`Hello, ${name}!`);\n  }\n  \n  // Export a class\n  export class Helper {\n    static formatDate(date) {\n      return new Intl.DateTimeFormat('en-US').format(date);\n    }\n  }\n</script>\n```\n\nTo access these exported values from a parent component, you need to get a reference to the component instance using `bind:this`:\n\n```svelte\n<script>\n  import MyComponent from './MyComponent.svelte';\n  \n  let componentRef;\n  \n  function handleClick() {\n    // Access the exported values\n    console.log(componentRef.VERSION); // \"1.0.0\"\n    componentRef.greet('World'); // Shows alert \"Hello, World!\"\n    console.log(componentRef.Helper.formatDate(new Date())); // Formatted date\n  }\n</script>\n\n<MyComponent bind:this={componentRef} />\n<button on:click={handleClick}>Access Component API</button>\n```\n\nThese exports are readonly, meaning a parent component cannot modify them (e.g., `componentRef.VERSION = '2.0.0'` would not work or would be ignored)."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How does Svelte 5's reactivity system work with component props?","answer":"In Svelte 5, props are reactive, but assignments within a `<script>` block are only run when the component is created. This means that if you destructure or derive values from props in the script block, these derived values won't automatically update when the props change.\n\n```svelte\n<script>\n  let { person } = $props();\n  \n  // This will only set `name` on component creation\n  // It will NOT update when `person` changes\n  let { name } = person;\n  \n  // To react to prop changes, use $derived or $effect\n  \n  // This will update whenever person.name changes\n  let reactivePersonName = $derived(person.name);\n  \n  // This effect will run whenever person changes\n  $effect(() => {\n    console.log(`Person updated: ${person.name}`);\n  });\n</script>\n\n<div>\n  <!-- This will always show the current person.name -->\n  <p>Current name: {person.name}</p>\n  \n  <!-- This won't update if person.name changes after component creation -->\n  <p>Initial name: {name}</p>\n  \n  <!-- This will update when person.name changes -->\n  <p>Reactive name: {reactivePersonName}</p>\n</div>\n```\n\nTo properly react to prop changes, you should either:\n1. Access the prop directly in the template (like `{person.name}`)\n2. Use the `$derived` rune to create derived values that update when props change\n3. Use the `$effect` rune to run side effects when props change\n\nThis is a significant change from Svelte 4's behavior, where reactivity was more implicit."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you create reactive state variables in Svelte 5 components?","answer":"In Svelte 5, you create reactive state variables using the `$state` rune. When you assign to a variable declared with `$state`, Svelte will automatically update the UI to reflect the new value.\n\n```svelte\n<script>\n  // Declare a reactive state variable\n  let count = $state(0);\n  \n  // This function updates the state and triggers UI updates\n  function increment() {\n    count += 1; // This assignment triggers reactivity\n  }\n  \n  // You can also have reactive objects\n  let user = $state({\n    name: 'John',\n    age: 30\n  });\n  \n  function makeUserOlder() {\n    // Property assignments also trigger reactivity\n    user.age += 1;\n    // Or you can replace the entire object\n    // user = { ...user, age: user.age + 1 };\n  }\n</script>\n\n<button on:click={increment}>Count: {count}</button>\n<button on:click={makeUserOlder}>Make {user.name} older (currently {user.age})</button>\n```\n\nThe `$state` rune replaces Svelte 4's implicit reactivity system where any top-level variable assignment would trigger updates. In Svelte 5, you must explicitly mark variables as reactive using `$state` if you want assignments to them to trigger UI updates."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you create derived values that update when their dependencies change in Svelte 5?","answer":"In Svelte 5, you can create derived values using the `$derived` rune. These values automatically update whenever their dependencies (other reactive values they reference) change.\n\n```svelte\n<script>\n  // Create reactive state\n  let count = $state(0);\n  let multiplier = $state(2);\n  \n  // Create a derived value that depends on count and multiplier\n  let doubled = $derived(count * multiplier);\n  \n  // Create a derived value with more complex logic\n  let status = $derived(\n    count < 5 ? 'Low' :\n    count < 10 ? 'Medium' :\n    'High'\n  );\n  \n  // You can also derive from props\n  let { price, quantity } = $props();\n  let total = $derived(price * quantity);\n  \n  function increment() {\n    count += 1;\n    // doubled and status will automatically update\n  }\n</script>\n\n<button on:click={increment}>Increment ({count})</button>\n<p>Doubled value: {doubled}</p>\n<p>Status: {status}</p>\n<p>Total: ${total}</p>\n\n<!-- You can also use multiplier controls -->\n<button on:click={() => multiplier += 1}>Increase multiplier ({multiplier})</button>\n```\n\nDerived values are read-only; you cannot assign to them directly. They recalculate automatically when any of their dependencies change. This is similar to Svelte 4's reactive declarations (`$: doubled = count * 2`), but with the new runes syntax."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you run side effects in response to state changes in Svelte 5?","answer":"In Svelte 5, you can use the `$effect` rune to run side effects whenever reactive values change. The effect function will run once initially and then re-run whenever any reactive values it references change.\n\n```svelte\n<script>\n  let count = $state(0);\n  let apiCalls = $state(0);\n  \n  // This effect runs whenever count changes\n  $effect(() => {\n    console.log(`Count changed to ${count}`);\n    \n    // You can perform side effects like DOM manipulation\n    document.title = `Count: ${count}`;\n  });\n  \n  // Effects can have cleanup functions\n  $effect(() => {\n    // Only run this effect if count is greater than 5\n    if (count <= 5) return;\n    \n    const interval = setInterval(() => {\n      console.log(`Current count is ${count}`);\n    }, 1000);\n    \n    // Return a cleanup function that runs before the next effect\n    // or when the component is destroyed\n    return () => {\n      clearInterval(interval);\n      console.log('Interval cleared');\n    };\n  });\n  \n  // Effects can be used with props too\n  let { threshold } = $props();\n  \n  $effect(() => {\n    if (count > threshold) {\n      alert(`Count exceeded threshold of ${threshold}!`);\n    }\n  });\n  \n  // You can also use effects for API calls\n  $effect(async () => {\n    if (count % 5 === 0 && count > 0) {\n      try {\n        apiCalls += 1;\n        const response = await fetch(`/api/record?count=${count}`);\n        const data = await response.json();\n        console.log('API response:', data);\n      } catch (error) {\n        console.error('API call failed:', error);\n      }\n    }\n  });\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n\n<button on:click={increment}>Increment ({count})</button>\n<p>API calls made: {apiCalls}</p>\n```\n\nThe `$effect` rune replaces Svelte 4's reactive statements (`$: { /* side effects */ }`). Effects are useful for synchronizing with external systems, making API calls, updating the DOM directly, or any other operation that shouldn't be part of the rendering process."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How can you access all props in a Svelte 5 component without knowing their names in advance?","answer":"In Svelte 5, you can access all props passed to a component by using only the rest parameter syntax with the `$props()` rune, without destructuring any specific props. This is useful for creating wrapper components or when you need to forward all props to another component or element.\n\n```svelte\n<script>\n  // Get all props without destructuring any specific ones\n  let allProps = $props();\n  \n  // Or you can destructure some known props and collect the rest\n  let { id, class: className, ...restProps } = $props();\n  \n  // You can now use allProps or restProps in your component\n  console.log('All props:', allProps);\n  console.log('Rest props:', restProps);\n  \n  // You can also add or modify props before forwarding them\n  let enhancedProps = {\n    ...restProps,\n    enhanced: true,\n    class: `${className || ''} wrapper`\n  };\n</script>\n\n<!-- Forward all props to a child element -->\n<div {...allProps}>\n  Basic forwarding\n</div>\n\n<!-- Or use the modified props -->\n<div id={id} {...enhancedProps}>\n  Enhanced forwarding\n</div>\n\n<!-- Forward to another component -->\n<ChildComponent {...restProps} additionalProp=\"value\" />\n```\n\nThis pattern is particularly useful for:\n1. Creating wrapper components that need to pass through most props\n2. Building higher-order components\n3. Implementing component libraries where you want to allow arbitrary HTML attributes\n\nThe spread syntax (`{...props}`) works both for HTML elements and for child Svelte components."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you handle prop validation or transformation in Svelte 5?","answer":"Svelte 5 doesn't have a built-in prop validation system like Vue's props option or React's PropTypes, but you can implement validation or transformation using `$effect` or by creating derived values based on props. Here's how you might approach it:\n\n```svelte\n<script>\n  // Get the raw props\n  let { count, items, callback } = $props();\n  \n  // Validate and transform props using $effect\n  $effect(() => {\n    // Type validation\n    if (typeof count !== 'number') {\n      console.warn('count prop should be a number but got', typeof count);\n    }\n    \n    // Array validation\n    if (!Array.isArray(items)) {\n      console.error('items prop must be an array');\n      // Provide fallback\n      items = [];\n    }\n    \n    // Function validation\n    if (callback && typeof callback !== 'function') {\n      console.error('callback prop must be a function');\n      // Provide fallback\n      callback = () => {};\n    }\n  });\n  \n  // Transform props into validated versions using $derived\n  let validCount = $derived(\n    typeof count === 'number' ? count : 0\n  );\n  \n  let validItems = $derived(\n    Array.isArray(items) ? items : []\n  );\n  \n  let validCallback = $derived(\n    typeof callback === 'function' ? callback : () => {}\n  );\n  \n  // Now use the validated props in your component\n  function handleAction() {\n    validCallback(validCount);\n  }\n</script>\n\n<div>\n  <p>Count: {validCount}</p>\n  <ul>\n    {#each validItems as item}\n      <li>{item}</li>\n    {/each}\n  </ul>\n  <button on:click={handleAction}>Call Callback</button>\n</div>\n```\n\nFor more complex validation, you could create a helper function:\n\n```svelte\n<script>\n  import { z } from 'zod'; // Popular validation library\n  \n  // Define a schema for your props\n  const PropsSchema = z.object({\n    count: z.number().default(0),\n    items: z.array(z.string()).default([]),\n    callback: z.function().optional()\n  });\n  \n  // Get raw props\n  let rawProps = $props();\n  \n  // Validate props and get default values for missing props\n  let validatedProps = $derived(() => {\n    try {\n      return PropsSchema.parse(rawProps);\n    } catch (error) {\n      console.error('Props validation error:', error);\n      // Return defaults on error\n      return PropsSchema.parse({});\n    }\n  });\n  \n  // Now destructure from the validated props\n  let count = $derived(validatedProps.count);\n  let items = $derived(validatedProps.items);\n  let callback = $derived(validatedProps.callback || (() => {}));\n</script>\n```\n\nThis approach gives you type safety, validation, and default values all in one system."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"What's the difference between using `$state`, `$derived`, and `$effect` in Svelte 5 components?","answer":"In Svelte 5, `$state`, `$derived`, and `$effect` are runes that serve different purposes in the reactivity system:\n\n1. `$state` - Creates a reactive variable that triggers updates when assigned to:\n\n```svelte\n<script>\n  // Create reactive state\n  let count = $state(0);\n  let user = $state({ name: 'John', age: 30 });\n  \n  function increment() {\n    // This assignment triggers reactivity\n    count += 1;\n    \n    // So does property assignment\n    user.age += 1;\n  }\n</script>\n```\n\n2. `$derived` - Creates a read-only value that automatically updates when its dependencies change:\n\n```svelte\n<script>\n  let count = $state(0);\n  \n  // This value updates whenever count changes\n  let doubled = $derived(count * 2);\n  let isEven = $derived(count % 2 === 0);\n  \n  // Cannot assign to derived values\n  // doubled = 10; // This would cause an error\n</script>\n```\n\n3. `$effect` - Runs side effects when reactive values change:\n\n```svelte\n<script>\n  let count = $state(0);\n  \n  // This function runs whenever count changes\n  $effect(() => {\n    console.log(`Count is now ${count}`);\n    document.title = `Count: ${count}`;\n    \n    // Can return a cleanup function\n    return () => {\n      console.log('Cleaning up before next effect run');\n    };\n  });\n</script>\n```\n\nKey differences:\n- `$state` variables are mutable and can be assigned to\n- `$derived` values are read-only and automatically update based on their dependencies\n- `$effect` functions run side effects and don't produce values used in the template\n\nYou would use:\n- `$state` for component state that needs to change over time\n- `$derived` for computed values based on state or props\n- `$effect` for side effects like API calls, DOM manipulation, or logging\n\nAll three work with props as well as with local state:\n\n```svelte\n<script>\n  // Props can be used with all three runes\n  let { initialCount, multiplier } = $props();\n  \n  // State initialized from props\n  let count = $state(initialCount);\n  \n  // Derived value using both state and props\n  let result = $derived(count * multiplier);\n  \n  // Effect that watches props\n  $effect(() => {\n    console.log(`Multiplier changed to ${multiplier}`);\n  });\n</script>\n```"}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How can you create a component with dynamic props in Svelte 5?","answer":"In Svelte 5, you can create components with dynamic props by using the rest parameter syntax with `$props()` and leveraging JavaScript's ability to compute property names. This allows your component to handle props that aren't known at development time.\n\n```svelte\n<!-- DynamicComponent.svelte -->\n<script>\n  // Get all props\n  let allProps = $props();\n  \n  // Track which props have been set\n  let propsSet = $derived(Object.keys(allProps));\n  \n  // You can also create a filtered version with only specific types\n  let dataProps = $derived(\n    Object.entries(allProps)\n      .filter(([key]) => key.startsWith('data-'))\n      .reduce((acc, [key, value]) => {\n        acc[key] = value;\n        return acc;\n      }, {})\n  );\n</script>\n\n<div class=\"dynamic-component\">\n  <h2>Dynamic Props Component</h2>\n  \n  <p>The following props were provided:</p>\n  <ul>\n    {#each propsSet as prop}\n      <li>\n        <strong>{prop}:</strong> \n        {typeof allProps[prop] === 'object' \n          ? JSON.stringify(allProps[prop]) \n          : String(allProps[prop])}\n      </li>\n    {/each}\n  </ul>\n  \n  <!-- Render a div with all data attributes -->\n  <div {...dataProps}>\n    This div has all data-* attributes applied\n  </div>\n</div>\n```\n\nUsage of the dynamic component:\n\n```svelte\n<script>\n  import DynamicComponent from './DynamicComponent.svelte';\n  \n  let dynamicValue = $state('initial');\n  let showExtra = $state(false);\n  \n  // Create dynamic props object\n  let extraProps = $derived(\n    showExtra \n      ? { 'data-extra': true, extraInfo: 'This is extra information' } \n      : {}\n  );\n</script>\n\n<input bind:value={dynamicValue} />\n<label>\n  <input type=\"checkbox\" bind:checked={showExtra} />\n  Show extra props\n</label>\n\n<!-- Pass both static and dynamic props -->\n<DynamicComponent \n  title=\"Dynamic Demo\"\n  value={dynamicValue}\n  data-test-id=\"dynamic-component\"\n  {...extraProps}\n/>\n```\n\nThis approach is useful for:\n1. Creating wrapper components that need to pass through arbitrary props\n2. Building component libraries that can accept any HTML attributes\n3. Implementing components that work with dynamic data attributes or ARIA attributes\n\nYou can also dynamically compute prop names when passing them:\n\n```svelte\n<script>\n  let propName = $state('color');\n  let propValue = $state('blue');\n  \n  // Create a dynamic props object\n  let dynamicProps = $derived({\n    [propName]: propValue\n  });\n</script>\n\n<input bind:value={propName} placeholder=\"Prop name\" />\n<input bind:value={propValue} placeholder=\"Prop value\" />\n\n<DynamicComponent {...dynamicProps} />\n```"}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you handle complex nested reactivity with objects and arrays in Svelte 5?","answer":"In Svelte 5, handling complex nested reactivity with objects and arrays requires understanding how the `$state` rune works with nested structures. Here's a comprehensive example:\n\n```svelte\n<script>\n  // Create a reactive nested structure\n  let user = $state({\n    name: 'John',\n    age: 30,\n    address: {\n      street: '123 Main St',\n      city: 'Anytown',\n      zipCode: '12345'\n    },\n    skills: ['JavaScript', 'Svelte', 'CSS']\n  });\n  \n  // Modifying nested properties triggers reactivity\n  function updateCity() {\n    // This will trigger reactivity\n    user.address.city = 'New City';\n  }\n  \n  // Adding array items\n  function addSkill(skill) {\n    // Both of these approaches work\n    user.skills.push(skill);\n    // Or using immutable pattern:\n    // user.skills = [...user.skills, skill];\n  }\n  \n  // Removing array items\n  function removeSkill(index) {\n    user.skills.splice(index, 1);\n    // Or using immutable pattern:\n    // user.skills = user.skills.filter((_, i) => i !== index);\n  }\n  \n  // Replacing an entire nested object\n  function moveUser() {\n    user.address = {\n      street: '456 New Ave',\n      city: 'Different Town',\n      zipCode: '67890'\n    };\n  }\n  \n  // Creating derived values from nested properties\n  let formattedAddress = $derived(\n    `${user.address.street}, ${user.address.city}, ${user.address.zipCode}`\n  );\n  \n  let skillCount = $derived(user.skills.length);\n  \n  // Effects watching nested properties\n  $effect(() => {\n    console.log(`User's city changed to: ${user.address.city}`);\n  });\n  \n  $effect(() => {\n    console.log(`User now has ${user.skills.length} skills`);\n  });\n  \n  // Working with arrays of objects\n  let todos = $state([\n    { id: 1, text: 'Learn Svelte', done: true },\n    { id: 2, text: 'Build an app', done: false }\n  ]);\n  \n  function addTodo(text) {\n    const id = Math.max(0, ...todos.map(t => t.id)) + 1;\n    todos.push({ id, text, done: false });\n  }\n  \n  function toggleTodo(id) {\n    const index = todos.findIndex(t => t.id === id);\n    if (index !== -1) {\n      todos[index].done = !todos[index].done;\n    }\n  }\n  \n  function removeTodo(id) {\n    todos = todos.filter(t => t.id !== id);\n  }\n  \n  // Derived values from array processing\n  let completedTodos = $derived(todos.filter(t => t.done));\n  let pendingTodos = $derived(todos.filter(t => !t.done));\n  let progress = $derived(\n    todos.length > 0 \n      ? Math.round((completedTodos.length / todos.length) * 100) \n      : 0\n  );\n</script>\n\n<div>\n  <h2>{user.name}'s Profile</h2>\n  <p>Age: {user.age}</p>\n  <p>Address: {formattedAddress}</p>\n  \n  <button on:click={updateCity}>Update City</button>\n  <button on:click={moveUser}>Move User</button>\n  \n  <h3>Skills ({skillCount})</h3>\n  <ul>\n    {#each user.skills as skill, i}\n      <li>\n        {skill}\n        <button on:click={() => removeSkill(i)}>Remove</button>\n      </li>\n    {/each}\n  </ul>\n  \n  <input \n    placeholder=\"Add skill\"\n    on:keydown={(e) => e.key === 'Enter' && addSkill(e.target.value) && (e.target.value = '')}\n  />\n  \n  <h3>Todo List ({progress}% complete)</h3>\n  <div>\n    {#each todos as todo (todo.id)}\n      <div class:done={todo.done}>\n        <input \n          type=\"checkbox\" \n          checked={todo.done} \n          on:change={() => toggleTodo(todo.id)}\n        />\n        <span>{todo.text}</span>\n        <button on:click={() => removeTodo(todo.id)}>Delete</button>\n      </div>\n    {/each}\n  </div>\n  \n  <input \n    placeholder=\"Add todo\"\n    on:keydown={(e) => e.key === 'Enter' && addTodo(e.target.value) && (e.target.value = '')}\n  />\n</div>\n\n<style>\n  .done {\n    text-decoration: line-through;\n    opacity: 0.7;\n  }\n</style>\n```\n\nKey points about nested reactivity in Svelte 5:\n1. Direct property assignments on reactive objects trigger updates\n2. Array mutations (push, splice, etc.) on reactive arrays trigger updates\n3. You can use both mutable and immutable update patterns\n4. Derived values can access deeply nested properties\n5. Effects can watch changes to nested properties\n6. For complex state, consider organizing related data together\n\nThis approach provides a powerful way to manage complex state in Svelte 5 components."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How can you implement conditional props in Svelte 5?","answer":"In Svelte 5, you can implement conditional props by leveraging JavaScript's capabilities to conditionally create or spread objects. Here are several approaches for handling conditional props:\n\n```svelte\n<script>\n  // Import a component that will receive conditional props\n  import Button from './Button.svelte';\n  \n  // Some component state\n  let isDisabled = $state(false);\n  let isLoading = $state(false);\n  let isAdmin = $state(false);\n  let size = $state('medium'); // 'small', 'medium', 'large'\n  \n  // Create conditional props based on component state\n  let buttonProps = $derived(() => {\n    return {\n      // Always include these props\n      type: 'button',\n      class: 'custom-button',\n      \n      // Conditional props based on state\n      ...(isDisabled && { disabled: true }),\n      ...(isLoading && { 'aria-busy': true, 'data-loading': true }),\n      \n      // Conditional prop values\n      variant: isAdmin ? 'admin' : 'user',\n      \n      // Conditional class names\n      classList: {\n        'is-disabled': isDisabled,\n        'is-loading': isLoading,\n        [`size-${size}`]: true"}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"What are runes in Svelte 5 and how do they differ from regular JavaScript functions?","answer":"In Svelte 5, runes are special symbols that control the Svelte compiler. They are essentially keywords in the Svelte language that have a `$` prefix and look like functions. For example: `let message = $state('hello');`.\n\nRunes differ from regular JavaScript functions in three important ways:\n1. You don't need to import them â they are built into the language\n2. They're not values â you cannot assign them to variables or pass them as arguments to functions\n3. Like JavaScript keywords, they are only valid in certain positions (the compiler will help you if you use them incorrectly)\n\nRunes are a new feature introduced in Svelte 5 and didn't exist in previous versions."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"Can you explain the syntax of runes in Svelte 5 with an example?","answer":"Runes in Svelte 5 have a specific syntax that distinguishes them from regular JavaScript code. All runes begin with a `$` prefix and are used like functions.\n\nHere's the basic syntax:\n```js\nlet variableName = $runeName(arguments);\n```\n\nFor example, with the `$state` rune:\n```js\nlet count = $state(0);\nlet user = $state({ name: 'Alice', age: 30 });\nlet items = $state(['apple', 'banana', 'cherry']);\n```\n\nThe `$` prefix signals to the Svelte compiler that this is a special instruction, not a regular function call. The compiler then processes these runes differently than it would process regular JavaScript code."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"In what file types can Svelte 5 runes be used?","answer":"According to the documentation, Svelte 5 runes can be used in the following file types:\n- `.svelte` files (Svelte component files)\n- `.svelte.js` files (Svelte JavaScript module files)\n- `.svelte.ts` files (Svelte TypeScript module files)\n\nThese are the file extensions where the Svelte compiler will recognize and process runes correctly. Using runes in other file types (like regular `.js` or `.ts` files) would not work as expected because the Svelte compiler doesn't process those files."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"What happens if you try to assign a rune to a variable or pass it as a function argument?","answer":"Runes in Svelte 5 cannot be assigned to variables or passed as function arguments because they are not values but rather part of the Svelte language syntax (similar to keywords in JavaScript).\n\nFor example, the following code would not work:\n\n```js\n// This won't work\nconst stateRune = $state;\nlet count = stateRune(0);\n\n// This also won't work\nfunction createState(runeFn, initialValue) {\n  return runeFn(initialValue);\n}\nlet count = createState($state, 0);\n```\n\nIf you attempt to use runes in these ways, the Svelte compiler will generate an error, informing you that runes can only be used in specific positions within your code."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"Are runes a backward-compatible feature in Svelte?","answer":"No, runes are not backward-compatible. As explicitly mentioned in the documentation with a \"LEGACY\" note: \"Runes didn't exist prior to Svelte 5.\"\n\nThis means that if you use runes in your code, it will only work with Svelte 5 or later versions. Code using runes cannot be used with Svelte 4 or earlier versions without modifications to remove or replace the rune functionality.\n\nThis represents a significant change in the Svelte framework's approach to reactivity and other core features."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"How does the Svelte compiler know to treat `$state` as a rune rather than a regular function call?","answer":"The Svelte compiler recognizes `$state` and other runes as special instructions rather than regular function calls through several mechanisms:\n\n1. The `$` prefix: All runes start with a dollar sign, which serves as a signal to the compiler.\n2. File context: Runes are only recognized in specific file types (`.svelte`, `.svelte.js`, and `.svelte.ts`).\n3. Syntactic analysis: The compiler analyzes the code and identifies patterns that match rune usage.\n\nWhen the compiler encounters a symbol with a `$` prefix that matches the pattern of a rune call in a valid file type, it treats it as a compiler instruction rather than as a regular JavaScript function call. This allows the compiler to apply special transformations to the code, enabling Svelte's reactivity system and other features.\n\nThe compiler will also verify that runes are used in valid positions within the code, similar to how JavaScript keywords can only be used in specific contexts."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"What error would you expect if you tried to import the `$state` rune?","answer":"If you tried to import the `$state` rune, you would receive a compiler error because runes are built into the Svelte language and don't need to be imported. They're not part of any module that can be imported.\n\nFor example, attempting to write:\n\n```js\nimport { $state } from 'svelte';\n// or\nimport { state as $state } from 'svelte';\n```\n\nWould result in an error. The compiler would inform you that runes are part of the language itself and don't need to be imported.\n\nThe correct way to use runes is to simply use them directly in your code without any import statements:\n\n```js\nlet count = $state(0);\n```\n\nThis is one of the key differences between runes and regular JavaScript functions - they're available globally within Svelte files without requiring imports."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"What is the conceptual meaning of the term \"rune\" in the context of Svelte 5?","answer":"The term \"rune\" in Svelte 5 draws from the definition provided in the documentation: \"A letter or mark used as a mystical or magic symbol.\"\n\nThis is an apt metaphor because:\n\n1. Like ancient runes, Svelte runes are special symbols (with the `$` prefix) that have power beyond their appearance.\n2. They invoke \"magic\" in the sense that they trigger special compiler behavior that transforms your code.\n3. They're part of a special \"language\" that the Svelte compiler understands.\n\nConceptually, runes represent a way for developers to communicate directly with the Svelte compiler, giving it instructions about how to transform and interpret the surrounding code. They're a bridge between regular JavaScript and Svelte's special features like reactivity.\n\nThe name \"rune\" helps distinguish these special compiler directives from regular JavaScript functions, emphasizing their unique nature and role in the framework."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"If runes are part of the Svelte language, how might this affect tooling like TypeScript or ESLint?","answer":"Since runes are part of the Svelte language and not standard JavaScript or TypeScript, this has several implications for tooling:\n\n1. **TypeScript**: Without special configuration, TypeScript would not recognize runes as valid syntax. TypeScript would need to be configured with Svelte-specific type definitions that define these runes. The Svelte team likely provides TypeScript declarations for runes to enable proper type checking and IntelliSense.\n\n2. **ESLint**: Standard ESLint configurations would flag runes as undefined variables or invalid syntax. Developers would need to use Svelte-specific ESLint plugins or configurations that understand runes.\n\n3. **Code editors**: IDEs and code editors would need Svelte-specific extensions to provide proper syntax highlighting, auto-completion, and error checking for runes.\n\n4. **Bundlers and transpilers**: Tools like Webpack, Rollup, or Babel would need Svelte-specific plugins to properly process files containing runes.\n\nThe introduction of runes represents a deeper integration of Svelte-specific syntax into the language, which means that the tooling ecosystem needs to adapt to properly support this syntax. This is similar to how JSX required special tooling support when it was introduced for React."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"How might the introduction of runes in Svelte 5 affect the migration of Svelte 4 projects?","answer":"The introduction of runes in Svelte 5 has significant implications for migrating projects from Svelte 4:\n\n1. **Breaking Change**: Since runes didn't exist in Svelte 4, they represent a new syntax and potentially a new mental model for reactivity and other features.\n\n2. **Code Refactoring**: Existing Svelte 4 code might need to be refactored to use runes if they replace or enhance previous patterns. For example, if runes provide a new way to handle reactivity, components using the old reactivity system might need updates.\n\n3. **Learning Curve**: Developers familiar with Svelte 4 will need to learn the new rune syntax and understand when and how to use them appropriately.\n\n4. **Tooling Updates**: Tools, plugins, and custom utilities built for Svelte 4 might need updates to support the new rune syntax.\n\n5. **Gradual Migration**: The Svelte team might provide a migration path that allows for gradual adoption of runes, possibly with compatibility layers or migration tools.\n\n6. **Documentation and Examples**: Existing documentation, tutorials, and examples based on Svelte 4 would need updates to reflect the new rune-based approach.\n\nThe introduction of such a fundamental new feature suggests that Svelte 5 represents a significant evolution of the framework, potentially requiring careful planning for migration from earlier versions."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"What are some examples of common runes in Svelte 5 besides `$state`?","answer":"While the provided documentation only explicitly mentions the `$state` rune, Svelte 5 likely includes several other runes for different purposes. Based on naming conventions and the purpose of runes, some possible examples might include:\n\n1. `$derived` - For creating derived state that updates when dependencies change\n2. `$effect` - For running side effects when reactive values change\n3. `$props` - For defining component props\n4. `$memo` - For memoizing expensive computations\n5. `$store` - For creating or accessing Svelte stores\n6. `$computed` - Another potential name for derived values\n\nA hypothetical example using multiple runes might look like:\n\n```js\nlet count = $state(0);\nlet doubleCount = $derived(count * 2);\n\n$effect(() => {\n  console.log(`Count changed to ${count}, double is ${doubleCount}`);\n});\n\nfunction increment() {\n  count++;\n}\n```\n\nHowever, it's important to note that the specific set of available runes and their exact syntax would be defined in the complete Svelte 5 documentation. The documentation excerpt provided only confirms the existence of `$state` as an example of a rune."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"How does the `$state` rune example in the documentation relate to reactivity in Svelte?","answer":"The `$state` rune example in the documentation (`let message = $state('hello')`) is related to Svelte's reactivity system. While the documentation doesn't explicitly explain the functionality of `$state`, its name and usage suggest that it's used to create reactive state in Svelte 5.\n\nIn Svelte's reactivity model, when state changes, the UI automatically updates to reflect those changes. The `$state` rune likely declares a reactive variable that, when modified, triggers updates to any part of the UI that depends on it.\n\nFor example:\n\n```svelte\n<script>\n  let count = $state(0);\n  \n  function increment() {\n    count++;  // This change would automatically update the UI\n  }\n</script>\n\n<button on:click={increment}>Increment</button>\n<p>The count is {count}</p>\n```\n\nIn this example, when the button is clicked and `count` is incremented, the paragraph displaying the count would automatically update without the developer having to manually update the DOM.\n\nThe `$state` rune appears to be Svelte 5's way of explicitly declaring reactive state, possibly replacing or enhancing the implicit reactivity model from previous Svelte versions where assignments to variables in component scripts were automatically tracked."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"How might runes affect the way component state is managed in Svelte 5 compared to Svelte 4?","answer":"In Svelte 4, reactivity was largely implicit - assigning to a variable declared in a component's script block would automatically trigger updates to any part of the UI that referenced that variable. The compiler would transform the code to track these assignments.\n\nWith the introduction of runes in Svelte 5, particularly the `$state` rune, it appears that state management becomes more explicit:\n\n```js\n// Svelte 4 style\nlet count = 0;  // Implicitly reactive when assigned to\n\n// Svelte 5 style with runes\nlet count = $state(0);  // Explicitly marked as reactive state\n```\n\nThis shift from implicit to explicit state declaration could have several implications:\n\n1. **Clarity**: It makes reactive state more obvious in the code, potentially improving readability.\n\n2. **Granularity**: It might allow developers to be more selective about what is reactive, potentially improving performance.\n\n3. **Consistency**: It creates a more consistent model across different contexts where reactivity is needed.\n\n4. **Mental Model**: It changes the mental model from \"assignments are tracked\" to \"state is declared.\"\n\n5. **External State**: It might make it easier to manage state outside of components or share state between components.\n\n6. **TypeScript Integration**: Explicit state declarations might improve type inference and checking.\n\nThis represents a significant evolution in Svelte's approach to reactivity, making the framework's behavior more explicit and potentially more powerful, while possibly requiring developers to be more deliberate about declaring state."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"What are the potential benefits of using runes in Svelte 5 compared to the previous approach?","answer":"The introduction of runes in Svelte 5 likely brings several benefits compared to the previous approach:\n\n1. **Explicit Reactivity**: By using runes like `$state`, developers explicitly declare what should be reactive, making the code's intent clearer.\n\n2. **Improved Debugging**: Explicit declarations might make it easier to track reactivity-related issues.\n\n3. **Optimized Compilation**: The compiler can potentially generate more efficient code when reactivity is explicitly declared.\n\n4. **Consistency Across Contexts**: Runes might provide a consistent way to handle reactivity in different contexts (components, modules, etc.).\n\n5. **Framework Evolution**: Runes provide a syntax for introducing new features without conflicting with existing JavaScript syntax.\n\n6. **Reduced \"Magic\"**: While Svelte is known for its \"magical\" reactivity, explicit runes might make the system feel less magical and more predictable.\n\n7. **Better TypeScript Integration**: Explicit declarations through runes might improve type inference and checking.\n\n8. **Enhanced Capabilities**: Runes might enable new features that weren't possible or were difficult to implement with the previous approach.\n\n9. **Modularity**: The explicit nature of runes might make it easier to use Svelte's reactivity system in non-component contexts.\n\n10. **Learning Curve**: For newcomers, explicit declarations might be easier to understand than implicit reactivity.\n\nThese benefits suggest that runes represent a significant evolution in Svelte's design philosophy, potentially making the framework more powerful, explicit, and easier to reason about."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"In what ways might the compiler behavior differ when processing code with runes versus regular JavaScript?","answer":"When processing code with runes, the Svelte compiler behaves differently from how it would process regular JavaScript in several ways:\n\n1. **Special Recognition**: The compiler specifically recognizes runes (symbols with `$` prefix) and treats them as compiler directives rather than regular function calls.\n\n2. **Code Transformation**: For runes, the compiler generates specialized code to implement features like reactivity, whereas regular JavaScript is generally passed through with minimal changes.\n\n3. **Static Analysis**: The compiler performs additional static analysis on runes to ensure they're used correctly and in valid positions.\n\n4. **Error Reporting**: The compiler provides specialized error messages for rune-related issues, different from regular JavaScript syntax errors.\n\n5. **Optimization**: Code using runes might undergo specific optimizations related to Svelte's reactivity system or other features.\n\n6. **Scope Handling**: The compiler might handle variable scopes differently when runes are involved, particularly for tracking reactive dependencies.\n\n7. **Type Handling**: In TypeScript contexts, runes might have special type handling different from regular functions.\n\n8. **Dead Code Elimination**: The compiler might apply different rules for eliminating unused code when runes are involved.\n\n9. **Build Output**: The compiled output for code using runes would include Svelte's runtime code for handling the specific features the runes enable.\n\nThis special treatment of runes is what enables Svelte's distinctive features like fine-grained reactivity, while still allowing developers to write code that looks similar to regular JavaScript."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"How might the context in which runes are used affect their behavior or validity?","answer":"The context in which runes are used can significantly affect their behavior and validity:\n\n1. **File Type Context**: As mentioned in the documentation, runes are only valid in `.svelte`, `.svelte.js`, and `.svelte.ts` files. Using them in regular `.js` or `.ts` files would result in errors.\n\n2. **Scope Context**: Runes might have different behavior or validity depending on whether they're used at the top level of a module, within a component script, inside functions, or in other scopes.\n\n3. **Initialization Context**: Runes like `$state` are likely meant for initialization (e.g., `let x = $state(0)`) and might not be valid in other contexts like reassignments.\n\n4. **Expression Context**: Runes might be invalid when used as part of larger expressions (e.g., `let x = $state(0) + 1`).\n\n5. **Component Lifecycle Context**: Some runes might only be valid during certain parts of a component's lifecycle.\n\n6. **Module vs Component Context**: Runes might behave differently when used in a component file versus a module file.\n\n7. **Server vs Client Context**: In server-side rendering contexts, certain runes might have different behavior or restrictions.\n\n8. **Conditional Context**: Using runes inside conditional statements might have special rules or limitations.\n\nFor example, a hypothetical usage might look like:\n\n```svelte\n<script>\n  // Valid: top-level in component script\n  let count = $state(0);\n  \n  function increment() {\n    // Valid: modifying state\n    count++;\n    \n    // Invalid: creating new state inside a function\n    let localState = $state(0);\n  }\n  \n  // Invalid: rune used in expression\n  let doubledState = $state(0) * 2;\n  \n  // Valid: using state in derived calculation\n  let doubled = $derived(count * 2);\n</script>\n```\n\nThe Svelte compiler would enforce these contextual rules and provide appropriate error messages when runes are used in invalid contexts."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"How might the introduction of runes affect the size and performance of compiled Svelte applications?","answer":"The introduction of runes in Svelte 5 could affect the size and performance of compiled applications in several ways:\n\n1. **Bundle Size Impact**:\n   - Positive: Explicit reactivity through runes might allow the compiler to generate more targeted code, potentially reducing bundle size.\n   - Negative: Supporting the rune system might require additional runtime code, potentially increasing the baseline bundle size.\n\n2. **Runtime Performance**:\n   - Positive: Explicit declaration of reactive state might enable more optimized change detection.\n   - Positive: The compiler can potentially generate more efficient code when it knows exactly what needs to be reactive.\n   - Negative: A more complex reactivity system might introduce some overhead in certain scenarios.\n\n3. **Compilation Performance**:\n   - The compiler might need to do more work to process runes, potentially increasing build times.\n   - However, explicit declarations might make some optimizations easier to implement.\n\n4. **Memory Usage**:\n   - Explicit reactivity might lead to more efficient memory usage by avoiding unnecessary reactivity.\n   - The runtime system for handling runes might have different memory characteristics than the previous approach.\n\n5. **Tree-shaking**:\n   - Runes might enable better tree-shaking of unused reactivity code.\n\nFor example, if only some variables need to be reactive:\n\n```js\n// With implicit reactivity, all variables might be treated as potentially reactive\nlet count = 0;\nlet nonReactive = \"hello\";\n\n// With explicit reactivity via runes, only count is reactive\nlet count = $state(0);\nlet nonReactive = \"hello\";  // Not reactive, potentially less overhead\n```\n\nThe actual impact would depend on the specific implementation details of the rune system and how it compares to Svelte 4's reactivity system. The Svelte team has historically prioritized performance, so it's likely that any changes would aim to maintain or improve Svelte's performance characteristics."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"How might developers need to adjust their mental model when transitioning from Svelte 4 to Svelte 5 with runes?","answer":"Transitioning from Svelte 4 to Svelte 5 with runes likely requires several adjustments to a developer's mental model:\n\n1. **From Implicit to Explicit Reactivity**: \n   - Svelte 4: \"All top-level variables in a component are potentially reactive when assigned to.\"\n   - Svelte 5: \"Only variables explicitly marked with `$state` or other reactivity runes are reactive.\"\n\n2. **Understanding Rune Semantics**:\n   - Learning what each rune does and when to use it.\n   - Understanding the constraints and rules around rune usage.\n\n3. **Compiler vs. Runtime Distinction**:\n   - Gaining a clearer understanding of what happens at compile time versus runtime.\n   - Recognizing that runes are compiler instructions, not runtime functions.\n\n4. **New Patterns for Common Tasks**:\n   - Learning new patterns for tasks like derived state, effects, and lifecycle management.\n   - For example, instead of `$: doubled = count * 2`, perhaps using `let doubled = $derived(count * 2)`.\n\n5. **Rethinking Component Design**:\n   - The new reactivity model might influence how components are structured.\n   - State management patterns might need to be reconsidered.\n\n6. **Different Debugging Approaches**:\n   - Debugging reactivity issues might require different techniques.\n   - Understanding how runes are transformed in the compiled output.\n\n7. **Adapting to New Best Practices**:\n   - Community best practices will evolve around runes.\n   - Previous patterns might become anti-patterns.\n\nFor example, a component that might have been written like this in Svelte 4:\n\n```svelte\n<script>\n  let count = 0;\n  $: doubled = count * 2;\n  \n  function increment() {\n    count += 1;\n  }\n  \n  $: {\n    console.log(`Count changed to ${count}`);\n  }\n</script>\n```\n\nMight be written like this in Svelte 5 with runes:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n  \n  function increment() {\n    count += 1;\n  }\n  \n  $effect(() => {\n    console.log(`Count changed to ${count}`);\n  });\n</script>\n```\n\nThis represents a significant shift in how reactivity is expressed, requiring developers to think more explicitly about what should be reactive and how reactivity flows through their application."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"What challenges might library authors face when supporting both Svelte 4 and Svelte 5 with runes?","answer":"Library authors supporting both Svelte 4 and Svelte 5 with runes would face several challenges:\n\n1. **Dual API Design**:\n   - Creating APIs that work with both Svelte 4's implicit reactivity and Svelte 5's rune-based approach.\n   - Potentially maintaining two versions of certain components or utilities.\n\n2. **Conditional Compilation**:\n   - Implementing detection mechanisms to determine which version of Svelte is being used.\n   - Using build tools to conditionally include the appropriate code.\n\n3. **Documentation Complexity**:\n   - Maintaining documentation that covers both approaches.\n   - Clearly explaining the differences and migration paths.\n\n4. **Testing Overhead**:\n   - Setting up test suites that verify functionality in both Svelte 4 and 5.\n   - Ensuring consistent behavior across versions.\n\n5. **TypeScript Type Definitions**:\n   - Creating type definitions that work correctly with both versions.\n   - Handling the new rune syntax in TypeScript.\n\n6. **Backward Compatibility Layers**:\n   - Potentially implementing compatibility layers to make Svelte 5 code work in Svelte 4 or vice versa.\n\n7. **Bundle Size Considerations**:\n   - Supporting both versions might increase bundle size if not carefully managed.\n\nFor example, a library author might need to implement a component like this:\n\n```js\n// Detect Svelte version\nconst isSvelte5 = typeof $state !== 'undefined';\n\nif (isSvelte5) {\n  // Svelte 5 implementation using runes\n  export function createCounter(initial = 0) {\n    let count = $state(initial);\n    return {\n      count,\n      increment: () => count++,\n      decrement: () => count--\n    };\n  }\n} else {\n  // Svelte 4 implementation using stores\n  import { writable } from 'svelte/store';\n  \n  export function createCounter(initial = 0) {\n    const count = writable(initial);\n    return {\n      count,\n      increment: () => count.update(n => n + 1),\n      decrement: () => count.update(n => n - 1)\n    };\n  }\n}\n```\n\nThis dual support would add complexity to library development and maintenance, potentially leading some authors to either drop support for older versions or delay adoption of the new features until they can fully transition."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"How might the introduction of runes in Svelte 5 influence the broader JavaScript ecosystem and other frameworks?","answer":"The introduction of runes in Svelte 5 could have several influences on the broader JavaScript ecosystem and other frameworks:\n\n1. **Reactivity System Evolution**:\n   - Other frameworks might be influenced by Svelte's explicit rune-based reactivity model.\n   - This could lead to convergence or divergence in how frameworks approach reactivity.\n\n2. **Compiler-First Approach**:\n   - Svelte's emphasis on compile-time with runes might encourage other frameworks to explore more compile-time optimizations.\n   - This could accelerate the trend toward build-time frameworks.\n\n3. **Syntax Innovation**:\n   - The `$` prefix for special compiler instructions might inspire similar syntax in other tools.\n   - It could normalize the idea of framework-specific syntax extensions to JavaScript.\n\n4. **Developer Experience Considerations**:\n   - Other frameworks might evaluate how explicit reactivity affects developer experience.\n   - This could influence design decisions in future framework versions.\n\n5. **Tooling Ecosystem**:\n   - Tools like ESLint, TypeScript, and various IDEs might evolve to better support framework-specific syntax like runes.\n   - This could lead to more sophisticated static analysis tools for framework code.\n\n6. **Cross-Framework Patterns**:\n   - Developers working across multiple frameworks might begin to expect similar explicit reactivity models.\n   - This could influence how developers structure their applications regardless of framework.\n\n7. **Web Standards Influence**:\n   - Successful patterns from runes might eventually influence web standards discussions.\n   - For example, if runes prove highly effective, similar patterns might be proposed for standardization.\n\n8. **Learning Resources**:\n   - The JavaScript learning ecosystem would expand to cover runes and similar concepts.\n   - This could raise the general understanding of reactivity systems among developers.\n\nFor example, we might see other frameworks experiment with similar approaches:\n\n```js\n// Hypothetical React-inspired syntax influenced by Svelte runes\nfunction Counter() {\n  const count = $state(0);\n  const doubled = $computed(() => count * 2);\n  \n  $effect(() => {\n    console.log(`Count changed to ${count}`);\n  });\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Doubled: {doubled}</p>\n      <button onClick={() => count++}>Increment</button>\n    </div>\n  );\n}\n```\n\nThe introduction of runes represents a significant innovation in how frameworks can extend JavaScript syntax for specific purposes, and its success or failure could influence the direction of frontend development more broadly."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"What is the purpose of the $state rune in Svelte 5, and how does it differ from state management in other frameworks?","answer":"The $state rune in Svelte 5 is used to create reactive state, which means that the UI automatically reacts and updates when the state changes. Unlike other frameworks where state management often involves special APIs, methods, or wrapper objects, Svelte's approach is much more straightforward.\n\nThe key difference is that with $state, you're working with regular JavaScript values rather than special objects or functions:\n\n```svelte\n<script>\n  let count = $state(0);\n</script>\n\n<button onclick={() => count++}>\n  clicks: {count}\n</button>\n```\n\nIn this example, `count` is just a regular number. You can update it using standard JavaScript operations (`count++`, `count = 10`, etc.) without needing to call special methods like `setState()`, `setValue()`, or using setters that you might find in other frameworks.\n\nThis design philosophy makes Svelte's reactivity system feel very natural - you write code as you normally would in JavaScript, and Svelte handles the reactivity behind the scenes."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"How does deep reactivity work with the $state rune when applied to arrays and objects?","answer":"When the $state rune is used with arrays or simple objects, Svelte creates a deeply reactive \"state proxy.\" This means that not only is the top-level object reactive, but all nested objects and arrays within it are also made reactive recursively.\n\nThese proxies allow Svelte to detect changes at any level of nesting, including when you use methods like `push()` on arrays or set properties deep within an object structure.\n\nFor example:\n\n```svelte\n<script>\n  let todos = $state([\n    {\n      done: false,\n      text: 'Learn Svelte 5'\n    },\n    {\n      done: true,\n      text: 'Read documentation'\n    }\n  ]);\n  \n  function toggleFirstTodo() {\n    // This change is detected even though it's nested inside an array\n    todos[0].done = !todos[0].done;\n  }\n  \n  function addTodo() {\n    // Adding a new object to the array is also reactive\n    todos.push({\n      done: false,\n      text: 'New todo item'\n    });\n    // The new object is automatically proxified\n  }\n</script>\n\n<button on:click={toggleFirstTodo}>Toggle first todo</button>\n<button on:click={addTodo}>Add todo</button>\n\n<ul>\n  {#each todos as todo}\n    <li class:done={todo.done}>\n      {todo.text}\n    </li>\n  {/each}\n</ul>\n```\n\nThe proxy system is applied recursively until Svelte encounters something that isn't an array or simple object. This allows for efficient updates that only affect the parts of the UI that depend on the specific properties that changed."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"What happens when you destructure values from a $state proxy, and why is this behavior important to understand?","answer":"When you destructure values from a $state proxy, the destructured variables are not reactive. They are evaluated at the point of destructuring and become detached from the reactive source.\n\nThis is a critical limitation to understand because it can lead to unexpected behavior if you're not aware of it:\n\n```svelte\n<script>\n  let person = $state({\n    name: 'Alice',\n    age: 30\n  });\n  \n  // Destructuring at this point\n  let { name, age } = person;\n  \n  function updatePerson() {\n    // This will update the reactive person object\n    person.age = 31;\n    person.name = 'Alicia';\n    \n    // But the destructured variables remain unchanged\n    console.log(name, age); // Still 'Alice' and 30\n  }\n</script>\n\n<div>\n  <!-- This will update when person changes -->\n  <p>From person object: {person.name}, {person.age}</p>\n  \n  <!-- This will NOT update when person changes -->\n  <p>From destructured vars: {name}, {age}</p>\n</div>\n\n<button on:click={updatePerson}>Update Person</button>\n```\n\nThis behavior is consistent with how JavaScript works normally - destructuring creates new variables with the values at that point in time. To maintain reactivity, you should access properties directly from the reactive object in your template or use derived state/computed values.\n\nIf you need to destructure for convenience in a function, do it locally within that function rather than at the component level:\n\n```svelte\n<script>\n  let person = $state({\n    name: 'Alice',\n    age: 30\n  });\n  \n  function formatPerson() {\n    // Local destructuring is fine for temporary use\n    let { name, age } = person;\n    return `${name} (${age})`;\n  }\n</script>\n```"}
{"source":"docs/svelte/02-runes/02-$state.md","question":"How can you use $state in classes, and what are the considerations when using methods from these classes in event handlers?","answer":"The $state rune can be used in class fields (both public and private) to create reactive properties within class instances. This allows for organizing related state and behavior together in an object-oriented approach.\n\nHere's how you can define a class with reactive state:\n\n```svelte\n<script>\n  class Todo {\n    done = $state(false);\n    text = $state('');\n    \n    constructor(text) {\n      this.text = text;\n    }\n    \n    toggle() {\n      this.done = !this.done;\n    }\n    \n    reset() {\n      this.text = '';\n      this.done = false;\n    }\n  }\n  \n  let todo = new Todo('Learn about $state in classes');\n</script>\n```\n\nHowever, when using methods from these classes in event handlers, you need to be careful about how `this` is bound. In JavaScript, the value of `this` inside a method depends on how the method is called.\n\nFor example, this won't work as expected:\n\n```svelte\n<button onclick={todo.reset}>Reset</button>\n```\n\nThe problem is that when the method is called this way, `this` inside the `reset` method will refer to the button element, not the `todo` instance. There are two ways to solve this:\n\n1. Use an inline function:\n```svelte\n<button onclick={() => todo.reset()}>Reset</button>\n```\n\n2. Define the method as an arrow function in the class:\n```js\nclass Todo {\n  done = $state(false);\n  text = $state('');\n  \n  constructor(text) {\n    this.text = text;\n  }\n  \n  // Arrow function preserves 'this' context\n  reset = () => {\n    this.text = '';\n    this.done = false;\n  }\n}\n```\n\nUsing arrow functions in class definitions ensures that `this` is always bound to the instance, but it has some trade-offs in terms of memory usage (each instance gets its own copy of the method rather than sharing it on the prototype).\n\nA complete example:\n\n```svelte\n<script>\n  class Todo {\n    done = $state(false);\n    text = $state('');\n    \n    constructor(text) {\n      this.text = text;\n    }\n    \n    toggle = () => {\n      this.done = !this.done;\n    }\n    \n    reset = () => {\n      this.text = '';\n      this.done = false;\n    }\n  }\n  \n  let todo = new Todo('Learn Svelte 5');\n</script>\n\n<div>\n  <input type=\"checkbox\" checked={todo.done} on:change={todo.toggle}>\n  <span class:completed={todo.done}>{todo.text}</span>\n  <button on:click={todo.reset}>Reset</button>\n</div>\n```"}
{"source":"docs/svelte/02-runes/02-$state.md","question":"What is $state.raw and when would you use it instead of regular $state?","answer":"`$state.raw` is a variant of the $state rune that creates reactive state without making objects and arrays deeply reactive. Unlike regular `$state`, which creates proxies for nested objects and arrays, `$state.raw` only makes the top-level assignment reactive.\n\nWith `$state.raw`, you cannot mutate properties of the object or use array methods like `push()` to trigger reactivity. Instead, you must replace the entire value with a new one:\n\n```svelte\n<script>\n  // Using $state.raw for an object\n  let person = $state.raw({\n    name: 'Heraclitus',\n    age: 49\n  });\n  \n  function incrementAge() {\n    // This will NOT work - mutation doesn't trigger updates\n    person.age += 1;\n    \n    // This WILL work - replacing the entire object\n    person = {\n      ...person,\n      age: person.age + 1\n    };\n  }\n  \n  // Using $state.raw for an array\n  let numbers = $state.raw([1, 2, 3]);\n  \n  function addNumber() {\n    // This will NOT work - array method doesn't trigger updates\n    numbers.push(numbers.length + 1);\n    \n    // This WILL work - creating a new array\n    numbers = [...numbers, numbers.length + 1];\n  }\n</script>\n\n<div>\n  <p>Person: {person.name}, {person.age}</p>\n  <button on:click={incrementAge}>Increment Age</button>\n  \n  <p>Numbers: {numbers.join(', ')}</p>\n  <button on:click={addNumber}>Add Number</button>\n</div>\n```\n\nYou would use `$state.raw` in the following scenarios:\n\n1. **Performance optimization**: For large objects or arrays that you don't plan to mutate but only replace entirely, `$state.raw` avoids the overhead of creating proxies for all nested properties.\n\n2. **Immutable data patterns**: If you're already following immutable data patterns (always creating new objects/arrays rather than mutating), `$state.raw` aligns with that approach.\n\n3. **External library compatibility**: Some external libraries might not work well with proxies, so using `$state.raw` can avoid potential issues.\n\n4. **Mixed reactivity**: You can have a raw container with reactive items. For example:\n```js\n// An array that itself is only reactive on replacement,\n// but contains objects that are deeply reactive\nlet todos = $state.raw([\n  $state({ text: 'Learn Svelte', done: false }),\n  $state({ text: 'Build an app', done: false })\n]);\n```\n\nThe key difference to remember is that with `$state.raw`, you must think in terms of replacement rather than mutation to trigger reactivity."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"How does $state.snapshot work, and in what scenarios would you use it?","answer":"`$state.snapshot` is a utility function that creates a static, non-reactive copy of a reactive state object. It takes a deeply reactive `$state` proxy and returns a plain JavaScript object or array that contains the current values but without any of the proxy wrapping.\n\nHere's how you use it:\n\n```svelte\n<script>\n  let counter = $state({ count: 0, lastClicked: null });\n  \n  function handleClick() {\n    counter.count++;\n    counter.lastClicked = new Date();\n    \n    // Create a snapshot of the current state\n    const snapshot = $state.snapshot(counter);\n    \n    // Log the plain object (not a proxy)\n    console.log(snapshot); // { count: 1, lastClicked: Date object }\n    \n    // Use the snapshot with an API or library\n    saveToDatabase(snapshot);\n  }\n  \n  function saveToDatabase(data) {\n    // Some external API call that expects a plain object\n    fetch('/api/save', {\n      method: 'POST',\n      body: JSON.stringify(data)\n    });\n  }\n</script>\n\n<button on:click={handleClick}>\n  Clicked {counter.count} times\n</button>\n```\n\nYou would use `$state.snapshot` in the following scenarios:\n\n1. **Working with external libraries**: Many libraries don't expect or can't properly handle proxy objects. For example, if you're using `structuredClone()`, JSON serialization, or certain DOM APIs.\n\n```js\n// This might cause issues because structuredClone can't handle proxies\nconst clonedState = structuredClone(reactiveObject);\n\n// This works correctly\nconst clonedState = structuredClone($state.snapshot(reactiveObject));\n```\n\n2. **Debugging**: When logging state to the console, proxies can be harder to inspect. A snapshot gives you a clean view of the current values.\n\n```js\n// Console output shows proxy internals\nconsole.log(reactiveObject);\n\n// Console output shows just the data\nconsole.log($state.snapshot(reactiveObject));\n```\n\n3. **Sending data over network**: When you need to send state to a server or through postMessage, having a plain object is usually safer.\n\n4. **Creating history/undo functionality**: If you're implementing undo/redo functionality, you can store snapshots of the state at different points in time.\n\n```js\nlet history = $state([]);\nlet currentState = $state({ value: 0 });\n\nfunction makeChange(newValue) {\n  // Save current state to history before changing\n  history.push($state.snapshot(currentState));\n  \n  // Update the state\n  currentState.value = newValue;\n}\n\nfunction undo() {\n  if (history.length > 0) {\n    // Restore previous state\n    currentState = $state(history.pop());\n  }\n}\n```\n\nRemember that the snapshot is a one-time copy - it won't stay in sync with the original state after it's created. If the original state changes after taking a snapshot, those changes won't be reflected in the snapshot."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"Explain how passing state to functions works in Svelte 5, and why it's important to understand JavaScript's pass-by-value nature when working with reactive state.","answer":"When passing state to functions in Svelte 5, it's crucial to understand that JavaScript is a pass-by-value language. This means that when you call a function, the arguments are the values themselves, not references to the variables that hold those values.\n\nWith reactive state, this has important implications:\n\n```svelte\n<script>\n  let count = $state(0);\n  \n  // This function receives the current value of count when called\n  function double(value) {\n    return value * 2;\n  }\n  \n  // The result is calculated once and doesn't update\n  let doubled = double(count);\n  \n  function increment() {\n    count++;\n    console.log(count); // Incremented value\n    console.log(doubled); // Still the initial doubled value\n  }\n</script>\n\n<button on:click={increment}>Increment</button>\n<p>Count: {count}, Doubled: {doubled}</p>\n```\n\nIn this example, `doubled` won't automatically update when `count` changes because `double()` was called once with the initial value of `count`. The function received a copy of that value, not a reactive connection to the variable.\n\nTo maintain reactivity when passing state to functions, you have several options:\n\n1. **Call the function directly in the template or where you need the result**:\n```svelte\n<p>Count: {count}, Doubled: {double(count)}</p>\n```\n\n2. **Use functions that return functions** (higher-order functions):\n```svelte\n<script>\n  let a = $state(1);\n  let b = $state(2);\n  \n  // This function returns a function that will recalculate when called\n  function createAdder(getA, getB) {\n    return () => getA() + getB();\n  }\n  \n  // Pass functions that return the current values\n  let sum = createAdder(() => a, () => b);\n  \n  function updateValues() {\n    a = 3;\n    b = 4;\n    console.log(sum()); // Will be 7, not 3\n  }\n</script>\n\n<p>Sum: {sum()}</p>\n<button on:click={updateValues}>Update</button>\n```\n\n3. **Use object properties with getters**:\n```svelte\n<script>\n  let input = $state({ a: 1, b: 2 });\n  \n  // This object has a getter that recalculates when accessed\n  let result = {\n    get value() {\n      return input.a + input.b;\n    }\n  };\n  \n  function updateValues() {\n    input.a = 3;\n    input.b = 4;\n    console.log(result.value); // Will be 7\n  }\n</script>\n\n<p>Result: {result.value}</p>\n<button on:click={updateValues}>Update</button>\n```\n\n4. **Use classes with methods that access this**:\n```svelte\n<script>\n  class Calculator {\n    a = $state(1);\n    b = $state(2);\n    \n    get sum() {\n      return this.a + this.b;\n    }\n    \n    updateValues(newA, newB) {\n      this.a = newA;\n      this.b = newB;\n    }\n  }\n  \n  let calc = new Calculator();\n</script>\n\n<p>Sum: {calc.sum}</p>\n<button on:click={() => calc.updateValues(3, 4)}>Update</button>\n```\n\nUnderstanding this pass-by-value behavior is essential for proper state management in Svelte applications. When you need a calculation to update reactively, you need to ensure it has access to the current values at the time it's evaluated, not just the values when it was first defined."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"What are the limitations of the deep reactivity system when using $state with complex objects?","answer":"While Svelte's deep reactivity system with $state is powerful, it does have several limitations when working with complex objects:\n\n1. **Non-object/array values aren't proxified**: The deep reactivity only works for arrays and \"simple objects\" (POJOs - Plain Old JavaScript Objects). Other types like Maps, Sets, Date objects, custom classes, etc., won't be made deeply reactive.\n\n```svelte\n<script>\n  // The Map itself isn't deeply reactive\n  let userMap = $state(new Map());\n  \n  function addUser() {\n    // This won't trigger reactivity\n    userMap.set('user1', { name: 'Alice' });\n    \n    // You need to force a reassignment\n    userMap = new Map(userMap);\n  }\n  \n  // Similarly with Set, Date, etc.\n  let dateSet = $state(new Set());\n  \n  function addDate() {\n    // This won't trigger reactivity\n    dateSet.add(new Date());\n    \n    // You need to force a reassignment\n    dateSet = new Set(dateSet);\n  }\n</script>\n```\n\n2. **Destructuring breaks reactivity**: When you destructure values from a reactive object, the destructured variables are not reactive:\n\n```svelte\n<script>\n  let person = $state({ name: 'Alice', age: 30 });\n  \n  // These destructured variables are not reactive\n  let { name, age } = person;\n  \n  function updatePerson() {\n    person.age++;\n    // The 'age' variable above remains 30\n  }\n</script>\n```\n\n3. **Property deletion might not be tracked**: While adding and modifying properties is tracked, deleting properties with the `delete` operator might not always trigger updates in all cases:\n\n```svelte\n<script>\n  let obj = $state({ a: 1, b: 2, c: 3 });\n  \n  function removeProperty() {\n    // This might not always trigger updates correctly\n    delete obj.b;\n    \n    // More reliable alternative\n    const { b, ...rest } = obj;\n    obj = rest;\n  }\n</script>\n```\n\n4. **Non-enumerable properties**: The proxy system primarily tracks enumerable properties, so non-enumerable properties might not trigger reactivity correctly.\n\n5. **Symbol properties**: Properties with Symbol keys might not be tracked correctly in all cases.\n\n6. **Performance with very large objects**: Deep reactivity creates proxies for every nested object and array, which can have performance implications for very large, deeply nested data structures. In such cases, consider using `$state.raw` for parts of your state tree that don't need deep reactivity.\n\n7. **Circular references**: While proxies can handle circular references better than some other approaches, extremely complex circular reference structures might still cause issues.\n\nTo work around these limitations:\n\n1. For non-object types like Map and Set, use immutable update patterns (create new instances).\n2. For destructuring, either avoid it or do it locally within functions rather than at component scope.\n3. Use classes with $state fields for more complex objects that need methods and custom behavior.\n4. Consider breaking very large state objects into smaller, more manageable pieces.\n5. Use `$state.raw` for parts of your state that don't need deep reactivity.\n\n```svelte\n<script>\n  // Example of working with a Map reactively\n  let userState = $state({\n    userMap: new Map(),\n    lastUpdated: null\n  });\n  \n  function addUser(id, name) {\n    // Create a new Map with the additional entry\n    const newMap = new Map(userState.userMap);\n    newMap.set(id, { name });\n    \n    // Update the state\n    userState.userMap = newMap;\n    userState.lastUpdated = new Date();\n  }\n</script>\n```"}
{"source":"docs/svelte/02-runes/02-$state.md","question":"What's the difference between using $state on a class field versus using it on a regular variable, and what are the advantages of the class-based approach?","answer":"Using $state on a class field versus a regular variable represents two different approaches to organizing reactive state in Svelte 5, each with distinct characteristics and advantages.\n\n**Basic Difference:**\n\nWith regular variables:\n```svelte\n<script>\n  let count = $state(0);\n  let name = $state('Guest');\n  \n  function increment() {\n    count++;\n  }\n  \n  function updateName(newName) {\n    name = newName;\n  }\n</script>\n```\n\nWith class fields:\n```svelte\n<script>\n  class User {\n    count = $state(0);\n    name = $state('Guest');\n    \n    increment() {\n      this.count++;\n    }\n    \n    updateName(newName) {\n      this.name = newName;\n    }\n  }\n  \n  let user = new User();\n</script>\n```\n\n**Advantages of the Class-Based Approach:**\n\n1. **Encapsulation of Related State and Behavior**: Classes allow you to group related state and the methods that operate on that state together, creating a more cohesive unit.\n\n```svelte\n<script>\n  class ShoppingCart {\n    items = $state([]);\n    total = $state(0);\n    \n    addItem(item) {\n      this.items.push(item);\n      this.recalculateTotal();\n    }\n    \n    removeItem(index) {\n      this.items.splice(index, 1);\n      this.recalculateTotal();\n    }\n    \n    recalculateTotal() {\n      this.total = this.items.reduce((sum, item) => sum + item.price, 0);\n    }\n    \n    applyDiscount(percentage) {\n      this.total = this.total * (1 - percentage / 100);\n    }\n  }\n  \n  let cart = new ShoppingCart();\n</script>\n\n<div>\n  <h2>Shopping Cart (Total: ${cart.total})</h2>\n  <ul>\n    {#each cart.items as item, i}\n      <li>\n        {item.name} - ${item.price}\n        <button on:click={() => cart.removeItem(i)}>Remove</button>\n      </li>\n    {/each}\n  </ul>\n  <button on:click={() => cart.addItem({ name: 'Product', price: 9.99 })}>\n    Add Item\n  </button>\n</div>\n```\n\n2. **Reusability and Instance Creation**: You can create multiple instances of the same class, each with its own state:\n\n```svelte\n<script>\n  class Counter {\n    count = $state(0);\n    label = $state('Counter');\n    \n    increment() {\n      this.count++;\n    }\n    \n    reset() {\n      this.count = 0;\n    }\n  }\n  \n  let counter1 = new Counter();\n  counter1.label = 'First Counter';\n  \n  let counter2 = new Counter();\n  counter2.label = 'Second Counter';\n</script>\n\n<div>\n  <div>\n    <h3>{counter1.label}: {counter1.count}</h3>\n    <button on:click={() => counter1.increment()}>Increment</button>\n    <button on:click={() => counter1.reset()}>Reset</button>\n  </div>\n  \n  <div>\n    <h3>{counter2.label}: {counter2.count}</h3>\n    <button on:click={() => counter2.increment()}>Increment</button>\n    <button on:click={() => counter2.reset()}>Reset</button>\n  </div>\n</div>\n```\n\n3. **Private Fields and Encapsulation**: You can use private class fields (with the `#` prefix) to hide implementation details:\n\n```svelte\n<script>\n  class PasswordManager {\n    username = $state('');\n    #password = $state('');  // Private field\n    isLoggedIn = $state(false);\n    \n    login(username, password) {\n      this.username = username;\n      this.#password = password;\n      this.#authenticate();\n    }\n    \n    #authenticate() {\n      // Private method\n      // In a real app, this would verify credentials\n      this.isLoggedIn = this.#password.length > 0;\n    }\n    \n    logout() {\n      this.username = '';\n      this.#password = '';\n      this.isLoggedIn = false;\n    }\n  }\n  \n  let auth = new PasswordManager();\n</script>\n```\n\n4. **Inheritance and Polymorphism**: You can use class inheritance to extend functionality:\n\n```svelte\n<script>\n  class BaseForm {\n    values = $state({});\n    errors = $state({});\n    \n    setValue(field, value) {\n      this.values[field] = value;\n      this.validate();\n    }\n    \n    validate() {\n      // Base validation logic\n    }\n  }\n  \n  class LoginForm extends BaseForm {\n    constructor() {\n      super();\n      this.values = { username: '', password: '' };\n    }\n    \n    validate() {\n      super.validate();\n      this.errors = {};\n      \n      if (!this.values.username) {\n        this.errors.username = 'Username is required';\n      }\n      \n      if (!this.values.password) {\n        this.errors.password = 'Password is required';\n      }\n    }\n    \n    submit() {\n      this.validate();\n      if (Object.keys(this.errors).length === 0) {\n        // Submit form\n      }\n    }\n  }\n  \n  let loginForm = new LoginForm();\n</script>\n```\n\n5. **Computed Properties with Getters**: You can use getters to create computed properties:\n\n```svelte\n<script>\n  class Person {\n    firstName = $state('John');\n    lastName = $state('Doe');\n    \n    get fullName() {\n      return `${this.firstName} ${this.lastName}`;\n    }\n  }\n  \n  let person = new Person();\n</script>\n\n<div>\n  <input bind:value={person.firstName} placeholder=\"First name\">\n  <input bind:value={person.lastName} placeholder=\"Last name\">\n  <p>Full name: {person.fullName}</p>\n</div>\n```\n\n6. **Method Binding Considerations**: As mentioned in the documentation, when using class methods in event handlers, be aware of `this` binding. You can use arrow functions in the class definition to avoid binding issues:\n\n```svelte\n<script>\n  class ClickCounter {\n    count = $state(0);\n    \n    // Arrow function preserves 'this'\n    increment = () => {\n      this.count++;\n    }\n  }\n  \n  let counter = new ClickCounter();\n</script>\n\n<!-- This works correctly because of the arrow function -->\n<button on:click={counter.increment}>\n  Increment ({counter.count})\n</button>\n```\n\nThe class-based approach is particularly valuable for complex components with multiple related state variables and methods that operate on that state. It provides better organization and encapsulation compared to using individual state variables, especially as your component's complexity grows."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"How can you effectively work with arrays in $state and what patterns should you use for adding, removing, and updating items?","answer":"Working with arrays in $state leverages Svelte's deep reactivity system, which automatically tracks changes to the array and its items. Here are effective patterns for common array operations:\n\n### Adding Items to Arrays\n\nYou can use standard array methods like `push`, `unshift`, or spread syntax:\n\n```svelte\n<script>\n  let todos = $state([\n    { id: 1, text: 'Learn Svelte', done: false }\n  ]);\n  \n  function addTodo(text) {\n    // Method 1: push (mutates the original array)\n    todos.push({ id: Date.now(), text, done: false });\n    \n    // Method 2: spread syntax (creates a new array)\n    todos = [...todos, { id: Date.now(), text, done: false }];\n    \n    // Method 3: unshift (adds to beginning, mutates original)\n    todos.unshift({ id: Date.now(), text, done: false });\n  }\n</script>\n\n<button on:click={() => addTodo('New todo')}>Add Todo</button>\n<ul>\n  {#each todos as todo}\n    <li>{todo.text}</li>\n  {/each}\n</ul>\n```\n\nWith $state, both mutation and replacement approaches work because the array is proxified.\n\n### Removing Items from Arrays\n\nYou can use methods like `splice`, `filter`, or slice manipulation:\n\n```svelte\n<script>\n  let todos = $state([\n    { id: 1, text: 'Learn Svelte', done: false },\n    { id: 2, text: 'Build an app', done: false }\n  ]);\n  \n  function removeTodo(id) {\n    // Method 1: splice (mutates the original array)\n    const index = todos.findIndex(todo => todo.id === id);\n    if (index !== -1) {\n      todos.splice(index, 1);\n    }\n    \n    // Method 2: filter (creates a new array)\n    todos = todos.filter(todo => todo.id !== id);\n  }\n</script>\n\n<ul>\n  {#each todos as todo}\n    <li>\n      {todo.text}\n      <button on:click={() => removeTodo(todo.id)}>Remove</button>\n    </li>\n  {/each}\n</ul>\n```\n\n### Updating Items in Arrays\n\nYou can update items by direct property access, using `map`, or with array index:\n\n```svelte\n<script>\n  let todos = $state([\n    { id: 1, text: 'Learn Svelte', done: false },\n    { id: 2, text: 'Build an app', done: false }\n  ]);\n  \n  function toggleTodo(id) {\n    // Method 1: Direct property access (if you have the reference)\n    const todo = todos.find(t => t.id === id);\n    if (todo) {\n      todo.done = !todo.done;\n    }\n    \n    // Method 2: Update by index\n    const index = todos.findIndex(t => t.id === id);\n    if (index !== -1) {\n      todos[index].done = !todos[index].done;\n      \n      // Alternatively, replace the whole object at that index\n      todos[index] = { ...todos[index], done: !todos[index].done };\n    }\n    \n    // Method 3: map (creates a new array)\n    todos = todos.map(todo => \n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    );\n  }\n  \n  function updateTodoText(id, newText) {\n    const index = todos.findIndex(t => t.id === id);\n    if (index !== -1) {\n      todos[index].text = newText;\n    }\n  }\n</script>\n\n<ul>\n  {#each todos as todo}\n    <li>\n      <input \n        type=\"checkbox\" \n        checked={todo.done} \n        on:change={() => toggleTodo(todo.id)}\n      />\n      <span class:completed={todo.done}>{todo.text}</span>\n      <button on:click={() => updateTodoText(todo.id, 'Updated text')}>\n        Update\n      </button>\n    </li>\n  {/each}\n</ul>\n```\n\n### Reordering Array Items\n\nYou can reorder using array methods or by creating a new array:\n\n```svelte\n<script>\n  let todos = $state([\n    { id: 1, text: 'Learn Svelte', done: false },\n    { id: 2, text: 'Build an app', done: false },\n    { id: 3, text: 'Deploy app', done: false }\n  ]);\n  \n  function moveUp(index) {\n    if (index <= 0) return;\n    \n    // Method 1: Swap elements (mutates array)\n    [todos[index], todos[index-1]] = [todos[index-1], todos[index]];\n    \n    // Method 2: Create new array with reordered elements\n    const newTodos = [...todos];\n    const item = newTodos.splice(index, 1)[0];\n    newTodos.splice(index - 1, 0, item);\n    todos = newTodos;\n  }\n  \n  function moveDown(index) {\n    if (index >= todos.length - 1) return;\n    \n    // Similar to moveUp but incrementing index\n    [todos[index], todos[index+1]] = [todos[index+1], todos[index]];\n  }\n  \n  function sortByText() {\n    // Create a new sorted array\n    todos = [...todos].sort((a, b) => a.text.localeCompare(b.text));\n  }\n</script>\n\n<button on:click={sortByText}>Sort Alphabetically</button>\n<ul>\n  {#each todos as todo, i}\n    <li>\n      {todo.text}\n      <button on:click={() => moveUp(i)} disabled={i === 0}>â</button>\n      <button on:click={() => moveDown(i)} disabled={i === todos.length - 1}>â</button>\n    </li>\n  {/each}\n</ul>\n```\n\n### Working with Nested Arrays\n\nWith deep reactivity, you can modify nested arrays as well:\n\n```svelte\n<script>\n  let categories = $state([\n    { \n      name: 'Work', \n      tasks: [\n        { text: 'Project A', done: false },\n        { text: 'Project B', done: true }\n      ]\n    },\n    { \n      name: 'Personal', \n      tasks: [\n        { text: 'Exercise', done: false }\n      ]\n    }\n  ]);\n  \n  function addTask(categoryIndex, taskText) {\n    categories[categoryIndex].tasks.push({\n      text: taskText,\n      done: false\n    });\n  }\n  \n  function toggleTask(categoryIndex, taskIndex) {\n    const task = categories[categoryIndex].tasks[taskIndex];\n    task.done = !task.done;\n  }\n</script>\n\n{#each categories as category, i}\n  <div>\n    <h3>{category.name}</h3>\n    <ul>\n      {#each category.tasks as task, j}\n        <li>\n          <input \n            type=\"checkbox\" \n            checked={task.done}\n            on:change={() => toggleTask(i, j)}\n          />\n          {task.text}\n        </li>\n      {/each}\n    </ul>\n    <button on:click={() => addTask(i, 'New task')}>\n      Add Task\n    </button>\n  </div>\n{/each}\n```\n\n### Best Practices\n\n1. **Prefer direct mutation for simple cases**: With $state, direct mutation of arrays (push, splice, etc.) works fine and is often cleaner.\n\n2. **Use immutable patterns for complex updates**: For more complex transformations, creating new arrays can be clearer and less error-prone.\n\n3. **Be careful with array references**: If you store a reference to an array item, remember it's still connected to the original array.\n\n4. **Use unique identifiers**: When working with arrays of objects, giving each item a unique ID makes operations like finding and updating specific items easier.\n\n5. **Consider using helper functions**: For common array operations, create reusable helper functions to keep your component code clean.\n\n```svelte\n<script>\n  let todos = $state([\n    { id: 1, text: 'Learn Svelte', done: false },\n    { id: 2, text: 'Build an app', done: false }\n  ]);\n  \n  // Helper functions\n  function addTodo(text) {\n    todos.push({ id: Date.now(), text, done: false });\n  }\n  \n  function removeTodo(id) {\n    todos = todos.filter(todo => todo.id !== id);\n  }\n  \n  function toggleTodo(id) {\n    const todo = todos.find(t => t.id === id);\n    if (todo) todo.done = !todo.done;\n  }\n</script>\n```\n\nWith Svelte's $state, you have the flexibility to choose between mutation and replacement patterns depending on what makes the most sense for your specific use case."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"How can you combine $state.raw and regular $state to optimize performance in applications with large data structures?","answer":"Combining `$state.raw` and regular `$state` can be a powerful strategy for optimizing performance in applications with large data structures. This hybrid approach allows you to be selective about which parts of your state tree need deep reactivity and which parts can use the more lightweight raw state.\n\n### Basic Strategy\n\nThe core strategy is to use `$state.raw` for large containers that you only replace entirely, while using regular `$state` for individual items or smaller objects that need fine-grained reactivity:\n\n```svelte\n<script>\n  // Large collection using raw state (only reactive on replacement)\n  let userCollection = $state.raw({\n    users: [\n      { id: 1, name: 'Alice', details: { age: 28, role: 'Developer' } },\n      { id: 2, name: 'Bob', details: { age: 34, role: 'Designer' } },\n      // ... potentially hundreds more users\n    ],\n    metadata: {\n      lastUpdated: new Date(),\n      totalCount: 2\n    }\n  });\n  \n  // Active user using regular state (deeply reactive)\n  let activeUser = $state(null);\n  \n  function selectUser(id) {\n    // Find the user from the raw collection\n    const user = userCollection.users.find(u => u.id === id);\n    \n    // Create a reactive copy for editing\n    activeUser = user ? { ...user } : null;\n  }\n  \n  function saveUser() {\n    if (!activeUser) return;\n    \n    // Create a new array with the updated user\n    const updatedUsers = userCollection.users.map(user => \n      user.id === activeUser.id ? { ...activeUser } : user\n    );\n    \n    // Replace the entire raw state object\n    userCollection = {\n      users: updatedUsers,\n      metadata: {\n        lastUpdated: new Date(),\n        totalCount: updatedUsers.length\n      }\n    };\n    \n    // Clear the active user\n    activeUser = null;\n  }\n</script>\n\n<!-- Display the user list -->\n<div class=\"user-list\">\n  {#each userCollection.users as user}\n    <div \n      class=\"user-item\" \n      class:active={activeUser?.id === user.id}\n      on:click={() => selectUser(user.id)}\n    >\n      {user.name}\n    </div>\n  {/each}\n</div>\n\n<!-- Edit the active user -->\n{#if activeUser}\n  <div class=\"user-editor\">\n    <input bind:value={activeUser.name} />\n    <input bind:value={activeUser.details.age} type=\"number\" />\n    <input bind:value={activeUser.details.role} />\n    <button on:click={saveUser}>Save</button>\n  </div>\n{/if}\n```\n\n### Advanced Patterns\n\nHere are more sophisticated patterns for combining raw and regular state:\n\n#### 1. Raw Collections with Reactive Items\n\nUse `$state.raw` for the collection and `$state` for individual items when they become active:\n\n```svelte\n<script>\n  // Large raw collection\n  let productCatalog = $state.raw([\n    /* hundreds of products */\n  ]);\n  \n  // Currently viewed products (deeply reactive)\n  let viewedProducts = $state([]);\n  \n  function loadPage(pageNumber) {\n    // Extract a page of products from the raw catalog\n    const startIndex = (pageNumber - 1) * 10;\n    const pageItems = productCatalog.slice(startIndex, startIndex + 10);\n    \n    // Make these items reactive for the current view\n    viewedProducts = pageItems.map(product => ({ ...product }));\n  }\n  \n  // Initialize with first page\n  loadPage(1);\n</script>\n\n<!-- Only render the current page of products -->\n{#each viewedProducts as product}\n  <div class=\"product-card\">\n    <h3>{product.name}</h3>\n    <p>{product.description}</p>\n    <button on:click={() => product.quantity += 1}>\n      Add to Cart ({product.quantity})\n    </button>\n  </div>\n{/each}\n```\n\n#### 2. Virtualized List with Raw Data and Reactive Viewport\n\nFor extremely large lists, combine raw state with virtualization:\n\n```svelte\n<script>\n  // Thousands of items in raw state\n  let allItems = $state.raw(Array.from({ length: 10000 }, (_, i) => ({\n    id: i,\n    text: `Item ${i}`,\n    data: { /* more properties */ }\n  })));\n  \n  // Only the visible items are deeply reactive\n  let visibleItems = $state([]);\n  let scrollPosition = $state(0);\n  let itemHeight = 50; // pixels\n  let containerHeight = 500; // pixels\n  \n  function updateVisibleItems() {\n    const startIndex = Math.floor(scrollPosition / itemHeight);\n    const visibleCount = Math.ceil(containerHeight / itemHeight) + 1;\n    \n    // Extract only the visible slice and make it reactive\n    visibleItems = allItems\n      .slice(startIndex, startIndex + visibleCount)\n      .map(item => ({ ...item }));\n  }\n  \n  function handleScroll(event) {\n    scrollPosition = event.target.scrollTop;\n    updateVisibleItems();\n  }\n  \n  // Initialize visible items\n  updateVisibleItems();\n</script>\n\n<div \n  class=\"virtual-list\"\n  style=\"height: {containerHeight}px; overflow-y: scroll;\"\n  on:scroll={handleScroll}\n>\n  <div style=\"height: {allItems.length * itemHeight}px; position: relative;\">\n    {#each visibleItems as item}\n      <div \n        style=\"position: absolute; top: {(item.id * itemHeight)}px; height: {itemHeight}px;\"\n      >\n        {item.text}\n        <!-- Reactive UI for this item -->\n        <input bind:value={item.data.someProperty} />\n      </div>\n    {/each}\n  </div>\n</div>\n```\n\n#### 3. Raw State for Immutable Data, Regular State for UI State\n\nUse `$state.raw` for reference data that rarely changes and regular `$state` for UI state:\n\n```svelte\n<script>\n  // Reference data in raw state (countries, categories, etc.)\n  let referenceData = $state.raw({\n    countries: [/* large list of countries */],\n    categories: [/* product categories */],\n    taxRates: {/* tax information */}\n  });\n  \n  // UI state with regular state (deeply reactive)\n  let uiState = $state({\n    selectedCountry: null,\n    selectedCategories: [],\n    filters: {\n      priceRange: [0, 1000],\n      inStock: true\n    },\n    pagination: {\n      currentPage: 1,\n      itemsPerPage: 20\n    }\n  });\n  \n  function selectCountry(countryCode) {\n    uiState.selectedCountry = countryCode;\n    // No need to create a new uiState object - it's deeply reactive\n  }\n</script>\n\n<!-- Country selector -->\n<select on:change={(e) => selectCountry(e.target.value)}>\n  <option value=\"\">Select a country</option>\n  {#each referenceData.countries as country}\n    <option value={country.code}>{country.name}</option>\n  {/each}\n</select>\n```\n\n#### 4. Raw State for Server Data, Regular State for Local Modifications\n\nUse `$state.raw` for data from the server and regular `$state` for local edits:\n\n```svelte\n<script>\n  // Server data in raw state\n  let serverData = $state.raw({\n    posts: [],\n    lastFetched: null\n  });\n  \n  // Local edits in regular state\n  let editState = $state({\n    editingPostId: null,\n    draft: null,\n    unsavedChanges: false\n  });\n  \n  async function fetchPosts() {\n    const response = await fetch('/api/posts');\n    const posts = await response.json();\n    \n    // Replace the entire raw state\n    serverData = {\n      posts,\n      lastFetched: new Date()\n    };\n  }\n  \n  function editPost(postId) {\n    const post = serverData.posts.find(p => p.id === postId);\n    if (post) {\n      editState.editingPostId = postId;\n      editState.draft = { ...post }; // Create a reactive copy\n      editState.unsavedChanges = false;\n    }\n  }\n  \n  async function saveChanges() {\n    if (!editState.draft) return;\n    \n    // Save to server\n    await fetch(`/api/posts/${editState.editingPostId}`, {\n      method: 'PUT',\n      body: JSON.stringify(editState.draft)\n    });\n    \n    // Update local data\n    const updatedPosts = serverData.posts.map(post => \n      post.id === editState.editingPostId ? { ...editState.draft } : post\n    );\n    \n    // Replace raw state\n    serverData = {\n      ...serverData,\n      posts: updatedPosts\n    };\n    \n    // Reset edit state\n    editState.editingPostId = null;\n    editState.draft = null;\n    editState.unsavedChanges = false;\n  }\n  \n  // Initial fetch\n  fetchPosts();\n</script>\n```\n\n### Performance Benefits\n\nThis hybrid approach offers several performance benefits:\n\n1. **Reduced proxy overhead**: By using `$state.raw` for large collections, you avoid creating proxies for every object and property in the collection.\n\n2. **Targeted reactivity**: By making only the active/visible items deeply reactive, you focus the reactivity system's work on just what's needed.\n\n3. **Optimized renders**: Changes to raw state only trigger updates when the entire object is replaced, which can be more efficient than responding to many small changes.\n\n4. **Memory efficiency**: Fewer proxies means less memory overhead, especially important for very large data sets.\n\n5. **Predictable updates**: By explicitly controlling when raw state is replaced, you have more control over when updates happen.\n\nBy strategically combining `$state.raw` and regular `$state`, you can build applications that handle large data structures efficiently while still providing reactive UI updates where needed."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"How does the $state rune handle nested objects, and what happens when you modify a deeply nested property?","answer":"The $state rune creates a deeply reactive state system for nested objects through the use of JavaScript Proxies. When you modify a deeply nested property, Svelte can detect this change and update only the parts of the UI that depend on that specific property.\n\n### How Deep Reactivity Works\n\nWhen you declare an object or array with $state, Svelte creates a proxy that wraps the original object. This proxy intercepts property access and modifications. For nested objects and arrays, Svelte recursively creates proxies for each nested object or array as well:\n\n```svelte\n<script>\n  let person = $state({\n    name: 'Alice',\n    contact: {\n      email: 'alice@example.com',\n      address: {\n        city: 'Wonderland',\n        postal: '12345'\n      }\n    },\n    skills: ['JavaScript', 'Svelte']\n  });\n</script>\n```\n\nIn this example:\n- `person` is a proxy\n- `person.contact` is a proxy\n- `person.contact.address` is a proxy\n- `person.skills` is a proxy\n\nThe proxification happens recursively until Svelte encounters something that isn't an array or a simple object.\n\n### What Happens When You Modify a Deeply Nested Property\n\nWhen you modify a deeply nested property, the following process occurs:\n\n1. The proxy at that level intercepts the modification\n2. Svelte marks that specific property as changed\n3. Any UI elements that depend on that property are scheduled for update\n4. The UI updates only those components that depend on the changed property\n\nFor example:\n\n```svelte\n<script>\n  let person = $state({\n    name: 'Alice',\n    contact: {\n      email: 'alice@example.com',\n      address: {\n        city: 'Wonderland',\n        postal: '12345'\n      }\n    }\n  });\n  \n  function updateCity() {\n    // Modifying a deeply nested property\n    person.contact.address.city = 'Looking Glass Land';\n  }\n  \n  function updateEmail() {\n    // Modifying a property one level deep\n    person.contact.email = 'alice.new@example.com';\n  }\n</script>\n\n<div>\n  <p>Name: {person.name}</p>\n  <p>Email: {person.contact.email}</p>\n  <p>City: {person.contact.address.city}</p>\n  <p>Postal: {person.contact.address.postal}</p>\n  \n  <button on:click={updateCity}>Update City</button>\n  <button on:click={updateEmail}>Update Email</button>\n</div>\n```\n\nWhen `updateCity()` is called:\n1. The proxy for `person.contact.address` intercepts the modification to `city`\n2. Svelte marks `person.contact.address.city` as changed\n3. Only the UI element displaying the city is updated - the other elements remain unchanged\n\nThis granular reactivity is more efficient than re-rendering the entire component when only a small part of the data has changed.\n\n### Code Example: Nested Updates and UI Effects\n\nHere's a more complete example showing how deep reactivity works in practice:\n\n```svelte\n<script>\n  let user = $state({\n    personal: {\n      name: 'Alice',\n      age: 28\n    },\n    account: {\n      username: 'alice123',\n      settings: {\n        theme: 'light',\n        notifications: {\n          email: true,\n          push: false,\n          sms: true\n        }\n      }\n    },\n    posts: [\n      { id: 1, title: 'Hello Svelte', likes: 10 },\n      { id: 2, title: 'Reactive Programming', likes: 15 }\n    ]\n  });\n  \n  // These functions modify different levels of nesting\n  function updateName() {\n    user.personal.name = 'Alicia';\n    console.log('Name updated');\n  }\n  \n  function toggleTheme() {\n    user.account.settings.theme = \n      user.account.settings.theme === 'light' ? 'dark' : 'light';\n    console.log('Theme toggled');\n  }\n  \n  function togglePushNotifications() {\n    user.account.settings.notifications.push = \n      !user.account.settings.notifications.push;\n    console.log('Push notifications toggled');\n  }\n  \n  function incrementLikes(postId) {\n    const post = user.posts.find(p => p.id === postId);\n    if (post) {\n      post.likes++;\n      console.log(`Likes for post ${postId} incremented`);\n    }\n  }\n  \n  function addPost() {\n    user.posts.push({\n      id: user.posts.length + 1,\n      title: `New Post ${user.posts.length + 1}`,\n      likes: 0\n    });\n    console.log('Post added');\n  }\n</script>\n\n<div class={`app-container ${user.account.settings.theme}`}>\n  <h2>User Profile</h2>\n  <div class=\"personal-info\">\n    <p>Name: {user.personal.name}</p>\n    <p>Age: {user.personal.age}</p>\n    <button on:click={updateName}>Update Name</button>\n  </div>\n  \n  <h3>Account Settings</h3>\n  <div class=\"account-settings\">\n    <p>Username: {user.account.username}</p>\n    <p>Theme: {user.account.settings.theme}</p>\n    <button on:click={toggleTheme}>Toggle Theme</button>\n    \n    <h4>Notification Preferences</h4>\n    <label>\n      <input \n        type=\"checkbox\" \n        checked={user.account.settings.notifications.email}\n        on:change={() => user.account.settings.notifications.email = !user.account.settings.notifications.email}\n      />\n      Email Notifications\n    </label>\n    <label>\n      <input \n        type=\"checkbox\" \n        checked={user.account.settings.notifications.push}\n        on:change={togglePushNotifications}\n      />\n      Push Notifications\n    </label>\n    <label>\n      <input \n        type=\"checkbox\" \n        checked={user.account.settings.notifications.sms}\n        on:change={() => user.account.settings.notifications.sms = !user.account.settings.notifications.sms}\n      />\n      SMS Notifications\n    </label>\n  </div>\n  \n  <h3>Posts</h3>\n  <div class=\"posts\">\n    {#each user.posts as post}\n      <div class=\"post\">\n        <h4>{post.title}</h4>\n        <p>Likes: {post.likes}</p>\n        <button on:click={() => incrementLikes(post.id)}>Like</button>\n      </div>\n    {/each}\n    <button on:click={addPost}>Add Post</button>\n  </div>\n</div>\n\n<style>\n  .app-container.light {\n    background-color: #fff;\n    color: #333;\n  }\n  \n  .app-container.dark {\n    background-color: #333;\n    color: #fff;\n  }\n  \n  .post {\n    border: 1px solid #ccc;\n    margin-bottom: 10px;\n    padding: 10px;\n  }\n</style>\n```\n\nIn this example, each function modifies a different part of the nested state structure:\n- `updateName()` changes a property two levels deep\n- `toggleTheme()` changes a property three levels deep\n- `togglePushNotifications()` changes a property four levels deep\n- `incrementLikes()` changes a property inside an array item\n- `addPost()` adds a new item to an array\n\nSvelte's reactivity system ensures that only the parts of the UI that depend on the changed properties are updated, providing efficient rendering.\n\n### Limitations and Edge Cases\n\nWhile deep reactivity is powerful, there are some limitations to be aware of:\n\n1. **Non-POJO objects**: Deep reactivity only works with arrays and \"Plain Old JavaScript Objects\" (POJOs). Other types like Maps, Sets, Date objects, etc. won't be made deeply reactive.\n\n2. **Destructuring breaks reactivity**: If you destructure properties from a reactive object, the destructured variables are not reactive:\n\n```svelte\n<script>\n  let person = $state({ name: 'Alice', age: 30 });\n  \n  // This breaks reactivity for these variables\n  let { name, age } = person;\n  \n  function updatePerson() {\n    person.age++; // UI using person.age will update\n    console.log(age); // Still 30 - destructured variable didn't update\n  }\n</script>\n```\n\n3. **Direct property assignment vs. object replacement**: When modifying nested properties, you can either modify the property directly or replace the entire object:\n\n```svelte\n<script>\n  let person = $state({\n    name: 'Alice',\n    contact: {\n      email: 'alice@example.com'\n    }\n  });\n  \n  // Method 1: Direct property modification (recommended with $state)\n  function updateEmail1() {\n    person.contact.email = 'newemail@example.com';\n  }\n  \n  // Method 2: Object replacement (also works but less efficient with $state)\n  function updateEmail2() {\n    person.contact = {\n      ...person.contact,\n      email: 'newemail@example.com'\n    };\n  }\n</script>\n```\n\nWith $state, the direct property modification approach (Method 1) is often cleaner and more efficient, as the proxy system handles the reactivity.\n\nUnderstanding how $state handles nested objects and the proxy system it creates is key to effectively using Svelte's reactivity system for complex data structures."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"What's the difference between $state and $state.raw when working with objects that contain non-POJO (Plain Old JavaScript Object) values like Maps, Sets, or custom class instances?","answer":"When working with objects that contain non-POJO values like Maps, Sets, or custom class instances, there are important differences in how `$state` and `$state.raw` behave. These differences affect reactivity, performance, and how you need to update these values.\n\n### How $state Handles Non-POJO Values\n\nWith regular `$state`, Svelte creates a deeply reactive proxy system, but this proxification only extends to arrays and plain objects (POJOs). When it encounters non-POJO values like Maps, Sets, Dates, or custom class instances, it stops the recursive proxification:\n\n```svelte\n<script>\n  let data = $state({\n    id: 1,\n    name: 'Project X',\n    // These will NOT be proxified internally\n    tags: new Set(['important', 'urgent']),\n    metadata: new Map([\n      ['created', new Date()],\n      ['owner', 'alice']\n    ]),\n    calculator: new Calculator(), // Custom class\n    // This WILL be proxified (nested plain object)\n    config: {\n      isActive: true,\n      priority: 'high'\n    }\n  });\n</script>\n```\n\nIn this example:\n- `data` itself is a proxy\n- `data.config` is also a proxy (nested plain object)\n- `data.tags` (Set), `data.metadata` (Map), and `data.calculator` (custom class) are not proxified internally\n\n### Reactivity Implications\n\n#### With $state:\n\n1. **Assignment is reactive**: Replacing the entire non-POJO value will trigger reactivity:\n\n```svelte\n<script>\n  let data = $state({\n    tags: new Set(['important']),\n    lastUpdated: new Date()\n  });\n  \n  function updateTags() {\n    // This triggers reactivity - entire Set is replaced\n    data.tags = new Set([...data.tags, 'urgent']);\n    \n    // This triggers reactivity - Date object is replaced\n    data.lastUpdated = new Date();\n  }\n</script>\n```\n\n2. **Internal mutations are NOT reactive**: Modifying the internal state of a non-POJO value doesn't trigger reactivity:\n\n```svelte\n<script>\n  let data = $state({\n    tags: new Set(['important']),\n    metadata: new Map([['status', 'pending']])\n  });\n  \n  function addTag() {\n    // This will NOT trigger reactivity!\n    data.tags.add('urgent');\n    \n    // This will NOT trigger reactivity!\n    data.metadata.set('priority', 'high');\n  }\n</script>\n```\n\n3. **Workaround for mutations**: To make mutations reactive, you need to trigger a reassignment:\n\n```svelte\n<script>\n  let data = $state({\n    tags: new Set(['important']),\n    metadata: new Map()\n  });\n  \n  function addTag(tag) {\n    // Add the tag\n    data.tags.add(tag);\n    \n    // Force reactivity by creating a new Set with the same values\n    data.tags = new Set(data.tags);\n    \n    // Alternative approach\n    // data = { ...data }; // Shallow copy of the container triggers reactivity\n  }\n  \n  function addMetadata(key, value) {\n    // Add the metadata\n    data.metadata.set(key, value);\n    \n    // Force reactivity by creating a new Map\n    data.metadata = new Map(data.metadata);\n  }\n</script>\n```\n\n#### With $state.raw:\n\nWith `$state.raw`, the behavior is more consistent, as it doesn't try to create deep proxies at all:\n\n```svelte\n<script>\n  let data = $state.raw({\n    tags: new Set(['important']),\n    metadata: new Map(),\n    config: { isActive: true } // Even this plain object is not deeply proxified\n  });\n  \n  function updateData() {\n    // This won't work for any property (as expected with raw state)\n    data.tags.add('urgent');\n    data.metadata.set('priority', 'high');\n    data.config.isActive = false;\n    \n    // This will work - replacing the entire object\n    data = {\n      ...data,\n      tags: new Set([...data.tags, 'urgent']),\n      metadata: new Map([...data.metadata, ['priority', 'high']]),\n      config: { ...data.config, isActive: false }\n    };\n  }\n</script>\n```\n\n### Practical Examples\n\n#### Example 1: Working with a Set in $state\n\n```svelte\n<script>\n  let userData = $state({\n    username: 'alice',\n    permissions: new Set(['read', 'comment'])\n  });\n  \n  function addPermission(permission) {\n    // Add to the Set\n    userData.permissions.add(permission);\n    \n    // Create a new Set to trigger reactivity\n    userData.permissions = new Set(userData.permissions);\n    \n    // Alternatively, trigger reactivity by creating a shallow copy of the container\n    // userData = { ...userData };\n  }\n  \n  function removePermission(permission) {\n    // Remove from the Set\n    userData.permissions.delete(permission);\n    \n    // Create a new Set to trigger reactivity\n    userData.permissions = new Set(userData.permissions);\n  }\n</script>\n\n<div>\n  <h3>User: {userData.username}</h3>\n  <p>Permissions:</p>\n  <ul>\n    {#each [...userData.permissions] as permission}\n      <li>\n        {permission}\n        <button on:click={() => removePermission(permission)}>Remove</button>\n      </li>\n    {/each}\n  </ul>\n  \n  <div>\n    <button on:click={() => addPermission('write')}>Add Write</button>\n    <button on:click={() => addPermission('admin')}>Add Admin</button>\n  </div>\n</div>\n```\n\n#### Example 2: Working with a Map in $state\n\n```svelte\n<script>\n  let cache = $state({\n    items: new Map(),\n    lastUpdated: null\n  });\n  \n  function addItem(key, value) {\n    // Update the Map\n    cache.items.set(key, value);\n    \n    // Create a new Map to trigger reactivity\n    cache.items = new Map(cache.items);\n    \n    // Update the timestamp\n    cache.lastUpdated = new Date();\n  }\n  \n  function removeItem(key) {\n    // Remove from the Map\n    cache.items.delete(key);\n    \n    // Create a new Map to trigger reactivity\n    cache.items = new Map(cache.items);\n    \n    // Update the timestamp\n    cache.lastUpdated = new Date();\n  }\n  \n  function clearCache() {\n    cache.items = new Map();\n    cache.lastUpdated = new Date();\n  }\n</script>\n\n<div>\n  <h3>Cache Contents ({cache.items.size} items)</h3>\n  {#if cache.lastUpdated}\n    <p>Last updated: {cache.lastUpdated.toLocaleString()}</p>\n  {/if}\n  \n  <ul>\n    {#each [...cache.items.entries()] as [key, value]}\n      <li>\n        {key}: {JSON.stringify(value)}\n        <button on:click={() => removeItem(key)}>Remove</button>\n      </li>\n    {/each}\n  </ul>\n  \n  <button on:click={() => addItem('key' + Date.now(), { value: Math.random() })}>\n    Add Random Item\n  </button>\n  <button on:click={clearCache}>Clear Cache</button>\n</div>\n```\n\n#### Example 3: Working with Custom Classes in $state\n\n```svelte\n<script>\n  class Counter {\n    constructor(initial = 0) {\n      this.value = initial;\n    }\n    \n    increment() {\n      this.value++;\n      return this.value;\n    }\n    \n    decrement() {\n      this.value--;\n      return this.value;\n    }\n    \n    reset() {\n      this.value = 0;"}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"What is the syntax for declaring derived state in Svelte 5, and how does it differ from regular state declarations?","answer":"In Svelte 5, derived state is declared using the `$derived` rune. Unlike regular state variables which are declared with `$state`, derived state values are computed based on other state values and automatically update when their dependencies change.\n\nThe syntax is:\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n```\n\nThe key difference is that `$derived` values are read-only and calculated based on other state, while `$state` values can be directly modified. When the dependencies of a derived value change, the derived value is automatically recalculated."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"Can you modify state within a $derived expression? Explain why or why not with an example.","answer":"No, you cannot modify state within a `$derived` expression. Svelte explicitly disallows state changes (like `count++`) inside derived expressions because derived values should be pure calculations without side effects.\n\nFor example, this would cause an error:\n```svelte\n<script>\n  let count = $state(0);\n  // This will cause an error\n  let invalid = $derived(count++);\n</script>\n```\n\nThe reason for this restriction is that derived values should be predictable transformations of their dependencies. Allowing side effects would break this model and could lead to infinite update loops or inconsistent state.\n\nInstead, derived values should only compute and return values based on their inputs:\n```svelte\n<script>\n  let count = $state(0);\n  // This is correct\n  let valid = $derived(count + 1);\n</script>\n```"}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How can you create complex derivations that don't fit in a simple expression?","answer":"For complex derivations that don't fit in a simple expression, Svelte 5 provides the `$derived.by` method which accepts a function as its argument. This allows you to write multi-line derivation logic with intermediate variables.\n\nHere's an example:\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let stats = $derived.by(() => {\n    let sum = 0;\n    let max = Number.MIN_SAFE_INTEGER;\n    let min = Number.MAX_SAFE_INTEGER;\n    \n    for (const n of numbers) {\n      sum += n;\n      if (n > max) max = n;\n      if (n < min) min = n;\n    }\n    \n    return {\n      sum,\n      average: sum / numbers.length,\n      max,\n      min\n    };\n  });\n</script>\n\n<p>Sum: {stats.sum}</p>\n<p>Average: {stats.average}</p>\n<p>Max: {stats.max}</p>\n<p>Min: {stats.min}</p>\n```\n\nThis approach is much cleaner than trying to squeeze complex logic into a single expression."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"What is the relationship between $derived and $derived.by in Svelte 5?","answer":"In Svelte 5, `$derived(expression)` is essentially equivalent to `$derived.by(() => expression)`. They both create derived state, but they differ in how the derivation is expressed:\n\n1. `$derived` takes a direct expression and is ideal for simple, one-line derivations.\n2. `$derived.by` takes a function and is better for complex, multi-line derivations.\n\nFor example, these two are functionally equivalent:\n```svelte\n<script>\n  let count = $state(0);\n  \n  // Using $derived with an expression\n  let doubled1 = $derived(count * 2);\n  \n  // Using $derived.by with a function\n  let doubled2 = $derived.by(() => count * 2);\n</script>\n```\n\nThe documentation explicitly states this equivalence: \"In essence, `$derived(expression)` is equivalent to `$derived.by(() => expression)`.\""}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How does Svelte determine what values are dependencies of a derived value?","answer":"Svelte determines dependencies of a derived value by tracking what state is read synchronously within the `$derived` expression or `$derived.by` function body. Any state accessed during the execution of the derivation function becomes a dependency.\n\nFor example:\n```svelte\n<script>\n  let a = $state(1);\n  let b = $state(2);\n  let c = $state(3);\n  \n  // a and b are dependencies, c is not\n  let sum = $derived(a + b);\n  \n  // Only a is a dependency here\n  let derivedA = $derived.by(() => {\n    if (a > 10) {\n      return a * 2;\n    }\n    return a;\n  });\n</script>\n```\n\nIn the first derived value, both `a` and `b` are dependencies because they're read in the expression. In the second example, only `a` is a dependency even though the function contains conditional logic.\n\nThis tracking is automatic and happens at runtime - Svelte observes which state values are accessed during the execution of the derivation."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How can you prevent a piece of state from being treated as a dependency in a derived value?","answer":"To prevent a piece of state from being treated as a dependency in a derived value, you can use the `untrack` function. This allows you to access state without establishing a dependency relationship.\n\nThe documentation mentions: \"To exempt a piece of state from being treated as a dependency, use [`untrack`](svelte#untrack).\"\n\nHere's an example of how you might use it:\n```svelte\n<script>\n  import { untrack } from 'svelte';\n  \n  let count = $state(0);\n  let threshold = $state(10);\n  \n  // count is a dependency, but threshold is not\n  let isLarge = $derived.by(() => {\n    // This will be tracked as a dependency\n    const currentCount = count;\n    \n    // This won't be tracked as a dependency\n    const currentThreshold = untrack(() => threshold);\n    \n    return currentCount > currentThreshold;\n  });\n</script>\n```\n\nIn this example, `isLarge` will update when `count` changes, but not when `threshold` changes, because we've used `untrack` to exempt `threshold` from being a dependency."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"Explain Svelte's \"push-pull reactivity\" model and how it applies to derived values.","answer":"Svelte uses a \"push-pull reactivity\" model, which is a hybrid approach to managing updates in the reactive system. Here's how it works:\n\n1. **Push phase**: When a piece of state is updated, Svelte immediately notifies all direct and indirect dependents that they are \"dirty\" and need to be recalculated. This is the \"push\" part - changes propagate outward from the source.\n\n2. **Pull phase**: However, the actual recalculation of derived values doesn't happen immediately. Instead, derived values are only re-evaluated when they are actually read (accessed in the code). This is the \"pull\" part - values are calculated on demand.\n\nFor example:\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n  let isLarge = $derived(doubled > 10);\n</script>\n\n<button onclick={() => count++}>\n  Count: {count}\n</button>\n\n<!-- isLarge is only recalculated when this part renders -->\n{#if someCondition}\n  <p>Is large: {isLarge}</p>\n{/if}\n```\n\nWhen `count` changes:\n1. Both `doubled` and `isLarge` are marked as dirty (push)\n2. `doubled` is recalculated when the button renders because it's referenced there\n3. `isLarge` is only recalculated if `someCondition` is true and that part of the template needs to render (pull)\n\nThis approach is efficient because it avoids unnecessary calculations for derived values that aren't currently being used in the UI."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How does Svelte optimize updates for derived values that depend on other state?","answer":"Svelte optimizes updates for derived values through a mechanism of reference equality checking. When a derived value is recalculated, Svelte compares the new value to the previous value. If they are referentially identical (same object reference for objects, or same value for primitives), Svelte will skip updating dependents of that derived value.\n\nThe documentation provides this example:\n```svelte\n<script>\n  let count = $state(0);\n  let large = $derived(count > 10);\n</script>\n\n<button onclick={() => count++}>\n  {large}\n</button>\n```\n\nIn this case, `large` is a boolean derived from whether `count > 10`. When `count` changes from, say, 5 to 6, the value of `large` remains `false`. Since the value of `large` hasn't changed (it's still `false`), Svelte won't update the button text, even though `count` changed and `large` was recalculated.\n\nThis optimization prevents unnecessary DOM updates when derived values effectively don't change, even if their dependencies do change. This is particularly valuable for complex UIs with many derived values."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"Can $derived be used with class fields? If so, how?","answer":"Yes, `$derived` can be used with class fields, just like `$state`. This allows you to create reactive, derived properties in class-based components.\n\nThe documentation mentions: \"As with `$state`, you can mark class fields as `$derived`.\"\n\nHere's an example of how you might use it in a class:\n```svelte\n<script>\n  class Counter {\n    count = $state(0);\n    doubled = $derived(this.count * 2);\n    isLarge = $derived(this.count > 10);\n    \n    increment() {\n      this.count++;\n    }\n  }\n  \n  let counter = new Counter();\n</script>\n\n<button onclick={() => counter.increment()}>\n  Count: {counter.count}, Doubled: {counter.doubled}\n</button>\n\n<p>Is the count large? {counter.isLarge ? 'Yes' : 'No'}</p>\n```\n\nIn this example, both `doubled` and `isLarge` are derived class fields that automatically update when `count` changes. The syntax is the same as for regular variables, but applied to class properties."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"What happens if a derived value depends on an array or object that is mutated in place?","answer":"When a derived value depends on an array or object that is mutated in place, Svelte will properly detect the change and update the derived value, as long as the mutation happens through a tracked state variable.\n\nHere's an example with an array:\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let sum = $derived.by(() => {\n    let total = 0;\n    for (const n of numbers) {\n      total += n;\n    }\n    return total;\n  });\n</script>\n\n<button onclick={() => numbers.push(numbers.length + 1)}>\n  Add number\n</button>\n\n<p>{numbers.join(' + ')} = {sum}</p>\n```\n\nIn this example, when we call `numbers.push()`, we're mutating the array in place rather than creating a new array. Svelte still detects this change because `numbers` is a tracked state variable, and the derived `sum` value will be recalculated.\n\nThe same applies to object mutations:\n```svelte\n<script>\n  let person = $state({ name: 'Alice', age: 30 });\n  let description = $derived(`${person.name} is ${person.age} years old`);\n</script>\n\n<button onclick={() => person.age++}>\n  Happy birthday!\n</button>\n\n<p>{description}</p>\n```\n\nWhen `person.age` is incremented, the `description` derived value will update accordingly."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How would you create a derived value that depends on multiple state variables?","answer":"Creating a derived value that depends on multiple state variables is straightforward - you simply reference all the needed state variables in your derivation expression or function.\n\nHere's an example using the simple `$derived` syntax:\n```svelte\n<script>\n  let width = $state(5);\n  let height = $state(10);\n  let color = $state('blue');\n  \n  // Depends on both width and height\n  let area = $derived(width * height);\n  \n  // Depends on width, height, and color\n  let description = $derived(`A ${color} rectangle with area ${width * height}`);\n</script>\n\n<button onclick={() => width++}>Increase width</button>\n<button onclick={() => height++}>Increase height</button>\n<button onclick={() => color = color === 'blue' ? 'red' : 'blue'}>Toggle color</button>\n\n<p>Area: {area}</p>\n<p>{description}</p>\n```\n\nFor more complex scenarios, you can use `$derived.by`:\n```svelte\n<script>\n  let products = $state([\n    { id: 1, name: 'Apple', price: 0.5, quantity: 10 },\n    { id: 2, name: 'Banana', price: 0.3, quantity: 15 },\n    { id: 3, name: 'Orange', price: 0.6, quantity: 8 }\n  ]);\n  let taxRate = $state(0.1);\n  let discount = $state(0);\n  \n  let orderSummary = $derived.by(() => {\n    let subtotal = 0;\n    for (const product of products) {\n      subtotal += product.price * product.quantity;\n    }\n    \n    let tax = subtotal * taxRate;\n    let total = subtotal + tax - discount;\n    \n    return {\n      subtotal: subtotal.toFixed(2),\n      tax: tax.toFixed(2),\n      discount: discount.toFixed(2),\n      total: total.toFixed(2)\n    };\n  });\n</script>\n\n<p>Subtotal: ${orderSummary.subtotal}</p>\n<p>Tax: ${orderSummary.tax}</p>\n<p>Discount: ${orderSummary.discount}</p>\n<p>Total: ${orderSummary.total}</p>\n```\n\nIn this example, `orderSummary` depends on the `products` array, the `taxRate`, and the `discount` amount. When any of these change, `orderSummary` will be recalculated."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"In what scenarios would you choose to use $derived.by over the simpler $derived syntax?","answer":"You would choose to use `$derived.by` over the simpler `$derived` syntax in several scenarios:\n\n1. **Complex calculations**: When your derivation involves multiple steps, intermediate variables, or complex logic that would be unwieldy in a single expression.\n\n```svelte\n<script>\n  let transactions = $state([\n    { type: 'income', amount: 1000 },\n    { type: 'expense', amount: 500 },\n    { type: 'expense', amount: 200 }\n  ]);\n  \n  let financialSummary = $derived.by(() => {\n    let income = 0;\n    let expenses = 0;\n    \n    for (const transaction of transactions) {\n      if (transaction.type === 'income') {\n        income += transaction.amount;\n      } else if (transaction.type === 'expense') {\n        expenses += transaction.amount;\n      }\n    }\n    \n    const balance = income - expenses;\n    const savingsRate = income > 0 ? ((income - expenses) / income) * 100 : 0;\n    \n    return {\n      income,\n      expenses,\n      balance,\n      savingsRate: savingsRate.toFixed(1) + '%'\n    };\n  });\n</script>\n```\n\n2. **Conditional logic**: When your derivation includes if/else statements or other conditional logic.\n\n```svelte\n<script>\n  let temperature = $state(22);\n  let units = $state('celsius');\n  \n  let temperatureDescription = $derived.by(() => {\n    let tempValue;\n    let displayUnits;\n    \n    if (units === 'celsius') {\n      tempValue = temperature;\n      displayUnits = 'Â°C';\n    } else {\n      tempValue = (temperature * 9/5) + 32;\n      displayUnits = 'Â°F';\n    }\n    \n    if (tempValue < 0) {\n      return `Freezing at ${tempValue}${displayUnits}`;\n    } else if (tempValue < 15) {\n      return `Cold at ${tempValue}${displayUnits}`;\n    } else if (tempValue < 25) {\n      return `Pleasant at ${tempValue}${displayUnits}`;\n    } else {\n      return `Hot at ${tempValue}${displayUnits}`;\n    }\n  });\n</script>\n```\n\n3. **Loops or iterations**: When you need to iterate over arrays or objects.\n\n```svelte\n<script>\n  let students = $state([\n    { name: 'Alice', scores: [85, 90, 92] },\n    { name: 'Bob', scores: [75, 80, 85] },\n    { name: 'Charlie', scores: [95, 88, 91] }\n  ]);\n  \n  let classReport = $derived.by(() => {\n    let highestAvg = 0;\n    let topStudent = '';\n    let classAverage = 0;\n    let totalScores = 0;\n    let scoreCount = 0;\n    \n    for (const student of students) {\n      const sum = student.scores.reduce((a, b) => a + b, 0);\n      const avg = sum / student.scores.length;\n      \n      if (avg > highestAvg) {\n        highestAvg = avg;\n        topStudent = student.name;\n      }\n      \n      totalScores += sum;\n      scoreCount += student.scores.length;\n    }\n    \n    classAverage = totalScores / scoreCount;\n    \n    return {\n      topStudent,\n      topAverage: highestAvg.toFixed(1),\n      classAverage: classAverage.toFixed(1)\n    };\n  });\n</script>\n```\n\n4. **Error handling**: When you need try/catch blocks.\n\n```svelte\n<script>\n  let jsonInput = $state('{\"name\": \"Alice\", \"age\": 30}');\n  \n  let parsedData = $derived.by(() => {\n    try {\n      return JSON.parse(jsonInput);\n    } catch (e) {\n      return { error: 'Invalid JSON input' };\n    }\n  });\n</script>\n```\n\nIn all these cases, the function-based approach of `$derived.by` provides the flexibility needed for more complex derivations that would be difficult or impossible to express in a single expression."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How do nested dependencies work with derived values in Svelte 5?","answer":"In Svelte 5, nested dependencies work naturally with derived values. When a derived value depends on another derived value, Svelte establishes a dependency chain where changes propagate through the chain automatically.\n\nHere's an example of nested dependencies:\n\n```svelte\n<script>\n  let count = $state(0);\n  \n  // First level of derivation\n  let doubled = $derived(count * 2);\n  \n  // Second level - depends on doubled\n  let isLarge = $derived(doubled > 10);\n  \n  // Third level - depends on isLarge\n  let message = $derived(isLarge ? \"That's a big number!\" : \"Still small...\");\n</script>\n\n<button onclick={() => count++}>\n  Count: {count}\n</button>\n\n<p>Doubled: {doubled}</p>\n<p>Is large: {isLarge}</p>\n<p>Message: {message}</p>\n```\n\nIn this example:\n1. When `count` changes, `doubled` is marked as dirty\n2. Since `doubled` is a dependency of `isLarge`, `isLarge` is also marked as dirty\n3. Since `isLarge` is a dependency of `message`, `message` is also marked as dirty\n4. When the template renders, each value is recalculated as needed\n\nThis chaining works for any depth of dependencies. The push-pull reactivity model ensures that:\n1. All affected derived values are marked as dirty (push phase)\n2. Only the values actually needed for rendering are recalculated (pull phase)\n\nThis is also true for more complex dependency chains involving `$derived.by`:\n\n```svelte\n<script>\n  let prices = $state([10, 20, 30]);\n  let taxRate = $state(0.1);\n  \n  // First level derivation\n  let subtotal = $derived.by(() => {\n    return prices.reduce((sum, price) => sum + price, 0);\n  });\n  \n  // Second level - depends on subtotal and taxRate\n  let orderDetails = $derived.by(() => {\n    const tax = subtotal * taxRate;\n    const total = subtotal + tax;\n    \n    return {\n      subtotal,\n      tax,\n      total,\n      formattedTotal: `$${total.toFixed(2)}`\n    };\n  });\n</script>\n\n<p>Items: {prices.join(', ')}</p>\n<p>Subtotal: ${subtotal.toFixed(2)}</p>\n<p>Tax: ${orderDetails.tax.toFixed(2)}</p>\n<p>Total: {orderDetails.formattedTotal}</p>\n```\n\nIn this example, changing either `prices` or `taxRate` will properly update all the derived values in the dependency chain."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How would you implement a filtered list using $derived in Svelte 5?","answer":"Implementing a filtered list using `$derived` in Svelte 5 is straightforward. You can create a derived value that filters an original list based on some criteria. Here's a complete example:\n\n```svelte\n<script>\n  // Original list of items\n  let items = $state([\n    { id: 1, name: 'Apple', category: 'fruit', inStock: true },\n    { id: 2, name: 'Banana', category: 'fruit', inStock: false },\n    { id: 3, name: 'Carrot', category: 'vegetable', inStock: true },\n    { id: 4, name: 'Potato', category: 'vegetable', inStock: true },\n    { id: 5, name: 'Orange', category: 'fruit', inStock: true }\n  ]);\n  \n  // Filter criteria\n  let searchQuery = $state('');\n  let selectedCategory = $state('all');\n  let showOnlyInStock = $state(false);\n  \n  // Derived filtered list\n  let filteredItems = $derived.by(() => {\n    return items.filter(item => {\n      // Filter by search query\n      const matchesSearch = item.name.toLowerCase().includes(searchQuery.toLowerCase());\n      \n      // Filter by category\n      const matchesCategory = selectedCategory === 'all' || item.category === selectedCategory;\n      \n      // Filter by stock status\n      const matchesStockStatus = !showOnlyInStock || item.inStock;\n      \n      return matchesSearch && matchesCategory && matchesStockStatus;\n    });\n  });\n  \n  // Another derived value for stats\n  let stats = $derived({\n    total: items.length,\n    filtered: filteredItems.length,\n    inStock: items.filter(item => item.inStock).length\n  });\n</script>\n\n<!-- Search and filter controls -->\n<div>\n  <input \n    type=\"text\" \n    placeholder=\"Search items...\" \n    bind:value={searchQuery}\n  />\n  \n  <select bind:value={selectedCategory}>\n    <option value=\"all\">All Categories</option>\n    <option value=\"fruit\">Fruits</option>\n    <option value=\"vegetable\">Vegetables</option>\n  </select>\n  \n  <label>\n    <input type=\"checkbox\" bind:checked={showOnlyInStock} />\n    Show only in-stock items\n  </label>\n</div>\n\n<!-- Stats -->\n<div>\n  Showing {stats.filtered} of {stats.total} items (In stock: {stats.inStock})\n</div>\n\n<!-- Filtered list -->\n<ul>\n  {#each filteredItems as item}\n    <li>\n      {item.name} - {item.category} \n      {#if !item.inStock}<span>(Out of stock)</span>{/if}\n    </li>\n  {/each}\n</ul>\n\n<!-- Add new item -->\n<button onclick={() => {\n  const id = items.length + 1;\n  items = [...items, { \n    id, \n    name: `New Item ${id}`, \n    category: 'fruit', \n    inStock: true \n  }];\n}}>\n  Add Item\n</button>\n```\n\nIn this example:\n\n1. We have a list of items with various properties\n2. We provide UI controls to filter by search query, category, and stock status\n3. The `filteredItems` derived value automatically updates whenever:\n   - The original items list changes\n   - Any of the filter criteria change\n4. We also have a `stats` derived value that provides information about the list\n\nThe power of this approach is that the filtering logic is declarative and reactive. When any dependency changes, the filtered list is automatically recalculated and the UI updates accordingly."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How can you optimize performance when working with expensive computations in derived values?","answer":"When working with expensive computations in derived values, there are several strategies to optimize performance:\n\n1. **Use memoization for expensive calculations**:\n```svelte\n<script>\n  import { memoize } from './utils'; // A custom memoization function\n  \n  let data = $state([/* large dataset */]);\n  \n  // Memoize the expensive calculation\n  const expensiveCalculation = memoize((items) => {\n    // Complex calculation that takes time\n    return result;\n  });\n  \n  // Use the memoized function in the derived\n  let processedData = $derived.by(() => {\n    return expensiveCalculation(data);\n  });\n</script>\n```\n\n2. **Limit dependencies with `untrack`**:\nIf some values don't always need to trigger recalculation, use `untrack`:\n```svelte\n<script>\n  import { untrack } from 'svelte';\n  \n  let items = $state([/* many items */]);\n  let config = $state({ /* rarely changing configuration */ });\n  \n  let processed = $derived.by(() => {\n    // items is tracked as a dependency\n    const currentItems = items;\n    \n    // config is not tracked, won't trigger recalculation when it changes\n    const currentConfig = untrack(() => config);\n    \n    return expensiveProcess(currentItems, currentConfig);\n  });\n</script>\n```\n\n3. **Batch updates to reduce recalculations**:\n```svelte\n<script>\n  let values = $state({ x: 0, y: 0, z: 0 });\n  \n  // Will recalculate only once after all properties are updated\n  function updateAllValues() {\n    const newValues = { \n      x: values.x + 1,\n      y: values.y + 1,\n      z: values.z + 1\n    };\n    values = newValues; // Single assignment\n  }\n  \n  // This would cause three separate recalculations\n  function inefficientUpdate() {\n    values.x += 1;\n    values.y += 1;\n    values.z += 1;\n  }\n  \n  let sum = $derived(values.x + values.y + values.z);\n</script>\n```\n\n4. **Use granular state to avoid unnecessary recalculations**:\n```svelte\n<script>\n  // Bad: one large state object means any change recalculates everything\n  let allSettings = $state({\n    theme: 'dark',\n    fontSize: 16,\n    notifications: true,\n    // many more settings...\n  });\n  \n  // Better: separate state means derived values only update when relevant parts change\n  let theme = $state('dark');\n  let fontSize = $state(16);\n  let notifications = $state(true);\n  \n  // Only recalculates when theme changes\n  let themeStyles = $derived({\n    backgroundColor: theme === 'dark' ? '#222' : '#fff',\n    color: theme === 'dark' ? '#fff' : '#222'\n  });\n  \n  // Only recalculates when fontSize changes\n  let textStyles = $derived({\n    fontSize: `${fontSize}px`,\n    lineHeight: `${fontSize * 1.5}px`\n  });\n</script>\n```\n\n5. **Use referential equality to your advantage**:\nRemember that Svelte skips updates if the derived value is referentially the same:\n```svelte\n<script>\n  let count = $state(0);\n  \n  // This will only cause updates when crossing the threshold\n  let category = $derived(count < 10 ? 'small' : 'large');\n  \n  // This derived value depends on category, not directly on count\n  let message = $derived(\n    category === 'small' \n      ? 'Not there yet' \n      : 'You reached the big leagues!'\n  );\n</script>\n```\n\n6. **Consider deferring expensive calculations**:\n```svelte\n<script>\n  let data = $state([/* large dataset */]);\n  let shouldCalculate = $state(false);\n  \n  let result = $derived.by(() => {\n    if (!shouldCalculate) {\n      return 'Click to calculate';\n    }\n    \n    // Expensive calculation only runs when shouldCalculate is true\n    return performExpensiveCalculation(data);\n  });\n</script>\n\n<button onclick={() => shouldCalculate = true}>\n  {shouldCalculate ? 'Recalculate' : 'Calculate'}\n</button>\n\n<p>Result: {result}</p>\n```\n\nBy applying these techniques, you can ensure your derived values remain performant even when dealing with complex calculations or large datasets."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How would you implement a sorting feature using $derived in Svelte 5?","answer":"Implementing a sorting feature using `$derived` in Svelte 5 is a great use case for derived state. Here's a complete example that demonstrates how to implement sortable tables:\n\n```svelte\n<script>\n  // Original data\n  let users = $state([\n    { id: 1, name: 'Alice', age: 28, email: 'alice@example.com', lastActive: new Date('2023-05-10') },\n    { id: 2, name: 'Bob', age: 35, email: 'bob@example.com', lastActive: new Date('2023-06-15') },\n    { id: 3, name: 'Charlie', age: 22, email: 'charlie@example.com', lastActive: new Date('2023-06-01') },\n    { id: 4, name: 'Diana', age: 41, email: 'diana@example.com', lastActive: new Date('2023-04-22') },\n    { id: 5, name: 'Evan', age: 19, email: 'evan@example.com', lastActive: new Date('2023-06-20') }\n  ]);\n  \n  // Sorting state\n  let sortField = $state('name');\n  let sortDirection = $state('asc'); // 'asc' or 'desc'\n  \n  // Function to toggle sort\n  function toggleSort(field) {\n    if (sortField === field) {\n      // Toggle direction if already sorting by this field\n      sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';\n    } else {\n      // New field, default to ascending\n      sortField = field;\n      sortDirection = 'asc';\n    }\n  }\n  \n  // Derived sorted users\n  let sortedUsers = $derived.by(() => {\n    // Create a new array to avoid mutating the original\n    const sorted = [...users];\n    \n    sorted.sort((a, b) => {\n      let aValue = a[sortField];\n      let bValue = b[sortField];\n      \n      // Handle different data types\n      if (sortField === 'lastActive') {\n        // For dates, compare timestamps\n        aValue = a[sortField].getTime();\n        bValue = b[sortField].getTime();\n      } else if (typeof aValue === 'string') {\n        // Case-insensitive string comparison\n        aValue = aValue.toLowerCase();\n        bValue = bValue.toLowerCase();\n      }\n      \n      // Compare values\n      if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;\n      if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;\n      return 0;\n    });\n    \n    return sorted;\n  });\n  \n  // Helper for displaying dates\n  function formatDate(date) {\n    return date.toLocaleDateString();\n  }\n</script>\n\n<table>\n  <thead>\n    <tr>\n      <th on:click={() => toggleSort('id')}>\n        ID {sortField === 'id' ? (sortDirection === 'asc' ? 'â' : 'â') : ''}\n      </th>\n      <th on:click={() => toggleSort('name')}>\n        Name {sortField === 'name' ? (sortDirection === 'asc' ? 'â' : 'â') : ''}\n      </th>\n      <th on:click={() => toggleSort('age')}>\n        Age {sortField === 'age' ? (sortDirection === 'asc' ? 'â' : 'â') : ''}\n      </th>\n      <th on:click={() => toggleSort('email')}>\n        Email {sortField === 'email' ? (sortDirection === 'asc' ? 'â' : 'â') : ''}\n      </th>\n      <th on:click={() => toggleSort('lastActive')}>\n        Last Active {sortField === 'lastActive' ? (sortDirection === 'asc' ? 'â' : 'â') : ''}\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    {#each sortedUsers as user}\n      <tr>\n        <td>{user.id}</td>\n        <td>{user.name}</td>\n        <td>{user.age}</td>\n        <td>{user.email}</td>\n        <td>{formatDate(user.lastActive)}</td>\n      </tr>\n    {/each}\n  </tbody>\n</table>\n\n<div>\n  <button onclick={() => {\n    // Add a new user\n    const id = users.length + 1;\n    users = [...users, {\n      id,\n      name: `User ${id}`,\n      age: Math.floor(Math.random() * 50) + 18,\n      email: `user${id}@example.com`,\n      lastActive: new Date()\n    }];\n  }}>\n    Add User\n  </button>\n</div>\n```\n\nKey aspects of this implementation:\n\n1. **State Management**:\n   - Original `users` array is stored as state\n   - `sortField` and `sortDirection` track the current sorting configuration\n\n2. **Sort Logic**:\n   - The `toggleSort` function handles changing the sort field and direction\n   - When a column header is clicked, it either changes the sort field or toggles the direction\n\n3. **Derived Sorted List**:\n   - `sortedUsers` is a derived value that depends on `users`, `sortField`, and `sortDirection`\n   - It creates a sorted copy of the users array based on the current sort configuration\n   - The sorting logic handles different data types (strings, numbers, dates)\n\n4. **UI Integration**:\n   - Column headers show sort indicators (â/â) for the current sort field\n   - Clicking headers triggers the sort toggle\n   - The table displays the sorted users automatically\n\nThis approach cleanly separates the sorting logic from the UI, making it easy to understand and maintain. The derived state automatically updates whenever the original data or sorting configuration changes."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How can you implement a cascading dropdown menu system using $derived in Svelte 5?","answer":"Implementing a cascading dropdown menu system is a perfect use case for `$derived` in Svelte 5. Here's a complete example of a three-level cascading dropdown for selecting a country, state/province, and city:\n\n```svelte\n<script>\n  // Sample hierarchical data\n  let countries = $state([\n    { id: 1, name: 'United States' },\n    { id: 2, name: 'Canada' },\n    { id: 3, name: 'United Kingdom' }\n  ]);\n  \n  let states = $state([\n    { id: 1, countryId: 1, name: 'California' },\n    { id: 2, countryId: 1, name: 'New York' },\n    { id: 3, countryId: 1, name: 'Texas' },\n    { id: 4, countryId: 2, name: 'Ontario' },\n    { id: 5, countryId: 2, name: 'Quebec' },\n    { id: 6, countryId: 2, name: 'British Columbia' },\n    { id: 7, countryId: 3, name: 'England' },\n    { id: 8, countryId: 3, name: 'Scotland' },\n    { id: 9, countryId: 3, name: 'Wales' }\n  ]);\n  \n  let cities = $state([\n    { id: 1, stateId: 1, name: 'Los Angeles' },\n    { id: 2, stateId: 1, name: 'San Francisco' },\n    { id: 3, stateId: 2, name: 'New York City' },\n    { id: 4, stateId: 2, name: 'Buffalo' },\n    { id: 5, stateId: 3, name: 'Houston' },\n    { id: 6, stateId: 3, name: 'Austin' },\n    { id: 7, stateId: 4, name: 'Toronto' },\n    { id: 8, stateId: 4, name: 'Ottawa' },\n    { id: 9, stateId: 5, name: 'Montreal' },\n    { id: 10, stateId: 5, name: 'Quebec City' },\n    { id: 11, stateId: 6, name: 'Vancouver' },\n    { id: 12, stateId: 6, name: 'Victoria' },\n    { id: 13, stateId: 7, name: 'London' },\n    { id: 14, stateId: 7, name: 'Manchester' },\n    { id: 15, stateId: 8, name: 'Edinburgh' },\n    { id: 16, stateId: 8, name: 'Glasgow' },\n    { id: 17, stateId: 9, name: 'Cardiff' },\n    { id: 18, stateId: 9, name: 'Swansea' }\n  ]);\n  \n  // User selections\n  let selectedCountryId = $state(null);\n  let selectedStateId = $state(null);\n  let selectedCityId = $state(null);\n  \n  // Derived filtered lists based on selections\n  let availableStates = $derived.by(() => {\n    if (!selectedCountryId) return [];\n    return states.filter(state => state.countryId === selectedCountryId);\n  });\n  \n  let availableCities = $derived.by(() => {\n    if (!selectedStateId) return [];\n    return cities.filter(city => city.stateId === selectedStateId);\n  });\n  \n  // Reset dependent dropdowns when parent selection changes\n  $effect(() => {\n    // When country changes, reset state and city\n    selectedStateId = null;\n    selectedCityId = null;\n  }, selectedCountryId);\n  \n  $effect(() => {\n    // When state changes, reset city\n    selectedCityId = null;\n  }, selectedStateId);\n  \n  // Derived selected items (for display)\n  let selectedCountry = $derived.by(() => {\n    if (!selectedCountryId) return null;\n    return countries.find(country => country.id === selectedCountryId);\n  });\n  \n  let selectedState = $derived.by(() => {\n    if (!selectedStateId) return null;\n    return states.find(state => state.id === selectedStateId);\n  });\n  \n  let selectedCity = $derived.by(() => {\n    if (!selectedCityId) return null;\n    return cities.find(city => city.id === selectedCityId);\n  });\n  \n  // Derived full location string\n  let locationString = $derived.by(() => {\n    const parts = [];\n    if (selectedCity) parts.push(selectedCity.name);\n    if (selectedState) parts.push(selectedState.name);\n    if (selectedCountry) parts.push(selectedCountry.name);\n    \n    return parts.length ? parts.join(', ') : 'Please select a location';\n  });\n</script>\n\n<div>\n  <!-- Country dropdown -->\n  <div>\n    <label for=\"country\">Country:</label>\n    <select \n      id=\"country\" \n      bind:value={selectedCountryId}\n    >\n      <option value={null}>Select a country</option>\n      {#each countries as country}\n        <option value={country.id}>{country.name}</option>\n      {/each}\n    </select>\n  </div>\n  \n  <!-- State dropdown (enabled only when country is selected) -->\n  <div>\n    <label for=\"state\">State/Province:</label>\n    <select \n      id=\"state\" \n      bind:value={selectedStateId}\n      disabled={!selectedCountryId}\n    >\n      <option value={null}>Select a state</option>\n      {#each availableStates as state}\n        <option value={state.id}>{state.name}</option>\n      {/each}\n    </select>\n  </div>\n  \n  <!-- City dropdown (enabled only when state is selected) -->\n  <div>\n    <label for=\"city\">City:</label>\n    <select \n      id=\"city\" \n      bind:value={selectedCityId}\n      disabled={!selectedStateId}\n    >\n      <option value={null}>Select a city</option>\n      {#each availableCities as city}\n        <option value={city.id}>{city.name}</option>\n      {/each}\n    </select>\n  </div>\n  \n  <!-- Display selected location -->\n  <div>\n    <h3>Selected Location:</h3>\n    <p>{locationString}</p>\n  </div>\n</div>\n```\n\nKey aspects of this implementation:\n\n1. **Data Structure**:\n   - Hierarchical data with relationships (countries contain states, states contain cities)\n   - Each item has an ID and a reference to its parent (e.g., `stateId` for cities)\n\n2. **Selection State**:\n   - Three separate state variables track the user's selections\n   - When a parent selection changes, child selections are reset\n\n3. **Derived Filtered Lists**:\n   - `availableStates` is derived from the selected country\n   - `availableCities` is derived from the selected state\n   - These lists automatically update when selections change\n\n4. **Derived Selected Items**:\n   - `selectedCountry`, `selectedState`, and `selectedCity` objects are derived from the selected IDs\n   - This makes it easy to access the full objects instead of just the IDs\n\n5. **Derived Display String**:\n   - `locationString` combines all selections into a human-readable format\n   - Updates automatically as selections change\n\n6. **Effects for Cascading Resets**:\n   - `$effect` blocks ensure that when a parent selection changes, child selections are reset\n\nThis approach creates a clean, reactive cascading dropdown system where each level's options depend on the selection in the previous level. The UI automatically updates to show only valid options at each step."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How does Svelte's push-pull reactivity model affect the performance of applications with many derived values?","answer":"Svelte's push-pull reactivity model provides significant performance benefits for applications with many derived values. Let's explore how this works and why it's efficient:\n\n### How Push-Pull Reactivity Works\n\n1. **Push Phase**: When a piece of state changes, Svelte immediately marks all dependent derived values as \"dirty\" (push). This propagation happens throughout the dependency graph.\n\n2. **Pull Phase**: The actual recalculation of derived values happens only when they are read (pull), typically during rendering.\n\n### Performance Benefits\n\n1. **Lazy Evaluation**: Derived values are only recalculated when they're actually needed, not immediately when their dependencies change. This means:\n\n```svelte\n<script>\n  let count = $state(0);\n  \n  // These are marked as dirty when count changes\n  let derived1 = $derived(expensiveCalculation1(count));\n  let derived2 = $derived(expensiveCalculation2(count));\n  let derived3 = $derived(expensiveCalculation3(count));\n</script>\n\n<!-- Only derived1 is actually recalculated if the others aren't displayed -->\n<p>{derived1}</p>\n\n{#if someCondition}\n  <!-- These are only calculated if someCondition is true -->\n  <p>{derived2}</p>\n  <p>{derived3}</p>\n{/if}\n```\n\n2. **Batched Updates**: Multiple state changes can be batched before recalculating derived values:\n\n```svelte\n<script>\n  let state = $state({ x: 0, y: 0, z: 0 });\n  \n  // All of these derived values are marked dirty\n  let derivedA = $derived(state.x + state.y);\n  let derivedB = $derived(state.y + state.z);\n  let derivedC = $derived(state.x + state.z);\n  \n  function updateState() {\n    // All updates in one batch\n    state = { \n      x: state.x + 1, \n      y: state.y + 1, \n      z: state.z + 1 \n    };\n    // Derived values are only recalculated once when read\n  }\n</script>\n```\n\n3. **Skip Unchanged Values**: If a derived value is recalculated but produces the same reference as before, downstream dependents won't be recalculated:\n\n```svelte\n<script>\n  let count = $state(0);\n  \n  // This only changes reference when crossing the threshold\n  let category = $derived(count < 10 ? 'small' : 'large');\n  \n  // This only recalculates when category actually changes\n  let message = $derived(\n    category === 'small' \n      ? 'Keep going!' \n      : 'You reached the goal!'\n  );\n</script>\n```\n\n4. **Topological Evaluation**: Derived values are calculated in the correct order based on their dependencies, ensuring no unnecessary recalculations:\n\n```svelte\n<script>\n  let a = $state(1);\n  let b = $state(2);\n  \n  // First level\n  let c = $derived(a + b);\n  \n  // Second level - depends on c\n  let d = $derived(c * 2);\n  \n  // Third level - depends on d\n  let e = $derived(d > 10 ? 'large' : 'small');\n</script>\n```\n\nWhen `a` changes, Svelte ensures `c` is recalculated before `d`, and `d` before `e`.\n\n### Real-World Performance Impact\n\nIn applications with many derived values, the push-pull model prevents performance issues in several ways:\n\n1. **Avoiding Redundant Calculations**: \n```svelte\n<script>\n  // In a complex dashboard with many metrics\n  let data = $state([/* large dataset */]);\n  \n  // Many derived metrics\n  let metric1 = $derived(calculateMetric1(data));\n  let metric2 = $derived(calculateMetric2(data));\n  // ... many more metrics\n  \n  // User toggles between dashboard views\n  let currentView = $state('summary');\n</script>\n\n<!-- Only the metrics needed for the current view are calculated -->\n{#if currentView === 'summary'}\n  <SummaryView metrics={[metric1, metric2]} />\n{:else if currentView === 'details'}\n  <DetailView metrics={[metric3, metric4, metric5]} />\n{/if}\n```\n\n2. **Efficient Updates in Large Forms**:\n```svelte\n<script>\n  // Form with many fields\n  let form = $state({\n    name: '',\n    email: '',\n    // ... many fields\n  });\n  \n  // Many validations\n  let nameValid = $derived(validateName(form.name));\n  let emailValid = $derived(validateEmail(form.email));\n  // ... many validations\n  \n  // Overall form validity\n  let formValid = $derived(nameValid && emailValid && /* other validations */);\n</script>\n```\n\nWhen a user types in one field, only the validations for that field and the overall form validity are recalculated, not all validations.\n\n3. **Conditional UI Rendering**:\nThe push-pull model works especially well with conditional rendering, as calculations for hidden UI elements are deferred until they're actually shown.\n\n### Summary\n\nSvelte's push-pull reactivity model provides excellent performance for applications with many derived values by:\n1. Only recalculating values when they're actually needed\n2. Skipping updates for unchanged values\n3. Optimizing the order of calculations\n4. Supporting efficient batched updates\n\nThis makes it possible to build complex, data-rich applications with many interdependent derived values without suffering performance degradation."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How would you implement a complex form validation system using $derived in Svelte 5?","answer":"Implementing a complex form validation system using `$derived` in Svelte 5 allows for reactive, declarative validation logic. Here's a comprehensive example of a registration form with complex validation rules:\n\n```svelte\n<script>\n  // Form state\n  let form = $state({\n    username: '',\n    email: '',\n    password: '',\n    confirmPassword: '',\n    birthDate: '',\n    phoneNumber: '',\n    country: '',\n    acceptTerms: false\n  });\n  \n  // Validation functions\n  function validateUsername(username) {\n    if (!username) return { valid: false, message: 'Username is required' };\n    if (username.length < 3) return { valid: false, message: 'Username must be at least 3 characters' };\n    if (username.length > 20) return { valid: false, message: 'Username must be less than 20 characters' };\n    if (!/^[a-zA-Z0-9_]+$/.test(username)) return { valid: false, message: 'Username can only contain letters, numbers, and underscores' };\n    return { valid: true, message: '' };\n  }\n  \n  function validateEmail(email) {\n    if (!email) return { valid: false, message: 'Email is required' };\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) return { valid: false, message: 'Please enter a valid email address' };\n    return { valid: true, message: '' };\n  }\n  \n  function validatePassword(password) {\n    if (!password) return { valid: false, message: 'Password is required' };\n    if (password.length < 8) return { valid: false, message: 'Password must be at least 8 characters' };\n    if (!/[A-Z]/.test(password)) return { valid: false, message: 'Password must contain at least one uppercase letter' };\n    if (!/[a-z]/.test(password)) return { valid: false, message: 'Password must contain at least one lowercase letter' };\n    if (!/[0-9]/.test(password)) return { valid: false, message: 'Password must contain at least one number' };\n    if (!/[^A-Za-z0-9]/.test(password)) return { valid: false, message: 'Password must contain at least one special character' };\n    return { valid: true, message: '' };\n  }\n  \n  function validateConfirmPassword(password, confirmPassword) {\n    if (!confirmPassword) return { valid: false, message: 'Please confirm your password' };\n    if (password !== confirmPassword) return { valid: false, message: 'Passwords do not match' };\n    return { valid: true, message: '' };\n  }\n  \n  function validateBirthDate(birthDate) {\n    if (!birthDate) return { valid: false, message: 'Birth date is required' };\n    \n    const today = new Date();\n    const birthDateObj = new Date(birthDate);\n    \n    if (isNaN(birthDateObj.getTime())) return { valid: false, message: 'Please enter a valid date' };\n    \n    // Calculate age\n    let age = today.getFullYear() - birthDateObj.getFullYear();\n    const monthDiff = today.getMonth() - birthDateObj.getMonth();\n    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDateObj.getDate())) {\n      age--;\n    }\n    \n    if (age < 18) return { valid: false, message: 'You must be at least 18 years old' };\n    if (age > 120) return { valid: false, message: 'Please enter a valid birth date' };\n    \n    return { valid: true, message: '' };\n  }\n  \n  function validatePhoneNumber(phoneNumber, country) {\n    if (!phoneNumber) return { valid: false, message: 'Phone number is required' };\n    \n    // Different validation based on country\n    if (country === 'US') {\n      // US phone format: XXX-XXX-XXXX\n      if (!/^\\d{3}-\\d{3}-\\d{4}$/.test(phoneNumber)) {\n        return { valid: false, message: 'US phone numbers should be in format XXX-XXX-XXXX' };\n      }\n    } else if (country === 'UK') {\n      // UK phone format: +44 XXXX XXXXXX\n      if (!/^\\+44 \\d{4} \\d{6}$/.test(phoneNumber)) {\n        return { valid: false, message: 'UK phone numbers should be in format +44 XXXX XXXXXX' };\n      }\n    } else {\n      // Generic validation for other countries\n      if (!/^\\+?[0-9\\s-]{8,}$/.test(phoneNumber)) {\n        return { valid: false, message: 'Please enter a valid phone number' };\n      }\n    }\n    \n    return { valid: true, message: '' };\n  }\n  \n  function validateCountry(country) {\n    if (!country) return { valid: false, message: 'Please select a country' };\n    return { valid: true, message: '' };\n  }\n  \n  function validateTerms(acceptTerms) {\n    if (!acceptTerms) return { valid: false, message: 'You must accept the terms and conditions' };\n    return { valid: true, message: '' };\n  }\n  \n  // Derived validation results\n  let usernameValidation = $derived(validateUsername(form.username));\n  let emailValidation = $derived(validateEmail(form.email));\n  let passwordValidation = $derived(validatePassword(form.password));\n  let confirmPasswordValidation = $derived(validateConfirmPassword(form.password, form.confirmPassword));\n  let birthDateValidation = $derived(validateBirthDate(form.birthDate));\n  let countryValidation = $derived(validateCountry(form.country));\n  let phoneValidation = $derived(validatePhoneNumber(form.phoneNumber, form.country));\n  let termsValidation = $derived(validateTerms(form.acceptTerms));\n  \n  // Password strength indicator\n  let passwordStrength = $derived.by(() => {\n    if (!form.password) return { score: 0, label: 'None' };\n    \n    let score = 0;\n    \n    // Length check\n    if (form.password.length >= 8) score += 1;\n    if (form.password.length >= 12) score += 1;\n    \n    // Character type checks\n    if (/[A-Z]/.test(form.password)) score += 1;\n    if (/[a-z]/.test(form.password)) score += 1;\n    if (/[0-9]/.test(form.password)) score += 1;\n    if (/[^A-Za-z0-9]/.test(form.password)) score += 1;\n    \n    // Common patterns check (negative)\n    if (/123|abc|qwerty|password/i.test(form.password)) score -= 1;\n    \n    // Ensure score is between 0-5\n    score = Math.max(0, Math.min(5, score));\n    \n    const labels = ['Very Weak', 'Weak', 'Fair', 'Good', 'Strong', 'Very Strong'];\n    \n    return {\n      score,\n      label: labels[score]\n    };\n  });\n  \n  // Overall form validity\n  let formValid = $derived(\n    usernameValidation.valid &&\n    emailValidation.valid &&\n    passwordValidation.valid &&\n    confirmPasswordValidation.valid &&\n    birthDateValidation.valid &&\n    countryValidation.valid &&\n    phoneValidation.valid &&\n    termsValidation.valid\n  );\n  \n  // Form submission\n  function handleSubmit() {\n    if (formValid) {\n      // In a real app, you'd submit the form data here\n      alert('Form submitted successfully!');\n    } else {\n      alert('Please fix the errors in the form before submitting.');\n    }\n  }\n</script>\n\n<form on:submit|preventDefault={handleSubmit}>\n  <h2>Registration Form</h2>\n  \n  <!-- Username field -->\n  <div class=\"form-group\">\n    <label for=\"username\">Username</label>\n    <input \n      type=\"text\" \n      id=\"username\" \n      bind:value={form.username} \n      class:invalid={!usernameValidation.valid && form.username !== ''}\n    />\n    {#if !usernameValidation.valid && form.username !== ''}\n      <p class=\"error\">{usernameValidation.message}</p>\n    {/if}\n  </div>\n  \n  <!-- Email field -->\n  <div class=\"form-group\">\n    <label for=\"email\">Email</label>\n    <input \n      type=\"email\" \n      id=\"email\" \n      bind:value={form.email}\n      class:invalid={!emailValidation.valid && form.email !== ''}\n    />\n    {#if !emailValidation.valid && form.email !== ''}\n      <p class=\"error\">{emailValidation.message}</p>\n    {/if}\n  </div>\n  \n  <!-- Password field -->\n  <div class=\"form-group\">\n    <label for=\"password\">Password</label>\n    <input \n      type=\"password\" \n      id=\"password\" \n      bind:value={form.password}\n      class:invalid={!passwordValidation.valid && form.password !== ''}\n    />\n    \n    <!-- Password strength meter -->\n    {#if form.password}\n      <div class=\"strength-meter\">\n        <div class=\"strength-bar\" style=\"width: {passwordStrength.score * 20}%\"></div>\n        <span>{passwordStrength.label}</span>\n      </div>\n    {/if}\n    \n    {#if !passwordValidation.valid && form.password !== ''}\n      <p class=\"error\">{passwordValidation.message}</p>\n    {/if}\n  </div>\n  \n  <!-- Confirm Password field -->\n  <div class=\"form-group\">\n    <label for=\"confirmPassword\">Confirm Password</label>\n    <input \n      type=\"password\" \n      id=\"confirmPassword\" \n      bind:value={form.confirmPassword}\n      class:invalid={!confirmPasswordValidation.valid && form.confirmPassword !== ''}\n    />\n    {#if !confirmPasswordValidation.valid && form.confirmPassword !== ''}\n      <p class=\"error\">{confirmPasswordValidation.message}</p>\n    {/if}\n  </div>\n  \n  <!-- Birth Date field -->\n  <div class=\"form-group\">\n    <label for=\"birthDate\">Birth Date</label>\n    <input \n      type=\"date\" \n      id=\"birthDate\" \n      bind:value={form.birthDate}\n      class:invalid={!birthDateValidation.valid && form.birthDate !== ''}\n    />\n    {#if !birthDateValidation.valid && form.birthDate !== ''}\n      <p class=\"error\">{birthDateValidation.message}</p>\n    {/if}\n  </div>\n  \n  <!-- Country field -->\n  <div class=\"form-group\">\n    <label for=\"country\">Country</label>\n    <select \n      id=\"country\" \n      bind:value={form.country}\n      class:invalid={!countryValidation.valid && form.country !== ''}\n    >\n      <option value=\"\">Select a country</option>\n      <option value=\"US\">United States</option>\n      <option value=\"UK\">United Kingdom</option>\n      <option value=\"CA\">Canada</option>\n      <option value=\"AU\">Australia</option>\n      <option value=\"Other\">Other</option>\n    </select>\n    {#if !countryValidation.valid && form.country !== ''}\n      <p class=\"error\">{countryValidation.message}</p>\n    {/if}\n  </div>\n  \n  <!-- Phone Number field -->\n  <div class=\"form-group\">\n    <label for=\"phoneNumber\">Phone Number</label>\n    <input \n      type=\"tel\" \n      id=\"phoneNumber\" \n      bind:value={form.phoneNumber}\n      placeholder={form.country === 'US' ? '123-456-7890' : \n                  form.country === 'UK' ? '+44 1234 567890' : \n                  'Enter phone number'}\n      class:invalid={!phoneValidation.valid && form.phoneNumber !== ''}\n    />\n    {#if !phoneValidation.valid && form.phoneNumber !== ''}\n      <p class=\"error\">{phoneValidation.message}</p>\n    {/if}\n  </div>\n  \n  <!-- Terms and Conditions -->\n  <div class=\"form-group checkbox\">\n    <label>\n      <input \n        type=\"checkbox\" \n        bind:checked={form.acceptTerms}\n      />\n      I accept the terms and conditions\n    </label>\n    {#if !termsValidation.valid && form.acceptTerms === false}\n      <p class=\"error\">{termsValidation.message}</p>\n    {/if}\n  </div>\n  \n  <!-- Submit button -->\n  <button type=\"submit\" disabled={!formValid}>\n    Register\n  </button>\n  \n  <!-- Form status -->\n  <div class=\"form-status\">\n    {#if formValid}\n      <p class=\"valid\">All fields are valid</p>\n    {:else}\n      <p class=\"invalid\">Please complete all required fields</p>\n    {/if}\n  </div>\n</form>\n\n<style>\n  .form-group {\n    margin-bottom: 1rem;\n  }\n  \n  .invalid {\n    border: 1px solid red;\n  }\n  \n  .error {\n    color: red;\n    font-size: 0.8rem;\n    margin-top: 0.2rem;\n  }\n  \n  .strength-meter {\n    height: 10px;\n    background-color: #e0e0e0;\n    margin-top: 5px;\n    position: relative;\n  }\n  \n  .strength-bar {\n    height: 100%;\n    background-color: green;\n    transition: width 0.3s;\n  }\n  \n  .form-status {\n    margin-top: 1rem;\n  }\n  \n  .valid {\n    color: green;\n  }\n</style>\n```\n\nKey aspects of this implementation:\n\n1. **Modular Validation Functions**:\n   - Each field has its own validation function that returns an object with `valid` status and error `message`\n   - Some validations depend on multiple fields (like confirm password)\n   - Complex validations like password strength and age calculation\n\n2. **Derived Validation Results**:\n   - Each validation result is a derived value that automatically updates when form fields change\n   - The `passwordStrength` uses `$derived.by` for more complex calculation with multiple steps\n\n3. **Interdependent Validations**:\n   - Phone number validation depends on the selected country\n   - Confirm password validation depends on the password field\n\n4. **Overall Form Validity**:\n   - `formValid` is a derived value that combines all individual validation results\n   - The submit button is disabled when the form is invalid\n\n5. **Reactive UI Feedback**:\n   - Error messages appear as the user types\n   - Fields are highlighted when invalid\n   - Password strength meter updates in real-time\n\n6. **Complex Validation Logic**:\n   - Age calculation from birth date\n   - Password strength scoring with multiple criteria\n   - Country-specific phone number validation\n\nThis approach leverages Svelte's reactivity system to create a dynamic form validation system where:\n- Validations run automatically when relevant fields change\n- Error messages appear and disappear reactively\n- The form's overall validity is always up-to-date\n- Complex interdependencies between fields are handled cleanly\n\nThe use of `$derived` makes the validation logic declarative and easy to understand, while keeping the UI in sync with the validation state at all times."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How can you debug issues with derived values in Svelte 5 applications?","answer":"Debugging issues with derived values in Svelte 5 applications requires"}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"What is the primary purpose of `$effect` in Svelte 5, and when should it be used?","answer":"The primary purpose of `$effect` in Svelte 5 is to run functions in response to state changes. Effects are used for side effects that need to happen when reactive state updates, such as:\n- Calling third-party libraries\n- Drawing on `<canvas>` elements\n- Making network requests\n- DOM manipulations outside of Svelte's template system\n- Setting up and tearing down event listeners\n\nEffects only run in the browser, not during server-side rendering.\n\n`$effect` should be used when you need to perform operations that fall outside of Svelte's declarative template system. It's an \"escape hatch\" for imperative code that needs to respond to reactive state changes.\n\nHere's an example of using `$effect` to draw on a canvas:\n\n```svelte\n<script>\n\tlet size = $state(50);\n\tlet color = $state('#ff3e00');\n\tlet canvas;\n\n\t$effect(() => {\n\t\tconst context = canvas.getContext('2d');\n\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n\n\t\t// this will re-run whenever `color` or `size` change\n\t\tcontext.fillStyle = color;\n\t\tcontext.fillRect(0, 0, size, size);\n\t});\n</script>\n\n<canvas bind:this={canvas} width=\"100\" height=\"100\" />\n<input type=\"range\" bind:value={size} min=\"10\" max=\"90\" />\n<input type=\"color\" bind:value={color} />\n```\n\nIt's important to note that you should generally avoid updating state inside effects, as it can lead to convoluted code and infinite update cycles."}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"How does Svelte's reactivity system determine which state changes should trigger an effect to re-run?","answer":"Svelte's reactivity system automatically tracks which pieces of reactive state are accessed inside an effect function and re-runs the effect when that state changes. This tracking happens during the synchronous execution of the effect function.\n\nThe tracking mechanism works as follows:\n\n1. When an effect runs, Svelte enters a \"tracking mode\"\n2. Any reactive values (`$state`, `$derived`, `$props`) that are read during the execution are registered as dependencies\n3. When those dependencies change later, the effect is scheduled to re-run\n\nHere's how it works in practice:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet name = $state('Svelte');\n\tlet unrelated = $state(42);\n\t\n\t$effect(() => {\n\t\t// This effect depends on `count` and `name`\n\t\tconsole.log(`Count is ${count} and name is ${name}`);\n\t\t\n\t\t// `unrelated` is not accessed, so changing it won't trigger this effect\n\t});\n</script>\n\n<button on:click={() => count++}>Increment count</button>\n<button on:click={() => name = name === 'Svelte' ? 'Runes' : 'Svelte'}>Toggle name</button>\n<button on:click={() => unrelated++}>This won't trigger the effect</button>\n```\n\nImportant details about dependency tracking:\n\n1. Only synchronously accessed values are tracked. Values accessed after an `await` or inside a `setTimeout`/`setInterval` won't be tracked:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\t\n\t$effect(() => {\n\t\t// `count` is tracked here\n\t\tconsole.log(\"Starting effect with count:\", count);\n\t\t\n\t\tsetTimeout(() => {\n\t\t\t// `count` is NOT tracked here, so changes won't trigger a re-run\n\t\t\tconsole.log(\"Inside timeout, count:\", count);\n\t\t}, 1000);\n\t});\n</script>\n```\n\n2. An effect only reruns when the object it reads changes, not when a property inside it changes:\n\n```svelte\n<script>\n\tlet state = $state({ value: 0 });\n\t\n\t// This won't re-run when state.value changes because state itself wasn't reassigned\n\t$effect(() => {\n\t\tconsole.log(\"state object:\", state);\n\t});\n\t\n\t// This will re-run when state.value changes\n\t$effect(() => {\n\t\tconsole.log(\"state.value:\", state.value);\n\t});\n</script>\n```\n\n3. An effect only depends on values it read during its last execution. This means conditional dependencies can change between runs:\n\n```svelte\n<script>\n\tlet showB = $state(false);\n\tlet valueB = $state(0);\n\t\n\t$effect(() => {\n\t\tconsole.log(\"Effect running\");\n\t\t\n\t\tif (showB) {\n\t\t\t// valueB is only a dependency when showB is true\n\t\t\tconsole.log(\"Value B:\", valueB);\n\t\t}\n\t});\n</script>\n```"}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"How do teardown functions work with `$effect`, and why are they important?","answer":"Teardown functions in `$effect` are functions that are returned by the effect and are automatically run:\n1. Immediately before the effect re-runs due to dependency changes\n2. When the component is destroyed\n\nThey provide a way to clean up resources or cancel ongoing operations before an effect runs again or when the component is removed from the DOM.\n\nHere's an example of using a teardown function to manage an interval:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet milliseconds = $state(1000);\n\n\t$effect(() => {\n\t\tconsole.log(`Setting up interval with ${milliseconds}ms delay`);\n\t\t\n\t\t// Set up the interval\n\t\tconst interval = setInterval(() => {\n\t\t\tcount += 1;\n\t\t}, milliseconds);\n\n\t\t// Return a teardown function\n\t\treturn () => {\n\t\t\tconsole.log('Clearing previous interval');\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n\n<h1>{count}</h1>\n\n<button onclick={() => (milliseconds *= 2)}>slower</button>\n<button onclick={() => (milliseconds /= 2)}>faster</button>\n```\n\nIn this example:\n- When the component first mounts, the effect runs and sets up an interval\n- When `milliseconds` changes, the teardown function runs first (clearing the old interval), then the effect runs again (creating a new interval with the updated timing)\n- When the component is destroyed, the teardown function runs to clean up the interval\n\nTeardown functions are crucial for:\n\n1. **Preventing memory leaks**: They allow you to clean up resources like event listeners, subscriptions, intervals, etc.\n\n2. **Cancelling ongoing operations**: You can abort fetch requests, animations, or other long-running operations.\n\n3. **Maintaining consistent state**: They ensure that you don't have multiple overlapping operations when dependencies change.\n\nAnother practical example with an event listener:\n\n```svelte\n<script>\n\tlet windowWidth = $state(window.innerWidth);\n\tlet throttleMs = $state(200);\n\n\t$effect(() => {\n\t\tlet timeout;\n\t\t\n\t\tconst handleResize = () => {\n\t\t\t// Throttle the updates\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(() => {\n\t\t\t\twindowWidth = window.innerWidth;\n\t\t\t}, throttleMs);\n\t\t};\n\t\t\n\t\twindow.addEventListener('resize', handleResize);\n\t\t\n\t\t// Clean up by removing the event listener\n\t\treturn () => {\n\t\t\tclearTimeout(timeout);\n\t\t\twindow.removeEventListener('resize', handleResize);\n\t\t};\n\t});\n</script>\n\n<p>Window width: {windowWidth}px</p>\n<label>\n\tThrottle: <input type=\"range\" bind:value={throttleMs} min=\"0\" max=\"1000\" step=\"50\" />\n\t{throttleMs}ms\n</label>\n```"}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"What's the difference between `$effect` and `$effect.pre`, and when would you use each?","answer":"`$effect` and `$effect.pre` are both effect runes in Svelte 5, but they differ in their timing relative to DOM updates:\n\n1. **`$effect`**: Runs after DOM updates have been applied, in a microtask after state changes.\n\n2. **`$effect.pre`**: Runs before DOM updates are applied, allowing you to perform operations that need to happen before the DOM is updated.\n\nHere's a comparison:\n\n| Feature | `$effect` | `$effect.pre` |\n|---------|-----------|---------------|\n| Timing | After DOM updates | Before DOM updates |\n| Use case | Most side effects | Pre-DOM-update operations |\n| Dependency tracking | Yes | Yes |\n| Teardown functions | Yes | Yes |\n\n`$effect.pre` is useful in specific scenarios where you need to capture or manipulate something before the DOM updates. A classic example is auto-scrolling a chat or message list:\n\n```svelte\n<script>\n\timport { tick } from 'svelte';\n\n\tlet div = $state();\n\tlet messages = $state([\n\t\t'Initial message'\n\t]);\n\t\n\tfunction addMessage() {\n\t\tmessages = [...messages, `Message #${messages.length + 1}`];\n\t}\n\n\t// Use $effect.pre to detect if we should auto-scroll\n\t$effect.pre(() => {\n\t\tif (!div) return; // not yet mounted\n\n\t\t// reference `messages` array length so that this code re-runs whenever it changes\n\t\tmessages.length;\n\n\t\t// Check if user was scrolled to bottom before new messages were added\n\t\tconst shouldAutoScroll = \n\t\t\tdiv.offsetHeight + div.scrollTop > div.scrollHeight - 20;\n\t\t\n\t\tif (shouldAutoScroll) {\n\t\t\t// Wait for DOM update, then scroll\n\t\t\ttick().then(() => {\n\t\t\t\tdiv.scrollTo(0, div.scrollHeight);\n\t\t\t});\n\t\t}\n\t});\n</script>\n\n<div class=\"chat-container\" bind:this={div}>\n\t{#each messages as message}\n\t\t<p class=\"message\">{message}</p>\n\t{/each}\n</div>\n\n<button on:click={addMessage}>Add message</button>\n\n<style>\n\t.chat-container {\n\t\theight: 200px;\n\t\toverflow-y: auto;\n\t\tborder: 1px solid #ccc;\n\t\tpadding: 10px;\n\t}\n\t.message {\n\t\tpadding: 5px;\n\t\tmargin: 5px 0;\n\t\tbackground: #f0f0f0;\n\t\tborder-radius: 4px;\n\t}\n</style>\n```\n\nIn this example, `$effect.pre` is crucial because:\n1. It runs before the DOM updates with new messages\n2. It checks if the user was already at the bottom of the scroll container\n3. If they were, it schedules a scroll operation after the DOM updates (using `tick()`)\n\nIf you used regular `$effect` instead, you would lose the ability to check the scroll position before the new messages were added, making it harder to determine if auto-scrolling should happen.\n\nApart from the timing difference, `$effect.pre` works exactly like `$effect` in terms of dependency tracking, teardown functions, and other behavior."}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"What are the common pitfalls when using `$effect`, and how can they be avoided?","answer":"There are several common pitfalls when using `$effect` in Svelte 5:\n\n### 1. Infinite Update Loops\n\nThe most common pitfall is creating an infinite update loop by both reading and writing to the same state variable inside an effect:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\t\n\t// DON'T DO THIS!\n\t$effect(() => {\n\t\t// This reads count, then updates it, causing the effect to run again\n\t\tcount = count + 1;\n\t});\n</script>\n```\n\n**Solution**: Avoid updating state inside effects that depend on that same state. If you absolutely must, use `untrack` to prevent the infinite loop:\n\n```svelte\n<script>\n\timport { untrack } from 'svelte';\n\tlet count = $state(0);\n\t\n\t$effect(() => {\n\t\t// Read the current value without tracking it as a dependency\n\t\tconst currentCount = untrack(() => count);\n\t\tcount = currentCount + 1;\n\t});\n</script>\n```\n\n### 2. Using Effects for State Synchronization\n\nUsing effects to keep two pieces of state in sync is a common anti-pattern:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet doubled = $state(0);\n\t\n\t// DON'T DO THIS!\n\t$effect(() => {\n\t\tdoubled = count * 2;\n\t});\n</script>\n```\n\n**Solution**: Use `$derived` instead:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n</script>\n```\n\n### 3. Bidirectional Synchronization with Effects\n\nCreating two effects that update each other's dependencies can cause problems:\n\n```svelte\n<script>\n\tlet total = 100;\n\tlet spent = $state(0);\n\tlet left = $state(total);\n\t\n\t// DON'T DO THIS!\n\t$effect(() => {\n\t\tleft = total - spent;\n\t});\n\t\n\t$effect(() => {\n\t\tspent = total - left;\n\t});\n</script>\n```\n\n**Solution**: Use callbacks or getters/setters instead:\n\n```svelte\n<script>\n\tlet total = 100;\n\tlet spent = $state(0);\n\t\n\t// Using a getter/setter object\n\tlet left = {\n\t\tget value() {\n\t\t\treturn total - spent;\n\t\t},\n\t\tset value(v) {\n\t\t\tspent = total - v;\n\t\t}\n\t};\n\t\n\tfunction updateSpent(e) {\n\t\tspent = +e.target.value;\n\t}\n</script>\n\n<input type=\"range\" value={spent} on:input={updateSpent} max={total} />\n<input type=\"range\" bind:value={left.value} max={total} />\n```\n\n### 4. Forgetting That Async Operations Don't Track Dependencies\n\nValues accessed after an `await` or inside callbacks won't be tracked:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\t\n\t$effect(async () => {\n\t\tconsole.log(\"Initial count:\", count); // This tracks count\n\t\t\n\t\tawait fetch('/some-api');\n\t\t\n\t\tconsole.log(\"After fetch, count:\", count); // This DOESN'T track count!\n\t});\n</script>\n```\n\n**Solution**: Capture the values you need before the async operation:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\t\n\t$effect(async () => {\n\t\tconst currentCount = count; // This tracks count\n\t\t\n\t\tawait fetch('/some-api');\n\t\t\n\t\tconsole.log(\"After fetch, count was:\", currentCount);\n\t\tconsole.log(\"Current count is now:\", count); // Re-read if needed\n\t});\n</script>\n```\n\n### 5. Not Cleaning Up Resources\n\nForgetting to return a teardown function can lead to memory leaks:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\t\n\t// DON'T DO THIS!\n\t$effect(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tcount++;\n\t\t}, 1000);\n\t\t\n\t\t// Missing teardown function!\n\t});\n</script>\n```\n\n**Solution**: Always return a teardown function for effects that create ongoing processes:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\t\n\t$effect(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tcount++;\n\t\t}, 1000);\n\t\t\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n```\n\n### 6. Not Understanding Object References\n\nEffects track object references, not their internal properties:\n\n```svelte\n<script>\n\tlet user = $state({ name: 'Alice', age: 30 });\n\t\n\t// This won't re-run when user.name changes\n\t$effect(() => {\n\t\tconsole.log(\"User object:\", user);\n\t});\n\t\n\tfunction updateName() {\n\t\tuser.name = 'Bob'; // Mutates the object but doesn't change the reference\n\t}\n</script>\n```\n\n**Solution**: Either track the specific properties you care about or create new objects when updating:\n\n```svelte\n<script>\n\tlet user = $state({ name: 'Alice', age: 30 });\n\t\n\t// This will re-run when user.name changes\n\t$effect(() => {\n\t\tconsole.log(\"User name:\", user.name);\n\t});\n\t\n\t// OR, create a new object reference\n\tfunction updateName() {\n\t\tuser = { ...user, name: 'Bob' };\n\t}\n</script>\n```"}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"How do nested effects work in Svelte 5, and what are their characteristics?","answer":"Nested effects in Svelte 5 are effects defined inside other effects. They have specific characteristics that are important to understand for proper usage.\n\n### Basic Nested Effect Example\n\n```svelte\n<script>\n\tlet outer = $state(0);\n\tlet inner = $state(0);\n\n\t$effect(() => {\n\t\tconsole.log('Outer effect running, outer =', outer);\n\t\t\n\t\t// This is a nested effect\n\t\t$effect(() => {\n\t\t\tconsole.log('Inner effect running, inner =', inner);\n\t\t});\n\t});\n</script>\n\n<button on:click={() => outer++}>Increment outer</button>\n<button on:click={() => inner++}>Increment inner</button>\n```\n\n### Key Characteristics of Nested Effects\n\n1. **Creation Timing**: Nested effects are created when their parent effect runs.\n\n2. **Destruction and Re-creation**: When a parent effect re-runs, all nested effects are destroyed and re-created.\n\n3. **Independent Tracking**: Nested effects track their own dependencies independently from their parent.\n\n4. **Lifecycle**: Nested effects follow the same lifecycle rules as regular effects but are tied to their parent's existence.\n\n### Example Demonstrating Nested Effect Behavior\n\n```svelte\n<script>\n\tlet showInner = $state(true);\n\tlet outerCount = $state(0);\n\tlet innerCount = $state(0);\n\n\t$effect(() => {\n\t\tconsole.log(`Outer effect running. outerCount: ${outerCount}`);\n\t\t\n\t\t// This cleanup will run when outer effect re-runs\n\t\treturn () => {\n\t\t\tconsole.log('Outer effect cleanup');\n\t\t};\n\t});\n\t\n\t$effect(() => {\n\t\t// This outer effect depends on showInner and outerCount\n\t\tconsole.log(`Conditional effect. outerCount: ${outerCount}, showInner: ${showInner}`);\n\t\t\n\t\tif (showInner) {\n\t\t\t// This nested effect is only created when showInner is true\n\t\t\t$effect(() => {\n\t\t\t\tconsole.log(`Inner effect running. innerCount: ${innerCount}`);\n\t\t\t\t\n\t\t\t\treturn () => {\n\t\t\t\t\tconsole.log('Inner effect cleanup');\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn () => {\n\t\t\tconsole.log('Conditional effect cleanup');\n\t\t};\n\t});\n</script>\n\n<div>\n\t<button on:click={() => outerCount++}>Increment outer ({outerCount})</button>\n\t<button on:click={() => innerCount++}>Increment inner ({innerCount})</button>\n\t<button on:click={() => showInner = !showInner}>\n\t\t{showInner ? 'Hide' : 'Show'} inner\n\t</button>\n</div>\n```\n\nIn this example:\n- When `outerCount` changes, the \"Conditional effect\" re-runs, destroying and re-creating the inner effect\n- When `showInner` toggles from true to false, the inner effect is destroyed\n- When `showInner` toggles from false to true, the inner effect is created\n- When `innerCount` changes, only the inner effect re-runs (if it exists)\n\n### Practical Use Cases for Nested Effects\n\n1. **Conditional Effect Setup**: Creating effects only when certain conditions are met\n\n```svelte\n<script>\n\tlet isLoggedIn = $state(false);\n\tlet userId = $state(null);\n\tlet notifications = $state([]);\n\n\t$effect(() => {\n\t\t// Only set up the notification listener when user is logged in\n\t\tif (isLoggedIn && userId) {\n\t\t\tconsole.log(`Setting up notifications for user ${userId}`);\n\t\t\t\n\t\t\t// Nested effect to handle notifications\n\t\t\t$effect(() => {\n\t\t\t\t// This would re-run if notifications change\n\t\t\t\tconsole.log(`User ${userId} has ${notifications.length} notifications`);\n\t\t\t});\n\t\t\t\n\t\t\t// In a real app, you might set up a WebSocket or polling here\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tnotifications = [...notifications, `Notification ${Date.now()}`];\n\t\t\t}, 3000);\n\t\t\t\n\t\t\treturn () => {\n\t\t\t\tconsole.log(`Cleaning up notifications for user ${userId}`);\n\t\t\t\tclearInterval(interval);\n\t\t\t};\n\t\t}\n\t});\n</script>\n```\n\n2. **Dynamic Effect Creation**: Creating multiple effects based on data\n\n```svelte\n<script>\n\tlet items = $state([\n\t\t{ id: 1, value: 0 },\n\t\t{ id: 2, value: 0 }\n\t]);\n\n\t$effect(() => {\n\t\t// Re-run when items array changes\n\t\tconsole.log(`Setting up ${items.length} item effects`);\n\t\t\n\t\t// Create an effect for each item\n\t\titems.forEach(item => {\n\t\t\t$effect(() => {\n\t\t\t\tconsole.log(`Item ${item.id} value changed to ${item.value}`);\n\t\t\t});\n\t\t});\n\t});\n</script>\n\n<div>\n\t{#each items as item}\n\t\t<div>\n\t\t\tItem {item.id}: {item.value}\n\t\t\t<button on:click={() => item.value++}>Increment</button>\n\t\t</div>\n\t{/each}\n\t<button on:click={() => items = [...items, { id: items.length + 1, value: 0 }]}>\n\t\tAdd item\n\t</button>\n</div>\n```\n\n### Important Considerations for Nested Effects\n\n1. **Re-creation Overhead**: Be cautious with deeply nested effects as they can lead to performance issues when parent effects frequently re-run.\n\n2. **Cleanup Functions**: Ensure proper cleanup in nested effects to avoid memory leaks, especially when the parent effect might re-run often.\n\n3. **State Updates**: Be extremely careful about updating state in nested effects to avoid infinite loops or confusing reactivity chains.\n\n4. **Alternative Approaches**: Sometimes, using `$effect.root()` might be more appropriate than nested effects for more control over the effect lifecycle."}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"What is the `$effect.tracking()` rune, and how can it be used in creating custom reactive abstractions?","answer":"The `$effect.tracking()` rune is an advanced feature in Svelte 5 that tells you whether the current code is running inside a tracking context, such as an effect or inside a template. It returns `true` if the code is being tracked for reactivity, and `false` otherwise.\n\n### Basic Usage\n\n```svelte\n<script>\n\tconsole.log('In component setup:', $effect.tracking()); // false\n\n\t$effect(() => {\n\t\tconsole.log('In effect:', $effect.tracking()); // true\n\t});\n</script>\n\n<p>In template: {$effect.tracking()}</p> <!-- true -->\n```\n\n### Understanding Tracking Contexts\n\nA tracking context in Svelte 5 is any environment where reactive dependencies are being automatically tracked:\n\n- Inside an `$effect` or `$effect.pre` function body\n- Inside a Svelte component template\n- Inside a `$derived` calculation\n\nWhen code executes in these contexts, Svelte automatically tracks which reactive values (`$state`, `$derived`, `$props`) are accessed.\n\n### Creating Custom Reactive Abstractions\n\nThe primary use case for `$effect.tracking()` is implementing custom reactive abstractions that behave differently depending on whether they're being used in a tracked context.\n\nHere's an example of implementing a custom `createSubscriber` function:\n\n```svelte\n<script>\n\t// Custom reactive abstraction\n\tfunction createSubscriber(source, initialValue = undefined) {\n\t\tlet value = initialValue;\n\t\tlet subscribers = [];\n\t\t\n\t\t// Subscribe to the external source\n\t\tconst unsubscribe = source.subscribe(newValue => {\n\t\t\tvalue = newValue;\n\t\t\t// Notify all subscribers\n\t\t\tsubscribers.forEach(callback => callback(value));\n\t\t});\n\t\t\n\t\t// The function we return\n\t\tfunction subscribe(callback) {\n\t\t\t// If we're in a tracking context, set up an effect\n\t\t\tif ($effect.tracking()) {\n\t\t\t\t$effect(() => {\n\t\t\t\t\t// Access value to track it\n\t\t\t\t\tconst currentValue = value;\n\t\t\t\t\tcallback(currentValue);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Otherwise, manually subscribe\n\t\t\t\tsubscribers.push(callback);\n\t\t\t\t// Initial call with current value\n\t\t\t\tcallback(value);\n\t\t\t\t\n\t\t\t\t// Return unsubscribe function\n\t\t\t\treturn () => {\n\t\t\t\t\tsubscribers = subscribers.filter(cb => cb !== callback);\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Cleanup function for the whole subscriber\n\t\tsubscribe.unsubscribe = () => {\n\t\t\tunsubscribe();\n\t\t\tsubscribers = [];\n\t\t};\n\t\t\n\t\t// Getter to access current value\n\t\tObject.defineProperty(subscribe, 'value', {\n\t\t\tget: () => {\n\t\t\t\t// If we're in a tracking context, make this reactive\n\t\t\t\tif ($effect.tracking()) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn subscribe;\n\t}\n\t\n\t// Example usage with a simple event emitter\n\tfunction createEventEmitter() {\n\t\tlet subscribers = [];\n\t\treturn {\n\t\t\tsubscribe(callback) {\n\t\t\t\tsubscribers.push(callback);\n\t\t\t\treturn () => {\n\t\t\t\t\tsubscribers = subscribers.filter(cb => cb !== callback);\n\t\t\t\t};\n\t\t\t},\n\t\t\temit(value) {\n\t\t\t\tsubscribers.forEach(callback => callback(value));\n\t\t\t}\n\t\t};\n\t}\n\t\n\t// Create an event emitter and subscriber\n\tconst emitter = createEventEmitter();\n\tconst subscriber = createSubscriber(emitter, 'initial value');\n\t\n\t// Demo state\n\tlet manuallySubscribed = $state('Not subscribed');\n\t\n\t// Example of manual subscription (in non-tracking context)\n\tfunction setupManualSubscription() {\n\t\tconst unsub = subscriber(value => {\n\t\t\tmanuallySubscribed = value;\n\t\t});\n\t\t\n\t\t// Clean up on component destroy\n\t\t$effect(() => {\n\t\t\treturn unsub;\n\t\t});\n\t}\n</script>\n\n<!-- In a tracking context, no manual subscription needed -->\n<p>Auto-tracked value: {subscriber.value}</p>\n\n<!-- Manual subscription demo -->\n<p>Manually subscribed value: {manuallySubscribed}</p>\n<button on:click={setupManualSubscription}>Subscribe manually</button>\n<button on:click={() => emitter.emit('New value ' + Math.random().toFixed(2))}>\n\tEmit new value\n</button>\n```\n\nIn this example:\n\n1. `createSubscriber` creates a reactive wrapper around an external subscription source\n2. It uses `$effect.tracking()` to determine how to handle subscriptions:\n   - In a tracking context (like a template), it automatically sets up an effect\n   - In a non-tracking context (like an event handler), it requires manual subscription\n\n### Real-world Use Cases\n\n1. **Adapters for External Libraries**: Create reactive wrappers for non-Svelte libraries\n\n```js\nfunction createStoreAdapter(reduxStore) {\n\tlet currentState = reduxStore.getState();\n\tlet subscribers = [];\n\t\n\tconst unsubscribe = reduxStore.subscribe(() => {\n\t\tcurrentState = reduxStore.getState();\n\t\tsubscribers.forEach(cb => cb(currentState));\n\t});\n\t\n\tfunction subscribe(callback) {\n\t\tif ($effect.tracking()) {\n\t\t\t$effect(() => {\n\t\t\t\tconst state = currentState;\n\t\t\t\tcallback(state);\n\t\t\t});\n\t\t} else {\n\t\t\tsubscribers.push(callback);\n\t\t\tcallback(currentState);\n\t\t\treturn () => {\n\t\t\t\tsubscribers = subscribers.filter(cb => cb !== callback);\n\t\t\t};\n\t\t}\n\t}\n\t\n\tsubscribe.getState = () => {\n\t\tif ($effect.tracking()) {\n\t\t\treturn currentState; // Make this reactive\n\t\t}\n\t\treturn currentState;\n\t};\n\t\n\tsubscribe.dispatch = reduxStore.dispatch;\n\tsubscribe.unsubscribe = unsubscribe;\n\t\n\treturn subscribe;\n}\n```\n\n2. **Smart Event Listeners**: Event listeners that clean up automatically in tracking contexts\n\n```js\nfunction createEventListener(target, eventName) {\n\tlet lastEvent = null;\n\tlet listeners = [];\n\t\n\tfunction handler(event) {\n\t\tlastEvent = event;\n\t\tlisteners.forEach(fn => fn(event));\n\t}\n\t\n\tfunction listen(callback) {\n\t\tif ($effect.tracking()) {\n\t\t\t// In tracking context, set up automatically\n\t\t\t$effect(() => {\n\t\t\t\ttarget.addEventListener(eventName, handler);\n\t\t\t\tif (lastEvent) callback(lastEvent);\n\t\t\t\t\n\t\t\t\treturn () => {\n\t\t\t\t\t// Only remove if no other effects are tracking\n\t\t\t\t\tif (listeners.length === 0) {\n\t\t\t\t\t\ttarget.removeEventListener(eventName, handler);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t} else {\n\t\t\t// Manual subscription\n\t\t\tlisteners.push(callback);\n\t\t\tif (listeners.length === 1) {\n\t\t\t\ttarget.addEventListener(eventName, handler);\n\t\t\t}\n\t\t\treturn () => {\n\t\t\t\tlisteners = listeners.filter(fn => fn !== callback);\n\t\t\t\tif (listeners.length === 0) {\n\t\t\t\t\ttarget.removeEventListener(eventName, handler);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\t\n\treturn listen;\n}\n\n// Usage\nconst onClick = createEventListener(window, 'click');\n```\n\nThe `$effect.tracking()` rune enables these kinds of abstractions that can adapt their behavior based on the context in which they're used, making them more flexible and easier to use in different scenarios."}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"How does the `$effect.root` rune work, and what problems does it solve?","answer":"The `$effect.root` rune is an advanced feature in Svelte 5 that creates a non-tracked scope that doesn't auto-cleanup. It allows you to create effects with more manual control over their lifecycle, and enables the creation of effects outside of the component initialization phase.\n\n### Basic Syntax and Behavior\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t// Create an effect root\n\tconst cleanup = $effect.root(() => {\n\t\t// Create an effect inside the root\n\t\t$effect(() => {\n\t\t\tconsole.log(`Count is now: ${count}`);\n\t\t});\n\n\t\t// Optional: Return a cleanup function for the root\n\t\treturn () => {\n\t\t\tconsole.log('Effect root cleanup');\n\t\t};\n\t});\n\t\n\t// Later, you can manually clean up the root and all its effects\n\tfunction cleanupEffects() {\n\t\tcleanup();\n\t}\n</script>\n\n<button on:click={() => count++}>Increment ({count})</button>\n<button on:click={cleanupEffects}>Cleanup effects</button>\n```\n\n### Key Characteristics of `$effect.root`\n\n1. **Non-tracked**: The function passed to `$effect.root` itself is not tracked for reactivity.\n\n2. **Manual Cleanup**: Effects created within an effect root don't automatically clean up when the component is destroyed - you need to call the returned cleanup function.\n\n3. **Flexible Timing**: Unlike regular effects, roots can be created at any time, not just during component initialization.\n\n4. **Isolation**: Effects inside a root are isolated from the component's normal effect hierarchy.\n\n### Problems Solved by `$effect.root`\n\n#### 1. Creating Effects Outside Component Initialization\n\nRegular effects must be created during component initialization, but `$effect.root` allows you to create effects dynamically:\n\n```svelte\n<script>\n\tlet dynamicEffects = $state([]);\n\tlet nextId = 0;\n\t\n\tfunction createDynamicEffect() {\n\t\tconst id = nextId++;\n\t\tconst count = $state(0);\n\t\t\n\t\tconst cleanup = $effect.root(() => {\n\t\t\t$effect(() => {\n\t\t\t\tconsole.log(`Effect ${id}: count is ${count}`);\n\t\t\t});\n\t\t\t\n\t\t\treturn () => {\n\t\t\t\tconsole.log(`Cleaning up effect ${id}`);\n\t\t\t};\n\t\t});\n\t\t\n\t\tdynamicEffects = [...dynamicEffects, {\n\t\t\tid,\n\t\t\tcount,\n\t\t\tincrement: () => count++,\n\t\t\tcleanup\n\t\t}];\n\t}\n\t\n\tfunction removeEffect(id) {\n\t\tconst effect = dynamicEffects.find(e => e.id === id);\n\t\tif (effect) {\n\t\t\teffect.cleanup(); // Manual cleanup\n\t\t\tdynamicEffects = dynamicEffects.filter(e => e.id !== id);\n\t\t}\n\t}\n</script>\n\n<button on:click={createDynamicEffect}>Create new effect</button>\n\n{#each dynamicEffects as effect}\n\t<div>\n\t\tEffect {effect.id}: {effect.count}\n\t\t<button on:click={effect.increment}>Increment</button>\n\t\t<button on:click={() => removeEffect(effect.id)}>Remove</button>\n\t</div>\n{/each}\n```\n\n#### 2. Manual Control Over Effect Lifecycle\n\nSometimes you need more control over when effects are cleaned up, independent of component lifecycle:\n\n```svelte\n<script>\n\tlet isConnected = $state(false);\n\tlet messages = $state([]);\n\tlet connectionEffectCleanup = null;\n\t\n\tfunction connect() {\n\t\tif (connectionEffectCleanup) return; // Already connected\n\t\t\n\t\tisConnected = true;\n\t\t\n\t\t// Create a connection effect that persists until manually disconnected\n\t\tconnectionEffectCleanup = $effect.root(() => {\n\t\t\tconsole.log('Setting up connection...');\n\t\t\t\n\t\t\t// Simulate WebSocket connection\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tmessages = [...messages, `Message at ${new Date().toLocaleTimeString()}`];\n\t\t\t}, 2000);\n\t\t\t\n\t\t\t$effect(() => {\n\t\t\t\t// This effect tracks messages and does something with them\n\t\t\t\tconsole.log(`Processing ${messages.length} messages`);\n\t\t\t});\n\t\t\t\n\t\t\treturn () => {\n\t\t\t\tconsole.log('Tearing down connection...');\n\t\t\t\tclearInterval(interval);\n\t\t\t};\n\t\t});\n\t}\n\t\n\tfunction disconnect() {\n\t\tif (!connectionEffectCleanup) return; // Not connected\n\t\t\n\t\tconnectionEffectCleanup();\n\t\tconnectionEffectCleanup = null;\n\t\tisConnected = false;\n\t}\n</script>\n\n<div>\n\t<button on:click={connect} disabled={isConnected}>Connect</button>\n\t<button on:click={disconnect} disabled={!isConnected}>Disconnect</button>\n\t\n\t<h3>Messages ({messages.length})</h3>\n\t<ul>\n\t\t{#each messages as message}\n\t\t\t<li>{message}</li>\n\t\t{/each}\n\t</ul>\n\t\n\t<button on:click={() => messages = []}>Clear messages</button>\n</div>\n```\n\n#### 3. Implementing Custom Reactive Systems\n\n`$effect.root` enables the creation of custom reactive systems that interact with Svelte's reactivity but have their own lifecycle:\n\n```js\n// Custom store implementation\nfunction createStore(initialState) {\n\tlet state = $state(initialState);\n\tlet subscribers = [];\n\t\n\t// Create effects for subscribers when they use the store\n\tfunction subscribe(callback) {\n\t\treturn $effect.root(() => {\n\t\t\t$effect(() => {\n\t\t\t\tcallback(state);\n\t\t\t});\n\t\t});\n\t}\n\t\n\tfunction update(updater) {\n\t\tstate = updater(state);\n\t}\n\t\n\tfunction set(newState) {\n\t\tstate = newState;\n\t}\n\t\n\treturn { subscribe, update, set };\n}\n```\n\n#### 4. Integration with External Libraries\n\nWhen integrating with external libraries that have their own lifecycle, `$effect.root` provides a clean way to manage effects:\n\n```svelte\n<script>\n\timport { onMount } from 'svelte';\n\timport { createChart } from 'some-chart-library';\n\t\n\tlet chartData = $state([10, 20, 30, 40]);\n\tlet chartContainer;\n\tlet chartEffectCleanup;\n\t\n\tonMount(() => {\n\t\t// Initialize chart\n\t\tconst chart = createChart(chartContainer, {\n\t\t\tdata: chartData\n\t\t});\n\t\t\n\t\t// Set up effect to update chart when data changes\n\t\tchartEffectCleanup = $effect.root(() => {\n\t\t\t$effect(() => {\n\t\t\t\tconsole.log('Updating chart with new data', chartData);\n\t\t\t\tchart.updateData(chartData);\n\t\t\t});\n\t\t\t\n\t\t\treturn () => {\n\t\t\t\tchart.destroy();\n\t\t\t};\n\t\t});\n\t\t\n\t\treturn () => {\n\t\t\t// Clean up when component unmounts\n\t\t\tif (chartEffectCleanup) {\n\t\t\t\tchartEffectCleanup();\n\t\t\t}\n\t\t};\n\t});\n</script>\n\n<div bind:this={chartContainer}></div>\n<button on:click={() => chartData = chartData.map(d => d + Math.random() * 10)}>\n\tUpdate data\n</button>\n```\n\n### Important Considerations When Using `$effect.root`\n\n1. **Memory Management**: Since effects in a root don't automatically clean up, you must manage cleanup manually to prevent memory leaks.\n\n2. **Debugging Complexity**: Using `$effect.root` adds complexity that can make debugging more difficult.\n\n3. **Use Sparingly**: In most cases, regular `$effect` is sufficient. Use `$effect.root` only when you need its specific capabilities.\n\n4. **Component Integration**: When using `$effect.root` within components, consider calling the cleanup function in an onDestroy or return function from onMount to ensure proper cleanup when the component is destroyed."}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"How do conditional dependencies work in `$effect`, and what are the implications for effect re-runs?","answer":"Conditional dependencies in `$effect` refer to reactive values that are only accessed under certain conditions within the effect. This has important implications for when the effect will re-run.\n\n### Basic Concept\n\nAn effect only depends on the values that it read during its last execution. If a value is conditionally accessed, it will only be a dependency when that condition is true.\n\n### Simple Example\n\n```svelte\n<script>\n\tlet showDetails = $state(false);\n\tlet details = $state('Some details');\n\tlet counter = $state(0);\n\t\n\t$effect(() => {\n\t\tconsole.log(`Effect running. Counter: ${counter}`);\n\t\t\n\t\t// details is only a dependency when showDetails is true\n\t\tif (showDetails) {\n\t\t\tconsole.log(`Details: ${details}`);\n\t\t}\n\t});\n</script>\n\n<button on:click={() => counter++}>Increment counter</button>\n<button on:click={() => showDetails = !showDetails}>\n\t{showDetails ? 'Hide' : 'Show'} details\n</button>\n<button on:click={() => details = 'Updated details ' + Date.now()}>\n\tUpdate details\n</button>\n```\n\nIn this example:\n1. The effect always depends on `counter`\n2. The effect depends on `details` only when `showDetails` is `true`\n3. When `showDetails` is `false`, changing `details` won't trigger the effect\n\n### Detailed Behavior Explanation\n\nWhen an effect runs:\n1. Svelte starts tracking accessed reactive values\n2. The effect function executes, potentially taking different code paths based on conditions\n3. Only the reactive values that were actually accessed during that execution become dependencies\n4. The next time the effect runs, the set of dependencies might change\n\n### Practical Example: Tab Component\n\n```svelte\n<script>\n\tlet activeTab = $state('info');\n\tlet infoData = $state({ title: 'Information', content: 'Some info content' });\n\tlet statsData = $state({ count: 42, trend: 'up' });\n\tlet settingsData = $state({ theme: 'dark', notifications: true });\n\t\n\t$effect(() => {\n\t\tconsole.log(`Active tab changed to: ${activeTab}`);\n\t\t\n\t\t// Only one of these blocks will execute, creating different dependencies\n\t\tif (activeTab === 'info') {\n\t\t\tconsole.log(`Info tab data: ${JSON.stringify(infoData)}`);\n\t\t\t// Effect depends on infoData\n\t\t} \n\t\telse if (activeTab === 'stats') {\n\t\t\tconsole.log(`Stats tab data: ${JSON.stringify(statsData)}`);\n\t\t\t// Effect depends on statsData\n\t\t}\n\t\telse if (activeTab === 'settings') {\n\t\t\tconsole.log(`Settings tab data: ${JSON.stringify(settingsData)}`);\n\t\t\t// Effect depends on settingsData\n\t\t}\n\t});\n</script>\n\n<div class=\"tabs\">\n\t<button \n\t\tclass:active={activeTab === 'info'} \n\t\ton:click={() => activeTab = 'info'}>\n\t\tInfo\n\t</button>\n\t<button \n\t\tclass:active={activeTab === 'stats'} \n\t\ton:click={() => activeTab = 'stats'}>\n\t\tStats\n\t</button>\n\t<button \n\t\tclass:active={activeTab === 'settings'} \n\t\ton:click={() => activeTab = 'settings'}>\n\t\tSettings\n\t</button>\n</div>\n\n<div class=\"tab-content\">\n\t{#if activeTab === 'info'}\n\t\t<h2>{infoData.title}</h2>\n\t\t<p>{infoData.content}</p>\n\t\t<button on:click={() => infoData.content = 'Updated content ' + Date.now()}>\n\t\t\tUpdate content\n\t\t</button>\n\t{:else if activeTab === 'stats'}\n\t\t<h2>Statistics</h2>\n\t\t<p>Count: {statsData.count}, Trend: {statsData.trend}</p>\n\t\t<button on:click={() => statsData.count += 1}>\n\t\t\tIncrement count\n\t\t</button>\n\t{:else if activeTab === 'settings'}\n\t\t<h2>Settings</h2>\n\t\t<label>\n\t\t\t<input \n\t\t\t\ttype=\"checkbox\" \n\t\t\t\tchecked={settingsData.notifications}\n\t\t\t\ton:change={() => settingsData.notifications = !settingsData.notifications}\n\t\t\t/>\n\t\t\tEnable notifications\n\t\t</label>\n\t\t<div>\n\t\t\tTheme: \n\t\t\t<select bind:value={settingsData.theme}>\n\t\t\t\t<option value=\"light\">Light</option>\n\t\t\t\t<option value=\"dark\">Dark</option>\n\t\t\t\t<option value=\"system\">System</option>\n\t\t\t</select>\n\t\t</div>\n\t{/if}\n</div>\n\n<style>\n\t.tabs {\n\t\tdisplay: flex;\n\t\tgap: 10px;\n\t\tmargin-bottom: 10px;\n\t}\n\t.active {\n\t\tbackground: #0066cc;\n\t\tcolor: white;\n\t}\n\t.tab-content {\n\t\tpadding: 15px;\n\t\tborder: 1px solid #ccc;\n\t\tborder-radius: 4px;\n\t}\n</style>\n```\n\nIn this tab component:\n1. When the active tab is 'info', the effect only depends on `activeTab` and `infoData`\n2. When the active tab is 'stats', the effect only depends on `activeTab` and `statsData`\n3. When the active tab is 'settings', the effect only depends on `activeTab` and `settingsData`\n\nThis means updates to data for inactive tabs won't cause unnecessary effect re-runs.\n\n### Implications and Benefits\n\n1. **Performance Optimization**: Effects only re-run when relevant data changes, reducing unnecessary executions.\n\n2. **Dynamic Dependency Tracking**: The set of dependencies can change over time based on application state.\n\n3. **Conditional Resource Management**: You can set up and tear down resources only when certain conditions are met.\n\n### Advanced Example: Conditional API Calls\n\n```svelte\n<script>\n\tlet isLoggedIn = $state(false);\n\tlet userId = $state(null);\n\tlet userProfile = $state(null);\n\tlet isLoading = $state(false);\n\tlet error = $state(null);\n\t\n\t// Simulate login/logout\n\tfunction login() {\n\t\tisLoggedIn = true;\n\t\tuserId = 'user_' + Math.floor(Math.random() * 1000);\n\t}\n\t\n\tfunction logout() {\n\t\tisLoggedIn = false;\n\t\tuserId = null;\n\t\tuserProfile = null;\n\t}\n\t\n\t// Effect with conditional API call\n\t$effect(async () => {\n\t\tconsole.log(`Auth state changed: logged in = ${isLoggedIn}, userId = ${userId}`);\n\t\t\n\t\t// Reset states\n\t\terror = null;\n\t\t\n\t\t// Only fetch profile when logged in and have userId\n\t\tif (isLoggedIn && userId) {\n\t\t\tisLoading = true;\n\t\t\t\n\t\t\ttry {\n\t\t\t\t// Simulate API call\n\t\t\t\tconsole.log(`Fetching profile for user ${userId}...`);\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n\t\t\t\t\n\t\t\t\t// This will be a dependency only when logged in\n\t\t\t\tuserProfile = {\n\t\t\t\t\tid: userId,\n\t\t\t\t\tname: `User ${userId.split('_')[1]}`,\n\t\t\t\t\temail: `user${userId.split('_')[1]}@example.com`,\n\t\t\t\t\tjoinDate: new Date().toISOString()\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tconsole.log(`Profile loaded for ${userId}`);\n\t\t\t} catch (err) {\n\t\t\t\terror = err.message || 'Failed to load profile';\n\t\t\t\tconsole.error('Error loading profile:', err);\n\t\t\t} finally {\n\t\t\t\tisLoading = false;\n\t\t\t}\n\t\t} else if (!isLoggedIn) {\n\t\t\t// Clear profile when logged out\n\t\t\tuserProfile = null;\n\t\t}\n\t});\n</script>\n\n<div>\n\t{#if isLoggedIn}\n\t\t<h2>Welcome, {userProfile?.name || 'User'}</h2>\n\t\t<button on:click={logout}>Logout</button>\n\t\t\n\t\t{#if isLoading}\n\t\t\t<p>Loading profile...</p>\n\t\t{:else if error}\n\t\t\t<p class=\"error\">{error}</p>\n\t\t{:else if userProfile}\n\t\t\t<div class=\"profile\">\n\t\t\t\t<p><strong>ID:</strong> {userProfile.id}</p>\n\t\t\t\t<p><strong>Email:</strong> {userProfile.email}</p>\n\t\t\t\t<p><strong>Joined:</strong> {new Date(userProfile.joinDate).toLocaleDateString()}</p>\n\t\t\t</div>\n\t\t{/if}\n\t{:else}\n\t\t<p>Please log in to see your profile</p>\n\t\t<button on:click={login}>Login</button>\n\t{/if}\n</div>\n\n<style>\n\t.error {\n\t\tcolor: red;\n\t}\n\t.profile {\n\t\tborder: 1px solid #ccc;\n\t\tpadding: 10px;\n\t\tborder-radius: 4px;\n\t\tmargin-top: 10px;\n\t}\n</style>\n```\n\nIn this example:\n1. The effect depends on `isLoggedIn` and `userId` in all cases\n2. It only depends on `userProfile` when `isLoggedIn` is `true` and `userId` is not `null`\n3. The API call only happens when the required conditions are met\n\n### Potential Pitfalls\n\n1. **Unexpected Behavior**: Developers might expect an effect to respond to changes in a value that was conditionally accessed but is currently not being accessed.\n\n2. **Stale Values**: If a condition changes and certain values are no longer accessed, the effect might be working with stale data when the condition changes back.\n\n3. **Complex Dependency Chains**: With multiple conditional dependencies, it can become difficult to reason about when an effect will re-run.\n\n### Best Practices\n\n1. **Keep Effects Focused**: Each effect should have a single responsibility to make dependencies clearer.\n\n2. **Document Conditional Dependencies**: Add comments explaining when certain dependencies will be tracked.\n\n3. **Consider Breaking Up Complex Effects**: Split complex effects with many conditional dependencies into multiple simpler effects.\n\n4. **Use `$derived` for Calculations**: For pure calculations based on state, prefer `$derived` over effects with conditional dependencies."}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"How does the lifecycle of an effect work in Svelte 5, and when exactly do effects run?","answer":"Understanding the lifecycle of effects in Svelte 5 is crucial for using them correctly. Let's break down when effects run, their execution order, and how they interact with the component lifecycle.\n\n### Effect Lifecycle Overview\n\n1. **Creation**: Effects are created during component initialization\n2. **First Run**: Effects run after the component is mounted to the DOM\n3. **Re-runs**: Effects re-run after state changes in a microtask\n4. **Teardown**: Effect cleanup functions run before re-runs and when the component is destroyed\n\n### Detailed Execution Timing\n\n#### Initial Run\n\n```svelte\n<script>\n\tconsole.log('1. Script initialization');\n\t\n\tlet mounted = $state(false);\n\t\n\t$effect(() => {\n\t\tconsole.log('4. Effect running');\n\t\tmounted = true;\n\t});\n\t\n\tconsole.log('2. After effect definition');\n</script>\n\n<div>\n\t{#if mounted}\n\t\t<p>5. Component is mounted</p>\n\t{:else}\n\t\t<p>3. Component is rendering</p>\n\t{/if}\n</div>\n```\n\nThe execution order will be:\n1. Script initialization\n2. After effect definition\n3. Component renders with \"Component is rendering\"\n4. Effect runs after DOM is mounted\n5. Component re-renders with \"Component is mounted\"\n\n#### Re-runs After State Changes\n\nEffects run in a microtask after state changes, which means:\n1. They run after synchronous code completes\n2. They run before the next animation frame\n3. Multiple state changes in the same synchronous code block will cause only one re-run\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet lastEffectRun = $state('Never');\n\t\n\t$effect(() => {\n\t\tconsole.log(`Effect running with count = ${count}`);\n\t\tlastEffectRun = new Date().toLocaleTimeString();\n\t});\n\t\n\tfunction incrementMultipleTimes() {\n\t\tconsole.log('Starting multiple updates');\n\t\tcount += 1;\n\t\tconsole.log('First update done');\n\t\tcount += 1;\n\t\tconsole.log('Second update done');\n\t\tcount += 1;\n\t\tconsole.log('Third update done');\n\t\t\n\t\t// The effect won't run until after this function completes\n\t\tconsole.log('Function complete, effect will run soon');\n\t}\n</script>\n\n<div>\n\t<p>Count: {count}</p>\n\t<p>Last effect run: {lastEffectRun}</p>\n\t<button on:click={() => count += 1}>Increment once</button>\n\t<button on:click={incrementMultipleTimes}>Increment three times</button>\n</div>\n```\n\nIn this example, clicking \"Increment three times\" will:\n1. Log all the console messages from the function\n2. Only then run the effect once with the final count value (not three separate times)\n\n### Batching and Update Order\n\nSvelte batches state updates and effect runs for performance. Here's the general order of operations:\n\n1. State is updated\n2. Microtask is scheduled\n3. Synchronous code finishes executing\n4. In the microtask:\n   a. Derived values are recalculated\n   b. DOM is updated\n   c. Effects run\n\nThis sequence ensures that effects always see the latest DOM state.\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tlet element;\n\t\n\t$effect(() => {\n\t\tconsole.log(`Effect running with count = ${count}, doubled = ${doubled}`);\n\t\tconsole.log(`DOM element text content: ${element?.textContent}`);\n\t});\n</script>\n\n<div>\n\t<p bind:this={element}>Count: {count}, Doubled: {doubled}</p>\n\t<button on:click={() => count += 1}>Increment</button>\n</div>\n```\n\n### Lifecycle with Async Operations\n\nEffects with async operations have special considerations:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet asyncResult = $state('No result');\n\t\n\t$effect(async () => {\n\t\tconsole.log(`Starting async effect with count = ${count}`);\n\t\t\n\t\t// Simulate API call\n\t\ttry {\n\t\t\tasyncResult = 'Loading...';\n\t\t\tconst result = await new Promise(resolve => \n\t\t\t\tsetTimeout(() => resolve(`Result for count ${count}`), 1000)\n\t\t\t);\n\t\t\tasyncResult = result;\n\t\t} catch (err) {\n\t\t\tasyncResult = `Error: ${err.message}`;\n\t\t}\n\t\t\n\t\tconsole.log(`Async effect completed for count = ${count}`);\n\t});\n</script>\n\n<div>\n\t<p>Count: {count}</p>\n\t<p>Async result: {asyncResult}</p>\n\t<button on:click={() => count += 1}>Increment</button>\n</div>\n```\n\nImportant notes about async effects:\n1. The async function runs immediately, but the awaited parts happen later\n2. If dependencies change while awaiting, the effect will re-run, potentially abandoning the previous async operation\n3. Only the synchronous part of the function tracks dependencies\n\n### Effect Cleanup Timing\n\nCleanup functions run at specific times:\n\n```svelte\n<script>\n\tlet visible = $state(true);\n\tlet count = $state(0);\n\t\n\tfunction ChildComponent() {\n\t\tconsole.log('Child component initializing');\n\t\t\n\t\t$effect(() => {\n\t\t\tconsole.log(`Child effect running with count = ${count}`);\n\t\t\t\n\t\t\treturn () => {\n\t\t\t\tconsole.log(`Child effect cleanup with count = ${count}`);\n\t\t\t};\n\t\t});\n\t\t\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\tconsole.log('Child component destroying');\n\t\t\t}\n\t\t};\n\t}\n\t\n\tlet child = visible ? ChildComponent() : null;\n\t\n\t$effect(() => {\n\t\tif (visible) {\n\t\t\tchild = ChildComponent();\n\t\t\t\n\t\t\treturn () => {\n\t\t\t\tconsole.log('Cleaning up child');\n\t\t\t\tchild.destroy();\n\t\t\t\tchild = null;\n\t\t\t};\n\t\t}\n\t});\n</script>\n\n<div>\n\t<p>Count: {count}</p>\n\t{#if visible}\n\t\t<div>Child component is visible</div>\n\t{:else}\n\t\t<div>Child component is hidden</div>\n\t{/if}\n\t<button on:click={() => count += 1}>Increment count</button>\n\t<button on:click={() => visible = !visible}>Toggle visibility</button>\n</div>\n```\n\nCleanup function execution order:\n1. **Before re-runs**: When dependencies change, the cleanup function runs immediately before the effect runs again\n2. **Before parent effect re-runs**: If a parent effect re-runs, child effect cleanup functions run first\n3. **Component destruction**: When a component is destroyed, all its effect cleanup functions run\n\n### Effect Execution Order\n\nWhen multiple effects exist, they run in the order they were defined:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\t\n\t$effect(() => {\n\t\tconsole.log('First effect runs first');\n\t});\n\t\n\t$effect(() => {\n\t\tconsole.log('Second effect runs second');\n\t});\n\t\n\tif (true) {\n\t\t$effect(() => {\n\t\t\tconsole.log('Third effect runs third');\n\t\t});\n\t}\n</script>\n```\n\n### `$effect.pre` vs `$effect` Timing\n\n`$effect.pre` runs before DOM updates, while `$effect` runs after:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet preEffectSaw = $state(null);\n\tlet normalEffectSaw = $state(null);\n\tlet element;\n\t\n\t$effect.pre(() => {\n\t\tpreEffectSaw = element?.textContent;\n\t\tconsole.log('Pre-effect saw:', preEffectSaw);\n\t});\n\t\n\t$effect(() => {\n\t\tnormalEffectSaw = element?.textContent;\n\t\tconsole.log('Normal effect saw:', normalEffectSaw);\n\t});\n</script>\n\n<div>\n\t<p bind:this={element}>Count: {count}</p>\n\t<button on:click={() => count += 1}>Increment</button>\n\t<p>Pre-effect saw: {preEffectSaw}</p>\n\t<p>Normal effect saw: {normalEffectSaw}</p>\n</div>\n```\n\nIn this example:\n- `$effect.pre` will see the DOM before the update (showing the previous count)\n- `$effect` will see the DOM after the update (showing the current count)\n\n### Complete Lifecycle Diagram\n\nHere's a complete representation of the effect lifecycle:\n\n1. **Component Initialization**\n   - Component script runs\n   - Effects are defined but don't run yet\n   - Initial render happens\n\n2. **Component Mounting**\n   - DOM is created\n   - Component is mounted\n   - Effects run for the first time (in a microtask)\n\n3. **State Updates**\n   - State changes\n   - Microtask is scheduled\n   - When microtask runs:\n     a. Derived values update\n     b. DOM updates are prepared\n     c. `$effect.pre` runs\n     d. DOM is updated\n     e. `$effect` runs\n\n4. **Component Destruction**\n   - Component is about to be removed\n   - Effect cleanup functions run\n   - Component is removed from DOM\n\n### Practical Example: Complete Lifecycle\n\n```svelte\n<script>\n\timport { onMount, onDestroy } from 'svelte';\n\t\n\tconsole.log('Component script starting');\n\t\n\tlet count = $state(0);\n\tlet mountTime = $state(null);\n\tlet preEffectRuns = $state(0);\n\tlet normalEffectRuns = $state(0);\n\t\n\tonMount(() => {\n\t\tconsole.log('onMount callback');\n\t\tmountTime = new Date().toLocaleTimeString();\n\t});\n\t\n\tonDestroy(() => {\n\t\tconsole.log('onDestroy callback');\n\t});\n\t\n\t$effect.pre(() => {\n\t\tconsole.log(`$effect.pre running, count = ${count}`);\n\t\tpreEffectRuns++;\n\t\t\n\t\treturn () => {\n\t\t\tconsole.log(`$effect.pre cleanup, count = ${count}`);\n\t\t};\n\t});\n\t\n\t$effect(() => {\n\t\tconsole.log(`$effect running, count = ${count}`);\n\t\tnormalEffectRuns++;\n\t\t\n\t\treturn () => {\n\t\t\tconsole.log(`$effect cleanup, count = ${count}`);\n\t\t};\n\t});\n\t\n\tconsole.log('Component script finishing');\n</script>\n\n<div>\n\t<p>Count: {count}</p>\n\t<p>Mount time: {mountTime || 'Not mounted yet'}</p>\n\t<p>Pre-effect runs: {preEffectRuns}</p>\n\t<p>Normal effect runs: {normalEffectRuns}</p>\n\t<button on:click={() => count += 1}>Increment</button>\n</div>\n```\n\nUnderstanding this lifecycle is essential for properly managing resources, avoiding memory leaks, and ensuring your effects run at the appropriate times."}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"How does dependency tracking work with object mutations in `$effect`?","answer":"Understanding how `$effect` tracks dependencies with objects is crucial, as it works differently than with primitive values. The key concept to grasp is that an effect only reruns when the object reference it reads changes, not when properties inside that object change.\n\n### Basic Object Tracking Behavior\n\n```svelte\n<script>\n\t// Object state\n\tlet user = $state({ name: 'Alice', age: 30 });\n\t\n\t// This effect depends on the user object reference\n\t$effect(() => {\n\t\tconsole.log(`User object: ${JSON.stringify(user)}`);\n\t});\n\t\n\t// This effect depends on user.name specifically\n\t$effect(() => {\n\t\tconsole.log(`User name: ${user.name}`);\n\t});\n\t\n\tfunction updateNameByMutation() {\n\t\t// This mutates the object but doesn't change the reference\n\t\tuser.name = 'Bob';\n\t}\n\t\n\tfunction updateNameByReplacement() {\n\t\t// This creates a new object reference\n\t\tuser = { ...user, name: 'Charlie' };\n\t}\n</script>\n\n<button on:click={updateNameByMutation}>\n\tUpdate name by mutation (only triggers second effect)\n</button>\n\n<button on:click={updateNameByReplacement}>\n\tUpdate name by replacement (triggers both effects)\n</button>\n```\n\nIn this example:\n1. The first effect depends on the `user` object reference\n2. The second effect depends on the `user.name` property\n3. When `updateNameByMutation` runs, only the second effect re-runs\n4. When `updateNameByReplacement` runs, both effects re-run\n\n### Deep Objects and Nested Properties\n\nThe same principle applies to deeply nested objects:\n\n```svelte\n<script>\n\tlet state = $state({\n\t\tuser: {\n\t\t\tprofile: {\n\t\t\t\tname: 'Alice',\n\t\t\t\tsettings: {\n\t\t\t\t\ttheme: 'dark',\n\t\t\t\t\tnotifications: true\n\t\t\t\t}\n\t\t\t},\n\t\t\tstats: {\n\t\t\t\tposts: 42,\n\t\t\t\tfollowers: 123\n\t\t\t}\n\t\t}\n\t});\n\t\n\t// Depends on the entire state object\n\t$effect(() => {\n\t\tconsole.log('State object changed');\n\t\tstate;  // Just reference it to track\n\t});\n\t\n\t// Depends on the user object\n\t$effect(() => {\n\t\tconsole.log('User object changed');\n\t\tstate.user;  // Just reference it to track\n\t});\n\t\n\t// Depends on the profile object\n\t$effect(() => {\n\t\tconsole.log('Profile object changed');\n\t\tstate.user.profile;  // Just reference it to track\n\t});\n\t\n\t// Depends on the name property\n\t$effect(() => {\n\t\tconsole.log(`Name changed to: ${state.user.profile.name}`);\n\t});\n\t\n\t// Depends on the theme property\n\t$effect(() => {\n\t\tconsole.log(`Theme changed to: ${state.user.profile.settings.theme}`);\n\t});\n\t\n\tfunction updateNameByMutation() {\n\t\tstate.user.profile.name = 'Bob';\n\t}\n\t\n\tfunction updateThemeByMutation() {\n\t\tstate.user.profile.settings.theme = 'light';\n\t}\n\t\n\tfunction updateProfileByReplacement() {\n\t\tstate.user.profile = {\n\t\t\t...state.user.profile,\n\t\t\tname: 'Charlie'\n\t\t};\n\t}\n\t\n\tfunction updateUserByReplacement() {\n\t\tstate.user = {\n\t\t\t...state.user,\n\t\t\tprofile: {\n\t\t\t\t...state.user.profile,\n\t\t\t\tname: 'Dave'\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction updateEntireState() {\n\t\tstate = {\n\t\t\t...state,\n\t\t\tuser: {\n\t\t\t\t...state.user,\n\t\t\t\tprofile: {\n\t\t\t\t\t...state.user.profile,\n\t\t\t\t\tname: 'Eve'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n</script>\n\n<div>\n\t<p>Current name: {state.user.profile.name}</p>\n\t<p>Current theme: {state.user.profile.settings.theme}</p>\n\t\n\t<div class=\"buttons\">\n\t\t<button on:click={updateNameByMutation}>Mutate name</button>\n\t\t<button on:click={updateThemeByMutation}>Mutate theme</button>\n\t\t<button on:click={updateProfileByReplacement}>Replace profile</button>\n\t\t<button on:click={updateUserByReplacement}>Replace user</button>\n\t\t<button on:click={updateEntireState}>Replace entire state</button>\n\t</div>\n</div>\n```\n\nIn this example:\n- `updateNameByMutation` triggers only the effect tracking `name`\n- `updateThemeByMutation` triggers only the effect tracking `theme`\n- `updateProfileByReplacement` triggers effects tracking `profile`, `name`, and `theme`\n- `updateUserByReplacement` triggers effects tracking `user`, `profile`, `name`, and `theme`\n- `updateEntireState` triggers all effects\n\n### Arrays and Collection Tracking\n\nArrays follow the same pattern - effects track the array reference, not its contents:\n\n```svelte\n<script>\n\tlet todos = $state([\n\t\t{ id: 1, text: 'Learn Svelte', done: false },\n\t\t{ id: 2, text: 'Build an app', done: false }\n\t]);\n\t\n\t// Tracks the todos array reference\n\t$effect(() => {\n\t\tconsole.log(`Todos array changed, length: ${todos.length}`);\n\t});\n\t\n\t// Tracks a specific todo item\n\t$effect(() => {\n\t\tif (todos[0]) {\n\t\t\tconsole.log(`First todo changed: ${JSON.stringify(todos[0])}`);\n\t\t}\n\t});\n\t\n\t// Tracks a specific property of a todo item\n\t$effect(() => {\n\t\tif (todos[0]) {\n\t\t\tconsole.log(`First todo done state: ${todos[0].done}`);\n\t\t}\n\t});\n\t\n\tfunction addTodo() {\n\t\t// Creates a new array reference\n\t\ttodos = [\n\t\t\t...todos,\n\t\t\t{ id: todos.length + 1, text: 'New todo', done: false }\n\t\t];\n\t}\n\t\n\tfunction updateFirstTodoByMutation() {\n\t\t// Mutates the object but keeps the same array reference\n\t\ttodos[0].done = !todos[0].done;\n\t}\n\t\n\tfunction updateFirstTodoByReplacement() {\n\t\t// Creates a new array with a new first object\n\t\ttodos = [\n\t\t\t{ ...todos[0], text: 'Updated todo' },\n\t\t\t...todos.slice(1)\n\t\t];\n\t}\n\t\n\tfunction removeTodo() {\n\t\t// Creates a new array without the last item\n\t\ttodos = todos.slice(0, -1);\n\t}\n</script>\n\n<div>\n\t<h2>Todos ({todos.length})</h2>\n\t<ul>\n\t\t{#each todos as todo}\n\t\t\t<li>\n\t\t\t\t<input\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tbind:checked={todo.done}\n\t\t\t\t/>\n\t\t\t\t<span class:done={todo.done}>{todo.text}</span>\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n\t\n\t<div class=\"buttons\">\n\t\t<button on:click={addTodo}>Add todo</button>\n\t\t<button on:click={updateFirstTodoByMutation}>Toggle first todo</button>\n\t\t<button on:click={updateFirstTodoByReplacement}>Update first todo text</button>\n\t\t<button on:click={removeTodo}>Remove last todo</button>\n\t</div>\n</div>\n\n<style>\n\t.done {\n\t\ttext-decoration: line-through;\n\t\topacity: 0.7;\n\t}\n</style>\n```\n\n### Implications for Immutable Update Patterns\n\nDue to this tracking behavior, it's often necessary to use immutable update patterns to ensure effects re-run appropriately:\n\n```svelte\n<script>"}
{"source":"docs/svelte/02-runes/05-$props.md","question":"What is the $props rune in Svelte 5 and how is it used to receive props in a component?","answer":"The `$props` rune in Svelte 5 is used to receive properties (props) passed from a parent component. Props are the inputs to a component, and the `$props` rune provides a way to access these inputs. \n\nYou can use the `$props` rune in two main ways:\n\n1. Capturing all props in a single object:\n```svelte\n<script>\n  let props = $props();\n</script>\n\n<p>this component is {props.adjective}</p>\n```\n\n2. Using destructuring (more common approach):\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n\n<p>this component is {adjective}</p>\n```\n\nThe parent component would pass these props like HTML attributes:\n```svelte\n<script>\n  import MyComponent from './MyComponent.svelte';\n</script>\n\n<MyComponent adjective=\"cool\" />\n```\n\nThe `$props` rune is one of Svelte 5's new reactive primitives that replaces the previous export-based approach to defining props in Svelte 4 and earlier."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"How can you provide fallback values for props in a Svelte 5 component?","answer":"In Svelte 5, you can provide fallback values for props using JavaScript's destructuring assignment syntax. Fallback values are used when the parent component does not provide a value for a specific prop.\n\nHere's how to define fallback values:\n\n```svelte\n<script>\n  // If the parent doesn't provide an 'adjective' prop, 'happy' will be used\n  let { adjective = 'happy' } = $props();\n</script>\n\n<p>this component is {adjective}</p>\n```\n\nThis is particularly useful for making props optional with sensible defaults. For example:\n\n```svelte\n<script>\n  let { \n    color = 'blue',\n    size = 'medium',\n    isActive = false,\n    items = []\n  } = $props();\n</script>\n```\n\nWhen a parent component uses this component without specifying these props, the fallback values will be used instead:\n\n```svelte\n<MyComponent /> <!-- Will use all the default values -->\n<MyComponent color=\"red\" /> <!-- Will use \"red\" for color and defaults for the rest -->\n```"}
{"source":"docs/svelte/02-runes/05-$props.md","question":"How can you rename props when destructuring from $props() in Svelte 5?","answer":"In Svelte 5, you can rename props when destructuring from `$props()` using the standard JavaScript destructuring assignment syntax with a colon. This is particularly useful when dealing with props that are JavaScript keywords or invalid identifiers.\n\nHere's how to rename props:\n\n```svelte\n<script>\n  // Rename the 'super' prop to 'trouper'\n  let { super: trouper = 'lights are gonna find me' } = $props();\n</script>\n\n<p>{trouper}</p>\n```\n\nThis technique is necessary when:\n1. A prop name is a JavaScript keyword (like `class`, `for`, `super`, etc.)\n2. A prop name contains characters that are invalid for JavaScript identifiers\n3. You want to use a different variable name internally than what's exposed externally\n\nAnother example with multiple renames:\n\n```svelte\n<script>\n  let { \n    'data-value': dataValue,\n    class: className,\n    for: htmlFor,\n    'aria-label': ariaLabel\n  } = $props();\n</script>\n\n<div class={className} for={htmlFor} aria-label={ariaLabel}>\n  {dataValue}\n</div>\n```\n\nWhen using the component, you'd still use the original prop names:\n```svelte\n<MyComponent super=\"amazing\" class=\"highlight\" for=\"username\" />\n```"}
{"source":"docs/svelte/02-runes/05-$props.md","question":"What is the rest property in $props() and how is it used?","answer":"The rest property in `$props()` is a way to collect all remaining props that weren't explicitly destructured. It uses the JavaScript rest parameter syntax (three dots `...` followed by a variable name) to gather any props that weren't specifically named in the destructuring pattern.\n\nHere's how to use the rest property:\n\n```svelte\n<script>\n  let { a, b, c, ...others } = $props();\n</script>\n```\n\nIn this example:\n- `a`, `b`, and `c` capture those specific props\n- `others` will be an object containing all other props passed to the component\n\nThis is particularly useful for:\n\n1. Creating wrapper components that need to forward most props to an underlying element or component:\n\n```svelte\n<script>\n  let { class: className, ...restProps } = $props();\n</script>\n\n<!-- Forward all other props to the button element -->\n<button class=\"btn {className}\" {...restProps}>\n  <slot></slot>\n</button>\n```\n\n2. When you need to separate known props from additional ones:\n\n```svelte\n<script>\n  let { title, description, ...attributes } = $props();\n</script>\n\n<div {...attributes}>\n  <h2>{title}</h2>\n  <p>{description}</p>\n</div>\n```\n\nThis allows component consumers to pass additional HTML attributes or props that will be applied to the root element without you having to explicitly define each one."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"Can you modify prop values inside a Svelte 5 component, and what are the implications?","answer":"In Svelte 5, you can temporarily reassign prop values inside a component, but there are important rules and implications to understand:\n\n1. **Temporary reassignment is allowed**: You can reassign a prop value locally within the child component, which will temporarily override the value passed from the parent.\n\n```svelte\n<!-- Child.svelte -->\n<script>\n  let { count } = $props();\n</script>\n\n<button onclick={() => (count += 1)}>\n  clicks (child): {count}\n</button>\n```\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n  let count = $state(0);\n</script>\n\n<button onclick={() => (count += 1)}>\n  clicks (parent): {count}\n</button>\n\n<Child {count} />\n```\n\nIn this example, the child can increment its own version of `count`, but if the parent updates its `count`, the child's value will be overridden.\n\n2. **Don't mutate props**: While reassignment is allowed, you should not mutate props unless they are declared with `$bindable`.\n\n3. **Regular objects**: If you pass a regular object as a prop, mutations to that object won't have any effect:\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n</script>\n\n<Child object={{ count: 0 }} />\n```\n\n```svelte\n<!-- Child.svelte -->\n<script>\n  let { object } = $props();\n</script>\n\n<button onclick={() => {\n  // This has no effect\n  object.count += 1;\n}}>\n  clicks: {object.count}\n</button>\n```\n\n4. **Reactive state proxies**: If you pass a reactive state proxy (created with `$state`), mutations will work but will trigger an `ownership_invalid_mutation` warning:\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n  let object = $state({count: 0});\n</script>\n\n<Child {object} />\n```\n\n```svelte\n<!-- Child.svelte -->\n<script>\n  let { object } = $props();\n</script>\n\n<button onclick={() => {\n  // Will update but with a warning\n  object.count += 1;\n}}>\n  clicks: {object.count}\n</button>\n```\n\n5. **Fallback values**: Fallback values for props not declared with `$bindable` are not transformed into reactive state proxies, so mutations won't cause updates:\n\n```svelte\n<script>\n  let { object = { count: 0 } } = $props();\n</script>\n\n<button onclick={() => {\n  // Has no effect if the fallback value is used\n  object.count += 1;\n}}>\n  clicks: {object.count}\n</button>\n```\n\nThe recommended pattern is to avoid mutating props. Instead:\n- Use callback props to communicate changes back to the parent\n- Use the `$bindable` rune if parent and child should share the same object"}
{"source":"docs/svelte/02-runes/05-$props.md","question":"How can you add type safety to props in Svelte 5 components?","answer":"Svelte 5 allows you to add type safety to your props by annotating your prop destructuring with type information. This can be done using TypeScript or JSDoc comments, depending on your preference.\n\n**Using TypeScript**:\n\nTo use TypeScript types, you need to set the `lang=\"ts\"` attribute on your script tag and then annotate your props:\n\n```svelte\n<script lang=\"ts\">\n  // Inline type annotation\n  let { adjective }: { adjective: string } = $props();\n</script>\n```\n\nYou can also define more complex types or interfaces separately:\n\n```svelte\n<script lang=\"ts\">\n  // Separate interface definition\n  interface Props {\n    name: string;\n    age: number;\n    isActive?: boolean; // Optional prop\n    items: string[];\n    onClick?: (id: string) => void;\n  }\n\n  let { name, age, isActive = false, items, onClick }: Props = $props();\n</script>\n```\n\n**Using JSDoc** (for JavaScript):\n\nIf you prefer not to use TypeScript, you can still add type information using JSDoc comments:\n\n```svelte\n<script>\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\nFor more complex types:\n\n```svelte\n<script>\n  /**\n   * @typedef {Object} Props\n   * @property {string} name - The user's name\n   * @property {number} age - The user's age\n   * @property {boolean} [isActive=false] - Whether the user is active\n   * @property {string[]} items - List of items\n   * @property {function(string): void} [onClick] - Click handler\n   */\n\n  /** @type {Props} */\n  let { name, age, isActive = false, items, onClick } = $props();\n</script>\n```\n\nAdding type information to your components has several benefits:\n1. It provides better IDE autocompletion and validation\n2. It helps other developers understand how to use your component\n3. It catches type-related errors at compile time\n4. It serves as documentation for the component's API\n\nIt's considered a best practice to add types to your components, especially for components that will be reused across your application or shared with others."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"What is $props.id() in Svelte 5 and when would you use it?","answer":"The `$props.id()` rune, introduced in Svelte 5.20.0, is a utility that generates a unique ID specific to the current component instance. This ID is guaranteed to be consistent between server and client during hydration, making it particularly useful for server-side rendering scenarios.\n\nThe primary use case for `$props.id()` is to create unique identifiers for elements that need to be connected through attributes like `for`, `aria-labelledby`, `aria-describedby`, and other similar attributes that require ID references.\n\nHere's how to use it:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n\n<form>\n  <label for=\"{uid}-firstname\">First Name: </label>\n  <input id=\"{uid}-firstname\" type=\"text\" />\n\n  <label for=\"{uid}-lastname\">Last Name: </label>\n  <input id=\"{uid}-lastname\" type=\"text\" />\n</form>\n```\n\nThis is particularly useful in several scenarios:\n\n1. **Accessibility**: Creating proper relationships between form elements and labels, or between elements and their descriptions/labels:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n\n<div>\n  <span id=\"{uid}-status\" class=\"visually-hidden\">\n    Current status: {status}\n  </span>\n  <button aria-describedby=\"{uid}-status\">\n    Submit\n  </button>\n</div>\n```\n\n2. **Multiple instances**: When you have multiple instances of the same component on a page, each needs unique IDs:\n\n```svelte\n<!-- This component can be used multiple times on a page -->\n<script>\n  const uid = $props.id();\n  let { label, value } = $props();\n</script>\n\n<div class=\"field\">\n  <label id=\"{uid}-label\" for=\"{uid}-input\">{label}</label>\n  <input \n    id=\"{uid}-input\" \n    aria-labelledby=\"{uid}-label\"\n    value={value} \n  />\n  <p id=\"{uid}-help\" class=\"help-text\">Please enter a valid {label}</p>\n</div>\n```\n\n3. **Complex components**: For components with multiple related elements like tabs, accordions, dropdown menus, etc.:\n\n```svelte\n<script>\n  const uid = $props.id();\n  let { tabs } = $props();\n  let activeTab = $state(0);\n</script>\n\n<div class=\"tabs\">\n  <div role=\"tablist\">\n    {#each tabs as tab, i}\n      <button \n        id=\"{uid}-tab-{i}\"\n        role=\"tab\"\n        aria-selected={activeTab === i}\n        aria-controls=\"{uid}-panel-{i}\"\n        onclick={() => activeTab = i}\n      >\n        {tab.title}\n      </button>\n    {/each}\n  </div>\n  \n  {#each tabs as tab, i}\n    <div \n      id=\"{uid}-panel-{i}\"\n      role=\"tabpanel\"\n      aria-labelledby=\"{uid}-tab-{i}\"\n      class:active={activeTab === i}\n    >\n      {tab.content}\n    </div>\n  {/each}\n</div>\n```\n\nUsing `$props.id()` is preferable to manually creating IDs or using libraries like `uuid` because it guarantees consistency during hydration, avoiding hydration mismatches that could occur with randomly generated IDs."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"How does prop reactivity work in Svelte 5, and how does it differ from Svelte 4?","answer":"Prop reactivity in Svelte 5 has been completely redesigned with the introduction of runes, offering a different approach compared to Svelte 4.\n\n**Svelte 5 Prop Reactivity:**\n\nIn Svelte 5, props are received using the `$props` rune:\n\n```svelte\n<script>\n  let { count } = $props();\n</script>\n\n<p>{count}</p>\n```\n\nKey characteristics of Svelte 5's prop reactivity:\n\n1. **Automatic reactivity**: References to props automatically update when the parent changes the prop value.\n\n2. **Local reassignment**: You can temporarily override a prop value locally, which won't affect the parent:\n\n```svelte\n<script>\n  let { count } = $props();\n</script>\n\n<button onclick={() => count += 1}>\n  Increment (local only): {count}\n</button>\n```\n\n3. **No mutation of objects**: While you can reassign props, you shouldn't mutate object props unless they're declared with `$bindable`.\n\n4. **Fine-grained reactivity**: Svelte 5 uses a fine-grained reactivity system where only the components that use a specific value get updated when that value changes.\n\n**Svelte 4 Prop Reactivity:**\n\nIn Svelte 4, props were defined using the `export` keyword:\n\n```svelte\n<script>\n  export let count;\n</script>\n\n<p>{count}</p>\n```\n\nKey differences from Svelte 5:\n\n1. **Export-based**: Props were defined by exporting variables.\n\n2. **Binding syntax**: Two-way binding used a different syntax with `bind:`:\n\n```svelte\n<!-- Parent in Svelte 4 -->\n<Child bind:count={parentCount} />\n```\n\n3. **Compiler-based reactivity**: Svelte 4 used a compile-time approach to reactivity with `$:` labels.\n\n**Major Differences:**\n\n1. **Syntax**: `$props()` rune vs `export let` declarations.\n\n2. **Two-way binding**: In Svelte 5, you use the `$bindable` rune instead of `bind:` directive.\n\n3. **Reactivity model**: Svelte 5 uses a runtime-based fine-grained reactivity system, while Svelte 4 used a compiler-based approach.\n\n4. **Temporary overrides**: Both versions allow local reassignment, but the reactivity model behind them differs.\n\n5. **Type safety**: Svelte 5 allows type annotations directly on the destructured props, which integrates better with TypeScript.\n\nHere's a side-by-side comparison:\n\n**Svelte 4:**\n```svelte\n<script>\n  export let name = 'world';\n  export let count = 0;\n  \n  function increment() {\n    count += 1; // Updates both local and parent if bound\n  }\n</script>\n\n<button on:click={increment}>\n  Clicks: {count}\n</button>\n<p>Hello {name}!</p>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let { name = 'world', count = 0 } = $props();\n  \n  function increment() {\n    count += 1; // Only updates locally\n  }\n</script>\n\n<button onclick={increment}>\n  Clicks: {count}\n</button>\n<p>Hello {name}!</p>\n```\n\nThe Svelte 5 approach with runes provides more explicit control over reactivity and better aligns with modern JavaScript patterns."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"What are the best practices for handling mutable props in Svelte 5?","answer":"Handling mutable props in Svelte 5 requires understanding some key principles to avoid common pitfalls. Here are the best practices:\n\n### 1. Avoid Mutating Props Directly\n\nThe general rule in Svelte 5 is: **don't mutate props**. Instead:\n\n- **Use reassignment** for primitive values:\n\n```svelte\n<script>\n  let { count } = $props();\n  \n  // Good: local reassignment\n  function increment() {\n    count += 1; // Creates a local override\n  }\n</script>\n```\n\n- **Create new objects** instead of mutating object props:\n\n```svelte\n<script>\n  let { user } = $props();\n  \n  // Good: creates a new object rather than mutating\n  function updateName(newName) {\n    user = { ...user, name: newName };\n  }\n  \n  // Bad: directly mutates the prop\n  function badUpdate(newName) {\n    user.name = newName; // Don't do this!\n  }\n</script>\n```\n\n### 2. Use Callback Props for Communication\n\nWhen a child component needs to communicate changes back to the parent, use callback props:\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n  let count = $state(0);\n  \n  function handleIncrement() {\n    count += 1;\n  }\n</script>\n\n<Child {count} onIncrement={handleIncrement} />\n```\n\n```svelte\n<!-- Child.svelte -->\n<script>\n  let { count, onIncrement } = $props();\n</script>\n\n<button onclick={onIncrement}>\n  Increment (parent's count): {count}\n</button>\n```\n\n### 3. Use $bindable for Two-Way Binding\n\nWhen you need true two-way binding between parent and child, use the `$bindable` rune:\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n  let user = $state({ name: 'John', age: 30 });\n</script>\n\n<Child bind:user />\n```\n\n```svelte\n<!-- Child.svelte -->\n<script>\n  let user = $bindable();\n  \n  // Now mutations are allowed and will update the parent\n  function incrementAge() {\n    user.age += 1; // This is OK with $bindable\n  }\n</script>\n\n<button onclick={incrementAge}>\n  Happy Birthday to {user.name}! Current age: {user.age}\n</button>\n```\n\n### 4. Be Careful with Fallback Values\n\nFallback values of props are not automatically made reactive, so mutations won't cause updates:\n\n```svelte\n<script>\n  let { items = [] } = $props();\n  \n  function addItem(item) {\n    items.push(item); // Won't cause updates if using the fallback value\n  }\n  \n  // Better approach\n  function addItem(item) {\n    items = [...items, item];\n  }\n</script>\n```\n\n### 5. Create Derived State\n\nIf you need to transform props, create derived state instead of mutating:\n\n```svelte\n<script>\n  let { users } = $props();\n  \n  // Derive a new array instead of filtering in place\n  $effect(() => {\n    activeUsers = users.filter(user => user.active);\n  });\n</script>\n```\n\n### 6. Understand Warning Messages\n\nPay attention to the `ownership_invalid_mutation` warning, which indicates you're mutating state that doesn't belong to your component.\n\n### 7. Immutable Data Patterns\n\nAdopt immutable data patterns for cleaner code:\n\n```svelte\n<script>\n  let { items } = $props();\n  \n  // Immutable operations\n  function addItem(newItem) {\n    items = [...items, newItem];\n  }\n  \n  function removeItem(id) {\n    items = items.filter(item => item.id !== id);\n  }\n  \n  function updateItem(id, updates) {\n    items = items.map(item => \n      item.id === id ? { ...item, ...updates } : item\n    );\n  }\n</script>\n```\n\nBy following these best practices, you'll avoid common issues with mutable props and create more predictable, maintainable Svelte components."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"How does temporary prop override work in Svelte 5, and when would you use it?","answer":"Temporary prop override in Svelte 5 allows a child component to locally change the value of a prop without affecting the parent component. This creates a local \"shadow\" of the prop that exists only within the child component.\n\n### How it works:\n\nWhen you reassign a prop in a child component, Svelte 5 creates a local copy of that value. The component will use this local value until the parent explicitly updates the prop, at which point the local override is discarded and the new parent value is used.\n\n```svelte\n<!-- Child.svelte -->\n<script>\n  let { count } = $props();\n</script>\n\n<button onclick={() => (count += 1)}>\n  Child count: {count}\n</button>\n```\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n  let count = $state(0);\n</script>\n\n<button onclick={() => (count += 1)}>\n  Parent count: {count}\n</button>\n\n<Child {count} />\n```\n\nIn this example:\n1. Initially, both buttons show the same count (0)\n2. If you click the child button, only the child's display updates\n3. If you then click the parent button, both displays update to the parent's new value (discarding the child's local value)\n\n### When to use temporary prop overrides:\n\n1. **Ephemeral UI state**: For temporary UI states that don't need to persist:\n\n```svelte\n<script>\n  let { isExpanded = false } = $props();\n</script>\n\n<div>\n  <button onclick={() => isExpanded = !isExpanded}>\n    {isExpanded ? 'Collapse' : 'Expand'}\n  </button>\n  \n  {#if isExpanded}\n    <div class=\"content\">\n      <slot></slot>\n    </div>\n  {/if}\n</div>\n```\n\n2. **Form inputs with local edits**:\n\n```svelte\n<script>\n  let { value = '', onSubmit } = $props();\n  \n  function handleSubmit() {\n    onSubmit(value);\n  }\n</script>\n\n<form on:submit|preventDefault={handleSubmit}>\n  <!-- User can edit locally without affecting parent until submit -->\n  <input bind:value />\n  <button type=\"submit\">Submit</button>\n</form>\n```\n\n3. **Optimistic UI updates**:\n\n```svelte\n<script>\n  let { todos } = $props();\n  let { addTodo, removeTodo } = $props();\n  \n  function handleAddTodo(text) {\n    // Optimistically add to local list\n    const newTodo = { id: Date.now(), text, completed: false };\n    todos = [...todos, newTodo];\n    \n    // Notify parent (which may eventually update the real list)\n    addTodo(text);\n  }\n</script>\n```\n\n4. **Filtering or sorting data locally**:\n\n```svelte\n<script>\n  let { items } = $props();\n  let sortOrder = $state('asc');\n  \n  $effect(() => {\n    // Sort items locally without affecting parent\n    if (sortOrder === 'asc') {\n      items = [...items].sort((a, b) => a.name.localeCompare(b.name));\n    } else {\n      items = [...items].sort((a, b) => b.name.localeCompare(a.name));\n    }\n  });\n</script>\n\n<button onclick={() => sortOrder = sortOrder === 'asc' ? 'desc' : 'asc'}>\n  Toggle Sort ({sortOrder})\n</button>\n\n<ul>\n  {#each items as item}\n    <li>{item.name}</li>\n  {/each}\n</ul>\n```\n\n### Important considerations:\n\n1. **Temporary nature**: Remember that parent updates will override local changes\n2. **Not for persistent state**: Don't use for state that needs to persist\n3. **Not for object mutations**: Only reassignment works reliably; don't mutate objects\n4. **Callbacks for important changes**: Use callback props to communicate important changes back to the parent\n\n### Example with synchronization:\n\n```svelte\n<!-- SearchComponent.svelte -->\n<script>\n  let { initialQuery = '', onSearch } = $props();\n  let query = initialQuery; // Local copy for editing\n  \n  // Sync with parent changes\n  $effect(() => {\n    query = initialQuery;\n  });\n  \n  function handleSearch() {\n    onSearch(query);\n  }\n</script>\n\n<div>\n  <input \n    bind:value={query} \n    placeholder=\"Search...\" \n    on:input={() => {\n      if (query === '') onSearch('');\n    }}\n  />\n  <button onclick={handleSearch}>Search</button>\n</div>\n```\n\nTemporary prop overrides provide a clean way to handle local state modifications without complex state management, but should be used thoughtfully with an understanding of their temporary nature."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"What are the limitations of using $props() in Svelte 5, and how can they be overcome?","answer":"While the `$props()` rune in Svelte 5 provides a powerful way to handle component inputs, it does have some limitations. Understanding these limitations and their workarounds is important for effective Svelte 5 development.\n\n### Limitations and Solutions:\n\n#### 1. No Direct Two-Way Binding\n\n**Limitation**: Unlike Svelte 4's `export let` with `bind:`, `$props()` doesn't automatically support two-way binding.\n\n**Solution**: Use the `$bindable` rune for two-way binding:\n\n```svelte\n<!-- Child.svelte -->\n<script>\n  let user = $bindable();\n  \n  function updateName(newName) {\n    user.name = newName; // This updates the parent's value\n  }\n</script>\n\n<!-- Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n  let user = $state({ name: 'John', age: 30 });\n</script>\n\n<Child bind:user />\n```\n\n#### 2. Prop Mutations Don't Work as Expected\n\n**Limitation**: Mutating object props doesn't reliably trigger updates and can cause warnings.\n\n**Solution**: Use immutable update patterns or `$bindable`:\n\n```svelte\n<!-- Immutable update pattern -->\n<script>\n  let { items } = $props();\n  \n  function addItem(item) {\n    items = [...items, item]; // Create a new array instead of mutating\n  }\n</script>\n```\n\n#### 3. No Default Prop Spread Operator\n\n**Limitation**: Unlike some frameworks, there's no built-in shorthand to spread all props to a child element.\n\n**Solution**: Use the rest pattern with destructuring:\n\n```svelte\n<script>\n  let { class: className, ...restProps } = $props();\n</script>\n\n<div class=\"container {className}\" {...restProps}>\n  <slot></slot>\n</div>\n```\n\n#### 4. Type Inference Limitations\n\n**Limitation**: TypeScript might not always perfectly infer complex prop types.\n\n**Solution**: Explicitly define prop types:\n\n```svelte\n<script lang=\"ts\">\n  interface Props {\n    items: Array<{id: number, name: string}>;\n    selected?: number;\n    onSelect: (id: number) => void;\n  }\n  \n  let { items, selected, onSelect }: Props = $props();\n</script>\n```\n\n#### 5. No Direct Access to Component Instance\n\n**Limitation**: Unlike some frameworks, there's no built-in way to get a reference to a component instance through props.\n\n**Solution**: Use callback props and actions:\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n  let childApi;\n  \n  function handleChildMount(api) {\n    childApi = api;\n  }\n</script>\n\n<Child onMount={handleChildMount} />\n<button onclick={() => childApi?.reset()}>Reset Child</button>\n\n<!-- Child.svelte -->\n<script>\n  let { onMount } = $props();\n  let count = $state(0);\n  \n  function reset() {\n    count = 0;\n  }\n  \n  // Expose API to parent\n  $effect(() => {\n    if (onMount) onMount({ reset });\n  });\n</script>\n\n<button onclick={() => count++}>Count: {count}</button>\n```\n\n#### 6. No Automatic Prop Validation\n\n**Limitation**: Svelte doesn't include built-in prop validation like some other frameworks.\n\n**Solution**: Implement validation manually with TypeScript or runtime checks:\n\n```svelte\n<script lang=\"ts\">\n  interface Props {\n    count: number;\n    name: string;\n  }\n  \n  let props = $props<Props>();\n  \n  // Runtime validation\n  $effect(() => {\n    if (typeof props.count !== 'number') {\n      console.error('Expected count to be a number');\n    }\n    if (!props.name) {\n      console.error('Name is required');\n    }\n  });\n</script>\n```\n\n#### 7. Fallback Values Aren't Reactive\n\n**Limitation**: Fallback values for props aren't automatically made reactive.\n\n**Solution**: Use `$state` for local state derived from props:\n\n```svelte\n<script>\n  let { items = [] } = $props();\n  let localItems = $state([]);\n  \n  // Initialize and sync with props\n  $effect(() => {\n    localItems = [...items];\n  });\n  \n  function addItem(item) {\n    localItems = [...localItems, item]; // This will be reactive\n  }\n</script>\n```\n\n#### 8. No Direct Prop Transformation\n\n**Limitation**: There's no built-in way to transform props before using them.\n\n**Solution**: Use `$derived` or `$effect` to create transformed values:\n\n```svelte\n<script>\n  let { firstName, lastName } = $props();\n  \n  let fullName = $derived(`${firstName} ${lastName}`);\n  let initials = $derived(`${firstName[0]}${lastName[0]}`);\n</script>\n\n<div>\n  <h1>{fullName}</h1>\n  <span class=\"initials\">{initials}</span>\n</div>\n```\n\nBy understanding these limitations and their workarounds, you can effectively use `$props()` in Svelte 5 while avoiding common pitfalls."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"How do you handle complex prop types with the $props rune in Svelte 5?","answer":"Handling complex prop types with the `$props` rune in Svelte 5 requires careful type definitions and proper destructuring. Here's a comprehensive guide to working with various complex prop types:\n\n### 1. Object Types\n\nFor objects with specific structures:\n\n```svelte\n<script lang=\"ts\">\n  // Define the object structure\n  interface User {\n    id: number;\n    name: string;\n    email: string;\n    preferences: {\n      theme: 'light' | 'dark';\n      notifications: boolean;\n    };\n  }\n  \n  // Use it in props\n  let { user }: { user: User } = $props();\n</script>\n\n<div>\n  <h2>{user.name}</h2>\n  <p>{user.email}</p>\n  <div class=\"theme-{user.preferences.theme}\">\n    Notifications: {user.preferences.notifications ? 'On' : 'Off'}\n  </div>\n</div>\n```\n\n### 2. Array Types\n\nFor arrays of primitive or complex types:\n\n```svelte\n<script lang=\"ts\">\n  interface Item {\n    id: number;\n    name: string;\n    price: number;\n  }\n  \n  let { \n    stringArray = [],\n    numberArray = [],\n    items = []\n  }: { \n    stringArray?: string[],\n    numberArray?: number[],\n    items?: Item[]\n  } = $props();\n</script>\n\n<div>\n  <!-- String array -->\n  <ul>\n    {#each stringArray as str}\n      <li>{str}</li>\n    {/each}\n  </ul>\n  \n  <!-- Complex item array -->\n  <div class=\"items\">\n    {#each items as item}\n      <div class=\"item\">\n        <h3>{item.name}</h3>\n        <p>${item.price.toFixed(2)}</p>\n      </div>\n    {/each}\n  </div>\n</div>\n```\n\n### 3. Function Types\n\nFor callback props and event handlers:\n\n```svelte\n<script lang=\"ts\">\n  interface Props {\n    onSelect: (id: number) => void;\n    onSubmit: (data: { name: string, email: string }) => Promise<boolean>;\n    formatter?: (value: number) => string;\n  }\n  \n  let { \n    onSelect, \n    onSubmit,\n    formatter = (n) => n.toString()\n  }: Props = $props();\n  \n  async function handleSubmit(event) {\n    event.preventDefault();\n    const data = { name: 'John', email: 'john@example.com' };\n    const success = await onSubmit(data);\n    if (success) {\n      // Handle success\n    }\n  }\n</script>\n\n<form on:submit={handleSubmit}>\n  <div class=\"items\">\n    {#each items as item}\n      <button \n        type=\"button\" \n        onclick={() => onSelect(item.id)}\n      >\n        {item.name} - {formatter(item.price)}\n      </button>\n    {/each}\n  </div>\n  <button type=\"submit\">Submit</button>\n</form>\n```\n\n### 4. Union Types\n\nFor props that can be one of several types:\n\n```svelte\n<script lang=\"ts\">\n  type Status = 'idle' | 'loading' | 'success' | 'error';\n  type Value = string | number | null;\n  \n  interface Props {\n    status: Status;\n    value: Value;\n    content: string | { html: string } | (() => string);\n  }\n  \n  let { status, value, content }: Props = $props();\n  \n  // Helper function to render content\n  function renderContent() {\n    if (typeof content === 'string') {\n      return content;\n    } else if (typeof content === 'function') {\n      return content();\n    } else {\n      return content.html;\n    }\n  }\n</script>\n\n<div class=\"component status-{status}\">\n  <p>Value: {value ?? 'None'}</p>\n  \n  <div class=\"content\">\n    {#if typeof content === 'string'}\n      {content}\n    {:else if typeof content === 'function'}\n      {content()}\n    {:else}\n      {@html content.html}\n    {/if}\n  </div>\n</div>\n```\n\n### 5. Generic Types\n\nFor reusable components that work with different data types:\n\n```svelte\n<script lang=\"ts\">\n  // Define a generic interface\n  interface Props<T> {\n    items: T[];\n    selectedId: string | number | null;\n    renderItem: (item: T) => string;\n    onSelect: (item: T) => void;\n  }\n  \n  // Use it with a specific type\n  let { \n    items, \n    selectedId = null,\n    renderItem,\n    onSelect\n  }: Props<{ id: number; name: string }> = $props();\n</script>\n\n<ul class=\"list\">\n  {#each items as item}\n    <li \n      class:selected={item.id === selectedId}\n      onclick={() => onSelect(item)}\n    >\n      {renderItem(item)}\n    </li>\n  {/each}\n</ul>\n```\n\n### 6. Record Types\n\nFor objects with dynamic keys:\n\n```svelte\n<script lang=\"ts\">\n  interface Props {\n    attributes: Record<string, string>;\n    data: Record<string, any>;\n    metadata?: Record<string, number | string | boolean>;\n  }\n  \n  let { attributes = {}, data = {}, metadata = {} }: Props = $props();\n</script>\n\n<div {...attributes}>\n  {#each Object.entries(data) as [key, value]}\n    <div class=\"data-item\">\n      <strong>{key}:</strong> {JSON.stringify(value)}\n    </div>\n  {/each}\n  \n  {#if Object.keys(metadata).length > 0}\n    <div class=\"metadata\">\n      {#each Object.entries(metadata) as [key, value]}\n        <span class=\"meta-tag\">{key}: {value}</span>\n      {/each}\n    </div>\n  {/if}\n</div>\n```\n\n### 7. Nested Component Props\n\nFor components that receive complex nested data:\n\n```svelte\n<script lang=\"ts\">\n  interface MenuItem {\n    id: string;\n    label: string;\n    icon?: string;\n    disabled?: boolean;\n    children?: MenuItem[];\n  }\n  \n  interface Props {\n    menu: MenuItem[];\n    config: {\n      expandedByDefault: boolean;\n      maxDepth: number;\n      theme: {\n        color: string;\n        fontSize: string;\n      };\n    };\n  }\n  \n  let { menu = [], config }: Props = $props();\n  \n  // Default values for nested properties\n  $effect(() => {\n    config = {\n      expandedByDefault: config?.expandedByDefault ?? false,\n      maxDepth: config?.maxDepth ?? 3,\n      theme: {\n        color: config?.theme?.color ?? 'blue',\n        fontSize: config?.theme?.fontSize ?? '16px'\n      }\n    };\n  });\n</script>\n\n<nav class=\"menu\" style=\"--color: {config.theme.color}; --font-size: {config.theme.fontSize}\">\n  <!-- Recursive menu rendering would go here -->\n</nav>\n```\n\n### 8. Using JSDoc for Complex Types\n\nIf you prefer using JavaScript with JSDoc:\n\n```svelte\n<script>\n  /**\n   * @typedef {Object} User\n   * @property {number} id - User ID\n   * @property {string} name - User's full name\n   * @property {string} email - User's email address\n   * @property {Object} preferences - User preferences\n   * @property {'light'|'dark'} preferences.theme - UI theme preference\n   * @property {boolean} preferences.notifications - Notification settings\n   */\n\n  /**\n   * @typedef {Object} Props\n   * @property {User} user - The user object\n   * @property {Function} onUpdate - Callback when user is updated\n   */\n\n  /** @type {Props} */\n  let { user, onUpdate } = $props();\n</script>\n```\n\nBy using these techniques, you can handle even the most complex prop types in Svelte 5 components while maintaining type safety and clear component interfaces."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"How do you handle conditional or optional props in Svelte 5?","answer":"Handling conditional or optional props in Svelte 5 involves several techniques to ensure your components are flexible and robust. Here's a comprehensive guide to working with optional props:\n\n### 1. Using Default Values\n\nThe most straightforward way to handle optional props is to provide default values during destructuring:\n\n```svelte\n<script>\n  let { \n    title = 'Default Title',\n    description = '',\n    isActive = false,\n    count = 0,\n    items = []\n  } = $props();\n</script>\n\n<div>\n  <h1>{title}</h1>\n  {#if description}\n    <p>{description}</p>\n  {/if}\n  <span class:active={isActive}>Status: {isActive ? 'Active' : 'Inactive'}</span>\n  <div>Count: {count}</div>\n  <ul>\n    {#each items as item}\n      <li>{item}</li>\n    {/each}\n  </ul>\n</div>\n```\n\n### 2. Type Annotations for Optional Props\n\nIn TypeScript, you can explicitly mark props as optional using the `?` notation:\n\n```svelte\n<script lang=\"ts\">\n  interface Props {\n    title: string;           // Required\n    description?: string;    // Optional\n    isActive?: boolean;      // Optional\n    count?: number;          // Optional\n    items?: string[];        // Optional\n  }\n  \n  let { \n    title,\n    description = '',\n    isActive = false,\n    count = 0,\n    items = []\n  }: Props = $props();\n</script>\n```\n\n### 3. Conditional Rendering Based on Prop Presence\n\nYou can conditionally render parts of your component based on whether optional props are provided:\n\n```svelte\n<script>\n  let props = $props();\n  \n  // Check if props exist without destructuring\n  const hasImage = 'imageUrl' in props;\n  const hasFooter = 'footerContent' in props;\n</script>\n\n<div class=\"card\">\n  <div class=\"card-header\">\n    <h2>{props.title}</h2>\n  </div>\n  \n  {#if hasImage}\n    <img src={props.imageUrl} alt={props.imageAlt || props.title} />\n  {/if}\n  \n  <div class=\"card-body\">\n    <p>{props.description || 'No description provided'}</p>\n  </div>\n  \n  {#if hasFooter}\n    <div class=\"card-footer\">\n      {props.footerContent}\n    </div>\n  {/if}\n</div>\n```\n\n### 4. Handling Function Props\n\nFor callback props, check if they exist before calling them:\n\n```svelte\n<script>\n  let { \n    onClick,\n    onHover,\n    onSubmit \n  } = $props();\n  \n  function handleClick(event) {\n    // Only call if the prop was provided\n    if (onClick) onClick(event);\n  }\n  \n  function handleSubmit(data) {\n    // Provide a default behavior if no callback\n    if (onSubmit) {\n      return onSubmit(data);\n    } else {\n      console.log('Form submitted:', data);\n      return true;\n    }\n  }\n</script>\n\n<button \n  onclick={handleClick}\n  onmouseover={onHover ? (e) => onHover(e) : undefined}\n>\n  Click me\n</button>\n```\n\n### 5. Destructuring with Rest for Unknown Props\n\nWhen you want to accept additional props beyond the ones you specifically handle:\n\n```svelte\n<script>\n  let { \n    className = '',\n    style = '',\n    id,\n    ...restProps \n  } = $props();\n</script>\n\n<div \n  class={className}\n  style={style}\n  id={id}\n  {...restProps}\n>\n  <slot></slot>\n</div>\n```\n\n### 6. Conditional Prop Transformation\n\nSometimes you need to transform props conditionally:\n\n```svelte\n<script>\n  let { \n    date,\n    format = 'short'\n  } = $props();\n  \n  let formattedDate = $derived(() => {\n    if (!date) return 'No date provided';\n    \n    try {\n      const dateObj = new Date(date);\n      \n      if (format === 'short') {\n        return dateObj.toLocaleDateString();\n      } else if (format === 'long') {\n        return dateObj.toLocaleDateString(undefined, {\n          weekday: 'long',\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric'\n        });\n      } else {\n        return dateObj.toISOString();\n      }\n    } catch (e) {\n      return 'Invalid date';\n    }\n  });\n</script>\n\n<div class=\"date-display\">{formattedDate}</div>\n```\n\n### 7. Object Props with Optional Properties\n\nWhen dealing with complex object props that have optional properties:\n\n```svelte\n<script lang=\"ts\">\n  interface User {\n    id: number;\n    name: string;\n    email?: string;\n    avatar?: string;\n    role?: 'admin' | 'user' | 'guest';\n  }\n  \n  let { user }: { user: User } = $props();\n  \n  // Provide defaults for nested optional properties\n  let displayName = $derived(user.name);\n  let avatarUrl = $derived(user.avatar || '/default-avatar.png');\n  let userRole = $derived(user.role || 'guest');\n</script>\n\n<div class=\"user-card\">\n  <img src={avatarUrl} alt={displayName} />\n  <h3>{displayName}</h3>\n  {#if user.email}\n    <p>{user.email}</p>\n  {/if}\n  <span class=\"badge role-{userRole}\">{userRole}</span>\n</div>\n```\n\n### 8. Advanced: Prop Validation with Default Fallbacks\n\nFor more complex validation with fallbacks:\n\n```svelte\n<script>\n  let props = $props();\n  \n  // Validate and provide defaults\n  let theme = $derived(() => {\n    const validThemes = ['light', 'dark', 'system'];\n    return validThemes.includes(props.theme) ? props.theme : 'system';\n  });\n  \n  let size = $derived(() => {\n    const validSizes = ['sm', 'md', 'lg', 'xl'];\n    return validSizes.includes(props.size) ? props.size : 'md';\n  });\n  \n  let count = $derived(() => {\n    const num = parseInt(props.count);\n    return !isNaN(num) ? num : 0;\n  });\n</script>\n\n<div class=\"component theme-{theme} size-{size}\">\n  Count: {count}\n</div>\n```\n\n### 9. Using $effect for Derived Optional Props\n\nWhen you need more complex logic for optional props:\n\n```svelte\n<script>\n  let { \n    items = [],\n    filter,\n    sortBy,\n    sortDirection = 'asc'\n  } = $props();\n  \n  let processedItems = $state([]);\n  \n  $effect(() => {\n    // Start with the original items\n    let result = [...items];\n    \n    // Apply filter if provided\n    if (filter) {\n      result = result.filter(item => \n        item.name.includes(filter) || \n        item.description.includes(filter)\n      );\n    }\n    \n    // Apply sorting if sortBy is provided\n    if (sortBy) {\n      result = result.sort((a, b) => {\n        const valueA = a[sortBy];\n        const valueB = b[sortBy];\n        \n        if (sortDirection === 'asc') {\n          return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;\n        } else {\n          return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;\n        }\n      });\n    }\n    \n    processedItems = result;\n  });\n</script>\n\n<div class=\"items-list\">\n  {#if processedItems.length === 0}\n    <p>No items found</p>\n  {:else}\n    <ul>\n      {#each processedItems as item}\n        <li>{item.name}</li>\n      {/each}\n    </ul>\n  {/if}\n</div>\n```\n\nThese techniques will help you create flexible components that gracefully handle optional props while maintaining clear interfaces and robust behavior."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"How can you effectively use the rest property with $props() in Svelte 5 components?","answer":"The rest property with `$props()` is a powerful feature in Svelte 5 that allows you to collect all remaining props not explicitly destructured. This enables more flexible and reusable components. Here's a comprehensive guide on effectively using the rest property:\n\n### Basic Usage of Rest Properties\n\nThe basic syntax uses the spread operator (`...`) followed by a variable name during destructuring:\n\n```svelte\n<script>\n  let { id, class: className, ...restProps } = $props();\n</script>\n\n<div id={id} class={className} {...restProps}>\n  <slot></slot>\n</div>\n```\n\nIn this example, `id` and `class` are extracted explicitly, while all other props are collected in `restProps`.\n\n### 1. Creating Wrapper Components\n\nOne of the most common uses is creating wrapper components that pass along attributes to underlying elements:\n\n```svelte\n<!-- Button.svelte - A styled button wrapper -->\n<script>\n  let { \n    variant = 'primary',\n    size = 'medium',\n    disabled = false,\n    ...restProps \n  } = $props();\n  \n  // Map variant and size to CSS classes\n  const variantClass = {\n    primary: 'btn-primary',\n    secondary: 'btn-secondary',\n    danger: 'btn-danger'\n  }[variant] || 'btn-primary';\n  \n  const sizeClass = {\n    small: 'btn-sm',\n    medium: 'btn-md',\n    large: 'btn-lg'\n  }[size] || 'btn-md';\n</script>\n\n<button \n  class=\"btn {variantClass} {sizeClass} {restProps.class || ''}\"\n  {disabled}\n  {...restProps}\n>\n  <slot></slot>\n</button>\n```\n\nUsage:\n```svelte\n<Button \n  variant=\"danger\"\n  size=\"large\"\n  onclick={() => alert('Clicked!')}\n  aria-label=\"Delete item\"\n  data-testid=\"delete-button\"\n>\n  Delete\n</Button>\n```\n\n### 2. Forwarding HTML Attributes\n\nRest properties are excellent for forwarding standard HTML attributes:\n\n```svelte\n<!-- Input.svelte -->\n<script>\n  let { \n    label,\n    error,\n    id = `input-${Math.random().toString(36).substring(2, 9)}`,\n    ...inputProps \n  } = $props();\n</script>\n\n<div class=\"form-field\">\n  <label for={id}>{label}</label>\n  \n  <input \n    {id}\n    class=\"input {error ? 'input-error' : ''} {inputProps.class || ''}\"\n    {...inputProps}\n  />\n  \n  {#if error}\n    <div class=\"error-message\">{error}</div>\n  {/if}\n</div>\n```\n\n### 3. Selectively Filtering Props\n\nSometimes you want to filter which props get passed along:\n\n```svelte\n<script>\n  let props = $props();\n  \n  // Extract known props\n  const { \n    width, \n    height, \n    src, \n    alt,\n    lazy = true,\n    ...otherProps \n  } = props;\n  \n  // Filter out specific props you don't want to forward\n  const { onLoad, onError, ...attributeProps } = otherProps;\n  \n  // Handle events separately\n  function handleLoad(event) {\n    console.log('Image loaded');\n    if (onLoad) onLoad(event);\n  }\n</script>\n\n{#if lazy}\n  <img \n    {src} \n    {alt} \n    {width} \n    {height}\n    loading=\"lazy\"\n    on:load={handleLoad}\n    on:error={onError}\n    {...attributeProps}\n  />\n{:else}\n  <img \n    {src} \n    {alt} \n    {width} \n    {height}\n    on:load={handleLoad}\n    on:error={onError}\n    {...attributeProps}\n  />\n{/if}\n```\n\n### 4. Building Compound Components\n\nFor complex compound components where props need to be distributed:\n\n```svelte\n<!-- Tabs.svelte -->\n<script>\n  let { \n    activeTab = 0,\n    orientation = 'horizontal',\n    ...restProps \n  } = $props();\n  \n  // Split rest props into those for the container vs. those for tab list\n  const containerProps = {};\n  const tabListProps = {};\n  \n  for (const [key, value] of Object.entries(restProps)) {\n    if (key.startsWith('container')) {\n      const newKey = key.replace('container', '').toLowerCase();\n      containerProps[newKey || 'class'] = value;\n    } else if (key.startsWith('tablist')) {\n      const newKey = key.replace('tablist', '').toLowerCase();\n      tabListProps[newKey || 'class'] = value;\n    }\n  }\n</script>\n\n<div \n  class=\"tabs-container orientation-{orientation} {containerProps.class || ''}\"\n  {...containerProps}\n>\n  <div \n    role=\"tablist\"\n    class=\"tab-list {tabListProps.class || ''}\"\n    aria-orientation={orientation}\n    {...tabListProps}\n  >\n    <slot name=\"tabs\"></slot>\n  </div>\n  \n  <div class=\"tab-panels\">\n    <slot name=\"panels\"></slot>\n  </div>\n</div>\n```\n\n### 5. TypeScript Support for Rest Props\n\nWith TypeScript, you can type your rest props:\n\n```svelte\n<script lang=\"ts\">\n  interface ButtonProps {\n    variant?: 'primary' | 'secondary' | 'danger';\n    size?: 'small' | 'medium' | 'large';\n    disabled?: boolean;\n    [key: string]: any; // This allows any additional props\n  }\n  \n  let { \n    variant = 'primary',\n    size = 'medium',\n    disabled = false,\n    ...restProps \n  }: ButtonProps = $props();\n</script>\n```\n\nFor more specific HTML element attributes:\n\n```svelte\n<script lang=\"ts\">\n  type InputProps = {\n    label: string;\n    error?: string;\n    id?: string;\n  } & Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    'id' // Omit attributes we're handling specially\n  >;\n  \n  let { \n    label,\n    error,\n    id = `input-${Math.random().toString(36).substring(2, 9)}`,\n    ...inputProps \n  }: InputProps = $props();\n</script>\n```\n\n### 6. Dynamic Attribute Handling\n\nFor more dynamic attribute handling:\n\n```svelte\n<script>\n  let { element = 'div', ...props } = $props();\n  \n  // Group props by type\n  const attrs = {};\n  const events = {};\n  const styles = {};\n  \n  for (const [key, value] of Object.entries(props)) {\n    if (key.startsWith('on:')) {\n      // Event handler\n      const eventName = key.slice(3);\n      events[eventName] = value;\n    } else if (key === 'style' && typeof value === 'object') {\n      // Style object\n      Object.assign(styles, value);\n    } else {\n      // Regular attribute\n      attrs[key] = value;\n    }\n  }\n  \n  // Convert style object to string\n  let styleString = '';\n  if (Object.keys(styles).length > 0) {\n    styleString = Object.entries(styles)\n      .map(([k, v]) => `${k}: ${v}`)\n      .join('; ');\n  }\n  \n  if (styleString) {\n    attrs.style = styleString;\n  }\n</script>\n\n<!-- Dynamically render the element with all attributes -->\n<svelte:element this={element} {...attrs}>\n  <slot></slot>\n</svelte:element>\n```\n\n### 7. Conditional Attribute Merging\n\nSometimes you need to conditionally merge certain attributes:\n\n```svelte\n<script>\n  let { \n    class: className = '',\n    style = '',\n    disabled = false,\n    readonly = false,\n    ...restProps \n  } = $props();\n  \n  // Compute aria attributes based on state\n  const ariaAttrs = {\n    'aria-disabled': disabled ? 'true' : undefined,\n    'aria-readonly': readonly ? 'true' : undefined\n  };\n  \n  // Filter out undefined values\n  const filteredAriaAttrs = Object.fromEntries(\n    Object.entries(ariaAttrs).filter(([_, v]) => v !== undefined)\n  );\n</script>\n\n<div \n  class=\"component {className}\"\n  style={style}\n  {...filteredAriaAttrs}\n  {...restProps}\n>\n  <slot></slot>\n</div>\n```\n\n### 8. Building a Prop Forwarding HOC Pattern\n\nFor more complex component composition:\n\n```svelte\n<!-- ForwardProps.svelte -->\n<script>\n  let { \n    component,\n    exclude = [],\n    ...allProps \n  } = $props();\n  \n  // Filter out props that shouldn't be forwarded\n  const forwardProps = {};\n  const excludeSet = new Set(exclude);\n  \n  for (const [key, value] of Object.entries(allProps)) {\n    if (!excludeSet.has(key)) {\n      forwardProps[key] = value;\n    }\n  }\n</script>\n\n<svelte:component this={component} {...forwardProps}>\n  <slot></slot>\n</svelte:component>\n```\n\nUsage:\n```svelte\n<ForwardProps \n  component={Button}\n  variant=\"primary\"\n  size=\"large\"\n  exclude={['class']}\n  class=\"special-class\"\n  onclick={() => console.log('Clicked')}\n/>\n```\n\nThese patterns demonstrate the flexibility and power of using rest properties with `$props()`, enabling you to create highly reusable and composable components in Svelte 5."}
{"source":"docs/svelte/02-runes/05-$props.md","question":"What's the difference between using $props() directly and destructuring the props in Svelte 5?","answer":"In Svelte 5, there are two main ways to use the `$props()` rune: capturing all props in a single object or destructuring them. Each approach has different implications for readability, flexibility, and maintainability.\n\n### Direct Usage vs. Destructuring\n\n#### Direct Usage:\n```svelte\n<script>\n  let props = $props();\n</script>\n\n<div>\n  <h1>{props.title}</h1>\n  <p>{props.description}</p>\n  <button onclick={props.onClick}>Click me</button>\n</div>\n```\n\n#### Destructuring:\n```svelte\n<script>\n  let { title, description, onClick } = $props();\n</script>\n\n<div>\n  <h1>{title}</h1>\n  <p>{description}</p>\n  <button {onClick}>Click me</button>\n</div>\n```\n\n### Key Differences:\n\n#### 1. Code Clarity and Documentation\n\n**Direct Usage:**\n- Less explicit about which props the component expects\n- Requires looking at the component body to understand which props are used\n- More difficult for IDE tooling to provide autocomplete\n\n**Destructuring:**\n- Clearly documents all expected props at the top of the component\n- Makes the component's API immediately visible\n- Better IDE support and autocomplete\n- Easier to add TypeScript types\n\n```svelte\n<script lang=\"ts\">\n  // Clear documentation of expected props\n  let { \n    title, \n    description, \n    onClick \n  }: { \n    title: string; \n    description: string; \n    onClick: () => void;\n  } = $props();\n</script>\n```\n\n#### 2. Default Values\n\n**Direct Usage:**\n- Requires inline defaults with logical OR or nullish coalescing\n\n```svelte\n<script>\n  let props = $props();\n</script>\n\n<div>\n  <h1>{props.title || 'Default Title'}</h1>\n  <p>{props.description ?? 'No description available'}</p>\n</div>\n```\n\n**Destructuring:**\n- Allows setting defaults directly in the destructuring pattern\n- Cleaner syntax for default values\n\n```svelte\n<script>\n  let { \n    title = 'Default Title', \n    description = 'No description available' \n  } = $props();\n</script>\n\n<div>\n  <h1>{title}</h1>\n  <p>{description}</p>\n</div>\n```\n\n#### 3. Dynamic Props and Forward Props\n\n**Direct Usage:**\n- Better for components that need to forward many unknown props\n- Easier to spread all props to a child element\n\n```svelte\n<script>\n  let props = $props();\n  \n  // Extract known props\n  const { class: className, ...otherProps } = props;\n</script>\n\n<div class=\"wrapper {className}\">\n  <!-- Forward all other props to the inner element -->\n  <div {...otherProps}>\n    <slot></slot>\n  </div>\n</div>\n```\n\n**Destructuring:**\n- Requires explicit rest parameter to collect unknown props\n- More verbose when forwarding props\n\n```svelte\n<script>\n  let { class: className, ...otherProps } = $props();\n</script>\n\n<div class=\"wrapper {className}\">\n  <div {...otherProps}>\n    <slot></slot>\n  </div>\n</div>\n```\n\n#### 4. Prop Presence Detection\n\n**Direct Usage:**\n- Easier to check if a prop was provided at all\n\n```svelte\n<script>\n  let props = $props();\n  \n  const hasIcon = 'icon' in props;\n  const hasFooter = 'footer' in props;\n</script>\n\n<div>\n  {#if hasIcon}\n    <div class=\"icon\">{props.icon}</div>\n  {/if}\n  \n  <div class=\"content\">\n    <slot></slot>\n  </div>\n  \n  {#if hasFooter}\n    <div class=\"footer\">{props.footer}</div>\n  {/if}\n</div>\n```\n\n**Destructuring:**\n- Requires different patterns to check if a prop was provided\n\n```svelte\n<script>\n  let props = $props();\n  let { icon, footer } = props;\n  \n  const hasIcon = 'icon' in props;\n  const hasFooter = 'footer' in props;\n</script>\n```\n\n#### 5. Property Renaming\n\n**Direct Usage:**\n- Can't rename props without extra variables\n\n**Destructuring:**\n- Can rename props during destructuring\n\n```svelte\n<script>\n  let { \n    class: className, \n    for: htmlFor,\n    'aria-label': ariaLabel\n  } = $props();\n</script>\n```\n\n#### 6. Performance Considerations\n\nThere's no significant performance difference between the two approaches. Both create the same reactive bindings to prop values.\n\n### 7. Combining Both Approaches\n\nFor complex components, you might combine both approaches:\n\n```svelte\n<script>\n  // Get the full props object\n  let allProps = $props();\n  \n  // Destructure known props\n  let { \n    title, \n    description, \n    variant = 'default',\n    size = 'medium'\n  } = allProps;\n  \n  // Extract specific props for different parts\n  const headerProps = {};\n  const bodyProps = {};\n  const footerProps = {};\n  \n  for (const [key, value] of Object.entries(allProps)) {\n    if (key.startsWith('header')) {\n      headerProps[key.replace('header', '')] = value;\n    } else if (key.startsWith('body')) {\n      bodyProps[key.replace('body', '')] = value;\n    } else if (key.startsWith('footer')) {\n      footerProps[key.replace('footer', '')] = value;\n    }\n  }\n</script>\n\n<div class=\"card variant-{variant} size-{size}\">\n  <div class=\"card-header\" {...headerProps}>\n    <h2>{title}</h2>\n  </div>\n  \n  <div class=\"card-body\" {...bodyProps}>\n    <p>{description}</p>\n    <slot></slot>\n  </div>\n  \n  <div class=\"card-footer\" {...footerProps}>\n    <slot name=\"footer\"></slot>\n  </div>\n</div>\n```\n\n### Best Practices and Recommendations:\n\n1. **For most components**: Use destructuring with default values\n   ```svelte\n   let { title = 'Default', count ="}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"What is the purpose of the `$bindable` rune in Svelte 5 and how does it differ from regular prop passing?","answer":"The `$bindable` rune in Svelte 5 enables two-way data binding between parent and child components. While ordinary props flow one way (from parent to child), the `$bindable` rune allows data to flow both ways - down from parent to child and back up from child to parent.\n\nThis means that when a child component modifies a `$bindable` prop, the change is reflected in the parent component's state. It also allows state proxies to be mutated directly in the child component.\n\nThe documentation notes that this pattern should be used \"sparingly and carefully\" as it makes data flow more complex, but it can simplify code in certain scenarios.\n\nHere's how to implement a `$bindable` prop in a child component:\n\n```svelte\n<script>\n  // Mark 'value' as bindable\n  let { value = $bindable(), ...props } = $props();\n</script>\n\n<input bind:value={value} {...props} />\n```\n\nThis allows a parent component to bind to that value:\n\n```svelte\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n  let message = $state('hello');\n</script>\n\n<ChildComponent bind:value={message} />\n<p>{message}</p>\n```\n\nWhen the input value changes in the child component, the `message` state in the parent component will update automatically."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"How do you declare a `$bindable` prop with a default value in Svelte 5?","answer":"To declare a `$bindable` prop with a default value in Svelte 5, you can pass the default value as an argument to the `$bindable()` rune. This default value will be used when no value is provided by the parent component.\n\nHere's how to implement it:\n\n```svelte\n<script>\n  // 'fallback' is the default value used when no prop is passed\n  let { value = $bindable('fallback'), ...props } = $props();\n</script>\n\n<input bind:value={value} {...props} />\n```\n\nIn this example, if the parent component doesn't pass a `value` prop or doesn't use `bind:value`, the input will display \"fallback\" as its initial value.\n\nThe parent component can use the component in multiple ways:\n1. With binding: `<ChildComponent bind:value={someState} />`\n2. With a one-way prop: `<ChildComponent value={someValue} />`\n3. With no value prop at all: `<ChildComponent />` (will use 'fallback')\n\nThis flexibility allows the component to be used in different contexts while maintaining sensible defaults."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"Is it mandatory for a parent component to use the `bind:` directive when a child component has a `$bindable` prop?","answer":"No, it is not mandatory for a parent component to use the `bind:` directive with a child component's `$bindable` prop. As stated in the documentation: \"The parent component doesn't have to use bind: â it can just pass a normal prop. Some parents don't want to listen to what their children have to say.\"\n\nThis means you have two options when using a component with `$bindable` props:\n\n1. Use `bind:` for two-way binding:\n```svelte\n<script>\n  import FancyInput from './FancyInput.svelte';\n  let message = $state('hello');\n</script>\n\n<FancyInput bind:value={message} />\n<!-- Changes to the input will update 'message' -->\n```\n\n2. Use normal prop passing for one-way binding:\n```svelte\n<script>\n  import FancyInput from './FancyInput.svelte';\n  let message = $state('hello');\n</script>\n\n<FancyInput value={message} />\n<!-- Changes to the input will NOT update 'message' -->\n```\n\nThis flexibility allows you to decide on a component-by-component basis whether you want two-way binding or the more traditional one-way data flow, giving you more control over how data moves through your application."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"How does the `$bindable` rune interact with Svelte 5's state management system?","answer":"The `$bindable` rune in Svelte 5 integrates seamlessly with the framework's state management system, particularly with state proxies created using `$state()`. When a `$bindable` prop is bound to a state value in a parent component, it creates a two-way connection that allows:\n\n1. Changes to the parent state to flow down to the child component\n2. Mutations in the child component to flow back up and update the parent state\n\nThis is particularly powerful because it means that a state proxy can be directly mutated in the child component, and those mutations will be properly tracked and reflected in the parent component.\n\nExample:\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n  let user = $state({ name: 'John', age: 30 });\n</script>\n\n<ChildComponent bind:userData={user} />\n<p>Name: {user.name}, Age: {user.age}</p>\n```\n\n```svelte\n<!-- ChildComponent.svelte -->\n<script>\n  let { userData = $bindable() } = $props();\n</script>\n\n<input \n  value={userData.name}\n  on:input={(e) => userData.name = e.target.value} \n/>\n<input \n  type=\"number\"\n  value={userData.age}\n  on:input={(e) => userData.age = Number(e.target.value)} \n/>\n```\n\nIn this example, when the inputs in the child component change, they directly mutate properties of the `user` state object in the parent. Svelte's reactivity system will detect these changes and update any UI that depends on them.\n\nThis creates a powerful pattern for component composition where child components can participate in state management while maintaining a clear connection to the parent's state."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"What are the potential drawbacks or risks of using `$bindable` props extensively in a Svelte application?","answer":"While the `$bindable` rune is a powerful feature in Svelte 5, the documentation explicitly notes that it \"isn't something you should do often\" and should be used \"sparingly and carefully.\" There are several potential drawbacks to extensive use of bindable props:\n\n1. **Complex data flow**: Two-way binding makes it harder to track how data changes throughout your application. When data can flow in multiple directions, it becomes more difficult to reason about the state of your application at any given time.\n\n2. **Implicit dependencies**: Binding creates implicit dependencies between components that aren't immediately obvious when reading the code, which can make maintenance more challenging.\n\n3. **Debugging challenges**: When a state value unexpectedly changes, it's harder to track down the source of the change if multiple components can modify the same value.\n\n4. **Testing complexity**: Components with two-way binding are typically more difficult to test in isolation since they have more complex interactions with their parent components.\n\n5. **Potential for unintended side effects**: A child component might modify a bound prop in ways the parent component doesn't expect, leading to bugs that are difficult to track down.\n\n6. **Reduced reusability**: Components that rely heavily on two-way binding may be less reusable because they make assumptions about how their parent components handle state.\n\nInstead of extensive use of `$bindable`, consider these alternatives:\n\n- Use event dispatching for child-to-parent communication\n- Pass callback functions as props\n- Use a centralized state management approach for more complex state\n- Use one-way data flow as the default, and only use `$bindable` when it significantly simplifies the code\n\nA good rule of thumb is to use `$bindable` primarily for form elements and UI controls where two-way binding is a natural fit for the user interaction model."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"How would you create a custom form input component using `$bindable` that supports validation?","answer":"Creating a custom form input with validation using `$bindable` allows us to create a reusable component that can both display and update values while also providing validation feedback. Here's a comprehensive example:\n\n```svelte\n<!-- ValidatedInput.svelte -->\n<script>\n  // Define props with bindable value\n  let { \n    value = $bindable(''), \n    label = '',\n    required = false,\n    minLength = 0,\n    maxLength = Infinity,\n    pattern = null,\n    errorMessage = '',\n    ...props \n  } = $props();\n  \n  // Local state for validation\n  let touched = $state(false);\n  let error = $derived(validateInput(value));\n  \n  // Validation function\n  function validateInput(val) {\n    if (required && !val) {\n      return 'This field is required';\n    }\n    \n    if (val.length < minLength) {\n      return `Minimum length is ${minLength} characters`;\n    }\n    \n    if (val.length > maxLength) {\n      return `Maximum length is ${maxLength} characters`;\n    }\n    \n    if (pattern && !new RegExp(pattern).test(val)) {\n      return errorMessage || 'Invalid format';\n    }\n    \n    return '';\n  }\n  \n  // Handle input change\n  function handleInput(e) {\n    value = e.target.value;\n    touched = true;\n  }\n  \n  // Handle blur event\n  function handleBlur() {\n    touched = true;\n  }\n</script>\n\n<div class=\"form-field\">\n  {#if label}\n    <label for=\"input-field\">{label}</label>\n  {/if}\n  \n  <input\n    id=\"input-field\"\n    value={value}\n    on:input={handleInput}\n    on:blur={handleBlur}\n    class:error={touched && error}\n    {...props}\n  />\n  \n  {#if touched && error}\n    <div class=\"error-message\">{error}</div>\n  {/if}\n</div>\n\n<style>\n  .form-field {\n    margin-bottom: 1rem;\n  }\n  \n  label {\n    display: block;\n    margin-bottom: 0.5rem;\n    font-weight: bold;\n  }\n  \n  input {\n    width: 100%;\n    padding: 0.5rem;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n  \n  input.error {\n    border-color: red;\n  }\n  \n  .error-message {\n    color: red;\n    font-size: 0.875rem;\n    margin-top: 0.25rem;\n  }\n</style>\n```\n\nNow we can use this component in a parent form:\n\n```svelte\n<!-- UserForm.svelte -->\n<script>\n  import ValidatedInput from './ValidatedInput.svelte';\n  \n  let formData = $state({\n    username: '',\n    email: '',\n    password: ''\n  });\n  \n  function handleSubmit() {\n    // Form submission logic here\n    console.log('Submitting:', formData);\n  }\n</script>\n\n<form on:submit|preventDefault={handleSubmit}>\n  <ValidatedInput\n    bind:value={formData.username}\n    label=\"Username\"\n    required\n    minLength={3}\n    maxLength={20}\n    placeholder=\"Enter username\"\n  />\n  \n  <ValidatedInput\n    bind:value={formData.email}\n    label=\"Email\"\n    required\n    pattern=\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n    errorMessage=\"Please enter a valid email address\"\n    placeholder=\"Enter email\"\n    type=\"email\"\n  />\n  \n  <ValidatedInput\n    bind:value={formData.password}\n    label=\"Password\"\n    required\n    minLength={8}\n    type=\"password\"\n    placeholder=\"Enter password\"\n  />\n  \n  <button type=\"submit\">Submit</button>\n</form>\n```\n\nThis example demonstrates:\n1. A reusable input component with validation\n2. Using `$bindable` to create a two-way binding for the input value\n3. Local validation state that doesn't affect the parent component\n4. Customizable validation rules through props\n5. Visual feedback for validation errors\n\nThe `$bindable` rune allows the parent form to receive updates from the input component while the component handles its own validation logic internally. This creates a clean separation of concerns while maintaining the convenience of two-way data binding."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"How does `$bindable` work with nested objects or arrays, and what are the implications for reactivity?","answer":"When using `$bindable` with nested objects or arrays in Svelte 5, the entire object or array reference is bound, not just individual properties. This has important implications for reactivity and how updates propagate between components.\n\nLet's explore this with an example:\n\n```svelte\n<!-- UserEditor.svelte -->\n<script>\n  let { user = $bindable({ name: '', email: '', preferences: { theme: 'light' } }) } = $props();\n  \n  function toggleTheme() {\n    // This directly mutates the nested object\n    user.preferences.theme = user.preferences.theme === 'light' ? 'dark' : 'light';\n  }\n</script>\n\n<div>\n  <input bind:value={user.name} placeholder=\"Name\" />\n  <input bind:value={user.email} placeholder=\"Email\" />\n  <button on:click={toggleTheme}>\n    Toggle theme (current: {user.preferences.theme})\n  </button>\n</div>\n```\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import UserEditor from './UserEditor.svelte';\n  \n  let userData = $state({\n    name: 'John Doe',\n    email: 'john@example.com',\n    preferences: {\n      theme: 'light'\n    }\n  });\n</script>\n\n<UserEditor bind:user={userData} />\n\n<div>\n  <h2>User Data:</h2>\n  <pre>{JSON.stringify(userData, null, 2)}</pre>\n</div>\n```\n\nKey implications:\n\n1. **Mutations are reflected in parent state**: When the child component mutates a nested property (like `user.preferences.theme`), that change is directly applied to the parent state object. This is because objects and arrays are passed by reference, and `$bindable` maintains that reference.\n\n2. **Deep reactivity**: Changes to nested properties trigger reactivity in both the child and parent components. In our example, changing the theme in the child component updates the display in both components.\n\n3. **No need for immutable updates**: Unlike React or other frameworks that require immutable update patterns, with `$bindable` you can directly mutate nested properties and Svelte's reactivity system will track these changes.\n\n4. **Potential gotchas**:\n   - If you replace the entire object (`user = { ...newData }`) instead of mutating its properties, you'll create a new reference that breaks the binding with the parent\n   - If multiple components bind to the same object, they can all mutate it, potentially leading to confusing state management\n\n5. **Arrays work similarly**: With bound arrays, you can use array methods that mutate the original array (push, pop, splice, etc.) and the changes will be reflected in the parent:\n\n```svelte\n<script>\n  let { items = $bindable([]) } = $props();\n  \n  function addItem() {\n    items.push({ id: Date.now(), text: 'New item' });\n    // The parent sees this change immediately\n  }\n</script>\n```\n\nBest practices:\n\n1. Be cautious with deeply nested mutations, as they can make it harder to track state changes\n2. Consider using flatter state structures when possible\n3. Document components that mutate bound objects or arrays so other developers understand the data flow\n4. For complex state management, consider using a dedicated state management solution instead of relying heavily on bindings\n\nBy understanding these implications, you can effectively use `$bindable` with nested data structures while maintaining clean and predictable code."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"How does the `$bindable` rune compare to the bind directive in Svelte 3/4, and what are the key differences in implementation?","answer":"The `$bindable` rune in Svelte 5 and the `export let` pattern with binding in Svelte 3/4 both enable two-way data binding between parent and child components, but they differ significantly in implementation and syntax.\n\n**Svelte 3/4 approach:**\n\n```svelte\n<!-- In Svelte 3/4 -->\n<script>\n  // Mark props as writable with 'export let'\n  export let value = 'default value';\n</script>\n\n<input bind:value={value} />\n```\n\n```svelte\n<!-- Parent in Svelte 3/4 -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n  let message = 'hello';\n</script>\n\n<ChildComponent bind:value={message} />\n<p>{message}</p>\n```\n\n**Svelte 5 approach with runes:**\n\n```svelte\n<!-- In Svelte 5 -->\n<script>\n  let { value = $bindable('default value'), ...props } = $props();\n</script>\n\n<input bind:value={value} {...props} />\n```\n\n```svelte\n<!-- Parent in Svelte 5 -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n  let message = $state('hello');\n</script>\n\n<ChildComponent bind:value={message} />\n<p>{message}</p>\n```\n\n**Key differences:**\n\n1. **Syntax and Declaration:**\n   - Svelte 3/4: Uses `export let` to declare bindable props\n   - Svelte 5: Uses the `$bindable()` rune within the `$props()` destructuring pattern\n\n2. **Prop Handling:**\n   - Svelte 3/4: All exported variables are automatically props\n   - Svelte 5: Props are explicitly declared through `$props()` and must be marked as bindable with `$bindable()`\n\n3. **Default Values:**\n   - Svelte 3/4: Default values are assigned directly in the export statement\n   - Svelte 5: Default values are passed as arguments to the `$bindable()` rune\n\n4. **Integration with State Management:**\n   - Svelte 3/4: Works with regular variables and reactive statements\n   - Svelte 5: Integrates with the new fine-grained reactivity system using `$state()` and other runes\n\n5. **Explicitness:**\n   - Svelte 3/4: All exported props are implicitly bindable\n   - Svelte 5: Props must be explicitly marked as bindable, making the intention clearer\n\n6. **Rest Props:**\n   - Svelte 3/4: Requires additional patterns to handle rest props\n   - Svelte 5: Rest props are naturally handled in the destructuring pattern (`...props`)\n\n7. **Conceptual Model:**\n   - Svelte 3/4: Binding is tied to the component's export mechanism\n   - Svelte 5: Binding is a separate concern from prop declaration, aligning with the runes philosophy of explicit declarations\n\n**Example of a more complex component in both versions:**\n\nSvelte 3/4:\n```svelte\n<script>\n  export let value = '';\n  export let label = '';\n  export let required = false;\n  \n  // Other local variables\n  let touched = false;\n</script>\n\n<label>\n  {label} {required ? '*' : ''}\n  <input \n    bind:value \n    on:blur={() => touched = true}\n    {...$$restProps}\n  />\n</label>\n```\n\nSvelte 5:\n```svelte\n<script>\n  let { \n    value = $bindable(''), \n    label = '', \n    required = false,\n    ...props\n  } = $props();\n  \n  // Other local state\n  let touched = $state(false);\n</script>\n\n<label>\n  {label} {required ? '*' : ''}\n  <input \n    bind:value \n    on:blur={() => touched = true}\n    {...props}\n  />\n</label>\n```\n\nThe Svelte 5 approach with `$bindable` makes the binding capability more explicit and integrates better with the runes-based reactivity system, while maintaining the convenience of two-way binding that Svelte developers appreciate."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"Can you use `$bindable` with computed or derived values, and if so, what are the implications?","answer":"Using `$bindable` with computed or derived values presents some interesting challenges and patterns in Svelte 5. The short answer is that while you can technically mark a derived value as bindable, there are important considerations regarding how mutations are handled.\n\nLet's explore this with examples:\n\n### Basic Derived Value\n\n```svelte\n<script>\n  // This pattern has limitations\n  let { value = $bindable(0) } = $props();\n  \n  // Derived from the bindable prop\n  let doubled = $derived(value * 2);\n</script>\n\n<div>\n  <p>Original: {value}</p>\n  <p>Doubled: {doubled}</p>\n  \n  <button on:click={() => value++}>Increment Original</button>\n  <!-- This won't work as expected -->\n  <button on:click={() => doubled++}>Try to increment doubled</button>\n</div>\n```\n\nIn this example, `doubled` is derived from `value`, but it's not directly bindable. When you try to increment `doubled`, it won't affect `value` because derived values are computed one-way.\n\n### Making a Computed Value Bindable\n\nIf you want to create a bindable prop that represents a transformation of another value, you need to handle both directions of the transformation:\n\n```svelte\n<!-- TemperatureConverter.svelte -->\n<script>\n  let { celsius = $bindable(0) } = $props();\n  \n  // Derived from celsius\n  let fahrenheit = $derived(celsius * 9/5 + 32);\n  \n  // Handle updates to fahrenheit\n  function updateFahrenheit(newFahrenheit) {\n    // Convert back to celsius and update the bindable prop\n    celsius = (newFahrenheit - 32) * 5/9;\n  }\n</script>\n\n<div>\n  <label>\n    Celsius:\n    <input type=\"number\" bind:value={celsius} />\n  </label>\n  \n  <label>\n    Fahrenheit:\n    <input \n      type=\"number\" \n      value={fahrenheit} \n      on:input={(e) => updateFahrenheit(Number(e.target.value))}\n    />\n  </label>\n</div>\n```\n\nIn this temperature converter example:\n1. `celsius` is a bindable prop that can be updated from the parent\n2. `fahrenheit` is derived from `celsius`\n3. When the user edits the fahrenheit input, we manually convert back to celsius\n\n### Creating a Bindable Computed Prop\n\nIf you want to expose a computed value as a bindable prop to the parent, you need to handle the transformation in the component:\n\n```svelte\n<!-- PriceEditor.svelte -->\n<script>\n  // Base price is bindable\n  let { priceInCents = $bindable(0) } = $props();\n  \n  // Derived dollars value for display\n  let priceInDollars = $derived(priceInCents / 100);\n  \n  // Handle updates to the dollars value\n  function updateDollars(dollars) {\n    priceInCents = Math.round(dollars * 100);\n  }\n</script>\n\n<div>\n  <label>\n    Price ($):\n    <input \n      type=\"number\" \n      step=\"0.01\"\n      value={priceInDollars} \n      on:input={(e) => updateDollars(Number(e.target.value))}\n    />\n  </label>\n</div>\n```\n\nThe parent component can bind to `priceInCents`:\n\n```svelte\n<script>\n  import PriceEditor from './PriceEditor.svelte';\n  \n  let productPrice = $state(1095); // $10.95 in cents\n</script>\n\n<PriceEditor bind:priceInCents={productPrice} />\n<p>Product price: ${(productPrice / 100).toFixed(2)}</p>\n```\n\n### Implications and Best Practices\n\n1. **Directional Transformation**: When working with computed bindable values, you need to handle both directions of the transformation (original â computed and computed â original).\n\n2. **Single Source of Truth**: It's best to keep one value as the source of truth (typically the simpler or more fundamental representation) and derive others from it.\n\n3. **Validation Concerns**: When transforming back from a computed value, consider validation and precision issues (like rounding errors with floating-point numbers).\n\n4. **Performance Considerations**: Complex transformations in both directions could impact performance if they run frequently.\n\n5. **Documentation**: Clearly document the behavior of bindable computed props, especially if the transformation isn't obvious.\n\n6. **Alternative Pattern**: For complex scenarios, consider using events instead of binding:\n\n```svelte\n<!-- Alternative to binding computed values -->\n<script>\n  let { priceInCents = 0 } = $props();\n  const dispatch = createEventDispatcher();\n  \n  let priceInDollars = $derived(priceInCents / 100);\n  \n  function updateDollars(dollars) {\n    dispatch('priceChange', Math.round(dollars * 100));\n  }\n</script>\n```\n\nIn summary, while you can create patterns that effectively make computed values bindable, it requires careful handling of the transformations in both directions. For simple cases, this can be a convenient pattern, but for more complex scenarios, consider whether a different communication pattern might be clearer."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"How can you use `$bindable` with form elements to create a custom form library in Svelte 5?","answer":"Creating a custom form library with `$bindable` in Svelte 5 allows you to build reusable, accessible form components with two-way data binding. Here's a comprehensive approach to building such a library:\n\n### 1. Base Form Component\n\nFirst, let's create a Form wrapper component that will manage form state and validation:\n\n```svelte\n<!-- Form.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte';\n  \n  let { \n    initialValues = $bindable({}),\n    validationSchema = null,\n    ...props\n  } = $props();\n  \n  const dispatch = createEventDispatcher();\n  \n  // Track form state\n  let touched = $state({});\n  let errors = $state({});\n  let isSubmitting = $state(false);\n  \n  // Validate the entire form\n  function validateForm() {\n    if (!validationSchema) return {};\n    \n    try {\n      validationSchema.validateSync(initialValues, { abortEarly: false });\n      return {};\n    } catch (validationError) {\n      const newErrors = {};\n      validationError.inner.forEach(err => {\n        newErrors[err.path] = err.message;\n      });\n      return newErrors;\n    }\n  }\n  \n  // Validate a single field\n  function validateField(name) {\n    if (!validationSchema) return;\n    \n    try {\n      validationSchema.validateSyncAt(name, initialValues);\n      errors[name] = '';\n    } catch (err) {\n      errors[name] = err.message;\n    }\n  }\n  \n  // Handle form submission\n  async function handleSubmit(event) {\n    event.preventDefault();\n    \n    // Mark all fields as touched\n    Object.keys(initialValues).forEach(key => {\n      touched[key] = true;\n    });\n    \n    // Validate all fields\n    const formErrors = validateForm();\n    errors = formErrors;\n    \n    // If there are errors, don't submit\n    if (Object.keys(formErrors).length > 0) {\n      dispatch('validationFailed', formErrors);\n      return;\n    }\n    \n    isSubmitting = true;\n    \n    try {\n      dispatch('submit', initialValues);\n    } finally {\n      isSubmitting = false;\n    }\n  }\n  \n  // Provide context for form fields\n  setContext('formContext', {\n    values: initialValues,\n    errors,\n    touched,\n    validateField,\n    setFieldTouched: (name) => {\n      touched[name] = true;\n      validateField(name);\n    }\n  });\n</script>\n\n<form on:submit={handleSubmit} {...props}>\n  <slot \n    values={initialValues}\n    errors={errors}\n    touched={touched}\n    isSubmitting={isSubmitting}\n  />\n</form>\n```\n\n### 2. Form Field Components\n\nNow, let's create reusable form field components that use `$bindable`:\n\n```svelte\n<!-- TextField.svelte -->\n<script>\n  import { getContext } from 'svelte';\n  \n  let {\n    name = '',\n    label = '',\n    type = 'text',\n    placeholder = '',\n    required = false,\n    value = $bindable(''),\n    ...props\n  } = $props();\n  \n  const { errors, touched, setFieldTouched } = getContext('formContext');\n  \n  // Handle blur event to mark field as touched\n  function handleBlur() {\n    setFieldTouched(name);\n  }\n  \n  // Determine if we should show an error\n  $: showError = touched[name] && errors[name];\n</script>\n\n<div class=\"form-field\">\n  {#if label}\n    <label for={name}>{label}{required ? ' *' : ''}</label>\n  {/if}\n  \n  <input\n    {type}\n    id={name}\n    {name}\n    {placeholder}\n    bind:value\n    on:blur={handleBlur}\n    class:error={showError}\n    {...props}\n  />\n  \n  {#if showError}\n    <div class=\"error-message\">{errors[name]}</div>\n  {/if}\n</div>\n\n<style>\n  .form-field {\n    margin-bottom: 1rem;\n  }\n  \n  label {\n    display: block;\n    margin-bottom: 0.25rem;\n    font-weight: 500;\n  }\n  \n  input {\n    width: 100%;\n    padding: 0.5rem;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n  \n  input.error {\n    border-color: #e53e3e;\n  }\n  \n  .error-message {\n    color: #e53e3e;\n    font-size: 0.875rem;\n    margin-top: 0.25rem;\n  }\n</style>\n```\n\n```svelte\n<!-- SelectField.svelte -->\n<script>\n  import { getContext } from 'svelte';\n  \n  let {\n    name = '',\n    label = '',\n    options = [],\n    required = false,\n    value = $bindable(''),\n    ...props\n  } = $props();\n  \n  const { errors, touched, setFieldTouched } = getContext('formContext');\n  \n  function handleBlur() {\n    setFieldTouched(name);\n  }\n  \n  $: showError = touched[name] && errors[name];\n</script>\n\n<div class=\"form-field\">\n  {#if label}\n    <label for={name}>{label}{required ? ' *' : ''}</label>\n  {/if}\n  \n  <select\n    id={name}\n    {name}\n    bind:value\n    on:blur={handleBlur}\n    class:error={showError}\n    {...props}\n  >\n    <option value=\"\" disabled>Select an option</option>\n    {#each options as option}\n      <option value={option.value}>{option.label}</option>\n    {/each}\n  </select>\n  \n  {#if showError}\n    <div class=\"error-message\">{errors[name]}</div>\n  {/if}\n</div>\n\n<style>\n  /* Similar styles as TextField */\n  .form-field {\n    margin-bottom: 1rem;\n  }\n  \n  select {\n    width: 100%;\n    padding: 0.5rem;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n  \n  select.error {\n    border-color: #e53e3e;\n  }\n  \n  /* ... other styles ... */\n</style>\n```\n\n### 3. Using the Form Library\n\nNow let's see how to use this custom form library:\n\n```svelte\n<!-- UserRegistrationForm.svelte -->\n<script>\n  import { Form, TextField, SelectField } from './form-library';\n  import * as yup from 'yup'; // For validation\n  \n  let formValues = $state({\n    username: '',\n    email: '',\n    password: '',\n    role: ''\n  });\n  \n  const validationSchema = yup.object({\n    username: yup.string().required('Username is required').min(3, 'Username must be at least 3 characters'),\n    email: yup.string().required('Email is required').email('Must be a valid email'),\n    password: yup.string().required('Password is required').min(8, 'Password must be at least 8 characters'),\n    role: yup.string().required('Please select a role')\n  });\n  \n  function handleSubmit(event) {\n    const formData = event.detail;\n    console.log('Form submitted with:', formData);\n    // Send data to server\n  }\n</script>\n\n<Form \n  bind:initialValues={formValues}\n  validationSchema={validationSchema}\n  on:submit={handleSubmit}\n  class=\"registration-form\"\n>\n  <svelte:fragment slot=\"default\" let:isSubmitting>\n    <TextField\n      name=\"username\"\n      label=\"Username\"\n      required\n      bind:value={formValues.username}\n    />\n    \n    <TextField\n      name=\"email\"\n      label=\"Email Address\"\n      type=\"email\"\n      required\n      bind:value={formValues.email}\n    />\n    \n    <TextField\n      name=\"password\"\n      label=\"Password\"\n      type=\"password\"\n      required\n      bind:value={formValues.password}\n    />\n    \n    <SelectField\n      name=\"role\"\n      label=\"Role\"\n      required\n      options={[\n        { value: 'user', label: 'User' },\n        { value: 'admin', label: 'Administrator' },\n        { value: 'editor', label: 'Editor' }\n      ]}\n      bind:value={formValues.role}\n    />\n    \n    <button type=\"submit\" disabled={isSubmitting}>\n      {isSubmitting ? 'Submitting...' : 'Register'}\n    </button>\n  </svelte:fragment>\n</Form>\n\n<style>\n  .registration-form {\n    max-width: 500px;\n    margin: 0 auto;\n  }\n  \n  button {\n    background-color: #4299e1;\n    color: white;\n    padding: 0.5rem 1rem;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-weight: bold;\n  }\n  \n  button:hover {\n    background-color: #3182ce;\n  }\n  \n  button:disabled {\n    background-color: #a0aec0;\n    cursor: not-allowed;\n  }\n</style>\n```\n\n### 4. Advanced Form Components\n\nLet's add a more complex form component that demonstrates the power of `$bindable` with nested data:\n\n```svelte\n<!-- ArrayField.svelte -->\n<script>\n  import { getContext } from 'svelte';\n  import { TextField } from './form-library';\n  \n  let {\n    name = '',\n    label = '',\n    itemLabel = 'Item',\n    value = $bindable([]),\n    ...props\n  } = $props();\n  \n  function addItem() {\n    value = [...value, ''];\n  }\n  \n  function removeItem(index) {\n    value = value.filter((_, i) => i !== index);\n  }\n</script>\n\n<div class=\"array-field\">\n  {#if label}\n    <label>{label}</label>\n  {/if}\n  \n  {#each value as item, index}\n    <div class=\"array-item\">\n      <TextField\n        name={`${name}[${index}]`}\n        label={`${itemLabel} ${index + 1}`}\n        bind:value={value[index]}\n      />\n      <button \n        type=\"button\" \n        class=\"remove-button\"\n        on:click={() => removeItem(index)}\n      >\n        Remove\n      </button>\n    </div>\n  {/each}\n  \n  <button type=\"button\" class=\"add-button\" on:click={addItem}>\n    Add {itemLabel}\n  </button>\n</div>\n\n<style>\n  .array-field {\n    margin-bottom: 1rem;\n    border: 1px solid #e2e8f0;\n    padding: 1rem;\n    border-radius: 4px;\n  }\n  \n  .array-item {\n    display: flex;\n    align-items: flex-start;\n    gap: 0.5rem;\n  }\n  \n  .add-button {\n    background-color: #48bb78;\n    color: white;\n    padding: 0.25rem 0.5rem;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  \n  .remove-button {\n    background-color: #f56565;\n    color: white;\n    padding: 0.25rem 0.5rem;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    margin-top: 1.5rem;\n  }\n</style>\n```\n\nThis array field component demonstrates how `$bindable` can work with arrays, allowing the parent form to track changes to the array items.\n\n### 5. Form Library Benefits\n\nThis custom form library built with `$bindable` offers several advantages:\n\n1. **Two-way binding**: Changes in form fields automatically update the parent component's state\n2. **Reusable components**: Form fields can be used across different forms\n3. **Validation integration**: Built-in support for schema validation\n4. **Accessibility**: Components can be built with accessibility in mind\n5. **Customization**: Each component can be styled and extended as needed\n6. **Type safety**: When used with TypeScript, can provide type checking for form values\n\nThe `$bindable` rune is central to this design, allowing form components to both display values from and send updates to the parent form state, creating a seamless form-building experience in Svelte 5."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"How can you use `$bindable` with third-party libraries or components that weren't built with Svelte?","answer":"Using `$bindable` with third-party libraries or non-Svelte components requires creating wrapper components that bridge between Svelte's binding system and the external library's API. This is a common pattern when integrating with charting libraries, map components, rich text editors, or other complex UI widgets.\n\nHere's a comprehensive guide to using `$bindable` with third-party libraries:\n\n### 1. Basic Integration Pattern\n\nThe general pattern involves:\n1. Creating a `$bindable` prop in your wrapper component\n2. Using lifecycle hooks to initialize the third-party component\n3. Setting up event listeners to detect changes in the external component\n4. Updating the `$bindable` prop when the external component changes\n5. Watching for changes to the `$bindable` prop and updating the external component\n\n### 2. Example with a Rich Text Editor (TinyMCE)\n\n```svelte\n<!-- TinyMCEEditor.svelte -->\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  let {\n    content = $bindable(''),\n    config = {\n      plugins: 'link image table code',\n      toolbar: 'undo redo | formatselect | bold italic | alignleft aligncenter alignright | bullist numlist outdent indent | link image',\n      height: 300\n    },\n    ...props\n  } = $props();\n  \n  let editorElement;\n  let editor;\n  let initializing = true;\n  \n  onMount(() => {\n    // Import TinyMCE dynamically\n    import('tinymce/tinymce').then(module => {\n      const tinymce = module.default;\n      \n      // Initialize TinyMCE\n      tinymce.init({\n        target: editorElement,\n        ...config,\n        setup: (ed) => {\n          editor = ed;\n          \n          // Listen for content changes and update the bindable prop\n          ed.on('Change', () => {\n            if (!initializing) {\n              content = ed.getContent();\n            }\n          });\n          \n          ed.on('init', () => {\n            // Set initial content\n            ed.setContent(content);\n            initializing = false;\n          });\n        }\n      });\n    });\n  });\n  \n  // Watch for external changes to content prop\n  $effect(() => {\n    if (editor && !initializing) {\n      const currentContent = editor.getContent();\n      if (content !== currentContent) {\n        editor.setContent(content);\n      }\n    }\n  });\n  \n  onDestroy(() => {\n    if (editor) {\n      editor.destroy();\n    }\n  });\n</script>\n\n<div class=\"tinymce-wrapper\">\n  <div bind:this={editorElement}></div>\n</div>\n\n<style>\n  .tinymce-wrapper {\n    margin-bottom: 1rem;\n  }\n</style>\n```\n\nUsage in a parent component:\n\n```svelte\n<script>\n  import TinyMCEEditor from './TinyMCEEditor.svelte';\n  \n  let articleContent = $state('<p>Initial content</p>');\n  \n  function saveArticle() {\n    console.log('Saving article with content:', articleContent);\n    // Save to server\n  }\n</script>\n\n<div class=\"article-editor\">\n  <h2>Edit Article</h2>\n  \n  <TinyMCEEditor bind:content={articleContent} />\n  \n  <div class=\"preview\">\n    <h3>Preview</h3>\n    <div class=\"content-preview\">\n      {@html articleContent}\n    </div>\n  </div>\n  \n  <button on:click={saveArticle}>Save Article</button>\n</div>\n```\n\n### 3. Example with a Mapping Library (Leaflet)\n\n```svelte\n<!-- LeafletMap.svelte -->\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  let {\n    center = $bindable([51.505, -0.09]), // [lat, lng]\n    zoom = $bindable(13),\n    markers = $bindable([]),\n    ...props\n  } = $props();\n  \n  let mapElement;\n  let map;\n  let markerLayer;\n  let isInitialized = false;\n  \n  onMount(async () => {\n    // Dynamically import Leaflet\n    const L = await import('leaflet');\n    \n    // Initialize map\n    map = L.map(mapElement).setView(center, zoom);\n    \n    // Add tile layer\n    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n      attribution: '&copy; OpenStreetMap contributors'\n    }).addTo(map);\n    \n    // Create marker layer group\n    markerLayer = L.layerGroup().addTo(map);\n    \n    // Update markers initially\n    updateMarkers();\n    \n    // Listen for map movements and update bindable props\n    map.on('moveend', () => {\n      const newCenter = [map.getCenter().lat, map.getCenter().lng];\n      const newZoom = map.getZoom();\n      \n      // Update bindable props\n      center = newCenter;\n      zoom = newZoom;\n    });\n    \n    // Listen for marker clicks\n    map.on('click', (e) => {\n      const newMarker = {\n        id: Date.now(),\n        position: [e.latlng.lat, e.latlng.lng],\n        title: `Marker ${markers.length + 1}`\n      };\n      \n      // Add to bindable markers array\n      markers = [...markers, newMarker];\n    });\n    \n    isInitialized = true;\n  });\n  \n  // Update map when center or zoom changes externally\n  $effect(() => {\n    if (map && isInitialized) {\n      const currentCenter = [map.getCenter().lat, map.getCenter().lng];\n      const currentZoom = map.getZoom();\n      \n      if (center[0] !== currentCenter[0] || center[1] !== currentCenter[1] || zoom !== currentZoom) {\n        map.setView(center, zoom);\n      }\n    }\n  });\n  \n  // Update markers when they change\n  $effect(() => {\n    if (markerLayer && isInitialized) {\n      updateMarkers();\n    }\n  });\n  \n  function updateMarkers() {\n    if (!markerLayer) return;\n    \n    // Clear existing markers\n    markerLayer.clearLayers();\n    \n    // Add markers from the bindable array\n    markers.forEach(marker => {\n      const L = window.L; // Access the globally available Leaflet\n      const leafletMarker = L.marker(marker.position)\n        .addTo(markerLayer)\n        .bindPopup(marker.title);\n      \n      // Add event listener for removing markers\n      leafletMarker.on('contextmenu', () => {\n        markers = markers.filter(m => m.id !== marker.id);\n      });\n    });\n  }\n  \n  onDestroy(() => {\n    if (map) {\n      map.remove();\n    }\n  });\n</script>\n\n<div class=\"map-container\">\n  <div class=\"map\" bind:this={mapElement}></div>\n  \n  <div class=\"instructions\">\n    <p>Click on the map to add markers</p>\n    <p>Right-click on markers to remove them</p>\n  </div>\n</div>\n\n<style>\n  .map-container {\n    position: relative;\n  }\n  \n  .map {\n    height: 400px;\n    width: 100%;\n    z-index: 1;\n  }\n  \n  .instructions {\n    background: rgba(255, 255, 255, 0.8);\n    padding: 10px;\n    position: absolute;\n    bottom: 10px;\n    right: 10px;\n    z-index: 2;\n    border-radius: 4px;\n    font-size: 0.875rem;\n  }\n</style>\n```\n\nUsage in a parent component:\n\n```svelte\n<script>\n  import LeafletMap from './LeafletMap.svelte';\n  \n  let mapCenter = $state([51.505, -0.09]);\n  let mapZoom = $state(13);\n  let locationMarkers = $state([\n    { id: 1, position: [51.505, -0.09], title: 'London' },\n    { id: 2, position: [48.8566, 2.3522], title: 'Paris' }\n  ]);\n  \n  function flyToLondon() {\n    mapCenter = [51.505, -0.09];\n    mapZoom = 13;\n  }\n  \n  function flyToParis() {\n    mapCenter = [48.8566, 2.3522];\n    mapZoom = 13;\n  }\n</script>\n\n<div class=\"map-page\">\n  <h2>Interactive Map</h2>\n  \n  <LeafletMap \n    bind:center={mapCenter} \n    bind:zoom={mapZoom}\n    bind:markers={locationMarkers}\n  />\n  \n  <div class=\"controls\">\n    <button on:click={flyToLondon}>Go to London</button>\n    <button on:click={flyToParis}>Go to Paris</button>\n  </div>\n  \n  <div class=\"marker-list\">\n    <h3>Markers ({locationMarkers.length})</h3>\n    {#each locationMarkers as marker}\n      <div class=\"marker-item\">\n        <span>{marker.title}</span>\n        <button on:click={() => {\n          locationMarkers = locationMarkers.filter(m => m.id !== marker.id);\n        }}>Remove</button>\n      </div>\n    {/each}\n  </div>\n</div>\n```\n\n### 4. Best Practices for Third-Party Integration\n\n1. **Handle initialization carefully**: Use flags like `isInitializing` to prevent update loops during the initial setup.\n\n2. **Clean up resources**: Always use `onDestroy` to clean up third-party components to prevent memory leaks.\n\n3. **Debounce updates when appropriate**: For components that might trigger rapid updates (like sliders or maps), consider debouncing updates to the `$bindable` prop.\n\n4. **Document integration details**: Make it clear in your component documentation how the binding works with the third-party library.\n\n5. **Provide configuration options**: Allow users to pass configuration options to the underlying library.\n\n6. **Handle errors gracefully**: Wrap third-party initialization in try/catch blocks and provide fallback UI if the library fails to load.\n\n7. **Consider SSR compatibility**: Some third-party libraries don't work with server-side rendering, so handle that case appropriately.\n\n### 5. Advanced Pattern: Adapter Factory\n\nFor more complex cases, you might want to create an adapter factory:\n\n```js\n// createBindableAdapter.js\nexport function createBindableAdapter(options) {\n  const {\n    initialize,\n    getValue,\n    setValue,\n    cleanup,\n    events = []\n  } = options;\n  \n  return function useBindableAdapter(element, bindableValue, updateCallback) {\n    let instance;\n    let isUpdating = false;\n    \n    function handleExternalChange() {\n      if (isUpdating) return;\n      \n      isUpdating = true;\n      updateCallback(getValue(instance));\n      isUpdating = false;\n    }\n    \n    // Initialize the third-party component\n    instance = initialize(element);\n    \n    // Set up event listeners\n    events.forEach(event => {\n      instance.on(event, handleExternalChange);\n    });\n    \n    // Return methods for updating and cleaning up\n    return {\n      update(newValue) {\n        if (isUpdating) return;\n        \n        isUpdating = true;\n        setValue(instance, newValue);\n        isUpdating = false;\n      },\n      destroy() {\n        events.forEach(event => {\n          instance.off(event, handleExternalChange);\n        });\n        cleanup(instance);\n      }\n    };\n  };\n}\n```\n\nUsing the adapter:\n\n```svelte\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  import { createBindableAdapter } from './createBindableAdapter';\n  \n  let {\n    value = $bindable(''),\n    ...props\n  } = $props();\n  \n  let element;\n  let adapter;\n  \n  const useEditor = createBindableAdapter({\n    initialize: (el) => {\n      // Initialize library and return instance\n      const editor = new FancyEditor(el, { /* config */ });\n      return editor;\n    },\n    getValue: (instance) => instance.getContent(),\n    setValue: (instance, value) => instance.setContent(value),\n    cleanup: (instance) => instance.destroy(),\n    events: ['change', 'input', 'blur']\n  });\n  \n  onMount(() => {\n    adapter = useEditor(element, value, (newValue) => {\n      value = newValue;\n    });\n  });\n  \n  $effect(() => {\n    if (adapter) {\n      adapter.update(value);\n    }\n  });\n  \n  onDestroy(() => {\n    if (adapter) {\n      adapter.destroy();\n    }\n  });\n</script>\n\n<div bind:this={element}></div>\n```\n\nBy following these patterns, you can effectively use `$bindable` with almost any third-party library, creating seamless integrations between Svelte's reactivity system and external components."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"What are the best practices for structuring component hierarchies when using `$bindable` props?","answer":"Structuring component hierarchies with `$bindable` props requires careful consideration to maintain clean data flow and component reusability. Here are comprehensive best practices for effectively using `$bindable` in component hierarchies:\n\n### 1. Limit Binding Depth\n\n**Best Practice**: Avoid binding across multiple levels of components.\n\n**Example of what to avoid**:\n```svelte\n<!-- App.svelte -->\n<script>\n  let user = $state({ name: 'John' });\n</script>\n\n<ParentComponent bind:user={user} />\n\n<!-- ParentComponent.svelte -->\n<script>\n  let { user = $bindable() } = $props();\n</script>\n\n<ChildComponent bind:user={user} />\n\n<!-- ChildComponent.svelte -->\n<script>\n  let { user = $bindable() } = $props();\n</script>\n\n<GrandchildComponent bind:user={user} />\n```\n\n**Better approach**:\n```svelte\n<!-- App.svelte -->\n<script>\n  let user = $state({ name: 'John' });\n</script>\n\n<ParentComponent bind:user={user} />\n\n<!-- ParentComponent.svelte -->\n<script>\n  let { user = $bindable() } = $props();\n</script>\n\n<ChildComponent \n  userName={user.name}\n  onNameChange={(newName) => user.name = newName} \n/>\n```\n\nWhen binding spans multiple component levels, it becomes difficult to track data flow and understand component dependencies. Limit binding to one level where possible.\n\n### 2. Use Binding Primarily for Form Components\n\n**Best Practice**: Reserve two-way binding primarily for form inputs and UI controls.\n\n**Good use case**:\n```svelte\n<!-- UserForm.svelte -->\n<script>\n  let { userData = $bindable({}) } = $props();\n</script>\n\n<div class=\"form\">\n  <TextField \n    label=\"Name\" \n    bind:value={userData.name} \n  />\n  <TextField \n    label=\"Email\" \n    bind:value={userData.email} \n  />\n</div>\n```\n\nForm components are a natural fit for two-way binding because they inherently involve both displaying and updating values.\n\n### 3. Document Bindable Props Clearly\n\n**Best Practice**: Clearly document which props are bindable and how they behave when bound.\n\n```svelte\n<script>\n  /**\n   * @prop {string} value - The input value (bindable)\n   * @prop {string} label - Label text for the input\n   * @prop {boolean} required - Whether the field is required\n   */\n  let { \n    value = $bindable(''), \n    label = '',\n    required = false,\n    ...props\n  } = $props();\n</script>\n```\n\nClear documentation helps other developers understand which props can be bound and how they should be used.\n\n### 4. Create Specialized Container Components\n\n**Best Practice**: Create specialized container components that manage related bindable props.\n\n```svelte\n<!-- AddressForm.svelte -->\n<script>\n  let { \n    address = $bindable({\n      street: '',\n      city: '',\n      state: '',\n      zip: ''\n    }) \n  } = $props();\n</script>\n\n<div class=\"address-form\">\n  <TextField label=\"Street\" bind:value={address.street} />\n  <TextField label=\"City\" bind:value={address.city} />\n  <TextField label=\"State\" bind:value={address.state} />\n  <TextField label=\"Zip Code\" bind:value={address.zip} />\n</div>\n```\n\nThis approach encapsulates related bindings within a single component, making the binding pattern clearer and more maintainable.\n\n### 5. Use Immutable Updates for Complex Objects\n\n**Best Practice**: For complex nested objects, consider using immutable update patterns even with bindable props.\n\n```svelte\n<!-- UserProfileEditor.svelte -->\n<script>\n  let { user = $bindable({}) } = $props();\n  \n  function updateAddress(field, value) {\n    // Create a new address object to ensure changes are detected\n    user = {\n      ...user,\n      address: {\n        ...user.address,\n        [field]: value\n      }\n    };\n  }\n</script>\n\n<div class=\"profile-editor\">\n  <TextField \n    label=\"Name\" \n    bind:value={user.name} \n  />\n  \n  <h3>Address</h3>\n  <TextField \n    label=\"Street\" \n    value={user.address?.street || ''}\n    on:input={(e) => updateAddress('street', e.target.value)} \n  />\n  <!-- Other address fields -->\n</div>\n```\n\nFor deeply nested objects, immutable updates can make state changes more predictable and avoid potential reactivity issues.\n\n### 6. Provide Non-Binding Alternatives\n\n**Best Practice**: Design components to work well with both binding and non-binding approaches.\n\n```svelte\n<!-- Counter.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte';\n  \n  let { \n    count = $bindable(0),\n    onChange = null\n  } = $props();\n  \n  const dispatch = createEventDispatcher();\n  \n  function increment() {\n    count += 1;\n    if (onChange) onChange(count);\n    dispatch('change', count);\n  }\n  \n  function decrement() {\n    count -= 1;\n    if (onChange) onChange(count);\n    dispatch('change', count);\n  }\n</script>\n\n<div class=\"counter\">\n  <button on:click={decrement}>-</button>\n  <span>{count}</span>\n  <button on:click={increment}>+</button>\n</div>\n```\n\nThis component can be used in multiple ways:\n```svelte\n<!-- With binding -->\n<Counter bind:count={myCount} />\n\n<!-- With callback -->\n<Counter count={myCount} onChange={(newCount) => myCount = newCount} />\n\n<!-- With event listener -->\n<Counter count={myCount} on:change={(e) => myCount = e.detail} />\n```\n\nProviding multiple interaction patterns makes components more flexible and reusable.\n\n### 7. Use Component Composition for Complex State Logic\n\n**Best Practice**: For complex state logic, use component composition rather than deep binding.\n\n```svelte\n<!-- UserManager.svelte -->\n<script>\n  let users = $state([\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' }\n  ]);\n  \n  function updateUser(id, updates) {\n    users = users.map(user => \n      user.id === id ? { ...user, ...updates } : user\n    );\n  }\n  \n  function deleteUser(id) {\n    users = users.filter(user => user.id !== id);\n  }\n</script>\n\n<div class=\"user-manager\">\n  {#each users as user (user.id)}\n    <UserCard \n      {user}\n      onUpdate={(updates) => updateUser(user.id, updates)}\n      onDelete={() => deleteUser(user.id)}\n    />\n  {/each}\n</div>\n```\n\nThis approach keeps state management logic centralized rather than distributing it across components through bindings.\n\n### 8. Avoid Circular Bindings\n\n**Best Practice**: Avoid creating circular binding dependencies between components.\n\n**Problematic pattern**:\n```svelte\n<!-- ComponentA.svelte -->\n<script>\n  let { valueA = $bindable(''), valueB = $bindable('') } = $props();\n</script>\n\n<ComponentB bind:valueA={valueB} bind:valueB={valueA} />\n```\n\nThis creates a circular reference that can lead to infinite update loops and unpredictable behavior.\n\n### 9. Use Binding with State Management\n\n**Best Practice**: When using state management, carefully consider where binding fits in the data flow.\n\n```svelte\n<!-- Using a store with binding -->\n<script>\n  import { userStore } from './stores';\n  \n  // Extract value from store\n  let userData = $state($userStore);\n  \n  // Watch for local changes and update store\n  $effect(() => {\n    userStore.set(userData);\n  });\n</script>\n\n<UserProfileForm bind:user={userData} />\n```\n\nWhen combining binding with state management, be explicit about how updates flow between bound components and your state stores.\n\n### 10. Component Architecture Patterns\n\n**Best Practice**: Structure your component hierarchy with clear data flow patterns.\n\n#### Container/Presentational Pattern:\n```svelte\n<!-- UserContainer.svelte (container) -->\n<script>\n  import { fetchUser, updateUser } from './api';\n  \n  let userId = $props().userId;\n  let userData = $state(null);\n  let isLoading = $state(true);\n  let error = $state(null);\n  \n  async function loadUser() {\n    isLoading = true;\n    error = null;\n    \n    try {\n      userData = await fetchUser(userId);\n    } catch (err) {\n      error = err.message;\n    } finally {\n      isLoading = false;\n    }\n  }\n  \n  async function handleUserUpdate(updatedData) {\n    try {\n      await updateUser(userId, updatedData);\n      userData = updatedData;\n    } catch (err) {\n      error = err.message;\n    }\n  }\n  \n  // Load user data initially\n  loadUser();\n</script>\n\n{#if isLoading}\n  <LoadingSpinner />\n{:else if error}\n  <ErrorMessage message={error} onRetry={loadUser} />\n{:else}\n  <UserProfile \n    user={userData}\n    onUpdate={handleUserUpdate}\n  />\n{/if}\n```\n\n```svelte\n<!-- UserProfile.svelte (presentational) -->\n<script>\n  import { createEventDispatcher } from 'svelte';\n  \n  let { \n    user = $props(),\n    onUpdate = $props()\n  } = $props();\n  \n  let editMode = $state(false);\n  let editedUser = $state({ ...user });\n  \n  function saveChanges() {\n    onUpdate(editedUser);\n    editMode = false;\n  }\n  \n  function startEditing() {\n    editedUser = { ...user };\n    editMode = true;\n  }\n  \n  function cancelEditing() {\n    editedUser = { ...user };\n    editMode = false;\n  }\n</script>\n\n<div class=\"user-profile\">\n  {#if editMode}\n    <UserForm bind:userData={editedUser} />\n    <div class=\"actions\">\n      <button on:click={saveChanges}>Save</button>\n      <button on:click={cancelEditing}>Cancel</button>\n    </div>\n  {:else}\n    <UserDisplay user={user} />\n    <button on:click={startEditing}>Edit</button>\n  {/if}\n</div>\n```\n\nThis pattern keeps state management logic in container components while presentational components focus on UI rendering and user interactions.\n\nBy following these best practices, you can create component hierarchies that use `$bindable` effectively while maintaining clear data flow, reusability, and maintainability in your Svelte 5 applications."}
{"source":"docs/svelte/02-runes/06-$bindable.md","question":"What is the relationship between `$bindable` and Svelte 5's `$state` and `$derived` runes?","answer":"The relationship between `$bindable` and other Svelte 5 runes like `$state` and `$derived` is an important aspect of understanding Svelte's reactivity system. These runes work together to create a cohesive reactive programming model, but they serve different purposes and have distinct interactions.\n\n### Basic Relationship Overview\n\n1. **`$state`**: Creates a reactive state variable that triggers updates when modified\n2. **`$derived`**: Creates a computed value that updates automatically when its dependencies change\n3. **`$bindable`**: Marks a component prop as capable of two-way binding\n\nThese runes work together in a complementary fashion, with `$bindable` often serving as a bridge between parent component state and child component interactions.\n\n### How `$bindable` Works with `$state`\n\nThe most common pattern is using `$bindable` props in child components that connect to `$state` variables in parent components:\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  // Create a reactive state variable\n  let count = $state(0);\n</script>\n\n<ChildComponent bind:value={count} />\n<p>Current count: {count}</p>\n```\n\n```svelte\n<!-- ChildComponent.svelte -->\n<script>\n  // Mark the prop as bindable\n  let { value = $bindable(0) } = $props();\n</script>\n\n<button on:click={() => value++}>Increment</button>\n<button on:click={() => value--}>Decrement</button>\n```\n\nIn this example:\n1. The parent creates a reactive `count` using `$state`\n2. The child receives this as a `$bindable` prop\n3. When the child modifies the value, the parent's state is updated\n4. When the parent's state changes (from any source), the child receives the updated value\n\nThis creates a seamless reactive circuit between parent and child components.\n\n### `$bindable` vs. `$state`\n\nWhile both enable reactivity, they serve different purposes:\n\n1. **Scope and Ownership**:\n   - `$state` creates a reactive variable owned by the component\n   - `$bindable` marks a prop that can be modified but is ultimately owned by the parent\n\n2. **Declaration Context**:\n   - `$state` is used for local component state\n   - `$bindable` is used specifically for component props\n\n3. **Update Mechanism**:\n   - `$state` updates trigger reactivity within the component\n   - `$bindable` updates propagate changes back to the parent's state\n\n### `$bindable` and `$derived`\n\n`$bindable` and `$derived` have an interesting relationship:\n\n1. **Direction"}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"What is the $inspect rune in Svelte 5, and how does it differ from using console.log?","answer":"The $inspect rune in Svelte 5 is a debugging utility similar to console.log, but with reactive capabilities. The key difference is that $inspect will re-run automatically whenever its arguments change.\n\nUnlike console.log, $inspect tracks reactive state deeply, meaning it will detect and report changes even when they occur inside nested objects or arrays when using fine-grained reactivity.\n\nHere's a basic example of using $inspect:\n\n```svelte\n<script>\n  let count = $state(0);\n  let message = $state('hello');\n  \n  // This will log to the console whenever count or message changes\n  $inspect(count, message);\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\nIn this example, clicking the button or typing in the input will trigger the $inspect rune to run again, logging the updated values to the console. With regular console.log, you would only see the initial values when the component first renders."}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"How can you customize the behavior of $inspect to perform actions other than logging to the console?","answer":"The $inspect rune returns a property called `with` that allows you to customize its behavior. You can invoke this property with a callback function that will be used instead of console.log.\n\nThe callback receives at least two arguments:\n1. The first argument is a string indicating the type of call - either \"init\" (for the initial run) or \"update\" (when reactive values change)\n2. The subsequent arguments are the values that were passed to $inspect\n\nThis allows for powerful custom debugging workflows. Here's an example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let user = $state({ name: 'Alice', role: 'Admin' });\n  \n  // Custom handling of reactive changes\n  $inspect(count, user).with((type, countValue, userValue) => {\n    if (type === 'update') {\n      console.log(`Count changed to: ${countValue}`);\n      console.log(`User is now:`, userValue);\n      \n      // You could add conditional breakpoints\n      if (countValue > 10) {\n        debugger;\n      }\n      \n      // Or log to a custom logging service\n      // myLoggingService.log('State updated', { count: countValue, user: userValue });\n    }\n  });\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<button onclick={() => user.role = 'User'}>Change Role</button>\n```\n\nThis approach gives you fine-grained control over debugging behavior, allowing you to implement conditional breakpoints, custom logging formats, or integration with monitoring tools."}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"How can you use $inspect to help trace the origin of state changes in a Svelte 5 application?","answer":"A common debugging challenge is determining where a particular state change originated from. The $inspect rune provides a convenient way to address this with the `with` method combined with `console.trace`.\n\nWhen you pass `console.trace` to the `with` method, it will print a stack trace to the console whenever the reactive values change, helping you identify which part of your code triggered the update:\n\n```svelte\n<script>\n  let count = $state(0);\n  let items = $state([1, 2, 3]);\n  \n  // This will print a stack trace whenever count or items change\n  $inspect(count, items).with(console.trace);\n  \n  function addItem() {\n    items = [...items, items.length + 1];\n  }\n  \n  function incrementCount() {\n    count++;\n  }\n</script>\n\n<button onclick={incrementCount}>Increment</button>\n<button onclick={addItem}>Add Item</button>\n```\n\nWhen either button is clicked, you'll see a stack trace in the console that shows exactly which function and event handler triggered the state change. This is particularly valuable in larger applications where state might be modified from multiple places.\n\nThe shorthand syntax is particularly clean:\n\n```js\n$inspect(someReactiveValue).with(console.trace);\n```\n\nThis approach saves time when debugging complex reactive flows and helps maintain a clear understanding of your application's state management."}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"What is $inspect.trace() and when was it introduced to Svelte 5?","answer":"The `$inspect.trace()` rune was added in Svelte 5.14 as a specialized debugging tool for tracing reactive updates within functions. Unlike the regular $inspect rune, which logs specific values, $inspect.trace() causes the surrounding function to be traced during development.\n\nWhen used inside an effect or derived value, $inspect.trace() will print information to the console about which pieces of reactive state caused the effect to re-run. This provides valuable visibility into the reactivity system's behavior.\n\nHere's how to use it:\n\n```svelte\n<script>\n  import { doSomeWork } from './elsewhere';\n  \n  let count = $state(0);\n  let name = $state('Svelte');\n  \n  $effect(() => {\n    // This will trace which reactive values trigger this effect\n    $inspect.trace();\n    \n    console.log(`Doing work with count=${count} and name=${name}`);\n    doSomeWork(count, name);\n  });\n</script>\n\n<button onclick={() => count++}>Update Count</button>\n<input bind:value={name} />\n```\n\nWhen the count or name changes, the console will show which specific reactive value triggered the effect to re-run. This is extremely helpful when debugging complex reactive chains or when trying to optimize performance by reducing unnecessary re-computations.\n\n$inspect.trace() can be used in both $effect and $derived contexts to better understand the reactivity flow in your application."}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"How can you add custom labels when using $inspect.trace() in Svelte 5?","answer":"When using $inspect.trace() in Svelte 5, you can provide an optional string argument that serves as a label for the trace output. This label helps identify different trace points in your code, making debugging more manageable in applications with multiple traced effects.\n\nHere's how to use labeled traces:\n\n```svelte\n<script>\n  let user = $state({ name: 'Alice', role: 'Admin' });\n  let settings = $state({ theme: 'dark', notifications: true });\n  \n  // A labeled trace for user-related effects\n  $effect(() => {\n    $inspect.trace('USER-EFFECT');\n    \n    // This effect processes user data\n    console.log(`Processing user: ${user.name} with role ${user.role}`);\n    updateUserInterface(user);\n  });\n  \n  // A different labeled trace for settings-related effects\n  $effect(() => {\n    $inspect.trace('SETTINGS-EFFECT');\n    \n    // This effect handles settings changes\n    console.log(`Applying settings: theme=${settings.theme}`);\n    applyTheme(settings.theme);\n  });\n  \n  function updateUserInterface(user) {\n    // Implementation details...\n  }\n  \n  function applyTheme(theme) {\n    // Implementation details...\n  }\n</script>\n\n<button onclick={() => user.role = 'Editor'}>Change Role</button>\n<button onclick={() => settings.theme = 'light'}>Toggle Theme</button>\n```\n\nIn this example, when the user's role changes, the console will show a trace labeled \"USER-EFFECT\", making it clear which effect was triggered. Similarly, changing the theme will produce a trace labeled \"SETTINGS-EFFECT\".\n\nThis labeling approach is particularly valuable in larger applications with many effects, as it helps you quickly identify which specific reactivity path was activated without having to decipher the entire stack trace."}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"How does $inspect handle deep reactivity in Svelte 5, and can you provide an example demonstrating this feature?","answer":"The $inspect rune in Svelte 5 is designed to track reactive state deeply, meaning it will detect and report changes even when they occur inside nested objects or arrays through fine-grained reactivity. This deep tracking capability makes $inspect particularly powerful for debugging complex state structures.\n\nHere's an example demonstrating deep reactivity tracking with $inspect:\n\n```svelte\n<script>\n  // Create a complex nested state structure\n  let user = $state({\n    personal: {\n      name: 'Alice',\n      age: 28\n    },\n    preferences: {\n      theme: 'dark',\n      notifications: {\n        email: true,\n        push: false\n      }\n    },\n    friends: ['Bob', 'Charlie', 'Diana']\n  });\n  \n  // Track the entire user object\n  $inspect(user);\n  \n  function updateName() {\n    // Modify a deeply nested property\n    user.personal.name = 'Alicia';\n  }\n  \n  function togglePushNotifications() {\n    // Toggle a deeply nested boolean\n    user.preferences.notifications.push = !user.preferences.notifications.push;\n  }\n  \n  function addFriend() {\n    // Modify an array inside the state\n    user.friends = [...user.friends, 'Eve'];\n  }\n</script>\n\n<button onclick={updateName}>Update Name</button>\n<button onclick={togglePushNotifications}>Toggle Push</button>\n<button onclick={addFriend}>Add Friend</button>\n\n<pre>{JSON.stringify(user, null, 2)}</pre>\n```\n\nIn this example, $inspect(user) will re-run and log to the console whenever:\n1. The user's name is changed (nested object property)\n2. The push notification setting is toggled (deeply nested boolean)\n3. A new friend is added to the array (array modification)\n\nThis deep reactivity tracking works because Svelte 5's fine-grained reactivity system can detect changes at any level of nesting within a reactive state object. The $inspect rune leverages this capability to provide comprehensive debugging information.\n\nWithout $inspect, you would need to manually add console.log statements throughout your code to track these changes, which would be more cumbersome and less reliable."}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"Can you use $inspect with multiple independent reactive values, and how would you implement conditional debugging based on specific state changes?","answer":"Yes, $inspect can be used with multiple independent reactive values, allowing you to monitor several pieces of state simultaneously. This is useful for debugging interactions between different parts of your application state.\n\nYou can also implement conditional debugging by combining $inspect.with() and custom logic to focus on specific state changes or conditions. Here's an example demonstrating both capabilities:\n\n```svelte\n<script>\n  // Define multiple independent reactive values\n  let count = $state(0);\n  let searchQuery = $state('');\n  let results = $state([]);\n  let isLoading = $state(false);\n  \n  // Monitor multiple values with a single $inspect\n  $inspect(count, searchQuery, results, isLoading).with((type, countVal, queryVal, resultsVal, loadingVal) => {\n    // Only log when we're not in the initial setup\n    if (type === 'update') {\n      // Create a custom formatted log\n      console.group('State Update');\n      \n      // Conditional debugging based on which values changed\n      if (countVal !== count) {\n        console.log(`Count changed: ${count} â ${countVal}`);\n      }\n      \n      if (queryVal !== searchQuery) {\n        console.log(`Search query changed: \"${searchQuery}\" â \"${queryVal}\"`);\n      }\n      \n      if (resultsVal !== results) {\n        console.log(`Results updated: ${results.length} â ${resultsVal.length} items`);\n        \n        // Additional detailed logging for significant changes\n        if (resultsVal.length > 10) {\n          console.warn('Large result set detected - check for performance issues');\n        }\n      }\n      \n      if (loadingVal !== isLoading) {\n        console.log(`Loading state: ${isLoading} â ${loadingVal}`);\n      }\n      \n      console.groupEnd();\n      \n      // Store the new values for the next comparison\n      count = countVal;\n      searchQuery = queryVal;\n      results = resultsVal;\n      isLoading = loadingVal;\n    }\n  });\n  \n  // Simulate search functionality\n  async function performSearch() {\n    isLoading = true;\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Update results based on search query\n    results = Array.from({ length: searchQuery.length * 2 }, (_, i) => \n      `Result ${i} for \"${searchQuery}\"`\n    );\n    \n    isLoading = false;\n    count++;\n  }\n</script>\n\n<input \n  bind:value={searchQuery} \n  placeholder=\"Search...\"\n/>\n<button \n  onclick={performSearch}\n  disabled={isLoading}\n>\n  {isLoading ? 'Searching...' : 'Search'}\n</button>\n\n<div>Search count: {count}</div>\n\n<ul>\n  {#each results as result}\n    <li>{result}</li>\n  {/each}\n</ul>\n```\n\nIn this example:\n1. We're tracking four different reactive values with a single $inspect call\n2. We use the .with() method to provide custom handling logic\n3. We implement conditional logging that only reports values that have actually changed\n4. We add specialized warnings for specific conditions (like large result sets)\n\nThis approach gives you fine-grained control over debugging output, allowing you to focus on relevant changes and reduce console noise. It's particularly valuable in complex applications where many state changes might be happening simultaneously."}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"How can you combine $inspect with $effect for debugging reactive workflows in Svelte 5?","answer":"Combining $inspect with $effect creates a powerful debugging setup for reactive workflows in Svelte 5. While $inspect by itself tracks and logs changes to reactive values, using it within $effect lets you implement more sophisticated debugging strategies and respond to state changes with custom logic.\n\nHere's an example demonstrating how to combine these features:\n\n```svelte\n<script>\n  // Define some reactive state\n  let count = $state(0);\n  let threshold = $state(5);\n  let history = $state([]);\n  \n  // Basic inspection of individual values\n  $inspect(count);\n  $inspect(threshold);\n  \n  // Use $effect for more complex debugging scenarios\n  $effect(() => {\n    // This effect runs whenever count or threshold changes\n    console.group(`Effect triggered [count: ${count}, threshold: ${threshold}]`);\n    \n    // Log the relationship between values\n    if (count > threshold) {\n      console.warn(`Count (${count}) exceeds threshold (${threshold})`);\n    } else {\n      console.log(`Count (${count}) is within threshold (${threshold})`);\n    }\n    \n    // Track state changes over time\n    history = [...history, { \n      timestamp: new Date().toISOString(),\n      count, \n      threshold,\n      exceeds: count > threshold\n    }];\n    \n    // Use $inspect.trace() within the effect to trace what triggered it\n    $inspect.trace('COUNT-THRESHOLD-EFFECT');\n    \n    console.groupEnd();\n  });\n  \n  // Another effect to demonstrate debugging asynchronous workflows\n  $effect(() => {\n    if (count > threshold) {\n      // Debug async operations\n      console.log(`Starting async operation for count=${count}`);\n      \n      simulateAsyncOperation(count).then(result => {\n        console.log(`Async operation completed with result: ${result}`);\n      });\n    }\n  });\n  \n  async function simulateAsyncOperation(value) {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return value * 2;\n  }\n  \n  // Function to export debug data\n  function exportDebugData() {\n    const debugData = {\n      currentState: { count, threshold },\n      history,\n      timestamp: new Date().toISOString()\n    };\n    \n    console.log('Exporting debug data:', debugData);\n    \n    // In a real app, you might download this as JSON\n    // or send it to a monitoring service\n    const dataStr = JSON.stringify(debugData, null, 2);\n    const dataUri = `data:application/json;charset=utf-8,${encodeURIComponent(dataStr)}`;\n    \n    const linkElement = document.createElement('a');\n    linkElement.setAttribute('href', dataUri);\n    linkElement.setAttribute('download', 'svelte-debug-data.json');\n    linkElement.click();\n  }\n</script>\n\n<div>\n  <button onclick={() => count++}>Increment Count</button>\n  <button onclick={() => count--}>Decrement Count</button>\n  <input type=\"number\" bind:value={threshold} />\n  <button onclick={exportDebugData}>Export Debug Data</button>\n</div>\n\n<div>\n  <h3>Current State</h3>\n  <p>Count: {count}</p>\n  <p>Threshold: {threshold}</p>\n  <p>Status: {count > threshold ? 'Exceeds threshold' : 'Within threshold'}</p>\n</div>\n\n<div>\n  <h3>History ({history.length} events)</h3>\n  <ul>\n    {#each history as entry}\n      <li>\n        {new Date(entry.timestamp).toLocaleTimeString()}: \n        Count={entry.count}, Threshold={entry.threshold}\n        {entry.exceeds ? 'â ï¸ Exceeded' : 'â Within limit'}\n      </li>\n    {/each}\n  </ul>\n</div>\n```\n\nIn this example:\n\n1. We use basic $inspect to track individual reactive values (count and threshold)\n2. We create an $effect that runs whenever count or threshold changes, providing detailed logging\n3. We use $inspect.trace() within the effect to identify what triggered each run\n4. We maintain a history of state changes for debugging purposes\n5. We implement a second effect to demonstrate debugging asynchronous operations\n6. We provide a function to export debug data for offline analysis\n\nThis combination of techniques creates a comprehensive debugging setup that:\n- Tracks individual value changes\n- Monitors relationships between values\n- Records a history of state changes\n- Identifies what triggered each effect\n- Handles asynchronous workflows\n- Allows exporting debug data\n\nThis approach is particularly valuable for complex applications where you need to understand not just what changed, but the implications of those changes and how they flow through your reactive system."}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"What are the performance implications of using $inspect in a production Svelte 5 application, and what best practices should be followed?","answer":"Using $inspect in a production Svelte 5 application can have performance implications, as it adds additional reactivity tracking and logging overhead. Here's a comprehensive look at the performance considerations and best practices:\n\n### Performance Implications\n\n1. **Increased Memory Usage**: Each $inspect call creates additional reactivity subscriptions, which consume memory.\n\n2. **Processing Overhead**: When tracked values change, $inspect re-runs its logging logic, which adds CPU overhead.\n\n3. **Console Bloat**: Excessive logging can slow down the browser's developer tools and make it harder to find relevant information.\n\n4. **Network Impact**: If you're sending logs to a remote service, this creates additional network traffic.\n\n5. **Render Performance**: Heavy use of $inspect, especially with complex objects, might impact rendering performance.\n\n### Best Practices\n\nTo mitigate these concerns, follow these best practices when using $inspect:\n\n#### 1. Remove or Disable in Production\n\nThe most important practice is to ensure $inspect calls don't run in production:\n\n```svelte\n<script>\n  import { dev } from '$app/environment'; // For SvelteKit\n  \n  let count = $state(0);\n  \n  // Only run in development\n  if (dev) {\n    $inspect(count);\n  }\n</script>\n```\n\nFor non-SvelteKit projects, you can use environment variables or build flags:\n\n```svelte\n<script>\n  const isDevelopment = import.meta.env.DEV; // Vite\n  // or\n  // const isDevelopment = process.env.NODE_ENV !== 'production'; // Webpack\n  \n  let user = $state({ name: 'Alice' });\n  \n  if (isDevelopment) {\n    $inspect(user);\n  }\n</script>\n```\n\n#### 2. Create a Debug Utility\n\nCreate a wrapper utility that centralizes debug logic:\n\n```js\n// debug.js\nexport function debugInspect(...args) {\n  if (import.meta.env.DEV) {\n    return $inspect(...args);\n  }\n  \n  // Return a dummy object with a with method that does nothing\n  return {\n    with: () => {}\n  };\n}\n```\n\nThen use it in your components:\n\n```svelte\n<script>\n  import { debugInspect } from './debug';\n  \n  let count = $state(0);\n  \n  debugInspect(count);\n</script>\n```\n\n#### 3. Be Selective About What You Inspect\n\nInstead of inspecting large objects, focus on specific properties:\n\n```svelte\n<script>\n  let user = $state({\n    name: 'Alice',\n    profile: { /* large object */ },\n    history: [ /* large array */ ]\n  });\n  \n  // Bad: Inspects the entire large object\n  // $inspect(user);\n  \n  // Better: Focus on specific properties of interest\n  $inspect(user.name);\n  \n  // Or track a derived value\n  $inspect($derived(user.history.length));\n</script>\n```\n\n#### 4. Use Conditional Inspection\n\nOnly activate inspection when specific conditions are met:\n\n```svelte\n<script>\n  let count = $state(0);\n  let isDebugging = $state(false);\n  \n  $effect(() => {\n    if (isDebugging && count > 10) {\n      $inspect(count).with(console.trace);\n    }\n  });\n</script>\n\n<!-- Toggle for enabling detailed debugging -->\n<label>\n  <input type=\"checkbox\" bind:checked={isDebugging} />\n  Enable Debugging\n</label>\n```\n\n#### 5. Implement Log Throttling\n\nFor frequently changing values, throttle the logging:\n\n```svelte\n<script>\n  import { throttle } from 'lodash-es';\n  \n  let position = $state({ x: 0, y: 0 });\n  \n  // Create a throttled logging function\n  const throttledLog = throttle(\n    (type, pos) => console.log(`Position: ${pos.x},${pos.y}`),\n    500 // Log at most every 500ms\n  );\n  \n  // Use the throttled function with $inspect\n  $inspect(position).with(throttledLog);\n  \n  function trackMouseMove(e) {\n    position = { x: e.clientX, y: e.clientY };\n  }\n</script>\n\n<div on:mousemove={trackMouseMove} style=\"height: 300px; border: 1px solid #ccc;\">\n  Move mouse here: {position.x}, {position.y}\n</div>\n```\n\n#### 6. Use Feature Flags for Complex Debugging\n\nImplement a feature flag system for enabling different levels of debugging:\n\n```js\n// debug-config.js\nexport const debugFlags = {\n  userActions: false,\n  networkRequests: false,\n  performanceMetrics: false,\n  stateChanges: true\n};\n```\n\n```svelte\n<script>\n  import { debugFlags } from './debug-config';\n  \n  let user = $state({ name: 'Alice' });\n  \n  if (import.meta.env.DEV && debugFlags.stateChanges) {\n    $inspect(user);\n  }\n</script>\n```\n\nBy following these best practices, you can leverage the powerful debugging capabilities of $inspect during development while ensuring it doesn't impact your production application's performance."}
{"source":"docs/svelte/02-runes/07-$inspect.md","question":"How does $inspect.trace() differ from regular $inspect, and in what scenarios would you choose one over the other?","answer":"$inspect.trace() and regular $inspect serve different debugging purposes in Svelte 5, and understanding their differences helps choose the right tool for specific debugging scenarios.\n\n### Key Differences\n\n1. **Purpose**:\n   - **$inspect**: Monitors specific reactive values and logs them when they change\n   - **$inspect.trace()**: Traces the execution of a function (typically an effect or derived value) to identify what reactive dependencies triggered it\n\n2. **Output**:\n   - **$inspect**: Logs the actual values being tracked\n   - **$inspect.trace()**: Provides information about which reactive dependencies caused the surrounding function to re-run\n\n3. **Usage Context**:\n   - **$inspect**: Can be used anywhere in your code\n   - **$inspect.trace()**: Designed to be used inside $effect or $derived functions\n\n4. **Introduction**:\n   - **$inspect**: Available since the initial release of Svelte 5 runes\n   - **$inspect.trace()**: Added in Svelte 5.14\n\n### When to Use $inspect\n\nUse regular $inspect when you want to:\n\n1. **Monitor Specific Values**: Track particular state variables and see their values when they change\n\n```svelte\n<script>\n  let user = $state({ name: 'Alice', role: 'Admin' });\n  let settings = $state({ theme: 'dark' });\n  \n  // Monitor specific values\n  $inspect(user.role, settings.theme);\n</script>\n```\n\n2. **Debug Data Transformations**: See how data is being transformed or processed\n\n```svelte\n<script>\n  let rawData = $state([1, 2, 3, 4, 5]);\n  \n  // See the original data\n  $inspect(rawData);\n  \n  // Process the data\n  let processedData = $derived(rawData.map(x => x * 2));\n  \n  // See the transformed result\n  $inspect(processedData);\n</script>\n```\n\n3. **Custom Debugging Logic**: Implement specialized debugging with the .with() method\n\n```svelte\n<script>\n  let count = $state(0);\n  \n  // Custom debugging with conditional breakpoints\n  $inspect(count).with((type, value) => {\n    if (type === 'update' && value > 10) {\n      console.warn(`Count exceeded threshold: ${value}`);\n      debugger;\n    }\n  });\n</script>\n```\n\n### When to Use $inspect.trace()\n\nUse $inspect.trace() when you want to:\n\n1. **Identify Reactive Triggers**: Determine which reactive dependencies are causing an effect to re-run\n\n```svelte\n<script>\n  let count = $state(0);\n  let name = $state('Svelte');\n  let settings = $state({ theme: 'dark' });\n  \n  $effect(() => {\n    // Find out which state variable triggered this effect\n    $inspect.trace('UI-UPDATE-EFFECT');\n    \n    // This effect uses multiple reactive values\n    document.title = `${name} (${count})`;\n    document.body.className = settings.theme;\n  });\n</script>\n```\n\n2. **Debug Complex Reactivity Chains**: Understand the flow of reactivity in complex components\n\n```svelte\n<script>\n  let formData = $state({\n    name: '',\n    email: '',\n    preferences: { newsletter: false }\n  });\n  \n  let validationErrors = $derived(() => {\n    // Trace what's triggering validation recalculations\n    $inspect.trace('VALIDATION');\n    \n    const errors = {};\n    \n    if (!formData.name) errors.name = 'Name is required';\n    if (!formData.email) errors.email = 'Email is required';\n    else if (!formData.email.includes('@')) errors.email = 'Invalid email format';\n    \n    return errors;\n  });\n  \n  $effect(() => {\n    // Trace what's triggering UI updates\n    $inspect.trace('FORM-UI-UPDATE');\n    \n    // Update UI based on validation state\n    updateFormUI(validationErrors);\n  });\n  \n  function updateFormUI(errors) {\n    // Implementation details...\n  }\n</script>\n```\n\n3. **Performance Optimization**: Identify unnecessary reactive recalculations\n\n```svelte\n<script>\n  let items = $state([\n    { id: 1, name: 'Item 1', category: 'A' },\n    { id: 2, name: 'Item 2', category: 'B' },\n    // More items...\n  ]);\n  \n  let filter = $state({ category: null });\n  \n  let filteredItems = $derived(() => {\n    // Trace when filtering happens and why\n    $inspect.trace('ITEM-FILTERING');\n    \n    if (!filter.category) return items;\n    return items.filter(item => item.category === filter.category);\n  });\n  \n  function addItem() {\n    // Add new item\n    items = [...items, { id: items.length + 1, name: `Item ${items.length + 1}`, category: 'A' }];\n  }\n</script>\n```\n\n### Combining Both Approaches\n\nFor comprehensive debugging, you can combine both methods:\n\n```svelte\n<script>\n  let userData = $state({\n    name: 'Alice',\n    email: 'alice@example.com',\n    preferences: { theme: 'dark', notifications: true }\n  });\n  \n  // Track specific values with $inspect\n  $inspect(userData.preferences);\n  \n  $effect(() => {\n    // Trace what triggered this effect\n    $inspect.trace('THEME-EFFECT');\n    \n    // Also log the specific value being used\n    $inspect(userData.preferences.theme);\n    \n    // Apply theme\n    document.body.className = userData.preferences.theme;\n  });\n</script>\n```\n\nThis combined approach gives you both the \"what\" (the actual values) and the \"why\" (which dependencies triggered the update), providing a complete picture for debugging complex reactive flows.\n\nIn summary, use regular $inspect when you need to see the actual values changing, and use $inspect.trace() when you need to understand what's triggering reactivity in your effects and derived values. For complex debugging scenarios, consider using both together for maximum visibility into your application's behavior."}
{"source":"docs/svelte/02-runes/08-$host.md","question":"What is the purpose of the `$host` rune in Svelte 5, and in what context can it be used?","answer":"The `$host` rune in Svelte 5 provides access to the host element when a component is compiled as a custom element. It's specifically designed for use with custom elements and allows you to interact with the host element directly.\n\nThe `$host` rune can only be used in components that have been designated as custom elements using the `<svelte:options customElement=\"element-name\" />` directive. It returns a reference to the actual DOM element that represents your custom element in the page.\n\nThis is particularly useful for operations like:\n- Dispatching custom events from the custom element\n- Accessing or modifying attributes and properties of the host element\n- Adding or removing event listeners to the host element\n- Manipulating the host element's style or class list\n\nHere's a basic example of using `$host` to dispatch custom events:\n\n```svelte\n<svelte:options customElement=\"my-counter\" />\n\n<script>\n  let count = $state(0);\n  \n  function increment() {\n    count++;\n    $host().dispatchEvent(new CustomEvent('changed', { \n      detail: { count } \n    }));\n  }\n</script>\n\n<button on:click={increment}>\n  Count: {count}\n</button>\n```\n\nThis custom element can then be used in any HTML or framework with event listeners:\n\n```html\n<my-counter id=\"counter\"></my-counter>\n\n<script>\n  document.getElementById('counter').addEventListener('changed', (e) => {\n    console.log('New count:', e.detail.count);\n  });\n</script>\n```\n\nWithout the `$host` rune, it would be much more difficult to create custom elements that can communicate with their containing environment."}
{"source":"docs/svelte/02-runes/08-$host.md","question":"How do you create a custom element in Svelte 5 that can dispatch events to its parent, and how does the `$host` rune facilitate this?","answer":"Creating a custom element in Svelte 5 that can dispatch events to its parent involves three main steps:\n\n1. Designating the component as a custom element\n2. Using the `$host` rune to access the host element\n3. Dispatching custom events from the host element\n\nHere's a detailed walkthrough:\n\nFirst, you need to mark your Svelte component as a custom element using the `<svelte:options>` directive:\n\n```svelte\n<svelte:options customElement=\"color-picker\" />\n```\n\nNext, you can use the `$host` rune to create a function that dispatches events from the custom element:\n\n```svelte\n<svelte:options customElement=\"color-picker\" />\n\n<script>\n  let selectedColor = $state('#ff0000');\n  \n  function dispatch(eventName, detail) {\n    // Use $host() to get a reference to the custom element itself\n    $host().dispatchEvent(new CustomEvent(eventName, { \n      detail,\n      bubbles: true,\n      composed: true // Allows the event to cross the shadow DOM boundary\n    }));\n  }\n  \n  function updateColor(newColor) {\n    selectedColor = newColor;\n    dispatch('color-change', { color: selectedColor });\n  }\n</script>\n\n<div class=\"color-picker\">\n  <input \n    type=\"color\" \n    value={selectedColor} \n    on:input={(e) => updateColor(e.target.value)}\n  />\n  <span>Selected: {selectedColor}</span>\n</div>\n\n<style>\n  .color-picker {\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n    padding: 12px;\n    border: 1px solid #ccc;\n  }\n</style>\n```\n\nThen, in the parent application, you can use this custom element and listen for its events:\n\n```svelte\n<script>\n  import './ColorPicker.svelte';\n  \n  let currentColor = $state('#ff0000');\n  \n  function handleColorChange(event) {\n    currentColor = event.detail.color;\n  }\n</script>\n\n<div class=\"app\">\n  <h1>Color Picker Demo</h1>\n  \n  <color-picker \n    oncolor-change={handleColorChange}\n  ></color-picker>\n  \n  <div class=\"color-preview\" style=\"background-color: {currentColor}\">\n    Current color: {currentColor}\n  </div>\n</div>\n\n<style>\n  .color-preview {\n    margin-top: 20px;\n    padding: 40px;\n    color: white;\n    text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);\n  }\n</style>\n```\n\nThe `$host` rune is crucial here because:\n1. It provides direct access to the custom element instance in the DOM\n2. It allows the component to dispatch events that can be listened to using standard DOM event patterns\n3. It enables the custom element to communicate with any parent environment, not just Svelte applications\n\nWithout `$host`, the component would be isolated and unable to communicate with its parent through the standard web component event system."}
{"source":"docs/svelte/02-runes/08-$host.md","question":"What are the limitations of using the `$host` rune in Svelte 5, and when is it not available?","answer":"The `$host` rune in Svelte 5 comes with several important limitations:\n\n1. **Only available in custom elements**: The `$host` rune can only be used in components that have been explicitly designated as custom elements using the `<svelte:options customElement=\"element-name\" />` directive. If you try to use `$host` in a regular Svelte component, you'll get a compilation error.\n\n2. **Returns null during SSR**: During server-side rendering (SSR), the `$host` rune will return null because there is no actual DOM element on the server.\n\n3. **No access before initialization**: The host element reference is only available after the component has been initialized. Trying to use `$host()` in top-level code might result in errors.\n\n4. **Limited to the host element**: The `$host` rune only provides access to the custom element itself, not to its shadow DOM or internal components.\n\n5. **Not reactive**: Changes to the host element won't automatically trigger reactivity in your component.\n\nHere's an example demonstrating these limitations:\n\n```svelte\n<!-- This will NOT work - no customElement option -->\n<script>\n  // This will cause a compilation error\n  console.log($host());\n  \n  function handleClick() {\n    // This would also fail\n    $host().classList.add('active');\n  }\n</script>\n\n<button on:click={handleClick}>Click me</button>\n```\n\nTo use `$host` correctly:\n\n```svelte\n<svelte:options customElement=\"my-element\" />\n\n<script>\n  // Don't use $host at the top level\n  // console.log($host()); // Could be null or undefined\n  \n  // Instead, use it in functions that will be called after initialization\n  function initialize() {\n    // Safe to use here\n    const host = $host();\n    if (host) {\n      host.classList.add('initialized');\n    }\n  }\n  \n  // Using $effect to ensure the component is mounted\n  $effect(() => {\n    initialize();\n  });\n  \n  function handleClick() {\n    const host = $host();\n    if (host) {\n      host.classList.toggle('active');\n    }\n  }\n</script>\n\n<button on:click={handleClick}>Click me</button>\n```\n\nAlternative approaches when `$host` is not available:\n- For regular components, use Svelte's built-in `dispatch` function to create component events\n- Use refs with `bind:this` to access DOM elements\n- For more complex state management between components, consider using stores or context\n\nRemember that `$host` is specifically designed for the web components use case and not as a general-purpose DOM manipulation tool."}
{"source":"docs/svelte/02-runes/08-$host.md","question":"How does event handling with `$host` differ from Svelte's standard event handling with `createEventDispatcher`?","answer":"Event handling with `$host` differs significantly from Svelte's standard event handling with `createEventDispatcher`. These differences stem from their distinct purposes and contexts:\n\n### `$host` Event Handling\n\nThe `$host` rune is used for dispatching DOM events from custom elements:\n\n```svelte\n<svelte:options customElement=\"custom-slider\" />\n\n<script>\n  let value = $state(50);\n  \n  function updateValue(newValue) {\n    value = newValue;\n    // Dispatch a standard DOM CustomEvent\n    $host().dispatchEvent(new CustomEvent('value-change', {\n      detail: { value },\n      bubbles: true\n    }));\n  }\n</script>\n\n<input \n  type=\"range\" \n  min=\"0\" \n  max=\"100\" \n  bind:value \n  on:input={() => updateValue(value)}\n/>\n<span>{value}%</span>\n```\n\nUsage in any environment (not just Svelte):\n\n```html\n<!-- In regular HTML -->\n<custom-slider id=\"slider\"></custom-slider>\n\n<script>\n  document.getElementById('slider').addEventListener('value-change', (event) => {\n    console.log('New value:', event.detail.value);\n  });\n</script>\n```\n\n```jsx\n{/* In React */}\n<custom-slider onvalue-change={(e) => console.log(e.detail.value)} />\n```\n\n### `createEventDispatcher` Event Handling\n\nSvelte's standard event dispatcher is used for component-to-component communication within Svelte:\n\n```svelte\n<!-- Slider.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte';\n  \n  const dispatch = createEventDispatcher();\n  export let value = 50;\n  \n  function updateValue(newValue) {\n    value = newValue;\n    // Dispatch a Svelte component event\n    dispatch('valueChange', { value });\n  }\n</script>\n\n<input \n  type=\"range\" \n  min=\"0\" \n  max=\"100\" \n  {value} \n  on:input={(e) => updateValue(e.target.value)}\n/>\n<span>{value}%</span>\n```\n\nUsage in Svelte:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import Slider from './Slider.svelte';\n  let currentValue = $state(50);\n  \n  function handleValueChange(event) {\n    currentValue = event.detail.value;\n  }\n</script>\n\n<Slider value={currentValue} on:valueChange={handleValueChange} />\n<p>Current value: {currentValue}%</p>\n```\n\n### Key Differences\n\n1. **Scope and Compatibility**:\n   - `$host`: Works across any framework or vanilla JS since it uses standard DOM events\n   - `createEventDispatcher`: Only works within Svelte components\n\n2. **Event Naming**:\n   - `$host`: Uses kebab-case by convention (e.g., 'value-change')\n   - `createEventDispatcher`: Often uses camelCase (e.g., 'valueChange')\n\n3. **Event Listening**:\n   - `$host`: Uses DOM event listeners or framework-specific event binding\n   - `createEventDispatcher`: Uses Svelte's `on:eventName` directive\n\n4. **Bubbling Behavior**:\n   - `$host`: Requires explicit `bubbles: true` to bubble through the DOM\n   - `createEventDispatcher`: Events don't bubble through the DOM, but propagate through Svelte's component hierarchy\n\n5. **Use Case**:\n   - `$host`: For creating reusable web components that work anywhere\n   - `createEventDispatcher`: For component communication within Svelte applications\n\n6. **Event Detail Access**:\n   - `$host`: Access via `event.detail`\n   - `createEventDispatcher`: Access via `event.detail`\n\nHere's a more complex example showing both approaches side by side:\n\n```svelte\n<!-- As a custom element -->\n<svelte:options customElement=\"form-field\" />\n\n<script>\n  let value = $state('');\n  let valid = $state(true);\n  \n  export let required = false;\n  export let pattern = null;\n  \n  function validate() {\n    if (required && value === '') {\n      valid = false;\n    } else if (pattern && !new RegExp(pattern).test(value)) {\n      valid = false;\n    } else {\n      valid = true;\n    }\n    \n    // Using $host to dispatch DOM events\n    $host().dispatchEvent(new CustomEvent('input', {\n      detail: { value, valid },\n      bubbles: true\n    }));\n    \n    $host().dispatchEvent(new CustomEvent('validation', {\n      detail: { valid },\n      bubbles: true\n    }));\n  }\n</script>\n\n<div class=\"field\" class:invalid={!valid}>\n  <input \n    value={value}\n    on:input={(e) => {\n      value = e.target.value;\n      validate();\n    }}\n  />\n  {#if !valid}\n    <span class=\"error\">Invalid input</span>\n  {/if}\n</div>\n```\n\nThe same component as a regular Svelte component:\n\n```svelte\n<!-- FormField.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte';\n  \n  const dispatch = createEventDispatcher();\n  \n  let value = $state('');\n  let valid = $state(true);\n  \n  export let required = false;\n  export let pattern = null;\n  \n  function validate() {\n    if (required && value === '') {\n      valid = false;\n    } else if (pattern && !new RegExp(pattern).test(value)) {\n      valid = false;\n    } else {\n      valid = true;\n    }\n    \n    // Using createEventDispatcher for Svelte events\n    dispatch('input', { value, valid });\n    dispatch('validation', { valid });\n  }\n</script>\n\n<div class=\"field\" class:invalid={!valid}>\n  <input \n    {value}\n    on:input={(e) => {\n      value = e.target.value;\n      validate();\n    }}\n  />\n  {#if !valid}\n    <span class=\"error\">Invalid input</span>\n  {/if}\n</div>\n```\n\nIn summary, use `$host` when creating custom elements that need to communicate with any framework or vanilla JS, and use `createEventDispatcher` when creating Svelte components that need to communicate with other Svelte components."}
{"source":"docs/svelte/02-runes/08-$host.md","question":"How can you use the `$host` rune to create a custom element that exposes properties and attributes in Svelte 5?","answer":"In Svelte 5, you can use the `$host` rune to create a custom element that exposes properties and attributes, allowing for two-way communication between the custom element and its parent. This involves not just dispatching events (as shown in previous examples) but also accessing and manipulating the host element's properties and attributes.\n\nHere's a comprehensive example of how to create a rich custom element with the `$host` rune:\n\n```svelte\n<svelte:options customElement=\"advanced-input\" />\n\n<script>\n  // Internal state\n  let inputValue = $state('');\n  let isFocused = $state(false);\n  let isValid = $state(true);\n  let validationMessage = $state('');\n  \n  // Define observed attributes and properties\n  const observedAttributes = ['placeholder', 'required', 'pattern', 'disabled'];\n  \n  // Initialize from host attributes\n  $effect(() => {\n    const host = $host();\n    if (!host) return;\n    \n    // Get initial values from attributes\n    const placeholder = host.getAttribute('placeholder') || '';\n    const required = host.hasAttribute('required');\n    const pattern = host.getAttribute('pattern') || null;\n    const disabled = host.hasAttribute('disabled');\n    \n    // Initialize component based on attributes\n    updatePlaceholder(placeholder);\n    updateRequired(required);\n    updatePattern(pattern);\n    updateDisabled(disabled);\n    \n    // Get initial value from value property if set\n    if (host.value) {\n      inputValue = host.value;\n      validate();\n    }\n    \n    // Define getters and setters for the value property\n    Object.defineProperty(host, 'value', {\n      get() {\n        return inputValue;\n      },\n      set(newValue) {\n        inputValue = newValue;\n        validate();\n      }\n    });\n    \n    // Define getter for validity\n    Object.defineProperty(host, 'valid', {\n      get() {\n        return isValid;\n      }\n    });\n    \n    // Define getter for validationMessage\n    Object.defineProperty(host, 'validationMessage', {\n      get() {\n        return validationMessage;\n      }\n    });\n    \n    // Define methods\n    host.focus = () => {\n      document.getElementById('input-field')?.focus();\n    };\n    \n    host.reset = () => {\n      inputValue = '';\n      isValid = true;\n      validationMessage = '';\n    };\n  });\n  \n  // Helper functions for attribute/property updates\n  function updatePlaceholder(value) {\n    document.getElementById('input-field')?.setAttribute('placeholder', value || '');\n  }\n  \n  function updateRequired(value) {\n    const input = document.getElementById('input-field');\n    if (input) {\n      if (value) {\n        input.setAttribute('required', '');\n      } else {\n        input.removeAttribute('required');\n      }\n    }\n    validate();\n  }\n  \n  function updatePattern(value) {\n    const input = document.getElementById('input-field');\n    if (input) {\n      if (value) {\n        input.setAttribute('pattern', value);\n      } else {\n        input.removeAttribute('pattern');\n      }\n    }\n    validate();\n  }\n  \n  function updateDisabled(value) {\n    const input = document.getElementById('input-field');\n    if (input) {\n      if (value) {\n        input.setAttribute('disabled', '');\n      } else {\n        input.removeAttribute('disabled');\n      }\n    }\n  }\n  \n  // Validate the input\n  function validate() {\n    const host = $host();\n    if (!host) return;\n    \n    const required = host.hasAttribute('required');\n    const pattern = host.getAttribute('pattern');\n    \n    // Reset validation state\n    isValid = true;\n    validationMessage = '';\n    \n    // Check if required and empty\n    if (required && !inputValue) {\n      isValid = false;\n      validationMessage = 'This field is required';\n    } \n    // Check pattern if provided\n    else if (pattern && inputValue) {\n      const regex = new RegExp(pattern);\n      if (!regex.test(inputValue)) {\n        isValid = false;\n        validationMessage = 'Please match the requested format';\n      }\n    }\n    \n    // Dispatch change and validation events\n    host.dispatchEvent(new CustomEvent('change', {\n      detail: { value: inputValue },\n      bubbles: true\n    }));\n    \n    host.dispatchEvent(new CustomEvent('validation', {\n      detail: { valid: isValid, message: validationMessage },\n      bubbles: true\n    }));\n    \n    // Update the host element's classes\n    if (isValid) {\n      host.classList.remove('invalid');\n      host.classList.add('valid');\n    } else {\n      host.classList.add('invalid');\n      host.classList.remove('valid');\n    }\n  }\n  \n  // Handle input changes\n  function handleInput(e) {\n    inputValue = e.target.value;\n    validate();\n  }\n  \n  // Handle focus events\n  function handleFocus() {\n    isFocused = true;\n    $host().classList.add('focused');\n    $host().dispatchEvent(new CustomEvent('focus', { bubbles: true }));\n  }\n  \n  function handleBlur() {\n    isFocused = false;\n    $host().classList.remove('focused');\n    $host().dispatchEvent(new CustomEvent('blur', { bubbles: true }));\n    validate();\n  }\n  \n  // Monitor attribute changes\n  // Note: In a real implementation, you'd use the attributeChangedCallback\n  // of the custom element, but here we're simulating with an effect\n  $effect(() => {\n    const host = $host();\n    if (!host) return;\n    \n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'attributes' && observedAttributes.includes(mutation.attributeName)) {\n          const attributeName = mutation.attributeName;\n          const attributeValue = host.getAttribute(attributeName);\n          \n          switch (attributeName) {\n            case 'placeholder':\n              updatePlaceholder(attributeValue);\n              break;\n            case 'required':\n              updateRequired(host.hasAttribute('required'));\n              break;\n            case 'pattern':\n              updatePattern(attributeValue);\n              break;\n            case 'disabled':\n              updateDisabled(host.hasAttribute('disabled'));\n              break;\n          }\n        }\n      });\n    });\n    \n    observer.observe(host, { attributes: true });\n    \n    return () => {\n      observer.disconnect();\n    };\n  });\n</script>\n\n<div class=\"input-container\" class:focused={isFocused} class:invalid={!isValid}>\n  <input\n    id=\"input-field\"\n    type=\"text\"\n    value={inputValue}\n    on:input={handleInput}\n    on:focus={handleFocus}\n    on:blur={handleBlur}\n  />\n  \n  {#if !isValid && validationMessage}\n    <div class=\"validation-message\">{validationMessage}</div>\n  {/if}\n</div>\n\n<style>\n  .input-container {\n    position: relative;\n    margin-bottom: 20px;\n  }\n  \n  input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    font-size: 16px;\n    transition: border-color 0.2s;\n  }\n  \n  .focused input {\n    border-color: #0066ff;\n    outline: none;\n    box-shadow: 0 0 0 2px rgba(0, 102, 255, 0.2);\n  }\n  \n  .invalid input {\n    border-color: #ff3300;\n  }\n  \n  .validation-message {\n    color: #ff3300;\n    font-size: 12px;\n    margin-top: 4px;\n  }\n  \n  :host(.invalid) {\n    --border-color: #ff3300;\n  }\n  \n  :host(.valid) {\n    --border-color: #00cc66;\n  }\n  \n  :host(.focused) {\n    --shadow-color: rgba(0, 102, 255, 0.2);\n  }\n</style>\n```\n\nNow let's see how to use this custom element in various contexts:\n\n**HTML Usage:**\n```html\n<advanced-input \n  placeholder=\"Enter your email\"\n  required\n  pattern=\"[^@]+@[^@]+\\.[a-zA-Z]{2,}\"\n  id=\"email-input\"\n></advanced-input>\n\n<script>\n  const input = document.getElementById('email-input');\n  \n  // Set value programmatically\n  input.value = 'test@example.com';\n  \n  // Listen for events\n  input.addEventListener('change', (e) => {\n    console.log('Value changed:', e.detail.value);\n  });\n  \n  input.addEventListener('validation', (e) => {\n    console.log('Valid:', e.detail.valid);\n    console.log('Message:', e.detail.message);\n  });\n  \n  // Access properties\n  console.log('Current value:', input.value);\n  console.log('Is valid:', input.valid);\n  \n  // Call methods\n  document.getElementById('reset-btn').addEventListener('click', () => {\n    input.reset();\n  });\n  \n  document.getElementById('focus-btn').addEventListener('click', () => {\n    input.focus();\n  });\n</script>\n```\n\n**Svelte Usage:**\n```svelte\n<script>\n  import './AdvancedInput.svelte';\n  \n  let email = $state('');\n  let isValid = $state(true);\n  let validationMessage = $state('');\n  \n  function handleChange(e) {\n    email = e.detail.value;\n  }\n  \n  function handleValidation(e) {\n    isValid = e.detail.valid;\n    validationMessage = e.detail.message;\n  }\n  \n  function resetForm() {\n    document.querySelector('advanced-input').reset();\n  }\n</script>\n\n<form on:submit|preventDefault={() => console.log('Submitting:', email)}>\n  <advanced-input\n    placeholder=\"Enter your email\"\n    required\n    pattern=\"[^@]+@[^@]+\\.[a-zA-Z]{2,}\"\n    onchange={handleChange}\n    onvalidation={handleValidation}\n  ></advanced-input>\n  \n  <button type=\"submit\" disabled={!isValid}>Submit</button>\n  <button type=\"button\" on:click={resetForm}>Reset</button>\n  \n  {#if !isValid}\n    <p class=\"error\">{validationMessage}</p>\n  {/if}\n</form>\n```\n\n**React Usage:**\n```jsx\nimport React, { useEffect, useRef, useState } from 'react';\nimport './AdvancedInput.svelte'; // Import the custom element\n\nfunction EmailForm() {\n  const inputRef = useRef(null);\n  const [email, setEmail] = useState('');\n  const [isValid, setIsValid] = useState(true);\n  const [message, setMessage] = useState('');\n  \n  useEffect(() => {\n    const input = inputRef.current;\n    \n    const handleChange = (e) => {\n      setEmail(e.detail.value);\n    };\n    \n    const handleValidation = (e) => {\n      setIsValid(e.detail.valid);\n      setMessage(e.detail.message);\n    };\n    \n    input.addEventListener('change', handleChange);\n    input.addEventListener('validation', handleValidation);\n    \n    return () => {\n      input.removeEventListener('change', handleChange);\n      input.removeEventListener('validation', handleValidation);\n    };\n  }, []);\n  \n  const resetForm = () => {\n    inputRef.current.reset();\n    setEmail('');\n    setIsValid(true);\n    setMessage('');\n  };\n  \n  return (\n    <form onSubmit={(e) => {\n      e.preventDefault();\n      console.log('Submitting:', email);\n    }}>\n      <advanced-input\n        ref={inputRef}\n        placeholder=\"Enter your email\"\n        required\n        pattern=\"[^@]+@[^@]+\\.[a-zA-Z]{2,}\"\n      ></advanced-input>\n      \n      <button type=\"submit\" disabled={!isValid}>Submit</button>\n      <button type=\"button\" onClick={resetForm}>Reset</button>\n      \n      {!isValid && <p className=\"error\">{message}</p>}\n    </form>\n  );\n}\n```\n\nThis example demonstrates:\n\n1. **Property access and manipulation**: Defining getters and setters for properties like `value` and `valid`\n2. **Method exposure**: Adding methods like `focus()` and `reset()` to the host element\n3. **Attribute observation**: Responding to changes in attributes\n4. **Event dispatching**: Sending events like 'change', 'validation', 'focus', and 'blur'\n5. **CSS customization**: Using `:host()` selectors for styling based on component state\n6. **Two-way communication**: Allowing both reading from and writing to the custom element\n\nThe `$host` rune makes all of this possible by providing direct access to the host element, allowing your Svelte component to enhance it with properties, methods, and event handlers while maintaining compatibility with any framework or vanilla JavaScript."}
{"source":"docs/svelte/02-runes/08-$host.md","question":"What's the difference between using `$host` for custom elements and using Svelte's action API for DOM manipulation?","answer":"The `$host` rune in Svelte 5 and Svelte's action API both deal with DOM manipulation, but they serve different purposes and have distinct characteristics. Let's examine their differences in detail:\n\n### The `$host` Rune\n\nThe `$host` rune is specifically designed for use with custom elements (web components) and provides access to the host element:\n\n```svelte\n<svelte:options customElement=\"tooltip-element\" />\n\n<script>\n  let isVisible = $state(false);\n  \n  // Initialize the host element\n  $effect(() => {\n    const host = $host();\n    if (!host) return;\n    \n    // Add methods to the host element\n    host.show = () => { isVisible = true; };\n    host.hide = () => { isVisible = false; };\n    host.toggle = () => { isVisible = !isVisible; };\n    \n    // Set up attribute observation\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.attributeName === 'position') {\n          updatePosition(host.getAttribute('position'));\n        }\n      }\n    });\n    \n    observer.observe(host, { attributes: true });\n    \n    return () => observer.disconnect();\n  });\n  \n  function updatePosition(position) {\n    // Update tooltip position based on attribute\n    console.log('Position changed to:', position);\n  }\n</script>\n\n<div class=\"tooltip\" class:visible={isVisible}>\n  <slot></slot>\n</div>\n\n<style>\n  .tooltip {\n    position: absolute;\n    opacity: 0;\n    transition: opacity 0.2s;\n    background: #333;\n    color: white;\n    padding: 5px 10px;\n    border-radius: 4px;\n    pointer-events: none;\n  }\n  \n  .visible {\n    opacity: 1;\n  }\n</style>\n```\n\n### Svelte's Action API\n\nActions are functions that run when an element is created and can return an object with lifecycle methods:\n\n```svelte\n<script>\n  // Define an action for tooltip functionality\n  function tooltip(node, options = {}) {\n    let position = options.position || 'top';\n    let visible = false;\n    let tooltipEl;\n    \n    function createTooltip() {\n      tooltipEl = document.createElement('div');\n      tooltipEl.className = 'tooltip';\n      tooltipEl.textContent = options.text || '';\n      document.body.appendChild(tooltipEl);\n    }\n    \n    function updatePosition() {\n      const rect = node.getBoundingClientRect();\n      \n      switch (position) {\n        case 'top':\n          tooltipEl.style.bottom = `${window.innerHeight - rect.top + 5}px`;\n          tooltipEl.style.left = `${rect.left + rect.width / 2}px`;\n          tooltipEl.style.transform = 'translateX(-50%)';\n          break;\n        case 'bottom':\n          tooltipEl.style.top = `${rect.bottom + 5}px`;\n          tooltipEl.style.left = `${rect.left + rect.width / 2}px`;\n          tooltipEl.style.transform = 'translateX(-50%)';\n          break;\n        // other positions...\n      }\n    }\n    \n    function show() {\n      if (!tooltipEl) createTooltip();\n      visible = true;\n      tooltipEl.classList.add('visible');\n      updatePosition();\n    }\n    \n    function hide() {\n      if (!tooltipEl) return;\n      visible = false;\n      tooltipEl.classList.remove('visible');\n    }\n    \n    // Set up event listeners\n    node.addEventListener('mouseenter', show);\n    node.addEventListener('mouseleave', hide);\n    \n    createTooltip();\n    \n    return {\n      update(newOptions) {\n        if (newOptions.position !== position) {\n          position = newOptions.position;\n          if (visible) updatePosition();\n        }\n        \n        if (newOptions.text !== options.text) {\n          options.text = newOptions.text;\n          if (tooltipEl) tooltipEl.textContent = options.text || '';\n        }\n      },\n      destroy() {\n        node.removeEventListener('mouseenter', show);\n        node.removeEventListener('mouseleave', hide);\n        if (tooltipEl) tooltipEl.remove();\n      }\n    };\n  }\n</script>\n\n<button use:tooltip={{ text: \"Click me!\", position: \"top\" }}>\n  Hover for tooltip\n</button>\n```\n\n### Key Differences\n\n1. **Purpose and Scope**:\n   - `$host`: Designed specifically for custom elements to access and enhance the host element\n   - Actions: General-purpose DOM manipulation for any element in a Svelte component\n\n2. **Component Integration**:\n   - `$host`: Makes a Svelte component usable as a web component across any framework\n   - Actions: Enhances elements within Svelte components but doesn't create reusable custom elements\n\n3. **Usage Context**:\n   - `$host`: Only available in components with `<svelte:options customElement=\"...\" />`\n   - Actions: Can be used on any element in any Svelte component\n\n4. **API Exposure**:\n   - `$host`: Can expose a public API (properties, methods, events) to users of the custom element\n   - Actions: Functionality is encapsulated within the Svelte component, not directly exposed\n\n5. **Lifecycle Management**:\n   - `$host`: Managed through Svelte's component lifecycle and rune effects\n   - Actions: Has explicit lifecycle hooks (init, update, destroy)\n\n6. **Framework Integration**:\n   - `$host`: Creates elements usable in any framework or vanilla JS\n   - Actions: Only usable within Svelte components\n\n7. **Reactivity Integration**:\n   - `$host`: Requires manual event dispatching to communicate changes\n   - Actions: Can directly interact with Svelte's reactivity system\n\n### When to Use Each\n\n**Use `$host` when**:\n- Creating reusable web components that need to work across frameworks\n- Exposing a public API for your component\n- Building a component library for wide distribution\n\n```svelte\n<svelte:options customElement=\"progress-bar\" />\n\n<script>\n  let value = $state(0);\n  let max = $state(100);\n  \n  $effect(() => {\n    const host = $host();\n    if (!host) return;\n    \n    // Get initial values from attributes\n    if (host.hasAttribute('value')) {\n      value = parseFloat(host.getAttribute('value'));\n    }\n    \n    if (host.hasAttribute('max')) {\n      max = parseFloat(host.getAttribute('max'));\n    }\n    \n    // Define properties\n    Object.defineProperty(host, 'value', {\n      get: () => value,\n      set: (v) => {\n        value = Math.min(Math.max(0, parseFloat(v) || 0), max);\n        host.dispatchEvent(new CustomEvent('change', { detail: { value } }));\n      }\n    });\n    \n    Object.defineProperty(host, 'max', {\n      get: () => max,\n      set: (m) => {\n        max = Math.max(1, parseFloat(m) || 100);\n        value = Math.min(value, max); // Adjust value if needed\n      }\n    });\n  });\n</script>\n\n<div class=\"progress-container\">\n  <div class=\"progress-bar\" style=\"width: {(value / max * 100)}%\"></div>\n  <div class=\"progress-text\">{Math.round(value / max * 100)}%</div>\n</div>\n\n<style>\n  .progress-container {\n    width: 100%;\n    height: 20px;\n    background: #eee;\n    border-radius: 10px;\n    overflow: hidden;\n    position: relative;\n  }\n  \n  .progress-bar {\n    height: 100%;\n    background: #0066ff;\n    transition: width 0.3s;\n  }\n  \n  .progress-text {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: #333;\n    font-weight: bold;\n    font-size: 12px;\n  }\n</style>\n```\n\n**Use Actions when**:\n- Enhancing elements within Svelte components\n- Reusing DOM manipulation logic across multiple components\n- Creating UI behaviors that don't need to be exposed as custom elements\n\n```svelte\n<script>\n  import { spring } from 'svelte/motion';\n  \n  function parallax(node, options = { factor: 0.5 }) {\n    let factor = options.factor;\n    let scrollY;\n    const initialTransform = node.style.transform || '';\n    \n    function update() {\n      const offset = -scrollY * factor;\n      node.style.transform = `${initialTransform} translateY(${offset}px)`;\n    }\n    \n    function handleScroll() {\n      scrollY = window.pageYOffset;\n      update();\n    }\n    \n    window.addEventListener('scroll', handleScroll);\n    handleScroll(); // Initial positioning\n    \n    return {\n      update(newOptions) {\n        if (newOptions.factor !== factor) {\n          factor = newOptions.factor;\n          update();\n        }\n      },\n      destroy() {\n        window.removeEventListener('scroll', handleScroll);\n      }\n    };\n  }\n  \n  let factor = $state(0.5);\n</script>\n\n<div class=\"hero\">\n  <div class=\"background\" use:parallax={{ factor }}>\n    <img src=\"background.jpg\" alt=\"Parallax background\" />\n  </div>\n  \n  <div class=\"content\">\n    <h1>Welcome to my site</h1>\n    <p>Scroll down to see the parallax effect</p>\n  </div>\n</div>\n\n<div class=\"controls\">\n  <label>\n    Parallax intensity:\n    <input type=\"range\" min=\"0\" max=\"1\" step=\"0.1\" bind:value={factor} />\n    {factor}\n  </label>\n</div>\n```\n\n### Combined Approach\n\nIn some cases, you might want to use both approaches together - creating a custom element with `$host` that internally uses actions for DOM manipulation:\n\n```svelte\n<svelte:options customElement=\"drag-drop-area\" />\n\n<script>\n  let files = $state([]);\n  \n  // Action for drag and drop functionality\n  function dragDrop(node) {\n    function handleDragOver(e) {\n      e.preventDefault();\n      node.classList.add('drag-over');\n    }\n    \n    function handleDragLeave() {\n      node.classList.remove('drag-over');\n    }\n    \n    function handleDrop(e) {\n      e.preventDefault();\n      node.classList.remove('drag-over');\n      \n      if (e.dataTransfer.items) {\n        files = [...e.dataTransfer.items]\n          .filter(item => item.kind === 'file')\n          .map(item => item.getAsFile());\n      } else {\n        files = [...e.dataTransfer.files];\n      }\n      \n      // Dispatch event through host element\n      $host().dispatchEvent(new CustomEvent('files-dropped', {\n        detail: { files },\n        bubbles: true\n      }));\n    }\n    \n    node.addEventListener('dragover', handleDragOver);\n    node.addEventListener('dragleave', handleDragLeave);\n    node.addEventListener('drop', handleDrop);\n    \n    return {\n      destroy() {\n        node.removeEventListener('dragover', handleDragOver);\n        node.removeEventListener('dragleave', handleDragLeave);\n        node.removeEventListener('drop', handleDrop);\n      }\n    };\n  }\n  \n  // Expose files property on the host element\n  $effect(() => {\n    const host = $host();\n    if (!host) return;\n    \n    Object.defineProperty(host, 'files', {\n      get: () => files\n    });\n    \n    host.clearFiles = () => {\n      files = [];\n    };\n  });\n</script>\n\n<div class=\"drop-area\" use:dragDrop>\n  <slot>\n    <p>Drag and drop files here</p>\n    {#if files.length > 0}\n      <ul>\n        {#each files as file}\n          <li>{file.name} ({Math.round(file.size / 1024)} KB)</li>\n        {/each}\n      </ul>\n    {/if}\n  </slot>\n</div>\n\n<style>\n  .drop-area {\n    border: 2px dashed #ccc;\n    border-radius: 8px;\n    padding: 20px;\n    text-align: center;\n    transition: background-color 0.2s, border-color 0.2s;\n  }\n  \n  .drop-area.drag-over {\n    background-color: rgba(0, 102, 255, 0.1);\n    border-color: #0066ff;\n  }\n  \n  :host {\n    display: block;\n  }\n</style>\n```\n\nIn summary, while both `$host` and actions deal with DOM manipulation, they serve different purposes. The `$host` rune is focused on creating and enhancing custom elements, while actions provide a way to encapsulate and reuse DOM manipulation logic within Svelte components. Choose the appropriate tool based on your specific use case and integration requirements."}
{"source":"docs/svelte/02-runes/08-$host.md","question":"How can you handle attribute changes in a Svelte 5 custom element using the `$host` rune?","answer":"Handling attribute changes in a Svelte 5 custom element using the `$host` rune requires implementing a monitoring mechanism since Svelte doesn't directly expose the standard custom element lifecycle callbacks. Here's a comprehensive approach to handling attribute changes:\n\n### Basic Attribute Change Handling\n\nThe most straightforward way to monitor attribute changes is to use a `MutationObserver` in combination with the `$host` rune:\n\n```svelte\n<svelte:options customElement=\"theme-switcher\" />\n\n<script>\n  // Internal state\n  let theme = $state('light');\n  let size = $state('medium');\n  \n  // List of attributes to observe\n  const observedAttributes = ['theme', 'size'];\n  \n  // Setup attribute observation\n  $effect(() => {\n    const host = $host();\n    if (!host) return;\n    \n    // Initialize from attributes\n    if (host.hasAttribute('theme')) {\n      theme = host.getAttribute('theme');\n    }\n    \n    if (host.hasAttribute('size')) {\n      size = host.getAttribute('size');\n    }\n    \n    // Create observer to watch for attribute changes\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'attributes' && observedAttributes.includes(mutation.attributeName)) {\n          const attrName = mutation.attributeName;\n          const newValue = host.getAttribute(attrName);\n          \n          // Update internal state based on attribute changes\n          if (attrName === 'theme') {\n            theme = newValue || 'light';\n          } else if (attrName === 'size') {\n            size = newValue || 'medium';\n          }\n        }\n      }\n    });\n    \n    // Start observing\n    observer.observe(host, { attributes: true });\n    \n    // Cleanup when component is destroyed\n    return () => observer.disconnect();\n  });\n</script>\n\n<button class=\"theme-button {theme} {size}\">\n  <slot>Switch Theme</slot>\n</button>\n\n<style>\n  .theme-button {\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    transition: all 0.3s;\n  }\n  \n  /* Theme styles */\n  .light {\n    background-color: #f0f0f0;\n    color: #333;\n  }\n  \n  .dark {\n    background-color: #333;\n    color: #fff;\n  }\n  \n  /* Size styles */\n  .small {\n    padding: 6px 12px;\n    font-size: 12px;\n  }\n  \n  .medium {\n    padding: 8px 16px;\n    font-size: 14px;\n  }\n  \n  .large {\n    padding: 10px 20px;\n    font-size: 16px;\n  }\n</style>\n```\n\n### Advanced Attribute Handling with Reflection\n\nFor a more complete implementation, you might want to reflect property changes back to attributes and vice versa, similar to how standard custom elements work:\n\n```svelte\n<svelte:options customElement=\"data-card\" />\n\n<script>\n  // Internal state with default values\n  let title = $state('Card Title');\n  let subtitle = $state('');\n  let loading = $state(false);\n  let expanded = $state(false);\n  \n  // Define which attributes to observe\n  const observedAttributes = ['title', 'subtitle', 'loading', 'expanded'];\n  \n  // Property to attribute reflection function\n  function reflectToAttribute(host, prop, value) {\n    if (!host) return;\n    \n    if (typeof value === 'boolean') {\n      // For boolean attributes\n      if (value) {\n        host.setAttribute(prop, '');\n      } else {\n        host.removeAttribute(prop);\n      }\n    } else if (value !== null && value !== undefined) {\n      // For string attributes\n      host.setAttribute(prop, value);\n    } else {\n      // For null/undefined values\n      host.removeAttribute(prop);\n    }\n  }\n  \n  // Setup property getters/setters and attribute observation\n  $effect(() => {\n    const host = $host();\n    if (!host) return;\n    \n    // Initialize from attributes\n    if (host.hasAttribute('title')) {\n      title = host.getAttribute('title');\n    }\n    \n    if (host.hasAttribute('subtitle')) {\n      subtitle = host.getAttribute('subtitle');\n    }\n    \n    if (host.hasAttribute('loading')) {\n      loading = true;\n    }\n    \n    if (host.hasAttribute('expanded')) {\n      expanded = true;\n    }\n    \n    // Define property getters/setters\n    Object.defineProperties(host, {\n      title: {\n        get: () => title,\n        set: (value) => {\n          title = value;\n          reflectToAttribute(host, 'title', value);\n        }\n      },\n      subtitle: {\n        get: () => subtitle,\n        set: (value) => {\n          subtitle = value;\n          reflectToAttribute(host, 'subtitle', value);\n        }\n      },\n      loading: {\n        get: () => loading,\n        set: (value) => {\n          loading = Boolean(value);\n          reflectToAttribute(host, 'loading', loading);\n        }\n      },\n      expanded: {\n        get: () => expanded,\n        set: (value) => {\n          expanded = Boolean(value);\n          reflectToAttribute(host, 'expanded', expanded);\n          \n          // Dispatch event when expanded state changes\n          host.dispatchEvent(new CustomEvent('expand-change', {\n            detail: { expanded },\n            bubbles: true\n          }));\n        }\n      }\n    });\n    \n    // Create observer for attribute changes\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'attributes' && observedAttributes.includes(mutation.attributeName)) {\n          const attrName = mutation.attributeName;\n          \n          switch (attrName) {\n            case 'title':\n              title = host.getAttribute('title') || '';\n              break;\n            case 'subtitle':\n              subtitle = host.getAttribute('subtitle') || '';\n              break;\n            case 'loading':\n              loading = host.hasAttribute('loading');\n              break;\n            case 'expanded':\n              const wasExpanded = expanded;\n              expanded = host.hasAttribute('expanded');\n              \n              // Only dispatch if the value actually changed\n              if (wasExpanded !== expanded) {\n                host.dispatchEvent(new CustomEvent('expand-change', {\n                  detail: { expanded },\n                  bubbles: true\n                }));\n              }\n              break;\n          }\n        }\n      });\n    });\n    \n    observer.observe(host, { attributes: true });\n    \n    // Define toggle method\n    host.toggleExpanded = () => {\n      host.expanded = !expanded;\n    };\n    \n    return () => observer.disconnect();\n  });\n  \n  // Watch internal state changes and reflect to attributes\n  $effect(() => {\n    const host = $host();\n    if (!host) return;\n    \n    reflectToAttribute(host, 'title', title);\n    reflectToAttribute(host, 'subtitle', subtitle);\n    reflectToAttribute(host, 'loading', loading);\n    reflectToAttribute(host, 'expanded', expanded);\n  });\n</script>\n\n<div class=\"card\" class:expanded class:loading>\n  {#if loading}\n    <div class=\"loading-indicator\">\n      <div class=\"spinner\"></div>\n    </div>\n  {/if}\n  \n  <div class=\"card-header\">\n    <h2>{title}</h2>\n    {#if subtitle}\n      <h3>{subtitle}</h3>\n    {/if}\n  </div>\n  \n  <div class=\"card-content\">\n    <slot></slot>\n  </div>\n  \n  <button class=\"expand-button\" on:click={() => expanded = !expanded}>\n    {expanded ? 'Collapse' : 'Expand'}\n  </button>\n</div>\n\n<style>\n  .card {\n    position: relative;\n    border: 1px solid #ddd;\n    border-radius: 8px;\n    padding: 16px;\n    max-height: 100px;\n    overflow: hidden;\n    transition: max-height 0.3s, box-shadow 0.3s;\n  }\n  \n  .card.expanded {\n    max-height: 500px;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n  }\n  \n  .card-header {\n    margin-bottom: 8px;\n  }\n  \n  .card-header h2 {\n    margin: 0;\n    font-size: 18px;\n  }\n  \n  .card-header h3 {\n    margin: 4px 0 0;\n    font-size: 14px;\n    color: #666;\n  }\n  \n  .card-content {\n    font-size: 14px;\n  }\n  \n  .expand-button {\n    margin-top: 8px;\n    background: transparent;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    padding: 4px 8px;\n    cursor: pointer;\n  }\n  \n  .loading {\n    pointer-events: none;\n    opacity: 0.7;\n  }\n  \n  .loading-indicator {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: rgba(255, 255, 255, 0.7);\n  }\n  \n  .spinner {\n    width: 24px;\n    height: 24px;\n    border: 3px solid #f3f3f3;\n    border-top: 3px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n  }\n  \n  @keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n</style>\n```\n\n### Using with Typed Properties\n\nFor more complex custom elements, you might want to handle different types of properties (string, number, boolean, object) correctly:\n\n```svelte\n<svelte:options customElement=\"data-table\" />\n\n<script>\n  // Define internal state\n  let data = $state([]);\n  let pageSize = $state(10);\n  let currentPage = $state(1);\n  let sortBy = $state(null);\n  let sortDirection = $state('asc');\n  let loading = $state(false);\n  \n  // Property definitions with types and defaults\n  const propDefinitions = {\n    data: { type: 'object', default: [] },\n    pageSize: { type: 'number', default: 10, attribute: 'page-size' },\n    currentPage: { type: 'number', default: 1, attribute: 'current-page' },\n    sortBy: { type: 'string', default: null, attribute: 'sort-by' },\n    sortDirection: { type: 'string', default: 'asc', attribute: 'sort-direction' },\n    loading: { type: 'boolean', default: false }\n  };\n  \n  // Convert attribute value to the correct type\n  function parseAttributeValue(value, type) {\n    if (value === null || value === undefined) return null;\n    \n    switch (type) {\n      case 'number':\n        return Number(value);\n      case 'boolean':\n        return value !== null;\n      case 'object':\n        try {\n          return JSON.parse(value);\n        } catch (e) {\n          console.error('Failed to parse JSON attribute', e);\n          return null;\n        }\n      case 'string':\n      default:\n        return value;\n    }\n  }\n  \n  // Convert property value to attribute value\n  function serializeValue(value, type) {\n    if (value === null || value === undefined) return null;\n    \n    switch (type) {\n      case 'boolean':\n        return value ? '' : null;\n      case 'object':\n        return JSON.stringify(value);\n      case 'number':\n      case 'string':\n      default:\n        return String(value);\n    }\n  }\n  \n  // Setup the custom element\n  $effect(() => {\n    const host = $host();\n    if (!host) return;\n    \n    // Initialize properties from attributes\n    for (const [prop, config] of Object.entries(propDefinitions)) {\n      const attrName = config.attribute || prop.toLowerCase();\n      \n      if (host.hasAttribute(attrName)) {\n        const attrValue = host.getAttribute(attrName);\n        const parsedValue = parseAttributeValue(attrValue, config.type);\n        \n        // Set initial state\n        switch (prop) {\n          case 'data': data = parsedValue || config.default; break;\n          case 'pageSize': pageSize = parsedValue || config.default; break;\n          case 'currentPage': currentPage = parsedValue || config.default; break;\n          case 'sortBy': sortBy = parsedValue || config.default; break;\n          case 'sortDirection': sortDirection = parsedValue || config.default; break;\n          case 'loading': loading = parsedValue || config.default; break;\n        }\n      }\n    }\n    \n    // Define getters and setters for each property\n    for (const [prop, config] of Object.entries(propDefinitions)) {\n      const attrName = config.attribute || prop.toLowerCase();\n      \n      Object.defineProperty(host, prop, {\n        get() {\n          switch (prop) {\n            case 'data': return data;\n            case 'pageSize': return pageSize;\n            case 'currentPage': return currentPage;\n            case 'sortBy': return sortBy;\n            case 'sortDirection': return sortDirection;\n            case 'loading': return loading;\n            default: return null;\n          }\n        },\n        set(value) {\n          // Update internal state\n          switch (prop) {\n            case 'data': \n              data = value || config.default;\n              break;\n            case 'pageSize': \n              pageSize = typeof value === 'number' ? value : config.default;\n              break;\n            case 'currentPage': \n              currentPage = typeof value === 'number' ? value : config.default;\n              break;\n            case 'sortBy': \n              sortBy = value || config.default;\n              break;\n            case 'sortDirection': \n              sortDirection = value || config.default;\n              break;\n            case 'loading': \n              loading = Boolean(value);\n              break;\n          }\n          \n          // Reflect to attribute if needed\n          const serializedValue = serializeValue(value, config.type);\n          \n          if (serializedValue === null) {\n            host.removeAttribute(attrName);\n          } else {\n            host.setAttribute(attrName, serializedValue);\n          }\n          \n          // Dispatch change event\n          host.dispatchEvent(new CustomEvent(`${prop}-change`, {\n            detail: { value },\n            bubbles: true\n          }));\n        }\n      });\n    }\n    \n    // Set up attribute observer\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type !== 'attributes') continue;\n        \n        const attrName = mutation.attributeName;\n        \n        // Find the corresponding property\n        const propEntry = Object.entries(propDefinitions).find(\n          ([_, config]) => (config.attribute || _.toLowerCase()) === attrName\n        );\n        \n        if (!propEntry) continue;\n        \n        const [prop, config] = propEntry;\n        const attrValue = host.getAttribute(attrName);\n        const parsedValue = parseAttributeValue(attrValue, config.type);\n        \n        // Update internal state without triggering the setter (to avoid loops)\n        switch (prop) {\n          case 'data': data = parsedValue || config.default; break;\n          case 'pageSize': pageSize = parsedValue || config.default; break;\n          case 'currentPage': currentPage = parsedValue || config.default; break;\n          case 'sortBy': sortBy = parsedValue || config.default; break;\n          case 'sortDirection': sortDirection = parsedValue || config.default; break;\n          case 'loading': loading = parsedValue || config.default; break;\n        }\n      }\n    });\n    \n    observer.observe(host, { attributes: true });\n    \n    // Add methods\n    host.nextPage = () => {\n      host.currentPage = currentPage + 1;\n    };\n    \n    host.prevPage = () => {\n      if (currentPage > 1) {\n        host.currentPage = currentPage - 1;\n      }\n    };\n    \n    host.sort = (column) => {\n      if (sortBy === column) {\n        host.sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';\n      } else {\n        host.sortBy = column;\n        host.sortDirection = 'asc';\n      }\n    };\n    \n    return () => observer.disconnect();\n  });\n  \n  // Compute visible data based on pagination and sorting\n  $derived(visibleData = () => {\n    // First sort the data if needed\n    let sortedData = [...data];\n    \n    if (sortBy) {\n      sortedData.sort((a, b) => {\n        const aValue = a[sortBy];\n        const bValue = b[sortBy];\n        \n        if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;\n        if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;\n        return 0;\n      });\n    }\n    \n    // Then paginate\n    const startIndex = (currentPage - 1) * pageSize;\n    return sortedData.slice(startIndex, startIndex + pageSize);\n  });\n  \n  // Compute total pages\n  $derived(totalPages = Math.ceil(data.length / pageSize));\n</script>\n\n<div class=\"data-table-container\" class:loading>\n  {#if loading}\n    <div class=\"loading-overlay\">Loading...</div>\n  {/if}\n  \n  <table class=\"data-table\">\n    <thead>\n      {#if data.length > 0}\n        <tr>\n          {#each Object.keys(data[0]) as column}\n            <th on:click={() => $host().sort(column)}>\n              {column}\n              {#if sortBy === column}\n                <span class=\"sort-indicator\">\n                  {sortDirection === 'asc' ? 'â' : 'â'}\n                </span>\n              {/if}\n            </th>\n          {/each}\n        </tr>\n      {/if}\n    </thead>\n    <tbody>\n      {#if visibleData.length === 0}\n        <tr>\n          <td colspan=\"100%\" class=\"empty-message\">\n            No data available\n          </td>\n        </tr>\n      {:else}\n        {#each visibleData as row}\n          <tr>\n            {#each Object.values(row) as cell}\n              <td>{cell}</td>\n            {/each}\n          </tr>\n        {/each}\n      {/if}\n    </tbody>\n  </table>\n  \n  {#if totalPages > 1}\n    <div class=\"pagination\">\n      <button \n        class=\"pagination-btn\" \n        disabled={currentPage === 1}\n        on:click={() => $host().prevPage()}\n      >\n        Previous\n      </button>\n      \n      <span class=\"page-info\">\n        Page {currentPage} of {totalPages}\n      </span>\n      \n      <button \n        class=\"pagination-btn\" \n        disabled={currentPage === totalPages}\n        on:click={() => $host().nextPage()}\n      >\n        Next\n      </button>\n    </div>\n  {/if}\n</div>\n\n<style>\n  .data-table-container {\n    position: relative;\n    width: 100%;\n    overflow: auto;\n  }\n  \n  .data-table {\n    width: 100%;\n    border-collapse: collapse;\n    font-size: 14px;\n  }\n  \n  .data-table th, .data-table td {\n    padding: 8px 12px;\n    border: 1px solid #ddd;\n    text-align: left;\n  }\n  \n  .data-table th {\n    background-color: #f5f5f5;\n    cursor: pointer;\n    user-select: none;\n  }\n  \n  .data-table th:hover {\n    background-color: #e5e5e5;\n  }\n  \n  .data-table tbody tr:nth-child(even) {\n    background-color: #f9f9f9;\n  }\n  \n  .data-table tbody tr:hover {\n    background-color: #f0f0f0;\n  }\n  \n  .sort-indicator {\n    margin-left: 4px;\n  }\n  \n  .empty-message {\n    text-align: center;\n    padding: 20px;\n    color: #666;\n  }\n  \n  .pagination {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-top: 16px;\n  }\n  \n  .pagination-btn {\n    padding: 6px 12px;\n    border: 1px solid #ddd;\n    background-color: #f5f5f5;\n    cursor: pointer;\n    border-radius: 4px;\n  }\n  \n  .pagination-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n  \n  .loading-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(255, 255, 255, 0.8);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-weight: bold;\n  }\n  \n  .loading {\n    pointer-events: none;\n  }\n</style>\n```\n\n### Usage Examples\n\nHere's how you could use the data-table custom element in different contexts:\n\n**HTML:**\n```html\n<data-table id=\"users-table\" loading></data-table>\n\n<script>\n  // Get a reference to the table\n  const table = document.getElementById('users-table');\n  \n  // Fetch data and update the table\n  fetch('/api/users')\n    .then(response => response.json())\n    .then(users => {\n      table.data = users;\n      table.loading = false;\n    });\n  \n  // Listen for changes\n  table.addEventListener('currentPage-change', (e) => {\n    console.log('Page changed:', e.detail.value);\n  });\n  \n  table.addEventListener('sortBy-change', (e) => {\n    console.log('Now sorting by:', e.detail.value);\n  });\n</script>\n```\n\n**Svelte:**\n```svelte\n<script>\n  import './DataTable.svelte';\n  \n  let userData = $state([]);\n  let isLoading = $state(true);\n  \n  // Fetch data\n  fetch('/api/users')\n    .then(response => response.json())\n    .then(data => {\n      userData = data;\n      isLoading"}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"What is the difference between lowercase tags and capitalized tags in Svelte templates, and how would you import and use a component from another file?","answer":"In Svelte's template syntax, the case of a tag determines whether it represents an HTML element or a component:\n\n- Lowercase tags (like `<div>`, `<button>`, `<input>`) represent regular HTML elements\n- Capitalized tags (like `<Widget>`, `<Button>`) or tags using dot notation (like `<my.stuff>`) represent components\n\nTo import and use a component from another file, you need to:\n1. Import the component in the `<script>` section\n2. Use the component in your template\n\nHere's an example:\n\n```svelte\n<script>\n  // Import the Widget component from a relative path\n  import Widget from './Widget.svelte';\n  \n  // You can also import from packages\n  import Button from 'my-ui-library/Button.svelte';\n</script>\n\n<div>\n  <!-- Using the imported components -->\n  <Widget />\n  <Button>Click me</Button>\n</div>\n```\n\nComponents can be self-closing (like `<Widget />`) if they don't have any children, or they can contain content (like `<Button>Click me</Button>`)."}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"Explain how attributes work in Svelte templates, including how boolean attributes, JavaScript expressions, and nullish values are handled.","answer":"Svelte attributes work similar to HTML attributes but with enhanced JavaScript capabilities:\n\n1. **Basic attributes**: Work exactly like HTML attributes\n   ```svelte\n   <div class=\"container\">\n     <input type=\"text\" placeholder=\"Enter your name\">\n   </div>\n   ```\n\n2. **Unquoted values**: Like in HTML, values can be unquoted\n   ```svelte\n   <input type=checkbox>\n   ```\n\n3. **JavaScript expressions in attributes**: You can include JavaScript expressions within attribute values\n   ```svelte\n   <a href=\"page/{pageNumber}\">Page {pageNumber}</a>\n   ```\n\n4. **Attributes as JavaScript expressions**: Entire attribute values can be JavaScript expressions\n   ```svelte\n   <button disabled={!isEnabled}>Submit</button>\n   ```\n\n5. **Boolean attributes**: These are included if their value is truthy and excluded if falsy\n   ```svelte\n   <input required={formIsValid} placeholder=\"Required if form is valid\">\n   <!-- If formIsValid is true, the required attribute will be included -->\n   <!-- If formIsValid is false, the required attribute will be omitted entirely -->\n   ```\n\n6. **Nullish values**: Attributes with nullish values (`null` or `undefined`) are excluded completely\n   ```svelte\n   <div title={description || null}>\n     <!-- If description is defined, title will be set to its value -->\n     <!-- If description is undefined or empty, no title attribute will appear -->\n   </div>\n   ```\n\n7. **Shorthand attribute syntax**: When the attribute name and value match, you can use the shorthand\n   ```svelte\n   <button {disabled}>\n     <!-- Equivalent to <button disabled={disabled}> -->\n   </button>\n   ```\n\nThis flexible handling of attributes makes it easy to conditionally apply attributes based on your component's state."}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"What are spread attributes in Svelte, and how can they be used with both HTML elements and components?","answer":"Spread attributes in Svelte allow you to pass multiple attributes or properties to an element or component at once using the JavaScript spread syntax (`...`). This is particularly useful when you have a collection of attributes that you want to apply without listing them individually.\n\nFor HTML elements:\n```svelte\n<script>\n  const inputAttributes = {\n    type: 'text',\n    placeholder: 'Enter your name',\n    required: true,\n    autocomplete: 'off'\n  };\n</script>\n\n<input {...inputAttributes} />\n<!-- Equivalent to: -->\n<!-- <input type=\"text\" placeholder=\"Enter your name\" required autocomplete=\"off\" /> -->\n```\n\nFor components:\n```svelte\n<script>\n  import UserProfile from './UserProfile.svelte';\n  \n  const userData = {\n    name: 'John Doe',\n    email: 'john@example.com',\n    avatar: '/images/john.png',\n    isAdmin: true\n  };\n</script>\n\n<UserProfile {...userData} />\n<!-- Equivalent to: -->\n<!-- <UserProfile name=\"John Doe\" email=\"john@example.com\" avatar=\"/images/john.png\" isAdmin={true} /> -->\n```\n\nYou can also combine spread attributes with regular attributes:\n```svelte\n<script>\n  const baseButtonProps = {\n    type: 'button',\n    class: 'btn'\n  };\n</script>\n\n<!-- Regular attributes will override any conflicting properties from the spread object -->\n<button {...baseButtonProps} class=\"btn primary\" disabled={!isValid}>\n  Submit\n</button>\n```\n\nMultiple spread attributes can be used on the same element or component:\n```svelte\n<div {...baseAttributes} {...conditionalAttributes} {...eventHandlers}>\n  Content\n</div>\n```\n\nSpread attributes are evaluated in order, so later attributes will override earlier ones if there are conflicts. This makes it easy to apply a base set of attributes and then override specific ones as needed."}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"How does event handling work in Svelte templates? Explain the naming convention, shorthand syntax, and the concept of event delegation.","answer":"Event handling in Svelte is done through attributes that start with `on`, followed by the event name. Here's a comprehensive explanation:\n\n### Basic Event Handling\n\n```svelte\n<button onclick={() => console.log('clicked')}>Click me</button>\n```\n\n### Event Naming Convention\n\nEvent attributes are case-sensitive. This allows Svelte to distinguish between standard DOM events and custom events:\n\n```svelte\n<button onclick={handleClick}>Click me</button> <!-- Listens for standard DOM 'click' event -->\n<CustomButton onClick={handleCustomClick}>Click me</CustomButton> <!-- Listens for custom 'Click' event -->\n```\n\n### Shorthand Syntax\n\nLike regular attributes, event handlers can use shorthand syntax when the handler name matches the event name:\n\n```svelte\n<script>\n  const onclick = () => console.log('clicked');\n</script>\n\n<button {onclick}>Click me</button>\n<!-- Equivalent to: -->\n<!-- <button onclick={onclick}>Click me</button> -->\n```\n\n### Spread Event Handlers\n\nEvent handlers can be included in spread attributes:\n\n```svelte\n<script>\n  const buttonEvents = {\n    onclick: () => console.log('clicked'),\n    onmouseover: () => console.log('mouse over'),\n    onmouseout: () => console.log('mouse out')\n  };\n</script>\n\n<button {...buttonEvents}>Interactive Button</button>\n```\n\n### Event Delegation\n\nSvelte uses event delegation for performance optimization. Instead of attaching event listeners to each individual element, Svelte attaches a single event listener at the application root for certain events, which then handles events as they bubble up.\n\nEvents that use delegation in Svelte include:\n- `click`, `dblclick`, `contextmenu`\n- `mousedown`, `mousemove`, `mouseout`, `mouseover`, `mouseup`\n- `pointerdown`, `pointermove`, `pointerout`, `pointerover`, `pointerup`\n- `touchend`, `touchmove`, `touchstart`\n- `input`, `change`, `beforeinput`\n- `keydown`, `keyup`\n- `focusin`, `focusout`\n\nWhen working with delegated events, there are some important considerations:\n\n1. When manually dispatching events, make sure to set `{ bubbles: true }` or the event won't reach the application root:\n```javascript\nconst event = new CustomEvent('click', { bubbles: true });\nelement.dispatchEvent(event);\n```\n\n2. When using `addEventListener` directly, avoid calling `stopPropagation()` as it will prevent the event from reaching the application root. Instead, use the `on` function from `svelte/events`:\n```svelte\n<script>\n  import { on } from 'svelte/events';\n  \n  function setup(element) {\n    const cleanup = on(element, 'click', (event) => {\n      console.log('Handled with proper order preservation');\n    });\n    \n    return cleanup; // Return cleanup function\n  }\n</script>\n\n<button use:setup>Click me</button>\n```\n\n### Touch Events\n\nFor `ontouchstart` and `ontouchmove` events, Svelte uses passive event listeners by default for better performance. This allows the browser to scroll immediately without waiting to see if `event.preventDefault()` is called. If you need to prevent defaults for these events, use the `on` function from `svelte/events`."}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"How do you include JavaScript expressions as text in a Svelte template, and what are the limitations or considerations when doing so?","answer":"In Svelte, you can include JavaScript expressions as text by surrounding them with curly braces `{}`. This is one of the core features of Svelte's template syntax.\n\n### Basic Text Expressions\n\n```svelte\n<script>\n  let name = 'world';\n  let a = 5;\n  let b = 3;\n</script>\n\n<h1>Hello {name}!</h1>\n<p>{a} + {b} = {a + b}.</p>\n```\n\nThis will render:\n```html\n<h1>Hello world!</h1>\n<p>5 + 3 = 8.</p>\n```\n\n### Complex Expressions\n\nYou can include any valid JavaScript expression within the curly braces:\n\n```svelte\n<script>\n  let count = 42;\n  let isLoggedIn = true;\n  let user = { name: 'John', role: 'admin' };\n</script>\n\n<p>The count is {count % 2 === 0 ? 'even' : 'odd'}.</p>\n<p>You are {isLoggedIn ? 'logged in' : 'logged out'}.</p>\n<p>Welcome, {user.name.toUpperCase()}!</p>\n```\n\n### Regular Expressions\n\nWhen using regular expression literals in text expressions, you need to wrap them in parentheses to avoid confusion with the curly braces:\n\n```svelte\n<script>\n  let value = 'abc123';\n</script>\n\n<div>Is alphabetic: {(/^[A-Za-z ]+$/).test(value) ? 'Yes' : 'No'}</div>\n```\n\n### Escaping Curly Braces\n\nIf you need to display actual curly braces in your template, you can use HTML entities:\n\n```svelte\n<p>To use curly braces in text, use &#123;HTML entities&#125;</p>\n<!-- Renders as: To use curly braces in text, use {HTML entities} -->\n```\n\nThe HTML entities for curly braces are:\n- For `{`: `&lbrace;`, `&lcub;`, or `&#123;`\n- For `}`: `&rbrace;`, `&rcub;`, or `&#125;`\n\n### Security Considerations\n\nText expressions are automatically escaped to prevent XSS attacks. This means if your expression evaluates to a string containing HTML, the HTML will be displayed as text rather than being rendered:\n\n```svelte\n<script>\n  let htmlString = '<strong>Bold text</strong>';\n</script>\n\n<div>{htmlString}</div>\n<!-- Renders as: <strong>Bold text</strong> (as text, not HTML) -->\n```\n\n### Rendering HTML\n\nIf you need to render HTML content, you must use the `{@html}` tag, but be careful as this bypasses Svelte's built-in XSS protection:\n\n```svelte\n<script>\n  let htmlContent = '<strong>Bold text</strong>';\n  // Be sure this content is trusted or sanitized!\n</script>\n\n<div>{@html htmlContent}</div>\n<!-- Renders as: Bold text (with actual bold formatting) -->\n```\n\nAlways ensure that any HTML content rendered with `{@html}` is trusted or properly sanitized to prevent XSS vulnerabilities."}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"What is the `{@html}` special tag in Svelte, and what security concerns should developers be aware of when using it?","answer":"The `{@html}` special tag in Svelte allows you to render HTML strings directly into the DOM. Unlike regular text expressions that automatically escape HTML to prevent security issues, `{@html}` renders the HTML as actual DOM elements.\n\n### Basic Usage\n\n```svelte\n<script>\n  let htmlString = '<strong>This text will be bold</strong> and <em>this will be italic</em>.';\n</script>\n\n<!-- Using regular text expression (HTML is escaped) -->\n<div>{htmlString}</div>\n<!-- Renders as: <strong>This text will be bold</strong> and <em>this will be italic</em>. -->\n\n<!-- Using @html (HTML is rendered) -->\n<div>{@html htmlString}</div>\n<!-- Renders as: This text will be bold and this will be italic. -->\n```\n\n### Security Concerns\n\nThe `{@html}` tag bypasses Svelte's automatic HTML escaping, which creates potential security vulnerabilities if not used carefully:\n\n1. **Cross-Site Scripting (XSS)**: If the HTML string contains malicious JavaScript, it will be executed when rendered:\n\n```svelte\n<script>\n  // DANGEROUS - never do this with user input\n  let userInput = '<img src=\"x\" onerror=\"alert(\\'XSS Attack\\')\">';\n</script>\n\n<div>{@html userInput}</div>\n<!-- This will execute the JavaScript in the onerror attribute! -->\n```\n\n2. **Data Injection**: An attacker could inject HTML that changes the appearance or behavior of your application, potentially tricking users:\n\n```svelte\n<script>\n  // DANGEROUS - never do this with user input\n  let userInput = '<div class=\"fake-login-form\">Please re-enter your password: <input type=\"password\"></div>';\n</script>\n\n<div>{@html userInput}</div>\n<!-- This could create a fake UI element to steal information -->\n```\n\n### Best Practices\n\nTo use `{@html}` safely:\n\n1. **Never use it with unsanitized user input**:\n```svelte\n<!-- DON'T DO THIS -->\n<div>{@html userComment}</div>\n```\n\n2. **Sanitize any dynamic content before rendering**:\n```svelte\n<script>\n  import sanitizeHtml from 'sanitize-html'; // Or another HTML sanitizer\n  \n  let userInput = '<script>alert(\"XSS\")</script>Hello <b>world</b>';\n  let sanitizedHtml = sanitizeHtml(userInput, {\n    allowedTags: ['b', 'i', 'em', 'strong', 'a'],\n    allowedAttributes: {\n      'a': ['href']\n    }\n  });\n  // sanitizedHtml would be: \"Hello <b>world</b>\"\n</script>\n\n<div>{@html sanitizedHtml}</div>\n```\n\n3. **Only use it with trusted content** that you control:\n```svelte\n<script>\n  // Content from your CMS or predefined templates is generally safe\n  let articleContent = `\n    <h2>Article Title</h2>\n    <p>This is <strong>safe</strong> content from our CMS.</p>\n  `;\n</script>\n\n<div class=\"article-content\">{@html articleContent}</div>\n```\n\n4. **Consider alternatives** like Markdown libraries that safely convert text to HTML:\n```svelte\n<script>\n  import marked from 'marked';\n  \n  let userMarkdown = '**Bold text** and *italic text*';\n  let htmlContent = marked(userMarkdown, { sanitize: true });\n</script>\n\n<div>{@html htmlContent}</div>\n```\n\nRemember, the golden rule is: never use `{@html}` with content that could potentially contain malicious code, especially user-generated content, without proper sanitization."}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"How do comments work in Svelte templates, and what special comment directives are available for controlling compiler behavior or adding component documentation?","answer":"Svelte supports several types of comments in templates, from basic HTML comments to special directive comments that affect compiler behavior or provide documentation.\n\n### Basic HTML Comments\n\nSvelte supports standard HTML comments that work just like they do in regular HTML:\n\n```svelte\n<!-- This is a regular HTML comment -->\n<h1>Hello world</h1>\n```\n\nThese comments are visible in the source code but not rendered in the final output.\n\n### Svelte-Ignore Comments\n\nSvelte provides special comments that start with `svelte-ignore` to disable specific compiler warnings for the next block of markup. This is particularly useful for accessibility warnings when you have intentionally designed something in a way that might trigger warnings.\n\n```svelte\n<!-- svelte-ignore a11y_autofocus -->\n<input bind:value={name} autofocus />\n```\n\nCommon ignore directives include:\n\n- `a11y_autofocus`: Ignores warnings about the autofocus attribute\n- `a11y_missing_attribute`: Ignores warnings about missing ARIA attributes\n- `a11y_missing_content`: Ignores warnings about elements that should have content\n- `a11y_no_noninteractive_tabindex`: Ignores warnings about tabindex on non-interactive elements\n- `a11y_no_interactive_element_to_noninteractive_role`: Ignores warnings about using non-interactive ARIA roles on interactive elements\n\nYou can ignore multiple warnings at once:\n\n```svelte\n<!-- svelte-ignore a11y_missing_attribute a11y_missing_content -->\n<div role=\"button\"></div>\n```\n\n### Component Documentation Comments\n\nSvelte 5 introduces a special comment syntax starting with `@component` that provides documentation for components. This documentation will appear when hovering over the component name in other files, improving developer experience:\n\n````svelte\n<!--\n@component\nThis is the main navigation component for the application.\n\n## Props\n- `items` - Array of navigation items\n- `active` - Current active item ID\n\n## Usage\n```html\n<Navigation items={navItems} active=\"home\" />\n```\n-->\n<script>\n  let { items, active } = $props();\n</script>\n\n<nav>\n  <ul>\n    {#each items as item}\n      <li class:active={item.id === active}>\n        <a href={item.url}>{item.label}</a>\n      </li>\n    {/each}\n  </ul>\n</nav>\n````\n\nThese component documentation comments:\n- Support Markdown formatting\n- Can include code examples using code blocks\n- Will show up in editor tooltips when hovering over the component name in imports or usage\n- Help document the component API without requiring external documentation\n\n### Script and Style Comments\n\nYou can also use JavaScript comments in the `<script>` section and CSS comments in the `<style>` section:\n\n```svelte\n<script>\n  // This is a JavaScript single-line comment\n  \n  /*\n    This is a JavaScript\n    multi-line comment\n  */\n  \n  let count = 0;\n</script>\n\n<style>\n  /* This is a CSS comment */\n  button {\n    /* This styling makes the button rounded */\n    border-radius: 4px;\n  }\n</style>\n\n<button on:click={() => count++}>\n  Clicked {count} times\n</button>\n```\n\n### Best Practices for Comments\n\n1. Use `svelte-ignore` sparingly and only when you're sure the warning can be safely ignored\n2. Document why you're ignoring warnings for future developers\n3. Use component documentation comments for reusable components to improve their usability\n4. Keep HTML comments out of critical rendering paths to avoid performance impacts\n\nComments are a powerful tool in Svelte for both documentation and controlling compiler behavior, making your code more maintainable and accessible."}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"Explain how Svelte handles boolean attributes and nullish values in element attributes. How does this differ from standard HTML behavior?","answer":"Svelte has a sophisticated system for handling attributes that extends beyond standard HTML behavior, particularly for boolean attributes and nullish values.\n\n### Boolean Attributes in Svelte\n\nIn Svelte, boolean attributes are included on an element if their value is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) and excluded if their value is [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy).\n\n```svelte\n<script>\n  let isDisabled = true;\n  let isRequired = false;\n</script>\n\n<button disabled={isDisabled}>This button is disabled</button>\n<input required={isRequired} placeholder=\"This input is not required\" />\n```\n\nIn this example:\n- The `disabled` attribute will be included because `isDisabled` is `true`\n- The `required` attribute will be completely omitted because `isRequired` is `false`\n\nThe rendered HTML would be:\n```html\n<button disabled>This button is disabled</button>\n<input placeholder=\"This input is not required\">\n```\n\nThis behavior differs from standard HTML where setting an attribute to `false` would still include the attribute with the string value \"false\":\n```html\n<!-- Standard HTML behavior if you wrote disabled=\"false\" -->\n<button disabled=\"false\">This would still be disabled in HTML</button>\n```\n\nIn HTML, the mere presence of boolean attributes like `disabled`, `checked`, `selected`, etc., activates them regardless of their value. Svelte's approach gives you more control by completely removing the attribute when the value is falsy.\n\n### Nullish Values in Svelte\n\nFor non-boolean attributes, Svelte includes the attribute unless its value is [nullish](https://developer.mozilla.org/en-US/docs/Glossary/Nullish) (`null` or `undefined`).\n\n```svelte\n<script>\n  let title = null;\n  let description = undefined;\n  let emptyString = '';\n  let zero = 0;\n</script>\n\n<div title={title}>No title attribute will appear</div>\n<div alt={description}>No alt attribute will appear</div>\n<div data-value={emptyString}>data-value=\"\" will appear</div>\n<div tabindex={zero}>tabindex=\"0\" will appear</div>\n```\n\nThe rendered HTML would be:\n```html\n<div>No title attribute will appear</div>\n<div>No alt attribute will appear</div>\n<div data-value=\"\">data-value=\"\" will appear</div>\n<div tabindex=\"0\">tabindex=\"0\" will appear</div>\n```\n\nThis behavior is particularly useful for conditionally applying attributes:\n\n```svelte\n<script>\n  let errorMessage = hasError ? 'Invalid input' : null;\n</script>\n\n<input aria-errormessage={errorMessage} />\n```\n\nIf `hasError` is true, the `aria-errormessage` attribute will be included; otherwise, it will be omitted entirely.\n\n### Practical Applications\n\nThis behavior enables several powerful patterns:\n\n1. **Conditional attributes**:\n```svelte\n<div class={condition ? 'active' : null}>\n  <!-- 'class' attribute only appears when condition is true -->\n</div>\n```\n\n2. **Optional ARIA attributes**:\n```svelte\n<button \n  aria-expanded={isExpanded}\n  aria-controls={isExpanded ? 'dropdown-content' : null}\n>\n  Toggle\n</button>\n```\n\n3. **Clean conditional rendering**:\n```svelte\n<script>\n  let href = isExternal ? externalUrl : null;\n  let onClick = isExternal ? null : handleInternalNavigation;\n</script>\n\n<a {href} onclick={onClick}>\n  Link\n</a>\n```\n\n### Summary of Differences from Standard HTML\n\n1. **Boolean attributes**:\n   - HTML: Present = true, regardless of value\n   - Svelte: Present if truthy, absent if falsy\n\n2. **Nullish values**:\n   - HTML: All values are converted to strings, including \"null\" and \"undefined\"\n   - Svelte: Attributes with `null` or `undefined` values are completely omitted\n\n3. **Empty strings**:\n   - HTML: Renders as empty attribute (e.g., `title=\"\"`)\n   - Svelte: Same behavior as HTML (not treated as nullish)\n\nThis system gives Svelte developers fine-grained control over attribute rendering while maintaining a clean, declarative syntax."}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"What is event delegation in Svelte, and which events are automatically delegated? What special considerations should developers keep in mind when working with delegated events?","answer":"Event delegation is a performance optimization technique that Svelte uses to reduce the number of event listeners in an application. Instead of attaching event listeners to each individual element, Svelte attaches a single event listener at the application root for certain events, which then handles events as they bubble up through the DOM.\n\n### How Event Delegation Works in Svelte\n\nWhen you use an event attribute like `onclick` in Svelte, the framework doesn't always attach a direct event listener to that element. Instead, for many common events, it attaches a single listener at the root level and uses the event's bubbling phase to determine which handler should be called based on the event's path.\n\n```svelte\n<button onclick={handleClick}>Click me</button>\n```\n\nFor this button, Svelte might not attach the event listener directly to the button. Instead, it relies on the click event bubbling up to the root where a single listener handles all click events.\n\n### Events That Are Delegated in Svelte\n\nSvelte automatically delegates the following events:\n\n**Mouse Events:**\n- `click`\n- `dblclick`\n- `mousedown`\n- `mousemove`\n- `mouseout`\n- `mouseover`\n- `mouseup`\n- `contextmenu`\n\n**Pointer Events:**\n- `pointerdown`\n- `pointermove`\n- `pointerout`\n- `pointerover`\n- `pointerup`\n\n**Touch Events:**\n- `touchend`\n- `touchmove`\n- `touchstart`\n\n**Form Events:**\n- `input`\n- `change`\n- `beforeinput`\n\n**Keyboard Events:**\n- `keydown`\n- `keyup`\n\n**Focus Events:**\n- `focusin`\n- `focusout`\n\n### Special Considerations for Working with Delegated Events\n\n1. **Event Bubbling is Required**\n\nWhen manually dispatching events that Svelte delegates, you must set the `bubbles: true` option, or the event won't reach the application root where the listener is attached:\n\n```javascript\n// This won't work with delegated events\nelement.dispatchEvent(new CustomEvent('click'));\n\n// This will work\nelement.dispatchEvent(new CustomEvent('click', { bubbles: true }));\n```\n\n2. **Avoid `stopPropagation` with Direct Event Listeners**\n\nIf you use `addEventListener` directly and call `stopPropagation()`, it will prevent the event from reaching the application root, which means Svelte's delegated handlers won't be invoked:\n\n```javascript\n// Problematic: will prevent Svelte's delegated handlers from running\nelement.addEventListener('click', (event) => {\n  event.stopPropagation();\n  // Handle event\n});\n```\n\n3. **Use the `on` Function from `svelte/events`**\n\nTo ensure proper event handling with correct order preservation, use the `on` function from `svelte/events` instead of direct `addEventListener` calls:\n\n```svelte\n<script>\n  import { on } from 'svelte/events';\n  \n  function setupButton(node) {\n    // This ensures proper order preservation with Svelte's event system\n    const dispose = on(node, 'click', (event) => {\n      console.log('Button clicked');\n    });\n    \n    return {\n      destroy() {\n        dispose(); // Clean up when the element is removed\n      }\n    };\n  }\n</script>\n\n<button use:setupButton>Click me</button>\n```\n\n4. **Event Handler Execution Order**\n\nWhen using `addEventListener` directly, handlers added manually inside the application root will run _before_ handlers added declaratively deeper in the DOM (with e.g., `onclick={...}`), in both capturing and bubbling phases. This can lead to unexpected behavior.\n\n5. **Passive Touch Event Listeners**\n\nFor performance reasons, `ontouchstart` and `ontouchmove` event handlers are passive by default in Svelte. This means they can't call `preventDefault()` to prevent scrolling. This greatly improves scrolling performance on touch devices.\n\nIf you need to prevent default behavior for these events (e.g., to prevent scrolling when implementing a custom slider), you should use the `on` function:\n\n```svelte\n<script>\n  import { on } from 'svelte/events';\n  \n  function setupTouchHandler(node) {\n    const dispose = on(node, 'touchmove', (event) => {\n      // Now we can prevent default\n      event.preventDefault();\n    }, { passive: false });\n    \n    return {\n      destroy() {\n        dispose();\n      }\n    };\n  }\n</script>\n\n<div use:setupTouchHandler class=\"custom-slider\">\n  <!-- Custom slider implementation -->\n</div>\n```\n\n### Example: Working with Delegated Events\n\n```svelte\n<script>\n  import { on } from 'svelte/events';\n  \n  function handleClick() {\n    console.log('Button clicked via Svelte delegation');\n  }\n  \n  function setupManualHandler(node) {\n    // Using Svelte's 'on' helper ensures proper integration with the delegation system\n    const dispose = on(node, 'click', (event) => {\n      console.log('Button clicked via manual handler');\n      // Don't call stopPropagation here unless you specifically want to\n      // prevent the delegated handler from running\n    });\n    \n    return {\n      destroy() {\n        dispose();\n      }\n    };\n  }\n  \n  function dispatchCustomEvent(node) {\n    function handleCustomDispatch() {\n      // Make sure to set bubbles: true for delegated events\n      const event = new CustomEvent('click', { \n        bubbles: true,\n        detail: { custom: true }\n      });\n      node.dispatchEvent(event);\n    }\n    \n    node.addEventListener('mouseenter', handleCustomDispatch);\n    \n    return {\n      destroy() {\n        node.removeEventListener('mouseenter', handleCustomDispatch);\n      }\n    };\n  }\n</script>\n\n<button \n  onclick={handleClick}\n  use:setupManualHandler\n  use:dispatchCustomEvent\n>\n  Hover and click me\n</button>\n```\n\nUnderstanding event delegation in Svelte helps you work more effectively with the framework's event system and avoid common pitfalls when implementing custom event handling logic."}
{"source":"docs/svelte/03-template-syntax/01-basic-markup.md","question":"How can you include literal curly braces in a Svelte template, and what approach should you take when working with regular expressions in text expressions?","answer":"Including literal curly braces in Svelte templates and working with regular expressions requires special handling because curly braces have special meaning in Svelte's template syntax.\n\n### Including Literal Curly Braces in Templates\n\nSince curly braces `{}` are used for JavaScript expressions in Svelte templates, you need to use HTML entities to display literal curly braces:\n\n```svelte\n<p>To display a literal curly brace, use HTML entities: &#123; and &#125;</p>\n```\n\nSvelte supports several HTML entity options for curly braces:\n\n1. For opening curly brace `{`:\n   - `&lbrace;`\n   - `&lcub;`\n   - `&#123;`\n\n2. For closing curly brace `}`:\n   - `&rbrace;`\n   - `&rcub;`\n   - `&#125;`\n\nExamples of using these entities:\n\n```svelte\n<p>CSS uses &lbrace; and &rbrace; for style blocks.</p>\n<p>JSON objects use &lcub; and &rcub; to define objects.</p>\n<p>In JavaScript, functions often contain &#123; and &#125; to define their body.</p>\n```\n\nThe rendered output would be:\n\n```\nCSS uses { and } for style blocks.\nJSON objects use { and } to define objects.\nIn JavaScript, functions often contain { and } to define their body.\n```\n\n### Working with Regular Expressions in Text Expressions\n\nRegular expressions in JavaScript often use forward slashes (`/pattern/`) and can include various special characters, including curly braces for quantifiers. When using regular expression literals in Svelte text expressions, you need to wrap them in parentheses to avoid confusion with Svelte's template syntax:\n\n```svelte\n<script>\n  let text = \"abc123\";\n  let onlyLetters = \"abcDEF\";\n  let repeatedText = \"abababab\";\n</script>\n\n<!-- Incorrect - will cause parsing errors -->\n<div>{/^[A-Za-z]+$/.test(text) ? 'Letters only' : 'Contains non-letters'}</div>\n\n<!-- Correct - wrapped in parentheses -->\n<div>{(/^[A-Za-z]+$/).test(text) ? 'Letters only' : 'Contains non-letters'}</div>\n\n<!-- Testing if a string contains only letters (case insensitive) -->\n<div>Is alphabetic only: {(/^[A-Za-z]+$/).test(onlyLetters) ? 'Yes' : 'No'}</div>\n\n<!-- Testing if a string matches a pattern with repetition -->\n<div>Is repetitive pattern: {(/^(ab)+$/).test(repeatedText) ? 'Yes' : 'No'}</div>\n```\n\nFor more complex regular expression usage, it's often cleaner to define the regex in the script section:\n\n```svelte\n<script>\n  let emailInput = \"user@example.com\";\n  \n  // Define regex in the script section\n  const EMAIL_REGEX = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  \n  function isValidEmail(email) {\n    return EMAIL_REGEX.test(email);\n  }\n</script>\n\n<div>\n  Email validation: {isValidEmail(emailInput) ? 'Valid' : 'Invalid'}\n</div>\n```\n\n### Combining Both: Displaying Regex Patterns with Curly Braces\n\nIf you need to display actual regex patterns that contain curly braces, combine both approaches:\n\n```svelte\n<script>\n  // A regex that matches 2-4 digits\n  const digitPattern = /\\d{2,4}/;\n  const patternString = String(digitPattern);\n</script>\n\n<div>\n  <p>The pattern {patternString} matches 2 to 4 digits.</p>\n  <p>In regex syntax, &lbrace;2,4&rbrace; means \"between 2 and 4 occurrences\".</p>\n</div>\n```\n\n### Advanced Example: Teaching Regex in a Svelte App\n\nHere's a more comprehensive example that might be used in an educational app about regular expressions:\n\n```svelte\n<script>\n  let patterns = [\n    { name: 'Digit', regex: /\\d/, description: 'Matches any digit (0-9)' },\n    { name: 'Word character', regex: /\\w/, description: 'Matches any letter, digit, or underscore' },\n    { name: 'Whitespace', regex: /\\s/, description: 'Matches any whitespace character' },\n    { name: 'Quantifier {n}', regex: /a{3}/, description: 'Matches exactly 3 consecutive \"a\" characters' },\n    { name: 'Quantifier {n,m}', regex: /a{2,4}/, description: 'Matches between 2 and 4 consecutive \"a\" characters' }\n  ];\n  \n  let testString = \"aa aaa aaaa\";\n  \n  function testRegex(regex, str) {\n    return regex.test(str);\n  }\n  \n  function highlightMatches(regex, str) {\n    // Convert regex to global to find all matches\n    const globalRegex = new RegExp(regex.source, 'g');\n    return str.replace(globalRegex, match => `<span class=\"highlight\">${match}</span>`);\n  }\n</script>\n\n<style>\n  .highlight {\n    background-color: yellow;\n    font-weight: bold;\n  }\n  \n  .pattern-card {\n    border: 1px solid #ccc;\n    padding: 10px;\n    margin-bottom: 10px;\n    border-radius: 4px;\n  }\n  \n  .matches {\n    color: green;\n  }\n  \n  .no-match {\n    color: red;\n  }\n</style>\n\n<h1>Regular Expression Patterns</h1>\n\n<input bind:value={testString} placeholder=\"Test string\">\n\n<div class=\"pattern-list\">\n  {#each patterns as pattern}\n    <div class=\"pattern-card\">\n      <h3>{pattern.name}</h3>\n      <p>Pattern: <code>{String(pattern.regex)}</code></p>\n      <p>{pattern.description}</p>\n      <p class={testRegex(pattern.regex, testString) ? 'matches' : 'no-match'}>\n        {testRegex(pattern.regex, testString) ? 'Matches' : 'Does not match'} the test string\n      </p>\n      {#if testRegex(pattern.regex, testString)}\n        <p>Matches highlighted: {@html highlightMatches(pattern.regex, testString)}</p>\n      {/if}\n    </div>\n  {/each}\n</div>\n\n<div class=\"regex-explanation\">\n  <h2>Understanding Curly Braces in Regex</h2>\n  <p>\n    In regular expressions, curly braces (&lbrace; and &rbrace;) are used as quantifiers to specify \n    how many times a character or group should be repeated.\n  </p>\n  <ul>\n    <li><code>\\d&lbrace;3&rbrace;</code> - Matches exactly 3 digits</li>\n    <li><code>\\w&lbrace;2,4&rbrace;</code> - Matches between 2 and 4 word characters</li>\n    <li><code>a&lbrace;2,&rbrace;</code> - Matches 2 or more \"a\" characters</li>\n  </ul>\n</div>\n```\n\nThis example demonstrates both how to properly use regular expressions in Svelte templates and how to display literal curly braces when explaining regex syntax."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"What is the basic syntax for conditional rendering in Svelte and how does it differ from conditional rendering in React or Vue?","answer":"In Svelte, conditional rendering is accomplished using the `{#if}` block syntax. The basic structure is:\n\n```svelte\n{#if expression}\n  <!-- Content to render when expression is truthy -->\n{/if}\n```\n\nThis differs significantly from React and Vue:\n\nIn React, conditional rendering typically uses JavaScript operators:\n```jsx\n// React conditional rendering\nfunction MyComponent({ condition }) {\n  return (\n    <div>\n      {condition ? <p>Condition is true</p> : null}\n      // or\n      {condition && <p>Condition is true</p>}\n    </div>\n  );\n}\n```\n\nIn Vue, you would use the v-if directive:\n```html\n<!-- Vue conditional rendering -->\n<template>\n  <div>\n    <p v-if=\"condition\">Condition is true</p>\n  </div>\n</template>\n```\n\nSvelte's approach uses template syntax that's part of the Svelte compiler. This allows for more readable templates, especially for complex conditional logic. The Svelte compiler handles the conditional rendering at build time, generating efficient JavaScript that doesn't include virtual DOM diffing overhead.\n\nFor example:\n```svelte\n<script>\n  let answer = 42;\n</script>\n\n{#if answer === 42}\n  <p>what was the question?</p>\n{/if}\n```\n\nThis will only render the paragraph when `answer` equals 42."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"How do you implement multiple conditional branches in Svelte's if blocks?","answer":"Svelte allows for multiple conditional branches using the `{:else if}` and `{:else}` syntax. This creates a structure similar to if-else if-else chains in JavaScript.\n\nThe full syntax pattern is:\n\n```svelte\n{#if firstCondition}\n  <!-- Content for when firstCondition is true -->\n{:else if secondCondition}\n  <!-- Content for when firstCondition is false but secondCondition is true -->\n{:else if thirdCondition}\n  <!-- Content for when both first and second conditions are false but thirdCondition is true -->\n{:else}\n  <!-- Content for when all conditions are false (fallback) -->\n{/if}\n```\n\nHere's a practical example from the documentation:\n\n```svelte\n{#if porridge.temperature > 100}\n  <p>too hot!</p>\n{:else if 80 > porridge.temperature}\n  <p>too cold!</p>\n{:else}\n  <p>just right!</p>\n{/if}\n```\n\nIn this example:\n1. If the porridge temperature is greater than 100, it shows \"too hot!\"\n2. If that's not true but the temperature is less than 80, it shows \"too cold!\"\n3. If neither condition is true (temperature is between 80 and 100, inclusive), it shows \"just right!\"\n\nYou can add as many `{:else if}` branches as needed for your logic, making complex conditional rendering straightforward and readable."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"Can Svelte's if blocks be used inside HTML elements or only to wrap entire elements? Provide examples of both approaches.","answer":"Svelte's if blocks are quite flexible and can be used both to wrap entire elements and within elements to conditionally render text or portions of content. This is mentioned in the documentation with the note: \"Blocks don't have to wrap elements, they can also wrap text within elements.\"\n\nExample 1: Wrapping entire elements\n```svelte\n<script>\n  let isLoggedIn = true;\n</script>\n\n{#if isLoggedIn}\n  <nav>\n    <a href=\"/dashboard\">Dashboard</a>\n    <a href=\"/profile\">Profile</a>\n    <a href=\"/settings\">Settings</a>\n  </nav>\n{:else}\n  <nav>\n    <a href=\"/login\">Login</a>\n    <a href=\"/signup\">Sign Up</a>\n  </nav>\n{/if}\n```\n\nExample 2: Conditional content within an element\n```svelte\n<script>\n  let user = { name: 'Alice', isAdmin: true };\n</script>\n\n<div class=\"user-card\">\n  <h2>{user.name} \n    {#if user.isAdmin}\n      <span class=\"badge\">Admin</span>\n    {/if}\n  </h2>\n  \n  <p>\n    Welcome back! \n    {#if user.isAdmin}\n      You have administrative privileges.\n    {:else}\n      You have standard user access.\n    {/if}\n  </p>\n</div>\n```\n\nExample 3: Conditionally adding attributes\n```svelte\n<script>\n  let isDisabled = true;\n  let buttonType = 'primary';\n</script>\n\n<button \n  class=\"btn {#if buttonType === 'primary'}btn-primary{:else}btn-secondary{/if}\"\n  {#if isDisabled}disabled{/if}\n>\n  Submit\n</button>\n```\n\nThis flexibility makes Svelte's conditional rendering powerful for creating dynamic UIs with clean, readable template code."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"How does Svelte's reactivity system interact with conditional rendering? Explain with an example showing how changes to reactive variables affect what's rendered.","answer":"Svelte's reactivity system seamlessly integrates with conditional rendering. When reactive variables (those that appear in assignments in a component) change, Svelte automatically updates the DOM to reflect the new state, including re-evaluating conditional blocks.\n\nHere's an example demonstrating this interaction:\n\n```svelte\n<script>\n  let count = 0;\n  let threshold = 5;\n  \n  function increment() {\n    count += 1;\n  }\n  \n  function decrement() {\n    count -= 1;\n  }\n  \n  // This is a derived value using reactivity\n  $: message = count > threshold ? 'High count' : 'Low count';\n</script>\n\n<button on:click={decrement}>-</button>\n<span>{count}</span>\n<button on:click={increment}>+</button>\n\n{#if count > threshold}\n  <p class=\"warning\">Count is getting high!</p>\n{:else if count < 0}\n  <p class=\"error\">Count shouldn't be negative!</p>\n{:else}\n  <p class=\"normal\">Count is in the normal range.</p>\n{/if}\n\n<div>Status: {message}</div>\n```\n\nIn this example:\n\n1. We have a reactive variable `count` that changes when buttons are clicked\n2. The conditional rendering block evaluates `count > threshold` and `count < 0` expressions\n3. When `count` changes:\n   - Svelte automatically re-evaluates the conditions in the `{#if}` block\n   - It updates the DOM to show the appropriate paragraph based on the current value\n   - The derived `message` value is also recalculated\n\nThis happens efficiently because:\n- Svelte analyzes your component at compile time to determine dependencies\n- It generates optimized JavaScript that only updates the parts of the DOM that need to change\n- There's no virtual DOM diffing or runtime overhead for tracking dependencies\n\nIf we added another reactive statement like:\n```svelte\n$: console.log(`Count is now ${count}`);\n```\n\nThis would also run whenever `count` changes, showing how Svelte's reactivity extends beyond just UI updates."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"What happens when you use complex expressions in Svelte's if blocks? Are there any limitations or best practices to be aware of?","answer":"Svelte allows you to use complex expressions in `{#if}` blocks, which gives you flexibility but also comes with some considerations for maintainability and performance.\n\nHere are examples of complex expressions and best practices:\n\n**Basic complex expressions**:\n```svelte\n<script>\n  let user = { age: 25, subscriptionTier: 'premium', lastLogin: new Date() };\n  let minAge = 18;\n  let premiumFeatures = ['advanced', 'priority'];\n</script>\n\n{#if user.age >= minAge && user.subscriptionTier === 'premium' && \n      (new Date() - user.lastLogin) < 1000 * 60 * 60 * 24 * 7}\n  <div>Welcome back premium user! Here are your special features.</div>\n{/if}\n```\n\n**Best practices and limitations**:\n\n1. **Readability concerns**: Very complex expressions can make templates harder to read and maintain. Consider moving complex logic to the script section:\n\n```svelte\n<script>\n  let user = { age: 25, subscriptionTier: 'premium', lastLogin: new Date() };\n  \n  // Move complex logic to computed values\n  $: isActivePremiumUser = \n      user.age >= 18 && \n      user.subscriptionTier === 'premium' && \n      (new Date() - user.lastLogin) < 1000 * 60 * 60 * 24 * 7;\n</script>\n\n{#if isActivePremiumUser}\n  <div>Welcome back premium user! Here are your special features.</div>\n{/if}\n```\n\n2. **Performance considerations**: Very complex expressions that depend on many reactive values will be re-evaluated whenever any of those values change. Breaking them down can sometimes help with performance:\n\n```svelte\n<script>\n  let items = [1, 2, 3, 4, 5];\n  let filter = 'even';\n  \n  // Computed once rather than in template\n  $: filteredItems = filter === 'even' \n    ? items.filter(n => n % 2 === 0) \n    : items.filter(n => n % 2 !== 0);\n  \n  $: hasFilteredItems = filteredItems.length > 0;\n</script>\n\n{#if hasFilteredItems}\n  <ul>\n    {#each filteredItems as item}\n      <li>{item}</li>\n    {/each}\n  </ul>\n{:else}\n  <p>No items match your filter.</p>\n{/if}\n```\n\n3. **Side effects**: Be cautious about expressions with side effects in conditional blocks:\n\n```svelte\n<!-- Not recommended: side effect in condition -->\n{#if saveUserPreference(user.preference) && user.isActive}\n  <div>Preferences saved and applied!</div>\n{/if}\n\n<!-- Better approach -->\n<script>\n  $: preferenceSaved = user.isActive ? saveUserPreference(user.preference) : false;\n</script>\n\n{#if preferenceSaved}\n  <div>Preferences saved and applied!</div>\n{/if}\n```\n\n4. **No statements in expressions**: You can only use expressions, not statements:\n\n```svelte\n<!-- This won't work -->\n{#if let x = 5; x > 3}\n  <p>This won't compile</p>\n{/if}\n\n<!-- Do this instead -->\n<script>\n  let x = 5;\n  $: isGreaterThan3 = x > 3;\n</script>\n\n{#if isGreaterThan3}\n  <p>This works!</p>\n{/if}\n```\n\nBy following these best practices, you can maintain readable templates while still leveraging Svelte's powerful conditional rendering capabilities."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"How can you handle conditional rendering of components in Svelte? Provide an example of conditionally rendering different components based on state.","answer":"In Svelte, you can conditionally render different components using the same `{#if}` block syntax. This is a powerful pattern for switching between different views or components based on application state.\n\nHere's a comprehensive example demonstrating conditional component rendering:\n\n```svelte\n<script>\n  import LoginForm from './LoginForm.svelte';\n  import SignupForm from './SignupForm.svelte';\n  import Dashboard from './Dashboard.svelte';\n  import LoadingSpinner from './LoadingSpinner.svelte';\n  import ErrorMessage from './ErrorMessage.svelte';\n  \n  let authState = 'login'; // Possible values: 'login', 'signup', 'authenticated'\n  let isLoading = false;\n  let error = null;\n  let userData = null;\n  \n  async function handleLogin(credentials) {\n    try {\n      isLoading = true;\n      error = null;\n      // Simulating API call\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      if (credentials.username === 'demo' && credentials.password === 'password') {\n        userData = { username: 'demo', name: 'Demo User', roles: ['user'] };\n        authState = 'authenticated';\n      } else {\n        throw new Error('Invalid credentials');\n      }\n    } catch (err) {\n      error = err.message;\n    } finally {\n      isLoading = false;\n    }\n  }\n  \n  function switchToSignup() {\n    authState = 'signup';\n    error = null;\n  }\n  \n  function switchToLogin() {\n    authState = 'login';\n    error = null;\n  }\n  \n  function logout() {\n    userData = null;\n    authState = 'login';\n  }\n</script>\n\n<div class=\"auth-container\">\n  {#if isLoading}\n    <LoadingSpinner />\n  {:else if error}\n    <ErrorMessage message={error} />\n    <button on:click={() => error = null}>Dismiss</button>\n  {:else if authState === 'authenticated' && userData}\n    <Dashboard user={userData} onLogout={logout} />\n  {:else if authState === 'login'}\n    <LoginForm onSubmit={handleLogin} onSwitchToSignup={switchToSignup} />\n  {:else if authState === 'signup'}\n    <SignupForm onSubmit={handleSignup} onSwitchToLogin={switchToLogin} />\n  {:else}\n    <!-- Fallback for unexpected states -->\n    <div>\n      <p>Something went wrong. Please try again.</p>\n      <button on:click={switchToLogin}>Return to login</button>\n    </div>\n  {/if}\n</div>\n```\n\nIn this example:\n\n1. We import various components: `LoginForm`, `SignupForm`, `Dashboard`, etc.\n2. Based on the `authState` and other variables (`isLoading`, `error`), we conditionally render different components\n3. The priority of conditions matters - we check for loading and error states first, then the various auth states\n4. Each component receives appropriate props and event handlers\n\nThis pattern is commonly used for:\n\n- Authentication flows (as shown)\n- Multi-step forms or wizards\n- Different application views\n- Feature toggles\n- Error/success/loading states\n\nYou can also conditionally render components based on props passed to a parent component:\n\n```svelte\n<script>\n  // A component that renders different visualizations based on data type\n  import BarChart from './charts/BarChart.svelte';\n  import LineChart from './charts/LineChart.svelte';\n  import PieChart from './charts/PieChart.svelte';\n  import TableView from './TableView.svelte';\n  \n  export let data;\n  export let visualizationType = 'table'; // Default view\n</script>\n\n<div class=\"visualization-container\">\n  {#if visualizationType === 'bar'}\n    <BarChart data={data} />\n  {:else if visualizationType === 'line'}\n    <LineChart data={data} />\n  {:else if visualizationType === 'pie'}\n    <PieChart data={data} />\n  {:else}\n    <TableView data={data} />\n  {/if}\n  \n  <div class=\"controls\">\n    <button class:active={visualizationType === 'table'} on:click={() => visualizationType = 'table'}>\n      Table\n    </button>\n    <button class:active={visualizationType === 'bar'} on:click={() => visualizationType = 'bar'}>\n      Bar Chart\n    </button>\n    <button class:active={visualizationType === 'line'} on:click={() => visualizationType = 'line'}>\n      Line Chart\n    </button>\n    <button class:active={visualizationType === 'pie'} on:click={() => visualizationType = 'pie'}>\n      Pie Chart\n    </button>\n  </div>\n</div>\n```\n\nThis approach keeps your templates clean and declarative while allowing for complex conditional logic."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"How does Svelte handle the mounting and unmounting of elements when using conditional rendering? What are the implications for components with lifecycle methods?","answer":"Svelte's conditional rendering with `{#if}` blocks directly affects when elements are mounted (added to the DOM) and unmounted (removed from the DOM). When a condition becomes truthy, Svelte creates and inserts the corresponding DOM elements; when it becomes falsy, Svelte removes those elements completely.\n\nThis behavior has important implications for component lifecycle and resource management:\n\n### Basic Element Mounting/Unmounting\n\n```svelte\n<script>\n  let showElement = false;\n  \n  function toggle() {\n    showElement = !showElement;\n  }\n</script>\n\n<button on:click={toggle}>\n  {showElement ? 'Hide' : 'Show'} Element\n</button>\n\n{#if showElement}\n  <div class=\"notification\">This element is conditionally rendered!</div>\n{/if}\n```\n\nIn this example, the div.notification is completely removed from the DOM when `showElement` is false, not just hidden.\n\n### Component Lifecycle\n\nWhen conditional rendering involves components, Svelte's lifecycle hooks come into play:\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n  let showChild = false;\n</script>\n\n<button on:click={() => showChild = !showChild}>\n  {showChild ? 'Destroy' : 'Create'} Component\n</button>\n\n{#if showChild}\n  <ChildComponent />\n{/if}\n```\n\n```svelte\n<!-- ChildComponent.svelte -->\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  let interval;\n  \n  onMount(() => {\n    console.log('Component mounted');\n    interval = setInterval(() => {\n      console.log('Component is alive');\n    }, 1000);\n    \n    return () => {\n      // This cleanup function runs when the component is destroyed\n      clearInterval(interval);\n      console.log('Cleanup in onMount return function');\n    };\n  });\n  \n  onDestroy(() => {\n    clearInterval(interval);\n    console.log('Component destroyed');\n  });\n</script>\n\n<div>I am a child component</div>\n```\n\nWhen `showChild` toggles:\n1. When changing from `false` to `true`:\n   - The component is created\n   - `onMount` is called\n   - The interval starts running\n\n2. When changing from `true` to `false`:\n   - The cleanup function returned from `onMount` runs\n   - `onDestroy` is called\n   - The component is removed from the DOM\n   - The interval is cleared (preventing memory leaks)\n\n### Implications and Best Practices\n\n1. **Resource Management**: Always clean up resources in `onDestroy` or the function returned from `onMount`:\n   - Event listeners\n   - Timers/intervals\n   - WebSocket connections\n   - Subscriptions to stores or observables\n\n2. **Performance Considerations**:\n   - Frequent mounting/unmounting of complex components can impact performance\n   - For components that toggle visibility frequently, consider using CSS for hiding instead:\n\n```svelte\n<script>\n  let isVisible = true;\n</script>\n\n<!-- Using CSS instead of conditional rendering for frequent toggles -->\n<div class:hidden={!isVisible}>\n  This content just toggles visibility without DOM creation/destruction\n</div>\n\n<style>\n  .hidden {\n    display: none;\n  }\n</style>\n```\n\n3. **State Persistence**: Components are completely recreated when conditions change:\n\n```svelte\n<script>\n  let showCounter = false;\n  let counterType = 'simple';\n</script>\n\n<button on:click={() => showCounter = !showCounter}>Toggle Counter</button>\n<button on:click={() => counterType = counterType === 'simple' ? 'advanced' : 'simple'}>\n  Switch Counter Type\n</button>\n\n{#if showCounter}\n  {#if counterType === 'simple'}\n    <SimpleCounter />\n  {:else}\n    <AdvancedCounter />\n  {/if}\n{/if}\n```\n\nIn this example:\n- Toggling `showCounter` will mount/unmount the active counter component\n- Changing `counterType` will unmount one counter component and mount the other\n- Any internal state in these components will be lost during these transitions\n\n4. **Animations**: For smoother transitions when conditionally rendering, consider using Svelte's built-in transitions:\n\n```svelte\n<script>\n  import { fade, slide } from 'svelte/transition';\n  let showElement = false;\n</script>\n\n<button on:click={() => showElement = !showElement}>Toggle</button>\n\n{#if showElement}\n  <div transition:slide>\n    This element will slide in and out instead of abruptly appearing/disappearing\n  </div>\n{/if}\n```\n\nBy understanding these implications, you can effectively manage component lifecycles and resources when using conditional rendering in Svelte."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"How do Svelte's if blocks interact with other block-level directives like #each and #await? Provide examples of nesting these blocks.","answer":"Svelte's block directives (`{#if}`, `{#each}`, and `{#await}`) can be nested within each other to create complex rendering logic. This nesting is a powerful feature that allows for highly dynamic UIs.\n\n### Nesting `{#if}` inside `{#each}`\n\nA common pattern is to conditionally render items within a loop:\n\n```svelte\n<script>\n  let users = [\n    { id: 1, name: 'Alice', isAdmin: true, isActive: true },\n    { id: 2, name: 'Bob', isAdmin: false, isActive: true },\n    { id: 3, name: 'Charlie', isAdmin: false, isActive: false },\n    { id: 4, name: 'Diana', isAdmin: true, isActive: false }\n  ];\n  \n  let showInactive = false;\n</script>\n\n<label>\n  <input type=\"checkbox\" bind:checked={showInactive}>\n  Show inactive users\n</label>\n\n<ul class=\"user-list\">\n  {#each users as user (user.id)}\n    {#if user.isActive || showInactive}\n      <li class:admin={user.isAdmin} class:inactive={!user.isActive}>\n        {user.name}\n        {#if user.isAdmin}\n          <span class=\"badge\">Admin</span>\n        {/if}\n        {#if !user.isActive}\n          <span class=\"status\">Inactive</span>\n        {/if}\n      </li>\n    {/if}\n  {/each}\n</ul>\n\n<style>\n  .admin { font-weight: bold; }\n  .inactive { opacity: 0.7; }\n  .badge { color: gold; }\n  .status { color: red; }\n</style>\n```\n\nIn this example:\n1. We loop through all users with `{#each}`\n2. We conditionally render each user based on their active status and the `showInactive` toggle\n3. Inside each list item, we conditionally render badges for admin and inactive status\n\n### Nesting `{#each}` inside `{#if}`\n\nYou can conditionally render entire lists:\n\n```svelte\n<script>\n  let categories = [\n    { id: 1, name: 'Electronics', items: ['Phone', 'Laptop', 'Tablet'] },\n    { id: 2, name: 'Books', items: ['Fiction', 'Biography', 'Technical'] },\n    { id: 3, name: 'Clothing', items: [] }\n  ];\n</script>\n\n<div class=\"categories\">\n  {#each categories as category}\n    <div class=\"category\">\n      <h2>{category.name}</h2>\n      \n      {#if category.items.length > 0}\n        <ul>\n          {#each category.items as item}\n            <li>{item}</li>\n          {/each}\n        </ul>\n      {:else}\n        <p>No items in this category</p>\n      {/if}\n    </div>\n  {/each}\n</div>\n```\n\n### Working with `{#await}` and `{#if}`\n\nThe `{#await}` block is used for handling promises. It can be combined with `{#if}` for complex async rendering:\n\n```svelte\n<script>\n  let userId = null;\n  let userPromise = null;\n  \n  function fetchUser(id) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        if (id > 0 && id < 100) {\n          resolve({ id, name: `User ${id}`, email: `user${id}@example.com` });\n        } else {\n          reject(new Error('Invalid user ID'));\n        }\n      }, 1000);\n    });\n  }\n  \n  function loadUser() {\n    if (userId) {\n      userPromise = fetchUser(userId);\n    }\n  }\n</script>\n\n<div>\n  <input type=\"number\" bind:value={userId} placeholder=\"Enter user ID\">\n  <button on:click={loadUser}>Load User</button>\n</div>\n\n{#if userPromise}\n  {#await userPromise}\n    <p>Loading user data...</p>\n  {:then user}\n    <div class=\"user-card\">\n      <h2>{user.name}</h2>\n      <p>{user.email}</p>\n      \n      {#if user.id < 50}\n        <p>Standard user</p>\n      {:else}\n        <p>Premium user</p>\n      {/if}\n    </div>\n  {:catch error}\n    <p class=\"error\">Error: {error.message}</p>\n  {/await}\n{:else}\n  <p>Enter a user ID and click \"Load User\"</p>\n{/if}\n```\n\nIn this example:\n1. We conditionally render the entire `{#await}` block based on whether `userPromise` exists\n2. Inside the `{:then}` branch of the await block, we use another `{#if}` block to show different content based on the user's ID\n\n### Complex Nesting with Multiple Block Types\n\nHere's a more complex example combining all three block types:\n\n```svelte\n<script>\n  let categories = [\n    { id: 'electronics', name: 'Electronics', featured: true },\n    { id: 'books', name: 'Books', featured: false },\n    { id: 'clothing', name: 'Clothing', featured: true }\n  ];\n  \n  let selectedCategory = null;\n  let showFeaturedOnly = false;\n  \n  function fetchItems(categoryId) {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        const items = {\n          'electronics': [\n            { id: 'e1', name: 'Smartphone', price: 699, inStock: true },\n            { id: 'e2', name: 'Laptop', price: 1299, inStock: false },\n            { id: 'e3', name: 'Tablet', price: 499, inStock: true }\n          ],\n          'books': [\n            { id: 'b1', name: 'Novel', price: 15, inStock: true },\n            { id: 'b2', name: 'Cookbook', price: 25, inStock: true },\n            { id: 'b3', name: 'Biography', price: 20, inStock: false }\n          ],\n          'clothing': [\n            { id: 'c1', name: 'T-Shirt', price: 20, inStock: true },\n            { id: 'c2', name: 'Jeans', price: 50, inStock: true },\n            { id: 'c3', name: 'Jacket', price: 100, inStock: true }\n          ]\n        };\n        \n        resolve(items[categoryId] || []);\n      }, 1000);\n    });\n  }\n</script>\n\n<div>\n  <label>\n    <input type=\"checkbox\" bind:checked={showFeaturedOnly}>\n    Show featured categories only\n  </label>\n</div>\n\n<div class=\"category-list\">\n  {#each categories as category (category.id)}\n    {#if !showFeaturedOnly || category.featured}\n      <button \n        class:selected={selectedCategory === category.id}\n        on:click={() => selectedCategory = category.id}\n      >\n        {category.name}\n        {#if category.featured}\n          â\n        {/if}\n      </button>\n    {/if}\n  {/each}\n</div>\n\n{#if selectedCategory}\n  <h2>Items in {categories.find(c => c.id === selectedCategory).name}</h2>\n  \n  {#await fetchItems(selectedCategory)}\n    <p>Loading items...</p>\n  {:then items}\n    {#if items.length > 0}\n      <ul class=\"item-list\">\n        {#each items as item (item.id)}\n          <li class:out-of-stock={!item.inStock}>\n            <span class=\"item-name\">{item.name}</span>\n            <span class=\"item-price\">${item.price}</span>\n            \n            {#if !item.inStock}\n              <span class=\"stock-status\">Out of stock</span>\n            {/if}\n          </li>\n        {/each}\n      </ul>\n    {:else}\n      <p>No items found in this category</p>\n    {/if}\n  {:catch error}\n    <p class=\"error\">Error loading items: {error.message}</p>\n  {/await}\n{:else}\n  <p>Select a category to view items</p>\n{/if}\n\n<style>\n  .selected { background-color: #ddf; }\n  .out-of-stock { opacity: 0.6; }\n  .stock-status { color: red; }\n</style>\n```\n\nThis complex example demonstrates:\n1. Conditional rendering of categories based on the \"featured\" filter\n2. Conditional rendering of the entire items section based on category selection\n3. Async loading of items with `{#await}`\n4. Conditional rendering of items based on availability\n5. Nested conditions for showing stock status\n\nThe ability to nest these blocks makes Svelte templates powerful while maintaining readability."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"What are the performance implications of using conditional rendering in Svelte compared to just hiding elements with CSS? When should you use each approach?","answer":"Svelte's conditional rendering with `{#if}` blocks and CSS-based hiding represent two different approaches to controlling element visibility, each with distinct performance characteristics and use cases.\n\n### Performance Comparison\n\n**Svelte's Conditional Rendering (`{#if}` blocks):**\n- Elements are completely added to or removed from the DOM\n- No DOM nodes exist for falsy conditions\n- Memory usage is lower for unused content\n- Initial rendering can be faster if many conditions are false\n\n**CSS-based Hiding:**\n- Elements remain in the DOM but are visually hidden\n- DOM nodes exist regardless of visibility\n- Memory usage is higher as all elements exist\n- Initial rendering includes all elements regardless of visibility\n\n### Benchmarking Example\n\nLet's look at a conceptual comparison:\n\n```svelte\n<script>\n  // Imagine we have 100 items but only show 10\n  let items = Array.from({ length: 100 }, (_, i) => ({ \n    id: i, \n    name: `Item ${i}`,\n    description: `This is a long description for item ${i}...`\n  }));\n  \n  let visibleItems = items.slice(0, 10);\n  let showAll = false;\n  \n  // Approach 1: Conditional rendering\n  let itemsToRender = showAll ? items : visibleItems;\n  \n  // Approach 2: CSS hiding (all items rendered, some hidden)\n  function isVisible(item) {\n    return showAll || visibleItems.includes(item);\n  }\n</script>\n\n<!-- Approach 1: Conditional Rendering -->\n<div>\n  <h2>Conditional Rendering</h2>\n  <ul>\n    {#each itemsToRender as item (item.id)}\n      <li>\n        <h3>{item.name}</h3>\n        <p>{item.description}</p>\n      </li>\n    {/each}\n  </ul>\n</div>\n\n<!-- Approach 2: CSS Hiding -->\n<div>\n  <h2>CSS Hiding</h2>\n  <ul>\n    {#each items as item (item.id)}\n      <li class:hidden={!isVisible(item)}>\n        <h3>{item.name}</h3>\n        <p>{item.description}</p>\n      </li>\n    {/each}\n  </ul>\n</div>\n\n<style>\n  .hidden {\n    display: none;\n  }\n</style>\n```\n\n**Performance implications:**\n\n1. **Initial Rendering**:\n   - Conditional rendering: Only renders 10 items (faster initial load)\n   - CSS hiding: Renders all 100 items (slower initial load)\n\n2. **Memory Usage**:\n   - Conditional rendering: Lower memory footprint (only 10 DOM nodes)\n   - CSS hiding: Higher memory footprint (100 DOM nodes)\n\n3. **Toggling Visibility**:\n   - Conditional rendering: More expensive (needs to create/destroy 90 DOM nodes)\n   - CSS hiding: Less expensive (just toggles CSS properties)\n\n4. **Event Listeners**:\n   - Conditional rendering: No listeners attached to non-rendered elements\n   - CSS hiding: Listeners remain attached to hidden elements (potential memory leak if not managed)\n\n### When to Use Each Approach\n\n**Use Conditional Rendering (`{#if}` blocks) when:**\n\n1. **Content is rarely toggled**: If visibility changes infrequently, the cost of creating/destroying DOM is paid rarely\n   ```svelte\n   {#if userRole === 'admin'}\n     <AdminPanel />\n   {/if}\n   ```\n\n2. **Large or complex content**: For heavy components or large DOM trees that would waste memory\n   ```svelte\n   {#if showDataGrid}\n     <DataGrid items={thousands_of_items} />\n   {/if}\n   ```\n\n3. **Content needs to be completely removed**: For security-sensitive information or when you want to ensure cleanup\n   ```svelte\n   {#if isAuthenticated}\n     <div class=\"secure-content\">\n       <p>Your account number: {accountNumber}</p>\n     </div>\n   {/if}\n   ```\n\n4. **Initialization logic matters**: When components have important mount/unmount lifecycle behavior\n   ```svelte\n   {#if isMapVisible}\n     <MapComponent onMount={() => initializeGoogleMaps()} />\n   {/if}\n   ```\n\n5. **Preventing unnecessary work**: When hidden content would still perform expensive operations\n   ```svelte\n   {#if showRealTimeData}\n     <RealTimeChart data={streamingData} />\n   {/if}\n   ```\n\n**Use CSS-based Hiding when:**\n\n1. **Content toggles frequently**: To avoid the performance cost of repeatedly creating/destroying DOM\n   ```svelte\n   <div class:hidden={!isTooltipVisible}>\n     Tooltip content that shows/hides on hover\n   </div>\n   ```\n\n2. **Animations are needed**: For smooth transitions between states\n   ```svelte\n   <div class:collapsed={!isExpanded} transition:slide>\n     Content that expands/collapses\n   </div>\n   ```\n\n3. **Preserving state is important**: When you need to maintain component state during visibility changes\n   ```svelte\n   <form class:hidden={!isFormVisible}>\n     <!-- Form inputs that should preserve their values when hidden -->\n     <input bind:value={formData.name}>\n   </form>\n   ```\n\n4. **Layout measurements matter**: When you need to calculate sizes of hidden elements\n   ```svelte\n   <div class:hidden={!showPreview} bind:clientHeight={previewHeight}>\n     Preview content\n   </div>\n   ```\n\n### Hybrid Approach\n\nSometimes a hybrid approach works best:\n\n```svelte\n<script>\n  let activeTab = 'details';\n  let tabsData = {};\n  \n  // Lazy load tab data only when needed\n  $: if (activeTab === 'statistics' && !tabsData.statistics) {\n    loadStatisticsData().then(data => {\n      tabsData = { ...tabsData, statistics: data };\n    });\n  }\n</script>\n\n<div class=\"tabs\">\n  <button class:active={activeTab === 'details'} on:click={() => activeTab = 'details'}>\n    Details\n  </button>\n  <button class:active={activeTab === 'statistics'} on:click={() => activeTab = 'statistics'}>\n    Statistics\n  </button>\n  <button class:active={activeTab === 'history'} on:click={() => activeTab = 'history'}>\n    History\n  </button>\n</div>\n\n<div class=\"tab-content\">\n  <div class:hidden={activeTab !== 'details'}>\n    <!-- Details content - always in DOM but hidden with CSS -->\n    <h2>Product Details</h2>\n    <p>Basic information that's lightweight</p>\n  </div>\n  \n  {#if activeTab === 'statistics' && tabsData.statistics}\n    <!-- Statistics content - conditionally rendered -->\n    <div>\n      <h2>Statistics</h2>\n      <ComplexChart data={tabsData.statistics} />\n    </div>\n  {:else if activeTab === 'statistics'}\n    <div class=\"loading\">Loading statistics...</div>\n  {/if}\n  \n  {#if activeTab === 'history'}\n    <!-- History content - conditionally rendered -->\n    <div>\n      <h2>History</h2>\n      <LargeDataTable data={historyData} />\n    </div>\n  {/if}\n</div>\n\n<style>\n  .hidden {\n    display: none;\n  }\n</style>\n```\n\nIn this hybrid approach:\n- The \"Details\" tab content always exists in the DOM but is hidden with CSS\n- The more complex \"Statistics\" and \"History\" tabs are conditionally rendered only when needed\n- Data for the Statistics tab is lazy-loaded only when that tab is selected\n\nThis approach gives you the best of both worlds: lightweight DOM for complex content that's rarely shown, and fast toggling for content that changes visibility frequently."}
{"source":"docs/svelte/03-template-syntax/02-if.md","question":"What are some common mistakes or gotchas when using conditional rendering in Svelte, and how can they be avoided?","answer":"Conditional rendering in Svelte is powerful but comes with some potential pitfalls. Here are common mistakes and how to avoid them:\n\n### 1. Losing Component State During Conditional Rendering\n\n**Problem**: When a component is conditionally rendered, its state is reset when it's removed from the DOM and later re-added.\n\n```svelte\n<!-- Problematic Example -->\n<script>\n  let showForm = true;\n  let formData = { name: '', email: '' };\n  \n  function toggleForm() {\n    showForm = !showForm;\n  }\n</script>\n\n<button on:click={toggleForm}>\n  {showForm ? 'Hide' : 'Show'} Form\n</button>\n\n{#if showForm}\n  <form>\n    <input bind:value={formData.name} placeholder=\"Name\">\n    <input bind:value={formData.email} placeholder=\"Email\">\n  </form>\n{/if}\n```\n\nIn this example, any data entered in the form is lost when `showForm` becomes false.\n\n**Solution**: Store state outside the conditionally rendered component or use CSS for visibility:\n\n```svelte\n<!-- Better approach -->\n<script>\n  let isFormVisible = true;\n  let formData = { name: '', email: '' };\n  \n  function toggleForm() {\n    isFormVisible = !isFormVisible;\n  }\n</script>\n\n<button on:click={toggleForm}>\n  {isFormVisible ? 'Hide' : 'Show'} Form\n</button>\n\n<form class:hidden={!isFormVisible}>\n  <input bind:value={formData.name} placeholder=\"Name\">\n  <input bind:value={formData.email} placeholder=\"Email\">\n</form>\n\n<style>\n  .hidden {\n    display: none;\n  }\n</style>\n```\n\n### 2. Forgetting to Clean Up Resources\n\n**Problem**: Resources like timers, event listeners, or subscriptions aren't cleaned up when components are unmounted.\n\n```svelte\n<!-- Problematic Component -->\n<script>\n  import { onMount } from 'svelte';\n  \n  onMount(() => {\n    const interval = setInterval(() => {\n      console.log('Tick');\n    }, 1000);\n    \n    // Missing cleanup!\n  });\n</script>\n```\n\n**Solution**: Always clean up in `onDestroy` or the function returned from `onMount`:\n\n```svelte\n<!-- Fixed Component -->\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  let interval;\n  \n  onMount(() => {\n    interval = setInterval(() => {\n      console.log('Tick');\n    }, 1000);\n    \n    // Cleanup in the function returned from onMount\n    return () => {\n      clearInterval(interval);\n    };\n  });\n  \n  // Alternative: use onDestroy\n  onDestroy(() => {\n    if (interval) clearInterval(interval);\n  });\n</script>\n```\n\n### 3. Excessive Re-rendering with Complex Conditions\n\n**Problem**: Complex conditions that depend on multiple reactive values cause re-evaluation on any change.\n\n```svelte\n<!-- Inefficient -->\n<script>\n  let users = [...]; // Large array\n  let searchTerm = '';\n  let filterActive = true;\n  let sortOrder = 'asc';\n</script>\n\n{#if users.length > 0}\n  {#each users\n    .filter(user => user.name.includes(searchTerm))\n    .filter(user => !filterActive || user.isActive)\n    .sort((a, b) => sortOrder === 'asc' ? \n      a.name.localeCompare(b.name) : \n      b.name.localeCompare(a.name)) \n    as user}\n    <UserCard {user} />\n  {/each}\n{:else}\n  <p>No users found</p>\n{/if}\n```\n\n**Solution**: Use reactive declarations to compute derived values:\n\n```svelte\n<!-- More efficient -->\n<script>\n  let users = [...];\n  let searchTerm = '';\n  let filterActive = true;\n  let sortOrder = 'asc';\n  \n  $: filteredAndSortedUsers = users\n    .filter(user => user.name.includes(searchTerm))\n    .filter(user => !filterActive || user.isActive)\n    .sort((a, b) => sortOrder === 'asc' ? \n      a.name.localeCompare(b.name) : \n      b.name.localeCompare(a.name));\n</script>\n\n{#if filteredAndSortedUsers.length > 0}\n  {#each filteredAndSortedUsers as user}\n    <UserCard {user} />\n  {/each}\n{:else}\n  <p>No users found</p>\n{/if}\n```\n\n### 4. Misunderstanding Scope and Variable Shadowing\n\n**Problem**: Variables declared inside conditional blocks shadow outer variables with the same name.\n\n```svelte\n<!-- Problematic -->\n<script>\n  let user = { name: 'Guest' };\n  let isLoggedIn = false;\n</script>\n\n{#if isLoggedIn}\n  {#await fetchUserDetails()}\n    <p>Loading...</p>\n  {:then user} <!-- This creates a new 'user' variable! -->\n    <p>Welcome, {user.name}</p>\n  {/await}\n{:else}\n  <p>Hello, {user.name}</p>\n{/if}\n```\n\n**Solution**: Use different variable names to avoid shadowing:\n\n```svelte\n<!-- Fixed -->\n<script>\n  let user = { name: 'Guest' };\n  let isLoggedIn = false;\n</script>\n\n{#if isLoggedIn}\n  {#await fetchUserDetails()}\n    <p>Loading...</p>\n  {:then userData} <!-- Different name avoids shadowing -->\n    <p>Welcome, {userData.name}</p>\n  {/await}\n{:else}\n  <p>Hello, {user.name}</p>\n{/if}\n```\n\n### 5. Forgetting to Handle Edge Cases\n\n**Problem**: Not handling null or undefined values in conditional logic.\n\n```svelte\n<!-- Problematic -->\n<script>\n  let user; // Initially undefined\n  \n  async function loadUser() {\n    user = await fetchUser();\n  }\n</script>\n\n<button on:click={loadUser}>Load User</button>\n\n<div class=\"user-card\">\n  <h2>{user.name}</h2> <!-- Error when user is undefined -->\n  <p>{user.email}</p>\n</div>\n```\n\n**Solution**: Use conditional rendering to handle null/undefined values:\n\n```svelte\n<!-- Fixed -->\n<script>\n  let user = null;\n  \n  async function loadUser() {\n    user = await fetchUser();\n  }\n</script>\n\n<button on:click={loadUser}>Load User</button>\n\n{#if user}\n  <div class=\"user-card\">\n    <h2>{user.name}</h2>\n    <p>{user.email}</p>\n  </div>\n{:else}\n  <p>No user loaded</p>\n{/if}\n```\n\n### 6. Misusing Else-If Chains\n\n**Problem**: Using long chains of else-if conditions that are hard to maintain.\n\n```svelte\n<!-- Hard to maintain -->\n{#if status === 'loading'}\n  <LoadingSpinner />\n{:else if status === 'success' && data.items.length > 0}\n  <DataTable items={data.items} />\n{:else if status === 'success' && data.items.length === 0}\n  <EmptyState />\n{:else if status === 'error' && error.code === 404}\n  <NotFoundError />\n{:else if status === 'error'}\n  <GenericError message={error.message} />\n{:else}\n  <InitialState />\n{/if}\n```\n\n**Solution**: Use computed properties or switch to object mapping for complex conditions:\n\n```svelte\n<!-- Better approach -->\n<script>\n  let status = 'idle';\n  let data = { items: [] };\n  let error = null;\n  \n  $: isEmpty = status === 'success' && data.items.length === 0;\n  $: isNotFound = status === 'error' && error?.code === 404;\n  \n  // Alternative: component mapping approach\n  const componentMap = {\n    'loading': LoadingSpinner,\n    'empty': EmptyState,\n    'notFound': NotFoundError,\n    'error': GenericError,\n    'success': DataTable,\n    'idle': InitialState\n  };\n  \n  $: currentView = \n    status === 'loading' ? 'loading' :\n    isEmpty ? 'empty' :\n    isNotFound ? 'notFound' :\n    status === 'error' ? 'error' :\n    status === 'success' ? 'success' :\n    'idle';\n    \n  $: componentProps = \n    currentView === 'error' ? { message: error.message } :\n    currentView === 'success' ? { items: data.items } :\n    {};\n</script>\n\n<!-- Simple if-else approach -->\n{#if status === 'loading'}\n  <LoadingSpinner />\n{:else if isEmpty}\n  <EmptyState />\n{:else if isNotFound}\n  <NotFoundError />\n{:else if status === 'error'}\n  <GenericError message={error.message} />\n{:else if status === 'success'}\n  <DataTable items={data.items} />\n{:else}\n  <InitialState />\n{/if}\n\n<!-- Or using dynamic components -->\n<svelte:component this={componentMap[currentView]} {...componentProps} />\n```\n\n### 7. Rendering Too Much Conditionally\n\n**Problem**: Wrapping large sections of UI in conditional blocks when only small parts need to change.\n\n```svelte\n<!-- Inefficient -->\n{#if isAdmin}\n  <div class=\"dashboard\">\n    <header>\n      <h1>Admin Dashboard</h1>\n      <nav><!-- Navigation items --></nav>\n    </header>\n    <main>\n      <AdminControls />\n    </main>\n    <footer><!-- Footer content --></footer>\n  </div>\n{:else}\n  <div class=\"dashboard\">\n    <header>\n      <h1>User Dashboard</h1>\n      <nav><!-- Navigation items --></nav>\n    </header>\n    <main>\n      <UserControls />\n    </main>\n    <footer><!-- Footer content --></footer>\n  </div>\n{/if}\n```\n\n**Solution**: Only conditionally render the parts that actually change:\n\n```svelte\n<!-- More efficient -->\n<div class=\"dashboard\">\n  <header>\n    <h1>{isAdmin ? 'Admin' : 'User'} Dashboard</h1>\n    <nav><!-- Navigation items --></nav>\n  </header>\n  <main>\n    {#if isAdmin}\n      <AdminControls />\n    {:else}\n      <UserControls />\n    {/if}\n  </main>\n  <footer><!-- Footer content --></footer>\n</div>\n```\n\n### 8. Not Using Key Blocks for Transitions Between States\n\n**Problem**: When switching between different states in a condition, transitions might not work as expected.\n\n```svelte\n<!-- Problematic for transitions -->\n<script>\n  import { fade } from 'svelte/transition';\n  let view = 'list';\n</script>\n\n{#if view === 'list'}\n  <div transition:fade>\n    <ListView />\n  </div>\n{:else if view === 'grid'}\n  <div transition:fade>\n    <GridView />\n  </div>\n{:else if view === 'table'}\n  <div transition:fade>\n    <TableView />\n  </div>\n{/if}\n```\n\n**Solution**: Use key blocks to ensure proper transitions:\n\n```svelte\n<!-- Better for transitions -->\n<script>\n  import { fade } from 'svelte/transition';\n  let view = 'list';\n</script>\n\n{#key view}\n  <div transition:fade>\n    {#if view === 'list'}\n      <ListView />\n    {:else if view === 'grid'}\n      <GridView />\n    {:else if view === 'table'}\n      <TableView />\n    {/if}\n  </div>\n{/key}\n```\n\n### 9. Forgetting That Conditions Are Re-evaluated\n\n**Problem**: Side effects in conditions can cause unexpected behavior.\n\n```svelte\n<!-- Problematic -->\n{#if saveUserData() && user.isActive}\n  <p>User data saved!</p>\n{/if}\n```\n\n**Solution**: Move side effects to reactive statements or functions:\n\n```svelte\n<!-- Better approach -->\n<script>\n  let user = { isActive: true };\n  let dataSaved = false;\n  \n  function handleSave() {\n    dataSaved = saveUserData();\n  }\n  \n  // Or use reactivity\n  $: if (shouldAutoSave) {\n    dataSaved = saveUserData();\n  }\n</script>\n\n<button on:click={handleSave}>Save</button>\n\n{#if dataSaved && user.isActive}\n  <p>User data saved!</p>\n{/if}\n```\n\n### 10. Using Complex Nesting Instead of Components\n\n**Problem**: Deeply nested conditional logic makes templates hard to maintain.\n\n```svelte\n<!-- Hard to maintain -->\n{#if isLoggedIn}\n  {#if userRole === 'admin'}\n    {#if adminSection === 'users'}\n      <!-- Admin user management UI -->\n    {:else if adminSection === 'settings'}\n      <!-- Admin settings UI -->\n    {:else}\n      <!-- Admin dashboard -->\n    {/if}\n  {:else if userRole === 'editor'}\n    <!-- Editor UI -->\n  {:else}\n    <!-- Regular user UI -->\n  {/if}\n{:else}\n  <!-- Login UI -->\n{/if}\n```\n\n**Solution**: Break down complex UI into smaller components:\n\n```svelte\n<!-- Main component -->\n<script>\n  import LoginView from './LoginView.svelte';\n  import AdminDashboard from './AdminDashboard.svelte';\n  import EditorDashboard from './EditorDashboard.svelte';\n  import UserDashboard from './UserDashboard.svelte';\n  \n  let isLoggedIn = false;\n  let userRole = 'user';\n</script>\n\n{#if !isLoggedIn}\n  <LoginView />\n{:else if userRole === 'admin'}\n  <AdminDashboard />\n{:else if userRole === 'editor'}\n  <EditorDashboard />\n{:else}\n  <UserDashboard />\n{/if}\n\n<!-- AdminDashboard.svelte -->\n<script>\n  import AdminUsers from './AdminUsers.svelte';\n  import AdminSettings from './AdminSettings.svelte';\n  import AdminHome from './AdminHome.svelte';\n  \n  export let section = 'home';\n</script>\n\n<nav>\n  <!-- Navigation tabs -->\n</nav>\n\n{#if section === 'users'}\n  <AdminUsers />\n{:else if section === 'settings'}\n  <AdminSettings />\n{:else}\n  <AdminHome />\n{/if}\n```\n\nBy being aware of these common mistakes and implementing the suggested solutions, you can use Svelte's conditional rendering more effectively and avoid potential issues in your applications."}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"How do you iterate over an array of items in a Svelte component, and what types of collections can be used with each blocks?","answer":"In Svelte, you can iterate over collections using the `{#each}` block syntax. This allows you to render a template for each item in a collection.\n\nThe basic syntax is:\n```svelte\n{#each expression as name}\n  <!-- content that uses name -->\n{/each}\n```\n\nYou can iterate over various types of collections:\n- Arrays\n- Array-like objects (anything with a `length` property)\n- Iterables like `Map` and `Set`\n- Essentially anything that can be used with `Array.from()`\n\nHere's a practical example of iterating over an array of shopping items:\n\n```svelte\n<script>\n  let items = [\n    { name: 'Apples', qty: 5 },\n    { name: 'Bananas', qty: 3 },\n    { name: 'Oranges', qty: 2 }\n  ];\n</script>\n\n<h1>Shopping list</h1>\n<ul>\n  {#each items as item}\n    <li>{item.name} x {item.qty}</li>\n  {/each}\n</ul>\n```\n\nThis will render:\n```html\n<h1>Shopping list</h1>\n<ul>\n  <li>Apples x 5</li>\n  <li>Bananas x 3</li>\n  <li>Oranges x 2</li>\n</ul>\n```\n\nThe `{#each}` block is extremely versatile and is one of the most commonly used template structures in Svelte applications."}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"How can you access the index of the current item when using an each block in Svelte?","answer":"In Svelte's `{#each}` blocks, you can access the index of the current item by adding a second parameter after the item name. This is similar to how the second parameter in JavaScript's `array.map()` callback provides the index.\n\nThe syntax for accessing the index is:\n\n```svelte\n{#each items as item, index}\n  <!-- content that uses both item and index -->\n{/each}\n```\n\nHere's a practical example that uses the index to number items in a list:\n\n```svelte\n<script>\n  let fruits = [\n    { name: 'Apples', qty: 5 },\n    { name: 'Bananas', qty: 3 },\n    { name: 'Oranges', qty: 2 }\n  ];\n</script>\n\n<h1>Fruit Inventory</h1>\n<ul>\n  {#each fruits as fruit, i}\n    <li>{i + 1}: {fruit.name} x {fruit.qty}</li>\n  {/each}\n</ul>\n```\n\nThis will render:\n```html\n<h1>Fruit Inventory</h1>\n<ul>\n  <li>1: Apples x 5</li>\n  <li>2: Bananas x 3</li>\n  <li>3: Oranges x 2</li>\n</ul>\n```\n\nThe index is zero-based (starts at 0), which is why we add 1 in the example above to display a more human-readable numbering starting from 1.\n\nYou can use the index for various purposes, such as:\n- Numbering items in a list\n- Applying alternating styles (e.g., `class:even={i % 2 === 0}`)\n- Conditionally rendering elements based on position\n- Creating unique IDs by combining with other data"}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"What are keyed each blocks in Svelte, and why are they important for optimizing DOM updates?","answer":"Keyed each blocks in Svelte are a powerful feature that helps optimize how the DOM is updated when data changes. They allow Svelte to track specific items across updates rather than simply re-rendering the entire list.\n\n## Basic Syntax\n\n```svelte\n{#each items as item (key)}\n  <!-- content -->\n{/each}\n```\n\nor with an index:\n\n```svelte\n{#each items as item, i (key)}\n  <!-- content -->\n{/each}\n```\n\n## Why Keys Are Important\n\nWithout keys, when data in a list changes, Svelte uses a simple strategy: it adds or removes items at the end of the list and updates any changed items in place. This works fine for static lists or when only appending items, but can cause problems when:\n\n1. Items are reordered\n2. Items are inserted or removed in the middle of the list\n3. You have components with local state in the list\n\nWith keyed each blocks, Svelte can identify which specific items have changed, been added, or been removed, regardless of their position in the array. This results in more efficient and predictable DOM updates.\n\n## Example with Keys\n\n```svelte\n<script>\n  let todos = [\n    { id: 1, text: 'Finish report', done: false },\n    { id: 2, text: 'Buy groceries', done: true },\n    { id: 3, text: 'Exercise', done: false }\n  ];\n\n  function removeTodo(id) {\n    todos = todos.filter(todo => todo.id !== id);\n  }\n</script>\n\n<ul>\n  {#each todos as todo (todo.id)}\n    <li>\n      <input type=\"checkbox\" bind:checked={todo.done}>\n      <span class:completed={todo.done}>{todo.text}</span>\n      <button on:click={() => removeTodo(todo.id)}>Remove</button>\n    </li>\n  {/each}\n</ul>\n```\n\nIn this example, when a todo is removed, Svelte uses the `id` as a key to identify exactly which DOM element to remove, rather than just removing the last element and updating all others.\n\n## Key Selection Guidelines\n\nThe key should:\n- Uniquely identify each item in the list\n- Be stable across updates (not change for the same logical item)\n- Typically be a string or number (though any value can work)\n\nCommon choices for keys include:\n- Database IDs\n- UUID/GUID values\n- Natural unique identifiers in your data\n\nUsing proper keys is especially important when your list items contain components with state or when animations are applied to list changes."}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"How can you use destructuring patterns with each blocks in Svelte?","answer":"Svelte's `{#each}` blocks support JavaScript destructuring patterns, which allow you to directly access properties of the items you're iterating over without having to reference the parent object repeatedly. This makes your code more concise and readable.\n\n## Object Destructuring\n\nYou can destructure object properties directly in the `each` block:\n\n```svelte\n<script>\n  let people = [\n    { id: 1, name: 'Alice', age: 25, role: 'Developer' },\n    { id: 2, name: 'Bob', age: 32, role: 'Designer' },\n    { id: 3, name: 'Charlie', age: 28, role: 'Manager' }\n  ];\n</script>\n\n<ul>\n  {#each people as { id, name, age, role }, i (id)}\n    <li>{i + 1}: {name} is {age} years old and works as a {role}</li>\n  {/each}\n</ul>\n```\n\nThis is equivalent to, but cleaner than:\n\n```svelte\n{#each people as person, i (person.id)}\n  <li>{i + 1}: {person.name} is {person.age} years old and works as a {person.role}</li>\n{/each}\n```\n\n## Using Rest Patterns\n\nYou can also use the rest pattern (`...rest`) to collect remaining properties:\n\n```svelte\n<script>\n  let items = [\n    { id: 1, name: 'Widget', price: 10, category: 'Tools', inStock: true },\n    { id: 2, name: 'Gadget', price: 20, category: 'Electronics', inStock: false },\n    { id: 3, name: 'Doohickey', price: 15, category: 'Misc', inStock: true }\n  ];\n</script>\n\n{#each items as { id, name, ...details }}\n  <div>\n    <h3>{name}</h3>\n    <ProductDetails {...details} />\n  </div>\n{/each}\n```\n\nThis is particularly useful when you want to pass multiple properties to a child component.\n\n## Array Destructuring\n\nYou can also destructure arrays in each blocks:\n\n```svelte\n<script>\n  let coordinates = [\n    [1, 5, 'Point A'],\n    [2, 3, 'Point B'],\n    [5, 7, 'Point C']\n  ];\n</script>\n\n<ul>\n  {#each coordinates as [x, y, label], i}\n    <li>{label}: ({x}, {y})</li>\n  {/each}\n</ul>\n```\n\n## Combined with Rest Pattern for Arrays\n\n```svelte\n<script>\n  let data = [\n    [1, 'red', 'apple', 'fruit'],\n    [2, 'yellow', 'banana', 'fruit'],\n    [3, 'green', 'broccoli', 'vegetable']\n  ];\n</script>\n\n{#each data as [id, ...properties]}\n  <div>\n    <span>Item #{id}</span>\n    <ItemProperties values={properties} />\n  </div>\n{/each}\n```\n\nUsing destructuring in `{#each}` blocks makes your templates cleaner and more maintainable, especially when working with complex data structures."}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"How can you handle empty lists gracefully in Svelte's each blocks?","answer":"Svelte provides an elegant way to handle empty lists using the `{:else}` clause within `{#each}` blocks. This allows you to display alternative content when the list you're iterating over has no items.\n\n## Basic Syntax\n\n```svelte\n{#each items as item}\n  <!-- Content to display for each item -->\n{:else}\n  <!-- Content to display when items is empty -->\n{/each}\n```\n\n## Practical Example\n\n```svelte\n<script>\n  let todos = []; // Empty array for demonstration\n  \n  function addTodo() {\n    const text = prompt('What needs to be done?');\n    if (text) {\n      todos = [...todos, { id: Date.now(), text, completed: false }];\n    }\n  }\n</script>\n\n<button on:click={addTodo}>Add Todo</button>\n\n<div class=\"todo-list\">\n  {#each todos as todo (todo.id)}\n    <div class=\"todo-item\">\n      <input type=\"checkbox\" bind:checked={todo.completed}>\n      <span class:completed={todo.completed}>{todo.text}</span>\n    </div>\n  {:else}\n    <div class=\"empty-state\">\n      <p>Your todo list is empty!</p>\n      <p>Click the button above to add your first todo item.</p>\n    </div>\n  {/each}\n</div>\n```\n\n## Use Cases\n\nThe `{:else}` clause is particularly useful for:\n\n1. **Empty state messaging**: Providing friendly messages when no data exists yet\n2. **First-time user experiences**: Showing instructions for new users\n3. **Loading placeholders**: Showing a message while data is being fetched (though you might want to use a separate loading state for this)\n4. **Error handling**: When combined with conditional checking, to show error states\n\n## More Complex Example\n\nHere's a more advanced example showing a shopping cart with empty state:\n\n```svelte\n<script>\n  let cart = [];\n  let loading = true;\n  let error = null;\n  \n  // Simulate fetching cart data\n  setTimeout(() => {\n    loading = false;\n    // Uncomment to simulate data\n    // cart = [\n    //   { id: 1, name: 'Headphones', price: 59.99, quantity: 1 },\n    //   { id: 2, name: 'Keyboard', price: 49.99, quantity: 1 }\n    // ];\n  }, 1000);\n  \n  function calculateTotal(items) {\n    return items.reduce((sum, item) => sum + (item.price * item.quantity), 0).toFixed(2);\n  }\n</script>\n\n<div class=\"cart-container\">\n  <h2>Your Shopping Cart</h2>\n  \n  {#if loading}\n    <p>Loading your cart...</p>\n  {:else if error}\n    <p class=\"error\">Error loading cart: {error}</p>\n  {:else}\n    {#each cart as item (item.id)}\n      <div class=\"cart-item\">\n        <span class=\"item-name\">{item.name}</span>\n        <span class=\"item-quantity\">x{item.quantity}</span>\n        <span class=\"item-price\">${item.price.toFixed(2)}</span>\n      </div>\n    {:else}\n      <div class=\"empty-cart\">\n        <img src=\"/empty-cart.svg\" alt=\"Empty cart\" />\n        <p>Your cart is empty</p>\n        <a href=\"/products\" class=\"button\">Continue Shopping</a>\n      </div>\n    {/each}\n    \n    {#if cart.length > 0}\n      <div class=\"cart-total\">\n        <span>Total:</span>\n        <span>${calculateTotal(cart)}</span>\n        <button class=\"checkout-button\">Proceed to Checkout</button>\n      </div>\n    {/if}\n  {/if}\n</div>\n```\n\nThis pattern creates a more polished user experience by providing appropriate feedback when there's no data to display, rather than simply showing nothing."}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"How can you create a grid or repeat a template n times without having an actual data array in Svelte?","answer":"Svelte provides a clever way to repeat a template a specific number of times without needing an actual data array. This is useful for creating grids, patterns, or any UI element that needs to be repeated a fixed number of times.\n\n## Basic Syntax\n\nYou can use an object with a `length` property in the `{#each}` block:\n\n```svelte\n{#each { length: n }}\n  <!-- Content to repeat n times -->\n{/each}\n```\n\nOr with an index:\n\n```svelte\n{#each { length: n }, i}\n  <!-- Content to repeat n times, with index i -->\n{/each}\n```\n\n## Creating a Chess Board\n\nA perfect example is creating an 8Ã8 chess board:\n\n```svelte\n<script>\n  // CSS for the chess board\n  const squareSize = '50px';\n</script>\n\n<style>\n  .chess-board {\n    display: grid;\n    grid-template-columns: repeat(8, 1fr);\n    grid-template-rows: repeat(8, 1fr);\n    width: 400px;\n    height: 400px;\n    border: 2px solid #333;\n  }\n  \n  .square {\n    width: 100%;\n    height: 100%;\n  }\n  \n  .black {\n    background-color: #769656;\n  }\n  \n  .white {\n    background-color: #eeeed2;\n  }\n</style>\n\n<div class=\"chess-board\">\n  {#each { length: 8 }, rank}\n    {#each { length: 8 }, file}\n      <div \n        class=\"square\" \n        class:black={(rank + file) % 2 === 1}\n        class:white={(rank + file) % 2 === 0}\n      ></div>\n    {/each}\n  {/each}\n</div>\n```\n\nThis creates a perfect chess board pattern without needing to define an array of 64 squares.\n\n## Creating a Star Rating Component\n\nHere's another practical example - a star rating component:\n\n```svelte\n<script>\n  export let rating = 3.5;\n  export let maxStars = 5;\n  \n  function getStarClass(position) {\n    const difference = rating - position;\n    \n    if (difference >= 0) return 'star-full';\n    if (difference > -1) return 'star-half';\n    return 'star-empty';\n  }\n</script>\n\n<style>\n  .stars {\n    display: flex;\n  }\n  \n  .star {\n    width: 24px;\n    height: 24px;\n    margin-right: 4px;\n  }\n  \n  .star-full {\n    color: gold;\n  }\n  \n  .star-half {\n    color: gold;\n  }\n  \n  .star-empty {\n    color: #ccc;\n  }\n</style>\n\n<div class=\"stars\">\n  {#each { length: maxStars }, i}\n    <div class=\"star {getStarClass(i + 1)}\">\n      <!-- Star SVG or icon would go here -->\n      â\n    </div>\n  {/each}\n</div>\n```\n\n## Creating a Calendar Grid\n\nHere's a more complex example creating a month calendar grid:\n\n```svelte\n<script>\n  export let year = new Date().getFullYear();\n  export let month = new Date().getMonth();\n  \n  function getDaysInMonth(year, month) {\n    return new Date(year, month + 1, 0).getDate();\n  }\n  \n  function getFirstDayOfMonth(year, month) {\n    return new Date(year, month, 1).getDay();\n  }\n  \n  const daysInMonth = getDaysInMonth(year, month);\n  const firstDay = getFirstDayOfMonth(year, month);\n  const totalCells = Math.ceil((daysInMonth + firstDay) / 7) * 7;\n</script>\n\n<style>\n  .calendar {\n    display: grid;\n    grid-template-columns: repeat(7, 1fr);\n    gap: 4px;\n    max-width: 400px;\n  }\n  \n  .day {\n    height: 40px;\n    border: 1px solid #ddd;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n  \n  .day-name {\n    font-weight: bold;\n    background-color: #f0f0f0;\n  }\n  \n  .empty {\n    background-color: #f9f9f9;\n  }\n  \n  .today {\n    background-color: #e6f7ff;\n    font-weight: bold;\n  }\n</style>\n\n<div class=\"calendar\">\n  <!-- Day names -->\n  {#each ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] as dayName}\n    <div class=\"day day-name\">{dayName}</div>\n  {/each}\n  \n  <!-- Calendar cells -->\n  {#each { length: totalCells }, i}\n    {@const dayNumber = i - firstDay + 1}\n    {@const isToday = dayNumber === new Date().getDate() && \n                      month === new Date().getMonth() && \n                      year === new Date().getFullYear()}\n    \n    <div class=\"day\" \n         class:empty={dayNumber <= 0 || dayNumber > daysInMonth}\n         class:today={isToday}>\n      {dayNumber > 0 && dayNumber <= daysInMonth ? dayNumber : ''}\n    </div>\n  {/each}\n</div>\n```\n\nThis technique is extremely useful for UI patterns, grids, and layouts where you need to repeat elements a specific number of times without creating unnecessary data structures."}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"How do you handle nested each blocks in Svelte, and what are some practical applications?","answer":"Nested each blocks in Svelte allow you to iterate through multi-dimensional data structures like nested arrays or objects with array properties. This pattern is especially useful for creating complex UIs like tables, grids, or hierarchical data visualizations.\n\n## Basic Syntax\n\n```svelte\n{#each outerArray as outerItem}\n  {#each outerItem.innerArray as innerItem}\n    <!-- Content using innerItem -->\n  {/each}\n{/each}\n```\n\n## Example: Creating a Table\n\nA common use case for nested each blocks is creating tables with rows and columns:\n\n```svelte\n<script>\n  let tableData = [\n    { id: 1, name: 'Alice', scores: [85, 90, 92] },\n    { id: 2, name: 'Bob', scores: [75, 80, 85] },\n    { id: 3, name: 'Charlie', scores: [95, 85, 90] }\n  ];\n  \n  let subjects = ['Math', 'Science', 'English'];\n</script>\n\n<table>\n  <thead>\n    <tr>\n      <th>Name</th>\n      {#each subjects as subject}\n        <th>{subject}</th>\n      {/each}\n      <th>Average</th>\n    </tr>\n  </thead>\n  <tbody>\n    {#each tableData as student (student.id)}\n      <tr>\n        <td>{student.name}</td>\n        {#each student.scores as score, i}\n          <td>{score}</td>\n        {/each}\n        <td>\n          {(student.scores.reduce((sum, score) => sum + score, 0) / student.scores.length).toFixed(1)}\n        </td>\n      </tr>\n    {/each}\n  </tbody>\n</table>\n```\n\n## Creating a Matrix or Grid\n\nNested each blocks are perfect for creating grids or matrices:\n\n```svelte\n<script>\n  // A 2D matrix for a game board\n  let board = [\n    [null, 'X', 'O'],\n    ['O', 'X', null],\n    [null, 'O', 'X']\n  ];\n  \n  function handleCellClick(row, col) {\n    if (board[row][col] === null) {\n      // Create a copy of the row to maintain immutability\n      const newRow = [...board[row]];\n      newRow[col] = 'X'; // Assume X is the current player\n      \n      // Create a copy of the board with the updated row\n      board = [\n        ...board.slice(0, row),\n        newRow,\n        ...board.slice(row + 1)\n      ];\n    }\n  }\n</script>\n\n<style>\n  .board {\n    display: grid;\n    grid-template-columns: repeat(3, 100px);\n    grid-template-rows: repeat(3, 100px);\n    gap: 5px;\n  }\n  \n  .cell {\n    border: 1px solid #333;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 2rem;\n    cursor: pointer;\n  }\n</style>\n\n<div class=\"board\">\n  {#each board as row, rowIndex}\n    {#each row as cell, colIndex}\n      <div \n        class=\"cell\" \n        on:click={() => handleCellClick(rowIndex, colIndex)}\n      >\n        {cell || ''}\n      </div>\n    {/each}\n  {/each}\n</div>\n```\n\n## Working with Hierarchical Data\n\nYou can also use nested each blocks for hierarchical data like a file system:\n\n```svelte\n<script>\n  let fileSystem = [\n    {\n      name: 'Documents',\n      type: 'folder',\n      children: [\n        { name: 'Report.pdf', type: 'file' },\n        { \n          name: 'Projects',\n          type: 'folder',\n          children: [\n            { name: 'Project1.docx', type: 'file' },\n            { name: 'Project2.docx', type: 'file' }\n          ]\n        }\n      ]\n    },\n    {\n      name: 'Pictures',\n      type: 'folder',\n      children: [\n        { name: 'Vacation.jpg', type: 'file' },\n        { name: 'Family.jpg', type: 'file' }\n      ]\n    }\n  ];\n  \n  // Recursive component to handle folders and files\n  function renderFileSystem(items, level = 0) {\n    const padding = level * 20 + 'px';\n    \n    return items.map(item => {\n      if (item.type === 'folder') {\n        return `\n          <div style=\"padding-left: ${padding}\">\n            ð ${item.name}\n          </div>\n          ${item.children ? renderFileSystem(item.children, level + 1) : ''}\n        `;\n      } else {\n        return `\n          <div style=\"padding-left: ${padding}\">\n            ð ${item.name}\n          </div>\n        `;\n      }\n    }).join('');\n  }\n</script>\n\n<!-- Using a recursive component approach instead -->\n<script>\n  // Component definition would be in a separate file\n  // This is just for demonstration\n  function FileSystemItem(item, level) {\n    const padding = level * 20 + 'px';\n    \n    return `\n      <div style=\"padding-left: ${padding}\">\n        ${item.type === 'folder' ? 'ð' : 'ð'} ${item.name}\n      </div>\n      ${item.children ? \n        `<div>\n          ${item.children.map(child => FileSystemItem(child, level + 1)).join('')}\n        </div>` \n        : ''}\n    `;\n  }\n</script>\n\n<div class=\"file-system\">\n  {#each fileSystem as item}\n    <div>\n      <div>ð {item.name}</div>\n      {#if item.children}\n        <div style=\"padding-left: 20px\">\n          {#each item.children as child}\n            {#if child.type === 'folder'}\n              <div>ð {child.name}</div>\n              {#if child.children}\n                <div style=\"padding-left: 20px\">\n                  {#each child.children as grandchild}\n                    <div>ð {grandchild.name}</div>\n                  {/each}\n                </div>\n              {/if}\n            {:else}\n              <div>ð {child.name}</div>\n            {/if}\n          {/each}\n        </div>\n      {/if}\n    </div>\n  {/each}\n</div>\n```\n\nFor truly recursive structures like file systems, a recursive component is often cleaner than deeply nested each blocks. However, for regular nested data with a known depth, nested each blocks work very well."}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"How can you combine keyed each blocks with destructuring patterns and explain the benefits of this approach?","answer":"Combining keyed each blocks with destructuring patterns in Svelte creates a powerful and elegant way to work with complex data structures. This approach offers both performance optimizations and improved code readability.\n\n## Basic Combined Syntax\n\n```svelte\n{#each items as { id, name, ...rest }, i (id)}\n  <!-- Content using destructured properties -->\n{/each}\n```\n\n## Benefits of This Approach\n\n1. **Performance optimization** - Keys help Svelte efficiently update the DOM\n2. **Code readability** - Destructuring makes template code cleaner and more direct\n3. **Reduced repetition** - No need to reference parent objects repeatedly\n4. **Direct access to properties** - Work with the exact data you need\n5. **Easier component composition** - Spread remaining properties to child components\n\n## Practical Example: User List with Details\n\n```svelte\n<script>\n  let users = [\n    { \n      id: 1, \n      name: 'Alice Johnson', \n      role: 'Developer', \n      email: 'alice@example.com',\n      skills: ['JavaScript', 'Svelte', 'CSS'],\n      active: true\n    },\n    { \n      id: 2, \n      name: 'Bob Smith', \n      role: 'Designer', \n      email: 'bob@example.com',\n      skills: ['UI/UX', 'Figma', 'Illustration'],\n      active: false\n    },\n    { \n      id: 3, \n      name: 'Charlie Garcia', \n      role: 'Manager', \n      email: 'charlie@example.com',\n      skills: ['Leadership', 'Agile', 'Communication'],\n      active: true\n    }\n  ];\n  \n  function toggleUserStatus(id) {\n    users = users.map(user => \n      user.id === id ? {...user, active: !user.active} : user\n    );\n  }\n</script>\n\n<style>\n  .user-card {\n    border: 1px solid #ddd;\n    padding: 15px;\n    margin-bottom: 10px;\n    border-radius: 4px;\n  }\n  \n  .inactive {\n    opacity: 0.6;\n    background-color: #f9f9f9;\n  }\n  \n  .user-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n  }\n  \n  .skills {\n    display: flex;\n    gap: 5px;\n    margin-top: 10px;\n  }\n  \n  .skill-tag {\n    background-color: #e0f7fa;\n    padding: 3px 8px;\n    border-radius: 12px;\n    font-size: 0.8rem;\n  }\n</style>\n\n<div class=\"user-list\">\n  {#each users as { id, name, role, email, skills, active }, i (id)}\n    <div class=\"user-card\" class:inactive={!active}>\n      <div class=\"user-header\">\n        <h3>{i + 1}. {name}</h3>\n        <button on:click={() => toggleUserStatus(id)}>\n          {active ? 'Deactivate' : 'Activate'}\n        </button>\n      </div>\n      \n      <div class=\"user-details\">\n        <p><strong>Role:</strong> {role}</p>\n        <p><strong>Email:</strong> {email}</p>\n        \n        <div class=\"skills\">\n          {#each skills as skill}\n            <span class=\"skill-tag\">{skill}</span>\n          {/each}\n        </div>\n      </div>\n    </div>\n  {/each}\n</div>\n```\n\n## Example with Component Composition\n\n```svelte\n<script>\n  import UserAvatar from './UserAvatar.svelte';\n  import UserDetails from './UserDetails.svelte';\n  import UserActions from './UserActions.svelte';\n  \n  let users = [\n    {\n      id: 'usr_123',\n      name: 'Alice Johnson',\n      avatar: '/avatars/alice.jpg',\n      email: 'alice@example.com',\n      role: 'Admin',\n      department: 'Engineering',\n      joinDate: '2021-03-15',\n      lastActive: '2023-06-10T14:30:00Z',\n      permissions: ['read', 'write', 'delete']\n    },\n    // More users...\n  ];\n</script>\n\n<div class=\"user-management\">\n  {#each users as { id, name, avatar, ...userDetails } (id)}\n    <div class=\"user-card\">\n      <div class=\"user-header\">\n        <UserAvatar src={avatar} name={name} />\n        <h3>{name}</h3>\n      </div>\n      \n      <!-- Pass all remaining properties to the details component -->\n      <UserDetails {...userDetails} />\n      \n      <!-- Pass just the ID and permissions -->\n      <UserActions \n        userId={id} \n        permissions={userDetails.permissions} \n      />\n    </div>\n  {/each}\n</div>\n```\n\n## Complex Example: Product Catalog with Variants\n\n```svelte\n<script>\n  import ProductImage from './ProductImage.svelte';\n  import VariantSelector from './VariantSelector.svelte';\n  import AddToCartButton from './AddToCartButton.svelte';\n  \n  let products = [\n    {\n      id: 'prod_1',\n      name: 'Ergonomic Chair',\n      price: 299.99,\n      image: '/products/chair.jpg',\n      description: 'A comfortable office chair with lumbar support.',\n      stock: 15,\n      variants: [\n        { id: 'var_1', color: 'Black', material: 'Leather', price: 299.99, stock: 10 },\n        { id: 'var_2', color: 'Brown', material: 'Leather', price: 299.99, stock: 5 },\n        { id: 'var_3', color: 'Gray', material: 'Fabric', price: 249.99, stock: 0 }\n      ]\n    },\n    // More products...\n  ];\n  \n  // Track selected variant for each product\n  let selectedVariants = {};\n  \n  function selectVariant(productId, variantId) {\n    selectedVariants = {\n      ...selectedVariants,\n      [productId]: variantId\n    };\n  }\n  \n  function getSelectedVariant(product) {\n    const variantId = selectedVariants[product.id];\n    return product.variants.find(v => v.id === variantId) || product.variants[0];\n  }\n</script>\n\n<div class=\"product-catalog\">\n  {#each products as { id, name, image, description, variants }, i (id)}\n    <div class=\"product-card\">\n      <ProductImage src={image} alt={name} />\n      \n      <div class=\"product-info\">\n        <h2>{name}</h2>\n        <p>{description}</p>\n        \n        <!-- Nested each with destructuring and keys -->\n        <div class=\"variants\">\n          <h4>Available Options:</h4>\n          {#each variants as { id: variantId, color, material, price, stock } (variantId)}\n            <div \n              class=\"variant-option\" \n              class:selected={selectedVariants[id] === variantId}\n              class:out-of-stock={stock === 0}\n              on:click={() => stock > 0 && selectVariant(id, variantId)}\n            >\n              <span class=\"color-swatch\" style=\"background-color: {color.toLowerCase()};\"></span>\n              <span>{color} / {material}</span>\n              <span>${price.toFixed(2)}</span>\n              {#if stock === 0}\n                <span class=\"stock-badge\">Out of stock</span>\n              {:else if stock < 5}\n                <span class=\"stock-badge\">Low stock</span>\n              {/if}\n            </div>\n          {/each}\n        </div>\n        \n        {@const selectedVariant = getSelectedVariant({ id, variants })}\n        <div class=\"product-actions\">\n          <span class=\"price\">${selectedVariant.price.toFixed(2)}</span>\n          <AddToCartButton \n            disabled={selectedVariant.stock === 0}\n            productId={id} \n            variantId={selectedVariant.id}\n          />\n        </div>\n      </div>\n    </div>\n  {/each}\n</div>\n```\n\nThis combined approach of using keyed each blocks with destructuring creates code that is both performant and highly readable. It's especially valuable when working with complex data structures or when building component-based UIs where you need to pass different properties to different child components."}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"What is the syntax for iterating through an array without using the array item in Svelte, and what are some creative use cases for this pattern?","answer":"In Svelte, you can iterate through an array without using the array item by omitting the `as` clause in the `{#each}` block. This is particularly useful when you just need to repeat a piece of UI a certain number of times without needing to reference the actual array elements.\n\n## Basic Syntax\n\n```svelte\n{#each expression}\n  <!-- Content to repeat -->\n{/each}\n```\n\nOr with an index:\n\n```svelte\n{#each expression, index}\n  <!-- Content to repeat with index -->\n{/each}\n```\n\n## Simple Example: Creating a Star Rating Display\n\n```svelte\n<script>\n  export let rating = 4;\n  export let maxStars = 5;\n</script>\n\n<div class=\"star-rating\">\n  {#each { length: maxStars }, i}\n    <span class=\"star\" class:filled={i < rating}>â</span>\n  {/each}\n</div>\n\n<style>\n  .star-rating {\n    display: flex;\n  }\n  \n  .star {\n    color: #ddd;\n    font-size: 24px;\n  }\n  \n  .filled {\n    color: gold;\n  }\n</style>\n```\n\n## Creative Use Case 1: Chess or Checkers Board\n\nOne of the most elegant uses for this pattern is creating a chess or checkers board:\n\n```svelte\n<script>\n  const boardSize = 8;\n</script>\n\n<style>\n  .chess-board {\n    display: grid;\n    grid-template-columns: repeat(8, 50px);\n    grid-template-rows: repeat(8, 50px);\n    border: 2px solid #333;\n  }\n  \n  .square {\n    width: 100%;\n    height: 100%;\n  }\n  \n  .black {\n    background-color: #769656;\n  }\n  \n  .white {\n    background-color: #eeeed2;\n  }\n  \n  /* Add file and rank labels */\n  .label {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 12px;\n    color: #666;\n  }\n</style>\n\n<div class=\"board-container\">\n  <!-- File labels (A-H) -->\n  <div style=\"display: flex; margin-left: 20px;\">\n    {#each { length: boardSize }, i}\n      <div style=\"width: 50px; text-align: center;\">\n        {String.fromCharCode(65 + i)}\n      </div>\n    {/each}\n  </div>\n  \n  <div style=\"display: flex;\">\n    <!-- Rank labels (1-8) -->\n    <div style=\"display: flex; flex-direction: column;\">\n      {#each { length: boardSize }, i}\n        <div style=\"height: 50px; display: flex; align-items: center;\">\n          {8 - i}\n        </div>\n      {/each}\n    </div>\n    \n    <!-- Chess board -->\n    <div class=\"chess-board\">\n      {#each { length: boardSize }, rank}\n        {#each { length: boardSize }, file}\n          <div \n            class=\"square\" \n            class:black={(rank + file) % 2 === 1}\n            class:white={(rank + file) % 2 === 0}\n            data-position=\"{String.fromCharCode(97 + file)}{8 - rank}\"\n          ></div>\n        {/each}\n      {/each}\n    </div>\n  </div>\n</div>\n```\n\n## Creative Use Case 2: Calendar or Planner\n\nCreating a monthly calendar grid:\n\n```svelte\n<script>\n  export let year = new Date().getFullYear();\n  export let month = new Date().getMonth();\n  \n  const monthNames = [\n    'January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December'\n  ];\n  \n  const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n  \n  function getDaysInMonth(year, month) {\n    return new Date(year, month + 1, 0).getDate();\n  }\n  \n  function getFirstDayOfMonth(year, month) {\n    return new Date(year, month, 1).getDay();\n  }\n  \n  const daysInMonth = getDaysInMonth(year, month);\n  const firstDay = getFirstDayOfMonth(year, month);\n  \n  // Calculate total number of cells needed (including empty cells)\n  const totalCells = Math.ceil((daysInMonth + firstDay) / 7) * 7;\n  \n  function isToday(day) {\n    const today = new Date();\n    return day === today.getDate() && \n           month === today.getMonth() && \n           year === today.getFullYear();\n  }\n</script>\n\n<style>\n  .calendar {\n    font-family: Arial, sans-serif;\n    max-width: 800px;\n    margin: 0 auto;\n  }\n  \n  .header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 20px;\n  }\n  \n  .grid {\n    display: grid;\n    grid-template-columns: repeat(7, 1fr);\n    gap: 4px;\n  }\n  \n  .day-name {\n    text-align: center;\n    font-weight: bold;\n    padding: 10px;\n    background-color: #f0f0f0;\n  }\n  \n  .day {\n    height: 80px;\n    border: 1px solid #ddd;\n    padding: 5px;\n    position: relative;\n  }\n  \n  .day-number {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    font-weight: bold;\n  }\n  \n  .empty {\n    background-color: #f9f9f9;\n  }\n  \n  .today {\n    background-color: #e6f7ff;\n    border: 2px solid #1890ff;\n  }\n</style>\n\n<div class=\"calendar\">\n  <div class=\"header\">\n    <button on:click={() => month = month === 0 ? 11 : month - 1}>Previous</button>\n    <h2>{monthNames[month]} {year}</h2>\n    <button on:click={() => month = month === 11 ? 0 : month + 1}>Next</button>\n  </div>\n  \n  <div class=\"grid\">\n    <!-- Day names -->\n    {#each dayNames as dayName}\n      <div class=\"day-name\">{dayName}</div>\n    {/each}\n    \n    <!-- Calendar days -->\n    {#each { length: totalCells }, i}\n      {@const dayNumber = i - firstDay + 1}\n      {@const isValidDay = dayNumber > 0 && dayNumber <= daysInMonth}\n      \n      <div class=\"day\" \n           class:empty={!isValidDay}\n           class:today={isValidDay && isToday(dayNumber)}>\n        {#if isValidDay}\n          <div class=\"day-number\">{dayNumber}</div>\n          <!-- Content for this day could go here -->\n        {/if}\n      </div>\n    {/each}\n  </div>\n</div>\n```\n\n## Creative Use Case 3: Pagination Component\n\nCreating pagination controls:\n\n```svelte\n<script>\n  export let currentPage = 1;\n  export let totalPages = 10;\n  export let onPageChange = (page) => {};\n  \n  // Determine which page numbers to show\n  function getVisiblePages() {\n    let pages = [];\n    \n    if (totalPages <= 7) {\n      // Show all pages if there are 7 or fewer\n      for (let i = 1; i <= totalPages; i++) {\n        pages.push(i);\n      }\n    } else {\n      // Always show first and last page\n      pages.push(1);\n      \n      if (currentPage <= 3) {\n        // Near the beginning\n        pages.push(2, 3, 4, '...', totalPages);\n      } else if (currentPage >= totalPages - 2) {\n        // Near the end\n        pages.push('...', totalPages - 3, totalPages - 2, totalPages - 1, totalPages);\n      } else {\n        // Somewhere in the middle\n        pages.push('...', currentPage - 1, currentPage, currentPage + 1, '...', totalPages);\n      }\n    }\n    \n    return pages;\n  }\n  \n  $: visiblePages = getVisiblePages();\n</script>\n\n<style>\n  .pagination {\n    display: flex;\n    list-style: none;\n    padding: 0;\n    margin: 20px 0;\n    justify-content: center;\n  }\n  \n  .page-item {\n    margin: 0 5px;\n  }\n  \n  .page-link {\n    padding: 8px 12px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    cursor: pointer;\n    color: #333;\n    text-decoration: none;\n  }\n  \n  .active .page-link {\n    background-color: #007bff;\n    color: white;\n    border-color: #007bff;\n  }\n  \n  .disabled .page-link {\n    color: #ccc;\n    cursor: not-allowed;\n  }\n</style>\n\n<nav aria-label=\"Pagination\">\n  <ul class=\"pagination\">\n    <!-- Previous button -->\n    <li class=\"page-item\" class:disabled={currentPage === 1}>\n      <a class=\"page-link\" \n         on:click={() => currentPage > 1 && onPageChange(currentPage - 1)}>\n        Previous\n      </a>\n    </li>\n    \n    <!-- Page numbers -->\n    {#each visiblePages as page}\n      {#if page === '...'}\n        <li class=\"page-item disabled\">\n          <span class=\"page-link\">...</span>\n        </li>\n      {:else}\n        <li class=\"page-item\" class:active={page === currentPage}>\n          <a class=\"page-link\" on:click={() => onPageChange(page)}>\n            {page}\n          </a>\n        </li>\n      {/if}\n    {/each}\n    \n    <!-- Next button -->\n    <li class=\"page-item\" class:disabled={currentPage === totalPages}>\n      <a class=\"page-link\" \n         on:click={() => currentPage < totalPages && onPageChange(currentPage + 1)}>\n        Next\n      </a>\n    </li>\n  </ul>\n</nav>\n```\n\n## Creative Use Case 4: Loading Skeleton\n\nCreating a loading skeleton UI:\n\n```svelte\n<script>\n  export let loading = true;\n  export let items = [];\n  export let skeletonCount = 5;\n</script>\n\n<style>\n  .skeleton {\n    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);\n    background-size: 200% 100%;\n    animation: loading 1.5s infinite;\n    border-radius: 4px;\n    height: 100px;\n    margin-bottom: 15px;\n  }\n  \n  @keyframes loading {\n    0% {\n      background-position: 200% 0;\n    }\n    100% {\n      background-position: -200% 0;\n    }\n  }\n</style>\n\n<div class=\"item-list\">\n  {#if loading}\n    {#each { length: skeletonCount }}\n      <div class=\"skeleton\"></div>\n    {/each}\n  {:else}\n    {#each items as item (item.id)}\n      <!-- Actual content -->\n      <div class=\"item\">\n        <h3>{item.title}</h3>\n        <p>{item.description}</p>\n      </div>\n    {/each}\n  {/if}\n</div>\n```\n\nThe ability to iterate without referencing the array item makes Svelte's each blocks incredibly versatile for UI patterns that require repetition based on a count rather than actual data. This pattern leads to cleaner, more readable code in these scenarios."}
{"source":"docs/svelte/03-template-syntax/03-each.md","question":"What are the different ways to handle conditional rendering within an each block in Svelte, and what are the tradeoffs?","answer":"Svelte offers several approaches to handle conditional rendering within each blocks, each with its own strengths and tradeoffs. Understanding these options helps you write more efficient and maintainable code.\n\n## 1. Using {:else} in Each Blocks\n\nThe simplest approach for handling empty arrays is using the built-in `:else` clause:\n\n```svelte\n{#each items as item}\n  <div class=\"item\">{item.name}</div>\n{:else}\n  <div class=\"empty-state\">No items available</div>\n{/each}\n```\n\n**Pros:**\n- Clean, declarative syntax\n- Clear separation between list and empty state\n- Built into Svelte's template syntax\n\n**Cons:**\n- Only handles the empty array case\n- Doesn't help with conditional rendering of individual items\n\n## 2. Using {#if} Inside {#each}\n\nFor conditional rendering of individual items based on their properties:\n\n```svelte\n{#each items as item}\n  {#if item.isVisible}\n    <div class=\"item\">{item.name}</div>\n  {/if}\n{/each}\n```\n\n**Pros:**\n- Clear, explicit conditional logic\n- Works well for complex conditions\n- Nested blocks are easy to understand\n\n**Cons:**\n- Creates DOM nodes that might not be used\n- Less efficient than filtering the array first\n- Can make templates more verbose\n\n## 3. Filtering the Array First\n\nPre-filter the array before iteration:\n\n```svelte\n<script>\n  $: visibleItems = items.filter(item => item.isVisible);\n</script>\n\n{#each visibleItems as item}\n  <div class=\"item\">{item.name}</div>\n{:else}\n  <div class=\"empty-state\">No visible items</div>\n{/each}\n```\n\n**Pros:**\n- More efficient - only iterates over items that will be displayed\n- Cleaner template syntax\n- `:else` works correctly for \"no visible items\" case\n\n**Cons:**\n- Logic is split between script and template\n- Additional reactive variable needed\n- May cause extra work if the filter is complex and the array is large\n\n## 4. Using the Ternary Operator or Logical AND\n\nFor simple conditional rendering within each item:\n\n```svelte\n{#each items as item}\n  {item.isVisible ? \n    <div class=\"item\">{item.name}</div> : \n    <div class=\"hidden-item\">Hidden: {item.name}</div>}\n{/each}\n```\n\nOr using logical AND for cases where you want nothing rendered:\n\n```svelte\n{#each items as item}\n  {item.isVisible && <div class=\"item\">{item.name}</div>}\n{/each}\n```\n\n**Pros:**\n- Compact syntax for simple conditions\n- Keeps related logic together\n- No need for nested blocks\n\n**Cons:**\n- Can become hard to read with complex conditions\n- Limited to simple expressions\n- Doesn't work well with multiple elements or components\n\n## 5. Using class:directives for Visual Conditions\n\nInstead of conditional rendering, conditionally style elements:\n\n```svelte\n{#each items as item}\n  <div \n    class=\"item\" \n    class:hidden={!item.isVisible}\n    class:featured={item.isFeatured}\n  >\n    {item.name}\n  </div>\n{/each}\n```\n\n**Pros:**\n- All items remain in the DOM (good for animations/transitions)\n- Clean syntax for visual conditions\n- Better performance for toggling visibility\n\n**Cons:**\n- Elements still exist in the DOM even when \"hidden\"\n- Not suitable when you need to completely remove elements\n- May not be appropriate for accessibility concerns\n\n## 6. Comprehensive Example with Multiple Approaches\n\nLet's look at a more complex example combining several techniques:\n\n```svelte\n<script>\n  let products = [\n    { id: 1, name: 'Laptop', price: 999, inStock: true, featured: true, category: 'electronics' },\n    { id: 2, name: 'Headphones', price: 99, inStock: true, featured: false, category: 'electronics' },\n    { id: 3, name: 'Keyboard', price: 59, inStock: false, featured: false, category: 'electronics' },\n    { id: 4, name: 'Coffee Mug', price: 12, inStock: true, featured: false, category: 'home' }\n  ];\n  \n  let selectedCategory = 'all';\n  let showOutOfStock = false;\n  \n  $: filteredProducts = products\n    .filter(p => selectedCategory === 'all' || p.category === selectedCategory)\n    .filter(p => showOutOfStock || p.inStock);\n    \n  function toggleStock() {\n    showOutOfStock = !showOutOfStock;\n  }\n</script>\n\n<div>\n  <div class=\"filters\">\n    <select bind:value={selectedCategory}>\n      <option value=\"all\">All Categories</option>\n      <option value=\"electronics\">Electronics</option>\n      <option value=\"home\">Home</option>\n    </select>\n    \n    <label>\n      <input type=\"checkbox\" bind:checked={showOutOfStock}>\n      Show out of stock items\n    </label>\n  </div>\n\n  <div class=\"product-list\">\n    {#each filteredProducts as product (product.id)}\n      <div \n        class=\"product-card\" \n        class:featured={product.featured}\n        class:out-of-stock={!product.inStock}\n      >\n        <h3>{product.name}</h3>\n        <p>${product.price}</p>\n        \n        {#if !product.inStock}\n          <span class=\"stock-badge\">Out of Stock</span>\n        {/if}\n        \n        <button disabled={!product.inStock}>\n          {product.inStock ? 'Add to Cart' : 'Notify When Available'}\n        </button>\n      </div>\n    {:else}\n      <div class=\"empty-state\">\n        {#if selectedCategory !== 'all'}\n          No {selectedCategory} products found\n          {#if !showOutOfStock}\n            <button on:click={toggleStock}>Show out of stock items</button>\n          {/if}\n        {:else}\n          No products match your criteria\n        {/if}\n      </div>\n    {/each}\n  </div>\n</div>\n```\n\n## 7. Using Slot-Based Components for Complex Conditional Logic\n\nFor very complex conditional rendering, you can create specialized components:\n\n```svelte\n<!-- ConditionalItem.svelte -->\n<script>\n  export let condition = false;\n</script>\n\n{#if condition}\n  <slot name=\"true\"></slot>\n{:else}\n  <slot name=\"false\"></slot>\n{/if}\n\n<!-- In parent component -->\n{#each items as item}\n  <ConditionalItem condition={item.isSpecial}>\n    <div slot=\"true\" class=\"special-item\">\n      <StarIcon />\n      <h3>{item.name}</h3>\n      <SpecialBadge />\n    </div>\n    \n    <div slot=\"false\" class=\"regular-item\">\n      <h3>{item.name}</h3>\n    </div>\n  </ConditionalItem>\n{/each}\n```\n\n**Pros:**\n- Encapsulates complex conditional logic\n- Makes templates cleaner\n- Reusable across the application\n\n**Cons:**\n- Adds component overhead\n- May be overkill for simple conditions\n- Requires creating and maintaining additional components\n\n## Conclusion and Best Practices\n\nWhen choosing a conditional rendering approach in Svelte's each blocks, consider:\n\n1. **Performance needs**: For large lists, pre-filtering is usually more efficient\n2. **Readability**: Choose the approach that makes your code most understandable\n3. **Complexity**: Simple conditions work well with class directives or inline logic; complex conditions may warrant separate components\n4. **DOM needs**: Consider whether elements need to be completely removed or just visually hidden\n5. **Accessibility**: Ensure conditional rendering doesn't create accessibility issues\n\nThe most appropriate technique depends on your specific use case, but Svelte's flexibility gives you many options to handle conditional rendering within each blocks efficiently."}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"What is the purpose of the key block in Svelte, and what is its basic syntax?","answer":"The key block in Svelte is a control flow structure that destroys and recreates its contents when the value of an expression changes. This is particularly useful for forcing components to be reinstantiated or for triggering transitions when values change.\n\nThe basic syntax is:\n```svelte\n{#key expression}\n  <!-- content that will be recreated when expression changes -->\n{/key}\n```\n\nWhere `expression` is any JavaScript expression whose value Svelte will track. When this value changes, Svelte will completely destroy the DOM elements inside the block and recreate them from scratch, running any initialization code again.\n\nThis is different from regular reactivity in Svelte, which typically updates only the parts of the DOM that need to change when data changes. The key block forces a complete recreation of its contents."}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"How would you use a key block to reset a component's state when a user ID changes?","answer":"When working with components that maintain internal state, you might want to completely reset that state when certain identifying properties change. The key block is perfect for this scenario.\n\nHere's an example of using a key block to reset a UserProfile component when the user ID changes:\n\n```svelte\n<script>\n  import UserProfile from './UserProfile.svelte';\n  \n  // This might come from a store, prop, or other source\n  export let currentUserId;\n</script>\n\n{#key currentUserId}\n  <UserProfile userId={currentUserId} />\n{/key}\n```\n\nIn this example, whenever `currentUserId` changes:\n1. The existing UserProfile component instance is completely destroyed\n2. A new instance is created with the new ID\n3. All component initialization code runs again\n4. Any internal state the component had is reset to its initial values\n\nWithout the key block, the component would just receive the new prop value but maintain its internal state, which might lead to inconsistencies if the component's state depends on the user ID."}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"Explain how key blocks can be used with transitions to create animation effects when data changes.","answer":"One of the most powerful uses of key blocks is to trigger transitions whenever a specific value changes. This allows you to create expressive UI animations that respond to data changes.\n\nHere's an example showing how to use a key block with a transition to animate a counter value:\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  import { elasticOut } from 'svelte/easing';\n  \n  let count = 0;\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n\n<button on:click={increment}>Increment</button>\n\n<div class=\"counter-container\">\n  {#key count}\n    <span \n      transition:fly={{ y: 20, duration: 400, easing: elasticOut }}\n    >\n      {count}\n    </span>\n  {/key}\n</div>\n\n<style>\n  .counter-container {\n    font-size: 2rem;\n    height: 3rem;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n</style>\n```\n\nIn this example:\n1. Each time the count changes, the entire span containing the count is destroyed and recreated\n2. The `fly` transition is applied both when the old element is removed (out) and when the new element is added (in)\n3. This creates a smooth animation effect where each new number appears to fly in from below\n\nWithout the key block, the transition would only play once when the element is first created, not on every count change."}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"What's the difference between using a key block and simply updating a component's props?","answer":"The difference between using a key block and simply updating a component's props is in how Svelte handles the component's lifecycle and internal state:\n\n**When updating props without a key block:**\n```svelte\n<script>\n  import ProfileCard from './ProfileCard.svelte';\n  export let userId;\n</script>\n\n<ProfileCard {userId} />\n```\n\nIn this case:\n- The component instance persists\n- Internal state is preserved\n- Only the props are updated\n- Component's `update` lifecycle runs\n- The component decides how to respond to prop changes\n\n**When using a key block:**\n```svelte\n<script>\n  import ProfileCard from './ProfileCard.svelte';\n  export let userId;\n</script>\n\n{#key userId}\n  <ProfileCard {userId} />\n{/key}\n```\n\nIn this case:\n- The entire component is destroyed\n- A completely new instance is created\n- All internal state is reset to initial values\n- All lifecycle hooks run again (onMount, etc.)\n- Any setup code in the component script runs again\n\nThe key block approach is useful when:\n- You want to clear all internal state\n- You need to re-run initialization logic\n- You want transitions to play again\n- You're working with third-party libraries that need proper cleanup and reinitialization\n\nHowever, it's more expensive performance-wise than simply updating props, so it should be used intentionally when the complete reset behavior is needed."}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"Can you use complex expressions in a key block, and if so, how would you implement a key block that resets when either of two values changes?","answer":"Yes, you can use complex expressions in a key block. Svelte will track the value of the entire expression and recreate the block contents when that value changes.\n\nHere's how you could implement a key block that resets when either of two values changes:\n\n```svelte\n<script>\n  import UserForm from './UserForm.svelte';\n  \n  export let userId;\n  export let formMode; // Could be 'create', 'edit', 'view', etc.\n</script>\n\n{#key `${userId}-${formMode}`}\n  <UserForm {userId} mode={formMode} />\n{/key}\n```\n\nIn this example, we're creating a composite key by concatenating the `userId` and `formMode` values with a separator. The key block will recreate its contents whenever either value changes.\n\nYou can use more complex expressions too:\n\n```svelte\n<script>\n  let user = { id: 1, name: 'Alice' };\n  let settings = { theme: 'dark', language: 'en' };\n  \n  function updateUser(newData) {\n    user = { ...user, ...newData };\n  }\n  \n  function updateSettings(newSettings) {\n    settings = { ...settings, ...newSettings };\n  }\n</script>\n\n{#key JSON.stringify({ userId: user.id, theme: settings.theme })}\n  <UserDashboard {user} {settings} />\n{/key}\n```\n\nIn this more complex example, the dashboard component will reset whenever either the user ID or the theme changes, but not when other properties like the user's name or language setting change.\n\nThe key expression can be any valid JavaScript expression, including function calls, object methods, or computed values, as long as it produces a value that can be compared for equality."}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"How would you use a key block with an array of items in a loop to ensure proper animations when the array changes?","answer":"When working with arrays in Svelte, you often want animations to play when items are added, removed, or reordered. You can combine the `#each` block with `#key` blocks to achieve this:\n\n```svelte\n<script>\n  import { fade, slide } from 'svelte/transition';\n  \n  let todos = [\n    { id: 1, text: 'Learn Svelte', done: false },\n    { id: 2, text: 'Build an app', done: false },\n    { id: 3, text: 'Deploy to production', done: false }\n  ];\n  \n  function addTodo(text) {\n    const id = Math.max(0, ...todos.map(t => t.id)) + 1;\n    todos = [...todos, { id, text, done: false }];\n  }\n  \n  function removeTodo(id) {\n    todos = todos.filter(todo => todo.id !== id);\n  }\n  \n  function toggleTodo(id) {\n    todos = todos.map(todo => \n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    );\n  }\n</script>\n\n<ul>\n  {#each todos as todo (todo.id)}\n    {#key todo.done}\n      <li \n        transition:slide={{ duration: 300 }}\n        class:done={todo.done}\n      >\n        <input \n          type=\"checkbox\" \n          checked={todo.done} \n          on:change={() => toggleTodo(todo.id)} \n        />\n        <span>{todo.text}</span>\n        <button on:click={() => removeTodo(todo.id)}>Delete</button>\n      </li>\n    {/key}\n  {/each}\n</ul>\n\n<style>\n  .done {\n    text-decoration: line-through;\n    opacity: 0.6;\n  }\n</style>\n```\n\nIn this example:\n\n1. The `#each` block uses `(todo.id)` as its key to track which todo is which when the array changes\n2. Inside each loop iteration, we have a `#key todo.done` block that will recreate the list item whenever the todo's done status changes\n3. The `slide` transition will play when:\n   - A new todo is added to the list\n   - A todo is removed from the list\n   - A todo's done status is toggled (because of the key block)\n\nThis approach gives you fine-grained control over when animations play. Without the inner key block, the transition would only play when items are added or removed, but not when their properties change."}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"What are some performance considerations when using key blocks in Svelte applications?","answer":"While key blocks are powerful, they come with performance implications that developers should be aware of:\n\n1. **DOM Reconstruction Cost**: Key blocks completely destroy and recreate DOM elements, which is more expensive than just updating properties or text content. This includes:\n   - Removing old elements from the DOM\n   - Creating new DOM elements\n   - Setting up event listeners again\n   - Running all lifecycle hooks\n\n2. **Component Reinitialization**: For components, this means:\n   - Running the component's script block again\n   - Reinitializing all reactive statements\n   - Triggering onMount and other lifecycle hooks\n   - Potentially making duplicate API calls if they're in onMount\n\n3. **Transition Performance**: When key blocks are used with transitions:\n   - Both in and out transitions will play simultaneously\n   - This can be CPU-intensive for complex animations\n   - Multiple transitions playing at once can cause jank on lower-end devices\n\nHere are some best practices to mitigate performance issues:\n\n```svelte\n<script>\n  // BAD: Using key block with an expensive computation\n  let expensiveData;\n  let id;\n  \n  $: {\n    // This will run on EVERY render if placed inside a key block\n    expensiveData = performExpensiveCalculation(id);\n  }\n</script>\n\n<!-- Better: Only use key blocks when necessary -->\n{#key id}\n  <!-- Only put what NEEDS to be reset inside the key block -->\n  <SpecificComponent {id} data={expensiveData} />\n{/key}\n\n<!-- GOOD: Keep expensive calculations outside the key block -->\n<script>\n  let count = 0;\n  \n  // Calculate expensive values outside components in key blocks\n  $: expensiveValue = calculateExpensive(count);\n</script>\n\n{#key count}\n  <!-- Pass the pre-calculated value -->\n  <Component value={expensiveValue} />\n{/key}\n```\n\nAdditional recommendations:\n- Don't nest key blocks unnecessarily\n- Be strategic about what you put in key blocks - only include what needs to reset\n- For lists, consider if you really need a key block inside each iteration\n- For large components, consider if a more targeted approach (like local state reset) might be more efficient\n- Use the Svelte devtools to monitor component creation/destruction\n- For very frequent updates, consider using CSS animations instead of transition directives"}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"How can key blocks be used with Svelte's slot system for creating reusable components with animations?","answer":"Key blocks can be combined with Svelte's slot system to create reusable components that provide animation capabilities to their children. This pattern is especially useful for creating transition containers or animated UI components.\n\nHere's an example of creating a reusable \"Refresher\" component that animates its content whenever a refresh is triggered:\n\nFirst, let's create the reusable component (`Refresher.svelte`):\n\n```svelte\n<script>\n  import { fade } from 'svelte/transition';\n  \n  // This prop is what we'll use as our key\n  export let refreshKey = 0;\n  \n  // Optional props to customize the transition\n  export let duration = 300;\n  export let transitionFn = fade;\n  export let transitionParams = {};\n</script>\n\n{#key refreshKey}\n  <div transition:transitionFn={{ duration, ...transitionParams }}>\n    <slot />\n  </div>\n{/key}\n```\n\nNow we can use this component in various places:\n\n```svelte\n<script>\n  import Refresher from './Refresher.svelte';\n  import { fly } from 'svelte/transition';\n  \n  let dataVersion = 0;\n  let data = { title: 'Initial Data' };\n  \n  function refreshData() {\n    // Simulate data fetch\n    setTimeout(() => {\n      data = { title: 'New Data ' + new Date().toLocaleTimeString() };\n    }, 300);\n    \n    // Immediately increment the key to trigger animation\n    dataVersion++;\n  }\n</script>\n\n<button on:click={refreshData}>Refresh Data</button>\n\n<!-- Basic usage -->\n<Refresher refreshKey={dataVersion}>\n  <div class=\"card\">\n    <h2>{data.title}</h2>\n    <p>This content will fade in/out when refreshed</p>\n  </div>\n</Refresher>\n\n<!-- Custom transition -->\n<Refresher \n  refreshKey={dataVersion}\n  transitionFn={fly} \n  transitionParams={{ y: 20, duration: 500 }}\n>\n  <div class=\"card\">\n    <h2>{data.title}</h2>\n    <p>This content will fly in/out when refreshed</p>\n  </div>\n</Refresher>\n\n<style>\n  .card {\n    padding: 1rem;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    margin: 1rem 0;\n  }\n</style>\n```\n\nThis pattern is powerful because:\n\n1. **Reusability**: The animation logic is encapsulated in the Refresher component\n2. **Flexibility**: The slot system allows any content to be animated\n3. **Customization**: Props allow customizing the transition type and parameters\n4. **Separation of Concerns**: The parent component only needs to manage the key value, not the animation details\n\nYou can extend this pattern for more complex scenarios:\n\n```svelte\n<!-- TabPanel.svelte -->\n<script>\n  import { slide } from 'svelte/transition';\n  \n  export let activeTab;\n</script>\n\n{#key activeTab}\n  <div class=\"tab-content\" transition:slide>\n    <slot />\n  </div>\n{/key}\n\n<!-- Usage -->\n<script>\n  import TabPanel from './TabPanel.svelte';\n  \n  let currentTab = 'home';\n  \n  function setTab(tab) {\n    currentTab = tab;\n  }\n</script>\n\n<div class=\"tabs\">\n  <button class:active={currentTab === 'home'} on:click={() => setTab('home')}>Home</button>\n  <button class:active={currentTab === 'about'} on:click={() => setTab('about')}>About</button>\n  <button class:active={currentTab === 'contact'} on:click={() => setTab('contact')}>Contact</button>\n</div>\n\n<TabPanel activeTab={currentTab}>\n  {#if currentTab === 'home'}\n    <h1>Home Page</h1>\n    <p>Welcome to our site!</p>\n  {:else if currentTab === 'about'}\n    <h1>About Us</h1>\n    <p>Learn about our company.</p>\n  {:else if currentTab === 'contact'}\n    <h1>Contact</h1>\n    <p>Get in touch with us.</p>\n  {/if}\n</TabPanel>\n```\n\nThis slot-based approach with key blocks allows for creating highly reusable animation components that can be applied throughout your application."}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"How can you use key blocks to handle form resets and animations in a Svelte application?","answer":"Key blocks are particularly useful for handling form resets and animations in Svelte applications. They allow you to completely reset a form's state and apply transitions when needed.\n\nHere's a comprehensive example of using key blocks with forms:\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  \n  // Form state\n  let formKey = 0;\n  let submitting = false;\n  let success = false;\n  let error = null;\n  \n  // Initial form values\n  const initialValues = {\n    name: '',\n    email: '',\n    message: ''\n  };\n  \n  // Current form values (will be reset when formKey changes)\n  let formValues = { ...initialValues };\n  \n  async function handleSubmit() {\n    submitting = true;\n    error = null;\n    \n    try {\n      // Simulate API call\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Check for demo error case\n      if (formValues.email === 'error@example.com') {\n        throw new Error('This email is used for demonstration errors');\n      }\n      \n      // Success!\n      success = true;\n      // Reset form with a new key after showing success message\n      setTimeout(() => {\n        formKey++;\n        success = false;\n      }, 2000);\n      \n    } catch (err) {\n      error = err.message;\n    } finally {\n      submitting = false;\n    }\n  }\n  \n  function resetForm() {\n    // Simply incrementing the key will reset the entire form\n    formKey++;\n    error = null;\n    success = false;\n  }\n</script>\n\n<div class=\"form-container\">\n  {#if success}\n    <div class=\"success-message\" transition:fly={{ y: -20 }}>\n      Thank you for your submission!\n    </div>\n  {/if}\n  \n  {#if error}\n    <div class=\"error-message\" transition:fly={{ y: -20 }}>\n      Error: {error}\n    </div>\n  {/if}\n  \n  {#key formKey}\n    <form \n      on:submit|preventDefault={handleSubmit}\n      transition:fade={{ duration: 200 }}\n    >\n      <div class=\"form-group\">\n        <label for=\"name\">Name</label>\n        <input \n          id=\"name\" \n          type=\"text\" \n          required\n          bind:value={formValues.name}\n          disabled={submitting}\n        />\n      </div>\n      \n      <div class=\"form-group\">\n        <label for=\"email\">Email</label>\n        <input \n          id=\"email\" \n          type=\"email\" \n          required\n          bind:value={formValues.email}\n          disabled={submitting}\n        />\n        <small>Use error@example.com to test error handling</small>\n      </div>\n      \n      <div class=\"form-group\">\n        <label for=\"message\">Message</label>\n        <textarea \n          id=\"message\" \n          required\n          bind:value={formValues.message}\n          disabled={submitting}\n        ></textarea>\n      </div>\n      \n      <div class=\"form-actions\">\n        <button type=\"button\" on:click={resetForm} disabled={submitting}>\n          Reset\n        </button>\n        <button type=\"submit\" disabled={submitting}>\n          {submitting ? 'Submitting...' : 'Submit'}\n        </button>\n      </div>\n    </form>\n  {/key}\n</div>\n\n<style>\n  .form-container {\n    max-width: 500px;\n    margin: 0 auto;\n    position: relative;\n  }\n  \n  .success-message {\n    background-color: #d4edda;\n    color: #155724;\n    padding: 1rem;\n    border-radius: 4px;\n    margin-bottom: 1rem;\n  }\n  \n  .error-message {\n    background-color: #f8d7da;\n    color: #721c24;\n    padding: 1rem;\n    border-radius: 4px;\n    margin-bottom: 1rem;\n  }\n  \n  .form-group {\n    margin-bottom: 1rem;\n  }\n  \n  label {\n    display: block;\n    margin-bottom: 0.5rem;\n    font-weight: bold;\n  }\n  \n  input, textarea {\n    width: 100%;\n    padding: 0.5rem;\n    border: 1px solid #ced4da;\n    border-radius: 4px;\n  }\n  \n  textarea {\n    min-height: 100px;\n    resize: vertical;\n  }\n  \n  .form-actions {\n    display: flex;\n    justify-content: space-between;\n    margin-top: 1.5rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  \n  button[type=\"submit\"] {\n    background-color: #007bff;\n    color: white;\n  }\n  \n  button[type=\"button\"] {\n    background-color: #6c757d;\n    color: white;\n  }\n  \n  button:disabled {\n    opacity: 0.65;\n    cursor: not-allowed;\n  }\n  \n  small {\n    color: #6c757d;\n    font-size: 0.875rem;\n  }\n</style>\n```\n\nKey benefits of using key blocks with forms:\n\n1. **Complete Form Reset**: By incrementing the `formKey`, the entire form is recreated, which:\n   - Resets all input values to their initial state\n   - Clears any validation states or CSS classes\n   - Resets focus states\n   - Rebuilds any custom form elements\n\n2. **Clean Animation**: The transition directives work smoothly with the key block to:\n   - Fade out the old form and fade in the new one\n   - Create a visual indication that the form has been reset\n   - Provide feedback to the user about form state changes\n\n3. **State Management**: This approach:\n   - Keeps form state clean and predictable\n   - Avoids the need to manually reset every field\n   - Ensures no lingering state from previous submissions\n\n4. **Error/Success Handling**: The pattern shown:\n   - Displays success/error messages with their own animations\n   - Automatically resets the form after successful submission\n   - Allows manual reset at any time\n\nThis pattern is especially useful for multi-step forms, where you might want to completely reset certain steps when the user navigates between them."}
{"source":"docs/svelte/03-template-syntax/04-key.md","question":"How do key blocks interact with Svelte's reactivity system, and how can they be used to solve reactivity edge cases?","answer":"Key blocks have an interesting relationship with Svelte's reactivity system and can help solve certain edge cases where normal reactivity doesn't provide the desired behavior.\n\n### Basic Interaction with Reactivity\n\nIn Svelte, reactivity is typically handled through:\n1. Assignments to variables\n2. Reactive declarations (`$: derived = source * 2`)\n3. Reactive statements (`$: { sideEffect(source); }`)\n\nKey blocks add another dimension to this system by allowing you to completely recreate parts of your component when specific values change.\n\n```svelte\n<script>\n  let count = 0;\n  \n  // Normal reactive declaration\n  $: doubled = count * 2;\n  \n  // Reactive statement with side effect\n  $: {\n    console.log(`Count changed to ${count}`);\n  }\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n\n<button on:click={increment}>Increment</button>\n\n<!-- Normal reactivity updates only what changed -->\n<p>Count: {count}, Doubled: {doubled}</p>\n\n<!-- Key block destroys and recreates everything inside -->\n{#key count}\n  <p>This entire paragraph is recreated when count changes: {count}</p>\n{/key}\n```\n\n### Solving Reactivity Edge Cases\n\nHere are some specific edge cases where key blocks can be particularly helpful:\n\n#### 1. Third-party libraries that don't work with Svelte's reactivity\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  import ChartLibrary from 'third-party-chart-lib';\n  \n  export let data;\n  let chartElement;\n  let chart;\n  \n  onMount(() => {\n    // Initialize third-party chart\n    chart = new ChartLibrary(chartElement, {\n      data: data,\n      // other options...\n    });\n    \n    return () => {\n      // Cleanup\n      if (chart) chart.destroy();\n    };\n  });\n  \n  // This won't work if the library doesn't have an update method\n  // $: if (chart && data) chart.update(data);\n</script>\n\n<!-- Solution: Use key block to recreate the chart when data changes -->\n{#key JSON.stringify(data)}\n  <div bind:this={chartElement}></div>\n{/key}\n```\n\n#### 2. Canvas elements that need complete redrawing\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  export let drawingData;\n  let canvas;\n  let ctx;\n  \n  function draw() {\n    if (!ctx) return;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw based on data\n    ctx.fillStyle = drawingData.color;\n    ctx.beginPath();\n    ctx.arc(\n      drawingData.x, \n      drawingData.y, \n      drawingData.radius, \n      0, \n      Math.PI * 2\n    );\n    ctx.fill();\n  }\n  \n  onMount(() => {\n    ctx = canvas.getContext('2d');\n    draw();\n  });\n  \n  // This works but might not be ideal for complex drawings\n  // $: if (ctx && drawingData) draw();\n</script>\n\n<!-- Alternative: Use key block for complete redraw cycle -->\n{#key JSON.stringify(drawingData)}\n  <canvas \n    bind:this={canvas} \n    width=\"400\" \n    height=\"400\"\n  ></canvas>\n{/key}\n```\n\n#### 3. Form inputs that need to be completely reset\n\n```svelte\n<script>\n  export let initialSearchTerm = '';\n  \n  // Local state that should reset when initialSearchTerm changes\n  let searchTerm;\n  let searchHistory = [];\n  let focused = false;\n  \n  function handleSearch() {\n    if (searchTerm.trim()) {\n      searchHistory = [...searchHistory, searchTerm];\n      // Perform search...\n    }\n  }\n  \n  // This only updates the value, but doesn't reset other state\n  // $: searchTerm = initialSearchTerm;\n</script>\n\n<!-- Solution: Key block resets all local state -->\n{#key initialSearchTerm}\n  <div class=\"search-container\">\n    <input \n      bind:value={searchTerm} \n      placeholder=\"Search...\"\n      on:focus={() => focused = true}\n      on:blur={() => focused = false}\n    />\n    <button on:click={handleSearch}>Search</button>\n    \n    {#if focused && searchHistory.length > 0}\n      <div class=\"search-history\">\n        <h4>Recent searches:</h4>\n        <ul>\n          {#each searchHistory as term}\n            <li>{term}</li>\n          {/each}\n        </ul>\n      </div>\n    {/if}\n  </div>\n{/key}\n```\n\n#### 4. Animations that should play on every data update\n\n```svelte\n<script>\n  import { fly, fade } from 'svelte/transition';\n  import { elasticOut } from 'svelte/easing';\n  \n  export let stockPrice;\n  export let previousPrice = stockPrice;\n  \n  $: priceChange = stockPrice - previousPrice;\n  $: direction = priceChange > 0 ? 'up' : priceChange < 0 ? 'down' : 'same';\n  \n  // Update previous price after animation completes\n  $: if (stockPrice !== previousPrice) {\n    setTimeout(() => {\n      previousPrice = stockPrice;\n    }, 1000);\n  }\n</script>\n\n<div class=\"stock-ticker\">\n  <span class=\"label\">Current Price:</span>\n  \n  <!-- Price with animation on every change -->\n  {#key stockPrice}\n    <span \n      class=\"price\"\n      class:up={direction === 'up'}\n      class:down={direction === 'down'}\n      transition:fly={{ y: direction === 'up' ? 20 : -20, duration: 800, easing: elasticOut }}\n    >\n      ${stockPrice.toFixed(2)}\n    </span>\n  {/key}\n  \n  <!-- Change indicator with animation -->\n  {#key priceChange}\n    {#if priceChange !== 0}\n      <span \n        class=\"change\"\n        class:up={direction === 'up'}\n        class:down={direction === 'down'}\n        transition:fade={{ duration: 400 }}\n      >\n        {direction === 'up' ? 'â' : 'â'} \n        ${Math.abs(priceChange).toFixed(2)}\n      </span>\n    {/if}\n  {/key}\n</div>\n\n<style>\n  .stock-ticker {\n    font-family: monospace;\n    font-size: 1.5rem;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n  \n  .up { color: green; }\n  .down { color: red; }\n  \n  .price {\n    font-weight: bold;\n  }\n  \n  .change {\n    font-size: 1rem;\n  }\n</style>\n```\n\n### Advanced Pattern: Combining Key Blocks with Stores\n\nYou can combine key blocks with Svelte stores for powerful patterns:\n\n```svelte\n<script>\n  import { writable } from 'svelte/store';\n  import { fade } from 'svelte/transition';\n  \n  // Create a store for notifications\n  const notifications = writable([]);\n  \n  // Helper to add notifications\n  function notify(message, type = 'info') {\n    const id = Date.now();\n    notifications.update(n => [\n      ...n,\n      { id, message, type, timestamp: new Date() }\n    ]);\n    \n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n      notifications.update(n => n.filter(item => item.id !== id));\n    }, 5000);\n  }\n  \n  // Demo functions\n  function addInfoNotification() {\n    notify('This is an information message');\n  }\n  \n  function addErrorNotification() {\n    notify('Something went wrong!', 'error');\n  }\n  \n  function addSuccessNotification() {\n    notify('Operation completed successfully', 'success');\n  }\n</script>\n\n<div>\n  <button on:click={addInfoNotification}>Add Info</button>\n  <button on:click={addErrorNotification}>Add Error</button>\n  <button on:click={addSuccessNotification}>Add Success</button>\n  \n  <div class=\"notifications-container\">\n    {#each $notifications as notification (notification.id)}\n      {#key notification.id}\n        <div \n          class=\"notification\"\n          class:error={notification.type === 'error'}\n          class:success={notification.type === 'success'}\n          transition:fade={{ duration: 300 }}\n        >\n          <span class=\"message\">{notification.message}</span>\n          <span class=\"time\">\n            {notification.timestamp.toLocaleTimeString()}\n          </span>\n        </div>\n      {/key}\n    {/each}\n  </div>\n</div>\n\n<style>\n  .notifications-container {\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    width: 300px;\n    max-height: 80vh;\n    overflow-y: auto;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n  }\n  \n  .notification {\n    background-color: #f8f9fa;\n    border-left: 4px solid #6c757d;\n    padding: 10px 15px;\n    border-radius: 4px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n    display: flex;\n    justify-content: space-between;\n  }\n  \n  .error {\n    border-left-color: #dc3545;\n    background-color: #f8d7da;\n  }\n  \n  .success {\n    border-left-color: #28a745;\n    background-color: #d4edda;\n  }\n  \n  .time {\n    font-size: 0.8rem;\n    opacity: 0.7;\n  }\n</style>\n```\n\nIn this example, we're using key blocks inside an each block to ensure that each notification gets its own transition, even if multiple notifications are added or removed at the same time.\n\nThe key block is essential here because it ensures that the transition plays for each specific notification, rather than just when the overall list changes."}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"How do await blocks work in Svelte, and what are the different states they can handle?","answer":"Await blocks in Svelte provide a way to handle asynchronous operations directly in your template, allowing you to branch on the three possible states of a Promise: pending, fulfilled, or rejected.\n\nThe basic syntax for an await block looks like this:\n\n```svelte\n{#await promise}\n\t<!-- promise is pending -->\n\t<p>waiting for the promise to resolve...</p>\n{:then value}\n\t<!-- promise was fulfilled -->\n\t<p>The value is {value}</p>\n{:catch error}\n\t<!-- promise was rejected -->\n\t<p>Something went wrong: {error.message}</p>\n{/await}\n```\n\nWhen the await block is rendered:\n1. If the promise is still pending, the content between `{#await promise}` and `{:then value}` is rendered.\n2. Once the promise resolves (fulfills), the content between `{:then value}` and `{:catch error}` (or the end of the block) is rendered, with `value` set to the resolved value.\n3. If the promise rejects, the content between `{:catch error}` and `{/await}` is rendered, with `error` set to the rejection reason.\n\nThis approach makes handling asynchronous operations much more declarative compared to imperative approaches using state variables and useEffect in React or similar patterns in other frameworks."}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"What happens if you pass a non-Promise value to an await block in Svelte?","answer":"When you pass a non-Promise value to an await block in Svelte, only the `:then` branch will be rendered. This behavior is consistent across both client-side and server-side rendering.\n\nFor example, if you have the following code:\n\n```svelte\n{#await 42}\n\t<p>This will never show</p>\n{:then value}\n\t<p>The value is {value}</p> <!-- This will immediately show \"The value is 42\" -->\n{:catch error}\n\t<p>This will never show</p>\n{/await}\n```\n\nThe await block will immediately render the `:then` branch with the value 42, skipping the pending state entirely. The `:catch` branch will also never be rendered since there's no possibility of rejection.\n\nThis behavior is particularly useful when you have a function that might return either a Promise or a direct value, as the await block will handle both cases appropriately without requiring additional conditional logic."}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"How can you simplify an await block if you don't need to handle all three states of a Promise?","answer":"Svelte allows you to simplify await blocks by omitting branches you don't need, making your code more concise. There are several variations:\n\n1. If you don't need to handle rejection cases (or no error is possible), you can omit the `:catch` block:\n\n```svelte\n{#await promise}\n\t<!-- promise is pending -->\n\t<p>Loading data...</p>\n{:then value}\n\t<!-- promise was fulfilled -->\n\t<p>The value is {value}</p>\n{/await}\n```\n\n2. If you don't care about the pending state, you can omit the initial block using a shorthand syntax:\n\n```svelte\n{#await promise then value}\n\t<p>The value is {value}</p>\n{/await}\n```\n\n3. If you only want to show the error state, you can omit the `:then` block:\n\n```svelte\n{#await promise catch error}\n\t<p>The error is {error}</p>\n{/await}\n```\n\nThese simplified forms make your code more focused on the states you actually care about, improving readability and maintainability."}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"How would you implement a data loading pattern with error handling using await blocks in Svelte?","answer":"Implementing a data loading pattern with error handling is one of the most common use cases for await blocks in Svelte. Here's a complete example:\n\n```svelte\n<script>\n  // Function that returns a promise\n  async function fetchUserData(userId) {\n    const response = await fetch(`https://api.example.com/users/${userId}`);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch user: ${response.status} ${response.statusText}`);\n    }\n    \n    return response.json();\n  }\n  \n  // Create a promise for the component to await\n  let userPromise = fetchUserData(123);\n  \n  // Function to retry loading if there was an error\n  function retryLoading() {\n    userPromise = fetchUserData(123);\n  }\n</script>\n\n<div class=\"user-profile\">\n  {#await userPromise}\n    <div class=\"loading-spinner\">\n      <p>Loading user data...</p>\n      <img src=\"spinner.gif\" alt=\"Loading\" />\n    </div>\n  {:then user}\n    <div class=\"user-card\">\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n      <p>Role: {user.role}</p>\n      <div class=\"user-stats\">\n        <span>Posts: {user.stats.posts}</span>\n        <span>Followers: {user.stats.followers}</span>\n      </div>\n    </div>\n  {:catch error}\n    <div class=\"error-message\">\n      <p>Failed to load user data: {error.message}</p>\n      <button on:click={retryLoading}>Retry</button>\n    </div>\n  {/await}\n</div>\n```\n\nThis pattern provides several benefits:\n1. Clear separation of the three states (loading, success, error)\n2. Declarative handling of async operations\n3. Easy error recovery with the retry button\n4. No need to manually track loading/error states with separate variables\n\nYou can also nest await blocks or use multiple await blocks for different resources, allowing for complex loading patterns while keeping the code readable."}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"Can you use destructuring in the `:then` and `:catch` blocks of a Svelte await block?","answer":"Yes, you can use destructuring in both the `:then` and `:catch` blocks of a Svelte await block. This is particularly useful when working with API responses or complex objects.\n\nHere's an example with destructuring in the `:then` block:\n\n```svelte\n<script>\n  const fetchUserData = async () => {\n    const response = await fetch('https://api.example.com/user');\n    return response.json();\n  };\n  \n  const userPromise = fetchUserData();\n</script>\n\n{#await userPromise}\n  <p>Loading user data...</p>\n{:then { name, email, role, permissions }}\n  <!-- Destructuring the user object -->\n  <div class=\"user-info\">\n    <h2>{name}</h2>\n    <p>Email: {email}</p>\n    <p>Role: {role}</p>\n    <div class=\"permissions\">\n      <h3>Permissions:</h3>\n      <ul>\n        {#each permissions as permission}\n          <li>{permission}</li>\n        {/each}\n      </ul>\n    </div>\n  </div>\n{:catch error}\n  <p>Error: {error.message}</p>\n{/await}\n```\n\nYou can also use destructuring in the `:catch` block, which is useful when working with more structured error objects:\n\n```svelte\n{#await complexApiCall()}\n  <p>Processing...</p>\n{:then result}\n  <p>Success: {result}</p>\n{:catch { code, message, details }}\n  <!-- Destructuring the error object -->\n  <div class=\"error-display\">\n    <h3>Error {code}</h3>\n    <p>{message}</p>\n    {#if details}\n      <ul>\n        {#each Object.entries(details) as [key, value]}\n          <li>{key}: {value}</li>\n        {/each}\n      </ul>\n    {/if}\n  </div>\n{/await}\n```\n\nThe documentation also specifically mentions an example of using destructuring with dynamic imports:\n\n```svelte\n{#await import('./Component.svelte') then { default: Component }}\n  <Component />\n{/await}\n```\n\nThis pattern is particularly useful for code-splitting and lazy-loading components."}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"How can you use await blocks for dynamic imports and code-splitting in Svelte?","answer":"Await blocks in Svelte are particularly useful for implementing dynamic imports and code-splitting, which can significantly improve your application's performance by loading JavaScript only when needed.\n\nHere's how you can use await blocks for dynamic component imports:\n\n```svelte\n<script>\n  let showHeavyComponent = false;\n  \n  function toggleComponent() {\n    showHeavyComponent = !showHeavyComponent;\n  }\n</script>\n\n<button on:click={toggleComponent}>\n  {showHeavyComponent ? 'Hide' : 'Show'} Heavy Component\n</button>\n\n{#if showHeavyComponent}\n  {#await import('./HeavyComponent.svelte')}\n    <p>Loading component...</p>\n  {:then module}\n    <svelte:component this={module.default} />\n  {:catch error}\n    <p>Failed to load component: {error.message}</p>\n  {/await}\n{/if}\n```\n\nYou can also use destructuring to make the code even cleaner:\n\n```svelte\n{#if showHeavyComponent}\n  {#await import('./HeavyComponent.svelte') then { default: HeavyComponent }}\n    <HeavyComponent />\n  {/await}\n{/if}\n```\n\nFor more complex scenarios, you might want to dynamically import different components based on some condition:\n\n```svelte\n<script>\n  export let componentType = 'default';\n  \n  $: componentPromise = (() => {\n    switch (componentType) {\n      case 'admin':\n        return import('./AdminDashboard.svelte');\n      case 'user':\n        return import('./UserProfile.svelte');\n      default:\n        return import('./DefaultView.svelte');\n    }\n  })();\n</script>\n\n{#await componentPromise}\n  <p>Loading appropriate view...</p>\n{:then { default: Component }}\n  <Component />\n{:catch error}\n  <p>Error loading component: {error.message}</p>\n{/await}\n```\n\nThis approach allows you to:\n1. Reduce initial bundle size by splitting code into smaller chunks\n2. Load components only when they're needed\n3. Show appropriate loading states while components are being fetched\n4. Handle any errors that might occur during the dynamic import"}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"How do await blocks in Svelte handle server-side rendering (SSR)?","answer":"When it comes to server-side rendering (SSR), await blocks in Svelte have specific behavior to ensure consistent rendering between server and client.\n\nThe key point from the documentation is:\n\n> If the provided expression is not a Promise, only the `:then` branch will be rendered, including during server-side rendering.\n\nFor actual Promises during SSR, Svelte will wait for the Promise to resolve before sending the response, ensuring that the server renders the fulfilled state rather than the pending state. This prevents hydration mismatches and provides a better user experience with content available on the initial page load.\n\nHere's how different scenarios are handled during SSR:\n\n1. **Regular values (non-Promises):**\n```svelte\n{#await 42}\n  <p>Loading...</p>\n{:then value}\n  <p>The value is {value}</p>\n{:catch error}\n  <p>Error: {error}</p>\n{/await}\n```\nDuring SSR, this will render `<p>The value is 42</p>` directly, skipping the loading state.\n\n2. **Resolved Promises:**\n```svelte\n<script>\n  const promise = Promise.resolve('data');\n</script>\n\n{#await promise}\n  <p>Loading...</p>\n{:then value}\n  <p>The value is {value}</p>\n{/await}\n```\nDuring SSR, Svelte will wait for this Promise to resolve and render `<p>The value is data</p>`.\n\n3. **Dynamic imports:**\n```svelte\n{#await import('./Component.svelte') then { default: Component }}\n  <Component />\n{/await}\n```\nDuring SSR, Svelte will import the component and render it directly.\n\nThis behavior ensures that your application renders meaningful content during server-side rendering rather than showing loading states, which improves both SEO and perceived performance.\n\nHowever, it's important to note that if you have long-running Promises, they could delay the server response. In such cases, you might want to consider alternative patterns like:\n\n1. Fetching data at the page/layout level and passing it to components\n2. Using server-only data fetching with tools like SvelteKit's `load` functions\n3. Implementing streaming SSR for progressive rendering"}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"How can you combine await blocks with other Svelte control flow statements like #if and #each?","answer":"Await blocks in Svelte can be combined with other control flow statements to create complex and powerful rendering patterns. Here are examples of combining await blocks with `#if` and `#each`:\n\n**Combining with #if:**\n\nYou can use conditional logic to determine whether to execute a Promise or which Promise to execute:\n\n```svelte\n<script>\n  export let userId = null;\n  \n  $: userPromise = userId ? fetchUser(userId) : null;\n  \n  async function fetchUser(id) {\n    const response = await fetch(`/api/users/${id}`);\n    return response.json();\n  }\n</script>\n\n{#if userPromise}\n  {#await userPromise}\n    <p>Loading user data...</p>\n  {:then user}\n    <div class=\"user-profile\">\n      <h2>{user.name}</h2>\n      <p>{user.email}</p>\n    </div>\n  {:catch error}\n    <p>Error loading user: {error.message}</p>\n  {/await}\n{:else}\n  <p>Please select a user to view their profile</p>\n{/if}\n```\n\n**Combining with #each:**\n\nYou can use await blocks inside each blocks to handle multiple asynchronous operations:\n\n```svelte\n<script>\n  export let userIds = [1, 2, 3, 4, 5];\n  \n  function fetchUser(id) {\n    return fetch(`/api/users/${id}`).then(r => r.json());\n  }\n</script>\n\n<div class=\"user-grid\">\n  {#each userIds as id}\n    <div class=\"user-card\">\n      {#await fetchUser(id)}\n        <div class=\"skeleton-loader\"></div>\n      {:then user}\n        <h3>{user.name}</h3>\n        <p>{user.email}</p>\n      {:catch error}\n        <p class=\"error\">Failed to load user {id}</p>\n      {/await}\n    </div>\n  {/each}\n</div>\n```\n\n**Nesting await blocks:**\n\nYou can also nest await blocks for dependent async operations:\n\n```svelte\n<script>\n  async function fetchUser(id) {\n    const response = await fetch(`/api/users/${id}`);\n    return response.json();\n  }\n  \n  async function fetchUserPosts(userId) {\n    const response = await fetch(`/api/users/${userId}/posts`);\n    return response.json();\n  }\n  \n  const userPromise = fetchUser(1);\n</script>\n\n{#await userPromise}\n  <p>Loading user...</p>\n{:then user}\n  <h2>{user.name}'s Profile</h2>\n  \n  {#await fetchUserPosts(user.id)}\n    <p>Loading {user.name}'s posts...</p>\n  {:then posts}\n    <div class=\"posts\">\n      {#each posts as post}\n        <div class=\"post\">\n          <h3>{post.title}</h3>\n          <p>{post.content}</p>\n        </div>\n      {/each}\n    </div>\n  {:catch error}\n    <p>Error loading posts: {error.message}</p>\n  {/await}\n{:catch error}\n  <p>Error loading user: {error.message}</p>\n{/await}\n```\n\nThese combinations allow you to create sophisticated UI patterns while keeping your code declarative and maintainable. The nesting capabilities are particularly powerful for handling dependencies between async operations without falling into callback hell or complex Promise chaining."}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"What are some best practices for using await blocks in Svelte applications?","answer":"When working with await blocks in Svelte, there are several best practices that can help you write more maintainable and performant code:\n\n**1. Move Promise creation to the script section:**\n\nInstead of creating Promises directly in the await block, define them in your script section:\n\n```svelte\n<!-- Good -->\n<script>\n  const dataPromise = fetchData();\n</script>\n\n{#await dataPromise}\n  <p>Loading...</p>\n{:then data}\n  <DisplayData {data} />\n{/await}\n\n<!-- Avoid -->\n{#await fetchData()}\n  <p>Loading...</p>\n{:then data}\n  <DisplayData {data} />\n{/await}\n```\n\nThis prevents creating new Promises on every render and makes debugging easier.\n\n**2. Use reactive declarations for dynamic Promises:**\n\nWhen your Promise depends on component props or state:\n\n```svelte\n<script>\n  export let userId;\n  \n  $: userPromise = fetchUser(userId);\n  \n  async function fetchUser(id) {\n    if (!id) return null;\n    const response = await fetch(`/api/users/${id}`);\n    return response.json();\n  }\n</script>\n\n{#await userPromise}\n  <p>Loading user...</p>\n{:then user}\n  {#if user}\n    <UserProfile {user} />\n  {:else}\n    <p>No user selected</p>\n  {/if}\n{:catch error}\n  <p>Error: {error.message}</p>\n{/await}\n```\n\n**3. Provide meaningful loading states:**\n\nDon't just show \"Loading...\" - create informative and visually appealing loading states:\n\n```svelte\n{#await userPromise}\n  <div class=\"user-skeleton\">\n    <div class=\"avatar-placeholder pulse\"></div>\n    <div class=\"name-placeholder pulse\"></div>\n    <div class=\"bio-placeholder pulse\"></div>\n  </div>\n{:then user}\n  <UserProfile {user} />\n{/await}\n```\n\n**4. Handle empty or null states appropriately:**\n\n```svelte\n{#await dataPromise}\n  <LoadingSpinner />\n{:then data}\n  {#if data && data.length > 0}\n    <DataTable {data} />\n  {:else}\n    <EmptyState message=\"No data available\" />\n  {/if}\n{/await}\n```\n\n**5. Use the simplified syntax when appropriate:**\n\nIf you don't need to show a loading state or error state, use the simplified syntax:\n\n```svelte\n<!-- If you only care about the result -->\n{#await dataPromise then data}\n  <DataDisplay {data} />\n{/await}\n\n<!-- If you only care about errors -->\n{#await riskyOperation catch error}\n  <ErrorNotification {error} />\n{/await}\n```\n\n**6. Consider caching for frequently accessed data:**\n\n```svelte\n<script>\n  import { writable } from 'svelte/store';\n  \n  // Cache for user data\n  const userCache = writable(new Map());\n  \n  async function fetchUser(id) {\n    // Check cache first\n    if ($userCache.has(id)) {\n      return $userCache.get(id);\n    }\n    \n    // Fetch and cache\n    const response = await fetch(`/api/users/${id}`);\n    const userData = await response.json();\n    userCache.update(cache => {\n      cache.set(id, userData);\n      return cache;\n    });\n    \n    return userData;\n  }\n  \n  export let userId;\n  $: userPromise = fetchUser(userId);\n</script>\n\n{#await userPromise}\n  <UserSkeleton />\n{:then user}\n  <UserProfile {user} />\n{/await}\n```\n\n**7. For dynamic imports, use the shortened form with destructuring:**\n\n```svelte\n{#await import('./HeavyComponent.svelte') then { default: Component }}\n  <Component />\n{/await}\n```\n\n**8. Handle errors gracefully with recovery options:**\n\n```svelte\n<script>\n  let dataPromise = fetchData();\n  \n  function retryFetch() {\n    dataPromise = fetchData();\n  }\n</script>\n\n{#await dataPromise}\n  <LoadingIndicator />\n{:then data}\n  <DataDisplay {data} />\n{:catch error}\n  <div class=\"error-container\">\n    <p>Failed to load data: {error.message}</p>\n    <button on:click={retryFetch}>Retry</button>\n  </div>\n{/await}\n```\n\nFollowing these best practices will help you create more robust and user-friendly applications when working with asynchronous operations in Svelte."}
{"source":"docs/svelte/03-template-syntax/05-await.md","question":"How do await blocks compare to other approaches for handling asynchronous operations in Svelte or other frameworks?","answer":"Await blocks in Svelte offer a unique and declarative approach to handling asynchronous operations compared to other methods in Svelte or other frameworks. Let's compare them:\n\n**1. Await Blocks vs. Manual State Management in Svelte**\n\nWith await blocks:\n```svelte\n<script>\n  const dataPromise = fetchData();\n</script>\n\n{#await dataPromise}\n  <p>Loading...</p>\n{:then data}\n  <DataDisplay {data} />\n{:catch error}\n  <p>Error: {error.message}</p>\n{/await}\n```\n\nWith manual state management:\n```svelte\n<script>\n  let loading = true;\n  let data = null;\n  let error = null;\n  \n  fetchData()\n    .then(result => {\n      data = result;\n      loading = false;\n    })\n    .catch(err => {\n      error = err;\n      loading = false;\n    });\n</script>\n\n{#if loading}\n  <p>Loading...</p>\n{:else if error}\n  <p>Error: {error.message}</p>\n{:else}\n  <DataDisplay {data} />\n{/if}\n```\n\nThe await block approach is more concise, less prone to state management bugs, and more declarative.\n\n**2. Svelte Await Blocks vs. React Suspense/useEffect**\n\nReact with useEffect:\n```jsx\nfunction DataComponent() {\n  const [loading, setLoading] = useState(true);\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    fetchData()\n      .then(result => {\n        setData(result);\n        setLoading(false);\n      })\n      .catch(err => {\n        setError(err);\n        setLoading(false);\n      });\n  }, []);\n  \n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error: {error.message}</p>;\n  return <DataDisplay data={data} />;\n}\n```\n\nReact with Suspense (still evolving):\n```jsx\n// Data fetching implementation with suspense support\nconst resource = createResource(fetchData);\n\nfunction DataComponent() {\n  try {\n    const data = resource.read();\n    return <DataDisplay data={data} />;\n  } catch (error) {\n    if (error instanceof Promise) {\n      throw error; // Let Suspense handle the loading state\n    }\n    return <p>Error: {error.message}</p>;\n  }\n}\n\n// Usage\n<Suspense fallback={<p>Loading...</p>}>\n  <DataComponent />\n</Suspense>\n```\n\nSvelte's await blocks provide a more integrated solution that doesn't require external libraries or complex patterns.\n\n**3. Svelte Await Blocks vs. Vue's Suspense**\n\nVue 3 with Suspense:\n```vue\n<template>\n  <Suspense>\n    <template #default>\n      <AsyncComponent />\n    </template>\n    <template #fallback>\n      <p>Loading...</p>\n    </template>\n  </Suspense>\n</template>\n```\n\nWhere AsyncComponent uses async setup:\n```vue\n<script setup>\nconst data = await fetchData();\n</script>\n\n<template>\n  <DataDisplay :data=\"data\" />\n</template>\n```\n\nVue's approach is also declarative but requires wrapping components in a Suspense component, whereas Svelte's await blocks can be used directly in templates.\n\n**4. Svelte Await Blocks vs. Angular's Async Pipe**\n\nAngular:\n```html\n<ng-container *ngIf=\"dataObservable$ | async as data; else loading\">\n  <app-data-display [data]=\"data\"></app-data-display>\n</ng-container>\n\n<ng-template #loading>\n  <p>Loading...</p>\n</ng-template>\n```\n\nAngular's approach is tied to its Observable pattern, while Svelte works directly with Promises.\n\n**5. Benefits of Svelte's Await Blocks:**\n\n- **Declarative:** Clearly expresses the three states of a Promise\n- **Concise:** Minimal boilerplate compared to manual state management\n- **Composable:** Can be nested and combined with other control flow statements\n- **Built-in:** No need for external libraries or complex patterns\n- **SSR-friendly:** Works well with server-side rendering\n- **Simplified variations:** Can omit branches you don't need\n\n**6. Limitations of Svelte's Await Blocks:**\n\n- Only works with Promises, not with other async patterns like Observables\n- No built-in caching or deduplication of requests\n- No built-in way to handle race conditions between multiple Promises\n- Limited control over timing of state transitions\n\n**7. When to Use Each Approach:**\n\n- **Use await blocks when:** You want a clear, declarative way to handle all states of a Promise directly in your template.\n- **Use manual state management when:** You need more control over the timing of state transitions or need to coordinate multiple async operations.\n- **Use a state management library when:** You need features like caching, deduplication, or complex dependency tracking.\n\nIn conclusion, Svelte's await blocks provide one of the most elegant and straightforward approaches to handling asynchronous operations in UI development, making it easier to reason about async code and reducing the likelihood of state management bugs."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"What are snippets in Svelte 5 and how do they differ from the approach used in Svelte 4 for reusing markup?","answer":"Snippets in Svelte 5 are a way to create reusable chunks of markup inside components. They're declared using the `{#snippet name()}...{/snippet}` syntax and rendered with the `{@render name()}` tag.\n\nSnippets are a major improvement over Svelte 4's slot system. In Svelte 4, content was passed to components using slots, which had several limitations. Snippets are more powerful and flexible because:\n\n1. They can be declared anywhere inside a component\n2. They can reference values from their surrounding scope\n3. They can accept parameters\n4. They can reference themselves and other snippets (enabling recursion)\n5. They're treated as values that can be passed as props\n\nHere's a simple example of a snippet:\n\n```svelte\n{#snippet greeting(name, message = \"Welcome!\")}\n  <div class=\"greeting\">\n    <h2>Hello, {name}!</h2>\n    <p>{message}</p>\n  </div>\n{/snippet}\n\n{@render greeting(\"John\")}\n{@render greeting(\"Sarah\", \"Great to see you again!\")}\n```\n\nDue to these advantages, slots are deprecated in Svelte 5 in favor of snippets."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"How do you pass parameters to snippets and what are the rules for parameter handling?","answer":"Snippets can accept parameters, which are defined in parentheses after the snippet name. The parameters work similar to function parameters in JavaScript, with a few specific rules:\n\n```svelte\n{#snippet name(param1, param2, paramN)}...{/snippet}\n```\n\nRules for snippet parameters:\n1. You can have any number of parameters\n2. Parameters can have default values (e.g., `{#snippet greeting(name, message = \"Hello!\")}`)\n3. You can use destructuring in parameters (e.g., `{#snippet user({name, age})}`)\n4. Rest parameters (`...rest`) are NOT supported\n\nWhen rendering a snippet, you pass the arguments in the render tag:\n\n```svelte\n{#snippet userCard(user, showDetails = false)}\n  <div class=\"card\">\n    <h3>{user.name}</h3>\n    {#if showDetails}\n      <p>Age: {user.age}</p>\n      <p>Email: {user.email}</p>\n    {/if}\n  </div>\n{/snippet}\n\n<!-- Render with required parameter only -->\n{@render userCard(currentUser)}\n\n<!-- Render with all parameters -->\n{@render userCard(currentUser, true)}\n\n<!-- Example with destructuring -->\n{#snippet profile({name, bio, avatar})}\n  <div class=\"profile\">\n    <img src={avatar} alt={name} />\n    <h2>{name}</h2>\n    <p>{bio}</p>\n  </div>\n{/snippet}\n\n{@render profile(userData)}\n```\n\nThe parameters are accessible only within the snippet's scope, just like function parameters in JavaScript."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"How do snippet scopes work in Svelte 5, and how can snippets reference each other?","answer":"Snippet scoping in Svelte 5 follows lexical scoping rules, similar to JavaScript functions. Here's how it works:\n\n1. Snippets can be declared anywhere inside your component\n2. They can reference values declared outside themselves (in parent scopes)\n3. They are 'visible' to everything in the same lexical scope (siblings and children of those siblings)\n4. Snippets can reference themselves and each other, enabling recursive patterns\n\nFor example, snippets can access component variables:\n\n```svelte\n<script>\n  let count = 0;\n  let userName = \"Alice\";\n</script>\n\n{#snippet counter()}\n  <!-- Can access the count variable from parent scope -->\n  <div>Current count: {count}</div>\n  <button on:click={() => count++}>Increment</button>\n{/snippet}\n\n{#snippet greeting()}\n  <!-- Can access the userName variable from parent scope -->\n  <h2>Hello, {userName}!</h2>\n{/snippet}\n\n{@render counter()}\n{@render greeting()}\n```\n\nRegarding snippet visibility, consider this example:\n\n```svelte\n<div>\n  {#snippet parent()}\n    <h2>Parent snippet</h2>\n    \n    {#snippet child()}\n      <p>Child snippet</p>\n    {/snippet}\n\n    <!-- This works because child is in scope -->\n    {@render child()}\n  {/snippet}\n\n  <!-- This will error because child is not in scope here -->\n  {@render child()}\n</div>\n\n<!-- This will also error because parent is only in scope inside the div -->\n{@render parent()}\n```\n\nSnippets can reference each other, enabling powerful recursive patterns:\n\n```svelte\n{#snippet countdown(n)}\n  {#if n > 0}\n    <div>{n}...</div>\n    {@render countdown(n - 1)}\n  {:else}\n    <div>Blast off! ð</div>\n  {/if}\n{/snippet}\n\n{#snippet nestedList(items)}\n  <ul>\n    {#each items as item}\n      <li>\n        {item.name}\n        {#if item.children && item.children.length > 0}\n          {@render nestedList(item.children)}\n        {/if}\n      </li>\n    {/each}\n  </ul>\n{/snippet}\n\n{@render countdown(5)}\n{@render nestedList(menuItems)}\n```\n\nThis recursive capability is powerful for rendering nested data structures like trees, menus, and recursive UI components."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"How do you pass snippets to components in Svelte 5, and what are the different approaches for doing so?","answer":"In Svelte 5, snippets are values just like any other, which means they can be passed to components as props. There are several approaches to pass snippets to components:\n\n**Approach 1: Passing explicitly declared snippets as props**\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import DataTable from './DataTable.svelte';\n  \n  const users = [\n    { id: 1, name: 'Alice', role: 'Developer' },\n    { id: 2, name: 'Bob', role: 'Designer' }\n  ];\n</script>\n\n{#snippet header()}\n  <th>ID</th>\n  <th>Name</th>\n  <th>Role</th>\n{/snippet}\n\n{#snippet row(user)}\n  <td>{user.id}</td>\n  <td>{user.name}</td>\n  <td>{user.role}</td>\n{/snippet}\n\n<DataTable data={users} {header} {row} />\n```\n\n```svelte\n<!-- DataTable.svelte -->\n<script>\n  let { data, header, row } = $props();\n</script>\n\n<table>\n  <thead>\n    <tr>{@render header()}</tr>\n  </thead>\n  <tbody>\n    {#each data as item}\n      <tr>{@render row(item)}</tr>\n    {/each}\n  </tbody>\n</table>\n```\n\n**Approach 2: Declaring snippets directly inside component tags**\n\nSvelte 5 has a convenient shorthand: snippets declared directly inside a component implicitly become props on the component:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import DataTable from './DataTable.svelte';\n  \n  const users = [\n    { id: 1, name: 'Alice', role: 'Developer' },\n    { id: 2, name: 'Bob', role: 'Designer' }\n  ];\n</script>\n\n<DataTable data={users}>\n  {#snippet header()}\n    <th>ID</th>\n    <th>Name</th>\n    <th>Role</th>\n  {/snippet}\n\n  {#snippet row(user)}\n    <td>{user.id}</td>\n    <td>{user.name}</td>\n    <td>{user.role}</td>\n  {/snippet}\n</DataTable>\n```\n\nThe DataTable component remains the same as in the first example.\n\n**Approach 3: Using the implicit `children` snippet**\n\nContent inside component tags that is not a snippet declaration implicitly becomes part of the `children` snippet:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import Button from './Button.svelte';\n</script>\n\n<Button>Click me!</Button>\n```\n\n```svelte\n<!-- Button.svelte -->\n<script>\n  let { children } = $props();\n</script>\n\n<button class=\"fancy-button\">\n  {@render children()}\n</button>\n```\n\nThis renders as: `<button class=\"fancy-button\">Click me!</button>`\n\n**Handling optional snippets**\n\nYou can handle cases where a snippet might not be provided using optional chaining or conditional rendering:\n\n```svelte\n<!-- Using optional chaining -->\n{@render header?.()}\n\n<!-- Using conditional rendering with fallback -->\n{#if footer}\n  {@render footer()}\n{:else}\n  <footer>Default footer content</footer>\n{/if}\n```\n\nThis flexibility makes snippets a powerful tool for creating composable and reusable UI components in Svelte 5."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"How do you type snippets in TypeScript when working with Svelte 5?","answer":"In Svelte 5, snippets implement the `Snippet` interface that can be imported from 'svelte'. This allows you to properly type your snippet props when using TypeScript.\n\nHere's how to type snippets in a Svelte 5 component:\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n\n  // Basic snippet typing\n  interface Props {\n    header: Snippet;              // Snippet with no parameters\n    row: Snippet<[any]>;          // Snippet with one parameter\n    footer: Snippet<[number, string]>; // Snippet with multiple parameters\n  }\n\n  let { header, row, footer }: Props = $props();\n</script>\n```\n\nNote that the type argument provided to `Snippet` is a tuple, since snippets can have multiple parameters.\n\nFor more specific typing, you can define the exact types that your snippets should accept:\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n\n  interface User {\n    id: number;\n    name: string;\n    email: string;\n    role: string;\n  }\n\n  interface Props {\n    users: User[];\n    header: Snippet;\n    row: Snippet<[User]>;\n    detail: Snippet<[User, boolean]>;\n  }\n\n  let { users, header, row, detail }: Props = $props();\n</script>\n```\n\nYou can also use generics to ensure type consistency between your data and snippets:\n\n```svelte\n<script lang=\"ts\" generics=\"T\">\n  import type { Snippet } from 'svelte';\n\n  let {\n    data,\n    header,\n    row\n  }: {\n    data: T[];\n    header: Snippet;\n    row: Snippet<[T]>;\n  } = $props();\n</script>\n\n<table>\n  <thead>\n    <tr>{@render header()}</tr>\n  </thead>\n  <tbody>\n    {#each data as item}\n      <tr>{@render row(item)}</tr>\n    {/each}\n  </tbody>\n</table>\n```\n\nIn this example, the generic `T` ensures that the type of items in the `data` array matches the type expected by the `row` snippet.\n\nFor optional snippets, you can use the nullable type:\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n\n  interface Props {\n    data: any[];\n    header: Snippet;\n    row: Snippet<[any]>;\n    footer?: Snippet;  // Optional snippet\n  }\n\n  let { data, header, row, footer }: Props = $props();\n</script>\n\n<!-- Handle optional snippet -->\n{#if footer}\n  {@render footer()}\n{/if}\n```\n\nThese typing capabilities ensure type safety when working with snippets in Svelte 5 applications."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"How can snippets help refactor duplicative code in Svelte components, and what are some practical examples?","answer":"Snippets in Svelte 5 are excellent for refactoring duplicative code within components. They allow you to extract common UI patterns into reusable chunks, improving maintainability and readability.\n\nLet's look at some practical examples:\n\n**Example 1: Refactoring repeated image handling**\n\nBefore (duplicative code):\n```svelte\n{#each images as image}\n  {#if image.href}\n    <a href={image.href}>\n      <figure>\n        <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n        <figcaption>{image.caption}</figcaption>\n      </figure>\n    </a>\n  {:else}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/if}\n{/each}\n```\n\nAfter (with snippet):\n```svelte\n{#snippet figure(image)}\n  <figure>\n    <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n    <figcaption>{image.caption}</figcaption>\n  </figure>\n{/snippet}\n\n{#each images as image}\n  {#if image.href}\n    <a href={image.href}>\n      {@render figure(image)}\n    </a>\n  {:else}\n    {@render figure(image)}\n  {/if}\n{/each}\n```\n\n**Example 2: Form input fields with labels and validation**\n\nBefore:\n```svelte\n<div class=\"field\">\n  <label for=\"name\">Name</label>\n  <input id=\"name\" bind:value={name} required />\n  {#if errors.name}\n    <div class=\"error\">{errors.name}</div>\n  {/if}\n</div>\n\n<div class=\"field\">\n  <label for=\"email\">Email</label>\n  <input id=\"email\" type=\"email\" bind:value={email} required />\n  {#if errors.email}\n    <div class=\"error\">{errors.email}</div>\n  {/if}\n</div>\n\n<div class=\"field\">\n  <label for=\"password\">Password</label>\n  <input id=\"password\" type=\"password\" bind:value={password} required />\n  {#if errors.password}\n    <div class=\"error\">{errors.password}</div>\n  {/if}\n</div>\n```\n\nAfter:\n```svelte\n{#snippet formField(id, label, type = \"text\", value, error)}\n  <div class=\"field\">\n    <label for={id}>{label}</label>\n    <input \n      {id} \n      {type} \n      bind:value={value} \n      required \n    />\n    {#if error}\n      <div class=\"error\">{error}</div>\n    {/if}\n  </div>\n{/snippet}\n\n{@render formField(\"name\", \"Name\", \"text\", name, errors.name)}\n{@render formField(\"email\", \"Email\", \"email\", email, errors.email)}\n{@render formField(\"password\", \"Password\", \"password\", password, errors.password)}\n```\n\n**Example 3: Card UI components**\n\nBefore:\n```svelte\n<div class=\"card\">\n  <div class=\"card-header\">\n    <h3>User Profile</h3>\n    <button class=\"close-button\">Ã</button>\n  </div>\n  <div class=\"card-body\">\n    <p>User details here...</p>\n  </div>\n  <div class=\"card-footer\">\n    <button class=\"primary\">Save</button>\n    <button class=\"secondary\">Cancel</button>\n  </div>\n</div>\n\n<div class=\"card\">\n  <div class=\"card-header\">\n    <h3>Settings</h3>\n    <button class=\"close-button\">Ã</button>\n  </div>\n  <div class=\"card-body\">\n    <p>Settings details here...</p>\n  </div>\n  <div class=\"card-footer\">\n    <button class=\"primary\">Apply</button>\n    <button class=\"secondary\">Reset</button>\n  </div>\n</div>\n```\n\nAfter:\n```svelte\n{#snippet card(title, onClose)}\n  <div class=\"card\">\n    <div class=\"card-header\">\n      <h3>{title}</h3>\n      <button class=\"close-button\" on:click={onClose}>Ã</button>\n    </div>\n    <div class=\"card-body\">\n      <slot />\n    </div>\n    <div class=\"card-footer\">\n      <slot name=\"footer\" />\n    </div>\n  </div>\n{/snippet}\n\n{#snippet userCard()}\n  {@render card(\"User Profile\", () => closeUserProfile())}\n    <p>User details here...</p>\n    \n    {#snippet footer()}\n      <button class=\"primary\">Save</button>\n      <button class=\"secondary\">Cancel</button>\n    {/snippet}\n  {@/render}\n{/snippet}\n\n{#snippet settingsCard()}\n  {@render card(\"Settings\", () => closeSettings())}\n    <p>Settings details here...</p>\n    \n    {#snippet footer()}\n      <button class=\"primary\">Apply</button>\n      <button class=\"secondary\">Reset</button>\n    {/snippet}\n  {@/render}\n{/snippet}\n\n{@render userCard()}\n{@render settingsCard()}\n```\n\n**Example 4: Data visualization components**\n\n```svelte\n{#snippet dataPoint(value, label, color)}\n  <div class=\"data-point\" style=\"background-color: {color}\">\n    <span class=\"value\">{value}</span>\n    <span class=\"label\">{label}</span>\n  </div>\n{/snippet}\n\n<div class=\"chart\">\n  {@render dataPoint(42, \"Users\", \"#ff6b6b\")}\n  {@render dataPoint(18, \"Active\", \"#48dbfb\")}\n  {@render dataPoint(7, \"New\", \"#1dd1a1\")}\n</div>\n```\n\nThese examples demonstrate how snippets can significantly reduce code duplication, improve maintainability, and create more modular component structures in Svelte 5 applications."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"How can you create recursive UI structures using snippets in Svelte 5?","answer":"Recursive UI structures are a perfect use case for snippets in Svelte 5. Since snippets can reference themselves, you can create elegant solutions for rendering nested data structures like trees, menus, file systems, or comment threads.\n\nHere are several examples of recursive UI patterns using snippets:\n\n**Example 1: Nested Comment Thread**\n\n```svelte\n<script>\n  const comments = [\n    {\n      id: 1,\n      author: \"Alice\",\n      text: \"Great article!\",\n      replies: [\n        {\n          id: 2,\n          author: \"Bob\",\n          text: \"I agree!\",\n          replies: []\n        },\n        {\n          id: 3,\n          author: \"Charlie\",\n          text: \"Thanks for sharing.\",\n          replies: [\n            {\n              id: 4,\n              author: \"Alice\",\n              text: \"You're welcome!\",\n              replies: []\n            }\n          ]\n        }\n      ]\n    },\n    {\n      id: 5,\n      author: \"Dave\",\n      text: \"Interesting perspective.\",\n      replies: []\n    }\n  ];\n</script>\n\n{#snippet commentThread(comments, depth = 0)}\n  <ul class=\"comments\" style=\"margin-left: {depth * 20}px\">\n    {#each comments as comment}\n      <li class=\"comment\">\n        <div class=\"comment-header\">\n          <strong>{comment.author}</strong>\n        </div>\n        <div class=\"comment-body\">\n          {comment.text}\n        </div>\n        {#if comment.replies.length > 0}\n          {@render commentThread(comment.replies, depth + 1)}\n        {/if}\n      </li>\n    {/each}\n  </ul>\n{/snippet}\n\n<div class=\"comment-section\">\n  <h2>Comments</h2>\n  {@render commentThread(comments)}\n</div>\n```\n\n**Example 2: File System Explorer**\n\n```svelte\n<script>\n  const fileSystem = [\n    {\n      name: \"Documents\",\n      type: \"folder\",\n      children: [\n        { name: \"resume.pdf\", type: \"file\" },\n        { \n          name: \"Projects\",\n          type: \"folder\",\n          children: [\n            { name: \"project1.docx\", type: \"file\" },\n            { name: \"project2.docx\", type: \"file\" }\n          ]\n        }\n      ]\n    },\n    {\n      name: \"Pictures\",\n      type: \"folder\",\n      children: [\n        { name: \"vacation.jpg\", type: \"file\" },\n        { name: \"family.jpg\", type: \"file\" }\n      ]\n    },\n    { name: \"notes.txt\", type: \"file\" }\n  ];\n</script>\n\n{#snippet fileExplorer(items, level = 0)}\n  <ul class=\"file-list\" style=\"padding-left: {level * 20}px\">\n    {#each items as item}\n      <li>\n        {#if item.type === 'folder'}\n          <span class=\"folder\">ð {item.name}</span>\n          {#if item.children && item.children.length > 0}\n            {@render fileExplorer(item.children, level + 1)}\n          {/if}\n        {:else}\n          <span class=\"file\">ð {item.name}</span>\n        {/if}\n      </li>\n    {/each}\n  </ul>\n{/snippet}\n\n<div class=\"file-explorer\">\n  <h2>File Explorer</h2>\n  {@render fileExplorer(fileSystem)}\n</div>\n```\n\n**Example 3: Recursive Countdown**\n\n```svelte\n{#snippet countdown(n)}\n  {#if n > 0}\n    <div class=\"countdown-item\">\n      {n}\n      {@render countdown(n - 1)}\n    </div>\n  {:else}\n    <div class=\"countdown-complete\">ð Blast off!</div>\n  {/if}\n{/snippet}\n\n<div class=\"countdown-container\">\n  {@render countdown(5)}\n</div>\n```\n\n**Example 4: Nested Menu Structure**\n\n```svelte\n<script>\n  const menu = [\n    {\n      name: \"Home\",\n      url: \"/\"\n    },\n    {\n      name: \"Products\",\n      children: [\n        { name: \"Hardware\", url: \"/products/hardware\" },\n        { \n          name: \"Software\", \n          children: [\n            { name: \"Desktop\", url: \"/products/software/desktop\" },\n            { name: \"Mobile\", url: \"/products/software/mobile\" }\n          ]\n        }\n      ]\n    },\n    {\n      name: \"About\",\n      url: \"/about\"\n    }\n  ];\n</script>\n\n{#snippet renderMenu(items, isSubmenu = false)}\n  <ul class={isSubmenu ? 'submenu' : 'main-menu'}>\n    {#each items as item}\n      <li>\n        {#if item.url}\n          <a href={item.url}>{item.name}</a>\n        {:else}\n          <span class=\"dropdown\">{item.name}</span>\n          {#if item.children}\n            {@render renderMenu(item.children, true)}\n          {/if}\n        {/if}\n      </li>\n    {/each}\n  </ul>\n{/snippet}\n\n<nav>\n  {@render renderMenu(menu)}\n</nav>\n```\n\n**Example 5: Tree View Component with Toggle Functionality**\n\n```svelte\n<script>\n  import { writable } from 'svelte/store';\n  \n  const expandedNodes = writable({});\n  \n  function toggleNode(id) {\n    expandedNodes.update(nodes => ({\n      ...nodes,\n      [id]: !nodes[id]\n    }));\n  }\n  \n  const treeData = {\n    id: \"root\",\n    name: \"Root\",\n    children: [\n      {\n        id: \"node1\",\n        name: \"Node 1\",\n        children: [\n          { id: \"node1-1\", name: \"Node 1.1\" },\n          { id: \"node1-2\", name: \"Node 1.2\" }\n        ]\n      },\n      {\n        id: \"node2\",\n        name: \"Node 2\",\n        children: [\n          { id: \"node2-1\", name: \"Node 2.1\" }\n        ]\n      }\n    ]\n  };\n</script>\n\n{#snippet treeNode(node)}\n  <div class=\"tree-node\">\n    {#if node.children && node.children.length > 0}\n      <button class=\"toggle\" on:click={() => toggleNode(node.id)}>\n        {$expandedNodes[node.id] ? 'â¼' : 'âº'}\n      </button>\n    {:else}\n      <span class=\"spacer\">â¢</span>\n    {/if}\n    \n    <span class=\"node-name\">{node.name}</span>\n    \n    {#if node.children && node.children.length > 0 && $expandedNodes[node.id]}\n      <div class=\"children\">\n        {#each node.children as child}\n          {@render treeNode(child)}\n        {/each}\n      </div>\n    {/if}\n  </div>\n{/snippet}\n\n<div class=\"tree-view\">\n  {@render treeNode(treeData)}\n</div>\n\n<style>\n  .children {\n    margin-left: 20px;\n  }\n  .tree-node {\n    margin: 5px 0;\n  }\n  .toggle {\n    background: none;\n    border: none;\n    cursor: pointer;\n  }\n</style>\n```\n\nThese examples showcase how snippets can elegantly handle recursive UI patterns in Svelte 5, making complex nested structures more maintainable and easier to implement."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"How do you handle optional snippets in Svelte 5 components, and what are the different approaches for providing fallback content?","answer":"In Svelte 5, you often need to handle cases where snippets might not be provided by the parent component. There are several approaches for working with optional snippets and providing fallback content.\n\n**Approach 1: Using optional chaining operator**\n\nThe simplest approach is to use optional chaining (`?.`) when rendering a snippet that might not exist:\n\n```svelte\n<script>\n  let { header, body, footer } = $props();\n</script>\n\n<div class=\"card\">\n  <div class=\"card-header\">\n    {@render header?.()}\n  </div>\n  \n  <div class=\"card-body\">\n    {@render body()}\n  </div>\n  \n  <div class=\"card-footer\">\n    {@render footer?.()}\n  </div>\n</div>\n```\n\nIn this example, if `header` or `footer` are not provided, nothing will be rendered in their respective containers.\n\n**Approach 2: Using conditional rendering with `#if` blocks**\n\nFor more control, including the ability to provide fallback content, use conditional rendering:\n\n```svelte\n<script>\n  let { header, body, footer } = $props();\n</script>\n\n<div class=\"card\">\n  <div class=\"card-header\">\n    {#if header}\n      {@render header()}\n    {:else}\n      <h3>Default Header</h3>\n    {/if}\n  </div>\n  \n  <div class=\"card-body\">\n    {@render body()}\n  </div>\n  \n  <div class=\"card-footer\">\n    {#if footer}\n      {@render footer()}\n    {:else}\n      <div class=\"default-footer\">\n        <button>Close</button>\n      </div>\n    {/if}\n  </div>\n</div>\n```\n\n**Approach 3: Using default props**\n\nYou can provide default snippets as part of your component's props:\n\n```svelte\n<script>\n  let { \n    header = () => ({\n      t: () => `<h3>Default Header</h3>`\n    }),\n    body,\n    footer = () => ({\n      t: () => `<div class=\"default-footer\"><button>Close</button></div>`\n    })\n  } = $props();\n</script>\n\n<div class=\"card\">\n  <div class=\"card-header\">\n    {@render header()}\n  </div>\n  \n  <div class=\"card-body\">\n    {@render body()}\n  </div>\n  \n  <div class=\"card-footer\">\n    {@render footer()}\n  </div>\n</div>\n```\n\nHowever, this approach is more complex and the previous approaches are generally preferred.\n\n**Approach 4: Combining approaches for complex components**\n\nFor more complex components, you can combine these approaches:\n\n```svelte\n<script>\n  // TypeScript example\n  import type { Snippet } from 'svelte';\n  \n  interface TableProps {\n    data: any[];\n    header?: Snippet;\n    row: Snippet<[any, number]>;\n    footer?: Snippet;\n    emptyState?: Snippet;\n  }\n  \n  let { data = [], header, row, footer, emptyState } = $props<TableProps>();\n</script>\n\n<table class=\"data-table\">\n  {#if header}\n    <thead>\n      <tr>{@render header()}</tr>\n    </thead>\n  {/if}\n  \n  <tbody>\n    {#if data.length > 0}\n      {#each data as item, index}\n        <tr>{@render row(item, index)}</tr>\n      {/each}\n    {:else if emptyState}\n      <tr>\n        <td colspan=\"100%\">\n          {@render emptyState()}\n        </td>\n      </tr>\n    {:else}\n      <tr>\n        <td colspan=\"100%\" class=\"empty-message\">\n          No data available\n        </td>\n      </tr>\n    {/if}\n  </tbody>\n  \n  {#if footer}\n    <tfoot>\n      <tr>{@render footer()}</tr>\n    </tfoot>\n  {/if}\n</table>\n```\n\n**Approach 5: Using snippet composition**\n\nYou can also compose snippets to provide default content that can be overridden:\n\n```svelte\n<script>\n  let { content, title = defaultTitle } = $props();\n  \n  // Define a default snippet\n  function defaultTitle() {\n    return {\n      t: () => `<h2>Default Title</h2>`\n    };\n  }\n</script>\n\n{#snippet layout()}\n  <div class=\"container\">\n    <header>\n      {@render title()}\n    </header>\n    <main>\n      {@render content()}\n    </main>\n  </div>\n{/snippet}\n\n{@render layout()}\n```\n\nWhen using optional snippets, it's also good practice to document which snippets are required and which are optional, especially in larger applications with many components:\n\n```svelte\n<script>\n  /**\n   * @component\n   * @prop {array} data - The data array to render\n   * @prop {Snippet} row - Required snippet for rendering each row (receives item and index)\n   * @prop {Snippet} [header] - Optional snippet for rendering the table header\n   * @prop {Snippet} [footer] - Optional snippet for rendering the table footer\n   * @prop {Snippet} [emptyState] - Optional snippet for rendering when data is empty\n   */\n  let { data = [], header, row, footer, emptyState } = $props();\n</script>\n```\n\nThese approaches provide flexible ways to handle optional snippets in Svelte 5 components, allowing for better component composition and reusability."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"How can you export snippets from a component for use in other components, and what are the limitations?","answer":"In Svelte 5 (specifically version 5.5.0 or newer), you can export snippets declared at the top level of a `.svelte` file from a `<script module>` section for use in other components. This feature enhances code reusability by allowing you to define snippets once and use them across multiple components.\n\nHere's how to export snippets:\n\n```svelte\n<!-- Button.svelte -->\n<script module>\n  // Export the snippets for use in other components\n  export { primaryButton, secondaryButton };\n</script>\n\n{#snippet primaryButton(text, onClick)}\n  <button \n    class=\"btn btn-primary\" \n    on:click={onClick}\n  >\n    {text}\n  </button>\n{/snippet}\n\n{#snippet secondaryButton(text, onClick)}\n  <button \n    class=\"btn btn-secondary\" \n    on:click={onClick}\n  >\n    {text}\n  </button>\n{/snippet}\n```\n\nThen, in another component, you can import and use these snippets:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import { primaryButton, secondaryButton } from './Button.svelte';\n  \n  function handleSave() {\n    console.log('Saving...');\n  }\n  \n  function handleCancel() {\n    console.log('Cancelled');\n  }\n</script>\n\n<div class=\"actions\">\n  {@render primaryButton('Save', handleSave)}\n  {@render secondaryButton('Cancel', handleCancel)}\n</div>\n```\n\n**Important Limitations:**\n\n1. **Scope Restrictions**: Exported snippets cannot reference any declarations in a non-module `<script>` section of the component, whether directly or indirectly (via other snippets). This is because the module script runs once when the component is first imported, while the instance script runs for each component instance.\n\n2. **Version Requirement**: This feature requires Svelte 5.5.0 or newer.\n\n**Example with limitation:**\n\nThis won't work:\n\n```svelte\n<!-- Won't work - trying to access instance variables -->\n<script>\n  let theme = 'dark';\n</script>\n\n<script module>\n  export { themedButton };\n</script>\n\n{#snippet themedButton(text)}\n  <!-- Error: Cannot access 'theme' from module script -->\n  <button class=\"btn-{theme}\">{text}</button>\n{/snippet}\n```\n\n**Workarounds for the limitations:**\n\n1. **Pass all dependencies as parameters**:\n\n```svelte\n<!-- Button.svelte -->\n<script module>\n  export { themedButton };\n</script>\n\n{#snippet themedButton(text, theme)}\n  <button class=\"btn-{theme}\">{text}</button>\n{/snippet}\n```\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import { themedButton } from './Button.svelte';\n  let theme = 'dark';\n</script>\n\n{@render themedButton('Click me', theme)}\n```\n\n2. **Use component composition instead**:\n\nFor more complex cases where snippets need access to component state, consider creating dedicated components instead of exportable snippets:\n\n```svelte\n<!-- ThemedButton.svelte -->\n<script>\n  let { text, theme } = $props();\n</script>\n\n<button class=\"btn-{theme}\">{text}</button>\n```\n\n**Practical Example: Form Field Library**\n\n```svelte\n<!-- FormFields.svelte -->\n<script module>\n  export { textField, numberField, emailField, passwordField };\n</script>\n\n{#snippet textField(id, label, value, onChange, error = null)}\n  <div class=\"form-field\">\n    <label for={id}>{label}</label>\n    <input \n      {id} \n      type=\"text\" \n      value={value} \n      on:input={onChange} \n    />\n    {#if error}\n      <div class=\"error\">{error}</div>\n    {/if}\n  </div>\n{/snippet}\n\n{#snippet numberField(id, label, value, onChange, error = null)}\n  <div class=\"form-field\">\n    <label for={id}>{label}</label>\n    <input \n      {id} \n      type=\"number\" \n      value={value} \n      on:input={onChange} \n    />\n    {#if error}\n      <div class=\"error\">{error}</div>\n    {/if}\n  </div>\n{/snippet}\n\n{#snippet emailField(id, label, value, onChange, error = null)}\n  <div class=\"form-field\">\n    <label for={id}>{label}</label>\n    <input \n      {id} \n      type=\"email\" \n      value={value} \n      on:input={onChange} \n    />\n    {#if error}\n      <div class=\"error\">{error}</div>\n    {/if}\n  </div>\n{/snippet}\n\n{#snippet passwordField(id, label, value, onChange, error = null)}\n  <div class=\"form-field\">\n    <label for={id}>{label}</label>\n    <input \n      {id} \n      type=\"password\" \n      value={value} \n      on:input={onChange} \n    />\n    {#if error}\n      <div class=\"error\">{error}</div>\n    {/if}\n  </div>\n{/snippet}\n```\n\nThen in your form component:\n\n```svelte\n<!-- LoginForm.svelte -->\n<script>\n  import { emailField, passwordField } from './FormFields.svelte';\n  \n  let email = '';\n  let password = '';\n  let errors = {};\n  \n  function handleEmailChange(e) {\n    email = e.target.value;\n  }\n  \n  function handlePasswordChange(e) {\n    password = e.target.value;\n  }\n  \n  function validateForm() {\n    errors = {};\n    if (!email) errors.email = 'Email is required';\n    if (!password) errors.password = 'Password is required';\n    return Object.keys(errors).length === 0;\n  }\n  \n  function handleSubmit() {\n    if (validateForm()) {\n      console.log('Submitting:', { email, password });\n    }\n  }\n</script>\n\n<form on:submit|preventDefault={handleSubmit}>\n  {@render emailField(\n    'email',\n    'Email Address',\n    email,\n    handleEmailChange,\n    errors.email\n  )}\n  \n  {@render passwordField(\n    'password',\n    'Password',\n    password,\n    handlePasswordChange,\n    errors.password\n  )}\n  \n  <button type=\"submit\">Log In</button>\n</form>\n```\n\nThis approach allows you to create reusable UI libraries with consistent styling and behavior while maintaining proper separation of concerns."}
{"source":"docs/svelte/03-template-syntax/06-snippet.md","question":"How do snippets compare to slots in Svelte 4, and why are slots deprecated in Svelte 5?","answer":"Snippets in Svelte 5 represent a significant evolution from slots in Svelte 4. Understanding the differences helps explain why slots are deprecated in Svelte 5 in favor of snippets.\n\n**Slots in Svelte 4:**\n\nIn Svelte 4, slots were the primary mechanism for content projection - passing content from a parent component to a child component:\n\n```svelte\n<!-- Child.svelte (Svelte 4) -->\n<div class=\"container\">\n  <header>\n    <slot name=\"header\">Default header</slot>\n  </header>\n  <main>\n    <slot>Default content</slot>\n  </main>\n  <footer>\n    <slot name=\"footer\">Default footer</slot>\n  </footer>\n</div>\n```\n\n```svelte\n<!-- Parent.svelte (Svelte 4) -->\n<Child>\n  <h1 slot=\"header\">Custom Header</h1>\n  <p>Main content goes here</p>\n  <div slot=\"footer\">Custom Footer</div>\n</Child>\n```\n\n**Snippets in Svelte 5:**\n\nSnippets offer a more powerful and flexible approach:\n\n```svelte\n<!-- Child.svelte (Svelte 5) -->\n<script>\n  let { header = defaultHeader, children, footer = defaultFooter } = $props();\n  \n  function defaultHeader() {\n    return {\n      t: () => `<h2>Default header</h2>`\n    };\n  }\n  \n  function defaultFooter() {\n    return {\n      t: () => `<div>Default footer</div>`\n    };\n  }\n</script>\n\n<div class=\"container\">\n  <header>\n    {@render header()}\n  </header>\n  <main>\n    {@render children()}\n  </main>\n  <footer>\n    {@render footer()}\n  </footer>\n</div>\n```\n\n```svelte\n<!-- Parent.svelte (Svelte 5) -->\n<Child>\n  {#snippet header()}\n    <h1>Custom Header</h1>\n  {/snippet}\n  \n  <p>Main content goes here</p>\n  \n  {#snippet footer()}\n    <div>Custom Footer</div>\n  {/snippet}\n</Child>\n```\n\n**Key Differences and Advantages of Snippets:**\n\n1. **Parameterization:**\n   - Slots: Cannot accept parameters. Content is static.\n   - Snippets: Can accept any number of parameters, making them dynamic and reusable.\n\n   ```svelte\n   <!-- With snippets -->\n   <Table>\n     {#snippet row(item, index)}\n       <td>{index + 1}</td>\n       <td>{item.name}</td>\n     {/snippet}\n   </Table>\n   ```\n\n2. **Scope Access:**\n   - Slots: Limited access to parent component scope.\n   - Snippets: Full access to the lexical scope where they're defined, including variables, functions, and stores.\n\n3. **Reusability:**\n   - Slots: Cannot be reused within the same component.\n   - Snippets: Can be reused multiple times within the same component.\n\n   ```svelte\n   {#snippet button(text)}\n     <button class=\"btn\">{text}</button>\n   {/snippet}\n   \n   {@render button(\"Save\")}\n   {@render button(\"Cancel\")}\n   {@render button(\"Delete\")}\n   ```\n\n4. **Composability:**\n   - Slots: Limited composability.\n   - Snippets: Can be composed together and can call other snippets, enabling complex patterns.\n\n   ```svelte\n   {#snippet header(title)}\n     <div class=\"header\">\n       <h1>{title}</h1>\n       {@render actions()}\n     </div>\n   {/snippet}\n   \n   {#snippet actions()}\n     <div class=\"actions\">\n       {@render button(\"New\")}\n       {@render button(\"Refresh\")}\n     </div>\n   {/snippet}\n   ```\n\n5. **Recursion:**\n   - Slots: Cannot easily handle recursive structures.\n   - Snippets: Support recursion, making them ideal for nested data structures.\n\n   ```svelte\n   {#snippet treeNode(node)}\n     <div>\n       {node.name}\n       {#if node.children?.length}\n         <ul>\n           {#each node.children as child}\n             <li>{@render treeNode(child)}</li>\n           {/each}\n         </ul>\n       {/if}\n     </div>\n   {/snippet}\n   ```\n\n6. **Exportability:**\n   - Slots: Cannot be exported for reuse in other components.\n   - Snippets: Can be exported and imported for use across components.\n\n7. **Type Safety:**\n   - Slots: Limited type safety in TypeScript.\n   - Snippets: Better TypeScript integration with the `Snippet` type.\n\n8. **First-class Values:**\n   - Slots: Not first-class values.\n   - Snippets: Are first-class values that can be passed as props, stored in variables, etc.\n\n9. **Conditional Rendering:**\n   - Slots: More cumbersome conditional rendering.\n   - Snippets: Easier to conditionally render with optional chaining or if blocks.\n\n**Why Slots are Deprecated in Svelte 5:**\n\nSlots are deprecated in Svelte 5 because snippets provide a superset of slot functionality with additional benefits:\n\n1. **More Powerful**: Snippets can do everything slots can do and more.\n2. **More Flexible**: The ability to pass parameters makes snippets more dynamic.\n3. **More Consistent**: Snippets provide a more consistent mental model that aligns with JavaScript functions.\n4. **Simpler API**: Snippets reduce the number of concepts developers need to learn.\n5. **Better Performance**: The new compilation strategy in Svelte 5 works better with snippets.\n\n**Migration from Slots to Snippets:**\n\nWhen migrating from Svelte 4 to Svelte 5, you'll need to convert slots to snippets:\n\nSvelte 4 (with slots):\n```svelte\n<!-- Component.svelte -->\n<div class=\"card\">\n  <div class=\"header\">\n    <slot name=\"header\">Default Header</slot>\n  </div>\n  <div class=\"body\">\n    <slot>Default Body</slot>\n  </div>\n  <div class=\"footer\">\n    <slot name=\"footer\">Default Footer</slot>\n  </div>\n</div>\n\n<!-- Usage -->\n<Component>\n  <h2 slot=\"header\">My Header</h2>\n  <p>My content</p>\n  <button slot=\"footer\">Close</button>\n</Component>\n```\n\nSvelte 5 (with snippets):\n```svelte\n<!-- Component.svelte -->\n<script>\n  let { header, children, footer } = $props();\n</script>\n\n<div class=\"card\">\n  <div class=\"header\">\n    {#if header}\n      {@render header()}\n    {:else}\n      Default Header\n    {/if}\n  </div>\n  <div class=\"body\">\n    {@render children()}\n  </div>\n  <div class=\"footer\">\n    {#if footer}\n      {@render footer()}\n    {:else}\n      Default Footer\n    {/if}\n  </div>\n</div>\n\n<!-- Usage -->\n<Component>\n  {#snippet header()}\n    <h2>My Header</h2>\n  {/snippet}\n  \n  <p>My content</p>\n  \n  {#snippet footer()}\n    <button>Close</button>\n  {/snippet}\n</Component>\n```\n\nIn conclusion, snippets represent a significant improvement over slots in almost every way, which is why slots are deprecated in Svelte 5. The transition to snippets may require some code changes when migrating from Svelte 4, but the benefits in terms of flexibility, reusability, and maintainability make it well worth the effort."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"What is the syntax for rendering a snippet in Svelte 5, and how does it differ from regular component inclusion?","answer":"In Svelte 5, snippets are rendered using the `{@render ...}` tag. This is different from regular component inclusion, which uses a component tag like `<MyComponent />`.\n\nThe `{@render ...}` tag is specifically designed to render snippets, which are reusable pieces of markup defined using the `{#snippet ...}` block.\n\nHere's an example of defining and rendering a snippet:\n\n```svelte\n{#snippet sum(a, b)}\n\t<p>{a} + {b} = {a + b}</p>\n{/snippet}\n\n{@render sum(1, 2)}\n{@render sum(3, 4)}\n{@render sum(5, 6)}\n```\n\nIn this example, we define a snippet called `sum` that takes two parameters (`a` and `b`), and then render it multiple times with different arguments. Each render call will output a paragraph with the sum calculation.\n\nUnlike components, snippets are defined within the same file where they are used, making them more suitable for template composition within a single component."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"How can you conditionally render different snippets in Svelte 5?","answer":"In Svelte 5, you can conditionally render different snippets by using a JavaScript expression within the `{@render ...}` tag. This allows you to dynamically choose which snippet to render based on certain conditions.\n\nFor example, you can use a ternary operator to select between different snippets:\n\n```svelte\n{#snippet coolSnippet()}\n  <div class=\"cool\">ð This is the cool snippet!</div>\n{/snippet}\n\n{#snippet lameSnippet()}\n  <div class=\"lame\">ð This is the lame snippet...</div>\n{/snippet}\n\n<button on:click={() => cool = !cool}>Toggle cool</button>\n\n{@render (cool ? coolSnippet : lameSnippet)()}\n```\n\nIn this example, we define two snippets (`coolSnippet` and `lameSnippet`), and then use a ternary expression to decide which one to render based on the value of the `cool` variable. When the button is clicked, it toggles the `cool` variable, which in turn changes which snippet is rendered.\n\nThis approach gives you flexibility to dynamically switch between different UI representations based on your application's state."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"How do you handle optional snippets in Svelte 5, and what happens if a snippet is undefined?","answer":"In Svelte 5, there are two main approaches to handle optional snippets (snippets that might be undefined):\n\n1. Using optional chaining:\n```svelte\n{@render children?.()}\n```\n\nThe optional chaining operator (`?.`) ensures that the snippet is only called if it exists. If `children` is undefined or null, the expression short-circuits and nothing is rendered, rather than throwing an error.\n\n2. Using conditional rendering with an `{#if ...}` block:\n```svelte\n{#if children}\n\t{@render children()}\n{:else}\n\t<p>fallback content</p>\n{/if}\n```\n\nThis approach gives you more control by allowing you to provide fallback content when the snippet is not available.\n\nThis is particularly useful when working with component props where a parent component might pass a snippet to a child component:\n\n```svelte\n<script>\n  // This prop might be undefined if not provided by the parent\n  export let headerContent = undefined;\n</script>\n\n<div class=\"card\">\n  <div class=\"card-header\">\n    {#if headerContent}\n      {@render headerContent()}\n    {:else}\n      <h3>Default Header</h3>\n    {/if}\n  </div>\n  <div class=\"card-body\">\n    <slot />\n  </div>\n</div>\n```\n\nIn this example, if `headerContent` is provided, it will be rendered; otherwise, a default header is shown."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"Can you pass parameters to snippets when rendering them? If so, how?","answer":"Yes, you can pass parameters to snippets when rendering them in Svelte 5. Snippets can be defined with parameters, similar to function parameters, and then those parameters can be provided when the snippet is rendered.\n\nHere's how it works:\n\n```svelte\n{#snippet userProfile(name, age, occupation)}\n  <div class=\"profile\">\n    <h2>{name}</h2>\n    <p>Age: {age}</p>\n    <p>Occupation: {occupation}</p>\n  </div>\n{/snippet}\n\n{@render userProfile(\"John Doe\", 32, \"Developer\")}\n{@render userProfile(\"Jane Smith\", 28, \"Designer\")}\n```\n\nIn this example, the `userProfile` snippet takes three parameters: `name`, `age`, and `occupation`. When rendering the snippet, we pass specific values for these parameters.\n\nYou can also use variables from your component's scope:\n\n```svelte\n<script>\n  let currentUser = {\n    name: \"Alice Johnson\",\n    age: 35,\n    occupation: \"Product Manager\"\n  };\n</script>\n\n{@render userProfile(currentUser.name, currentUser.age, currentUser.occupation)}\n```\n\nParameters make snippets highly reusable, allowing you to create template fragments that can adapt to different data inputs."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"How do snippets in Svelte 5 help with code organization and reusability compared to other approaches?","answer":"Snippets in Svelte 5 provide several advantages for code organization and reusability:\n\n1. **In-file reusability**: Snippets allow you to define reusable template fragments within the same component file, reducing the need to create separate components for small UI patterns.\n\n```svelte\n<script>\n  let items = [\n    { id: 1, name: 'Item 1', important: true },\n    { id: 2, name: 'Item 2', important: false },\n    { id: 3, name: 'Item 3', important: true }\n  ];\n</script>\n\n{#snippet itemRow(item)}\n  <tr class={item.important ? 'important' : ''}>\n    <td>{item.id}</td>\n    <td>{item.name}</td>\n    <td>\n      <button on:click={() => item.important = !item.important}>\n        Toggle Importance\n      </button>\n    </td>\n  </tr>\n{/snippet}\n\n<table>\n  <thead>\n    <tr>\n      <th>ID</th>\n      <th>Name</th>\n      <th>Actions</th>\n    </tr>\n  </thead>\n  <tbody>\n    {#each items as item (item.id)}\n      {@render itemRow(item)}\n    {/each}\n  </tbody>\n</table>\n```\n\n2. **Parameterization**: Snippets can accept parameters, making them adaptable to different contexts.\n\n3. **Simplified component composition**: For complex components, snippets offer a way to break down the template into logical parts without the overhead of creating multiple component files.\n\n4. **Better encapsulation**: Unlike extracted components, snippets have access to the component's scope, making state management simpler.\n\n5. **Reduced prop drilling**: Since snippets exist within the component, they have access to all variables in that scope without needing to pass them as props.\n\nCompared to alternatives:\n\n- **vs. Components**: Snippets are lighter-weight than full components and don't require separate files.\n- **vs. Functions returning HTML**: Snippets are more declarative and provide proper Svelte template syntax with reactivity.\n- **vs. `{#each}` blocks**: Snippets are more reusable across different parts of a component.\n- **vs. Slots**: Snippets are defined and used within a single component, whereas slots are for parent-child component communication.\n\nSnippets fill an important middle ground in the component composition spectrum, allowing for clean code organization without the overhead of creating many small components."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"What happens if you try to render a snippet with the wrong number of arguments in Svelte 5?","answer":"In Svelte 5, when you render a snippet with the wrong number of arguments, the behavior depends on whether you're providing too few or too many arguments:\n\n1. **Too few arguments**: Missing parameters will be `undefined` in the snippet, which might cause unexpected behavior or errors depending on how the snippet uses those parameters.\n\n2. **Too many arguments**: Extra arguments will simply be ignored.\n\nFor example, consider this snippet definition:\n\n```svelte\n{#snippet greeting(firstName, lastName)}\n  <p>Hello, {firstName} {lastName}!</p>\n{/snippet}\n\n<!-- Missing the lastName parameter -->\n{@render greeting(\"John\")}\n<!-- Output: \"Hello, John undefined!\" -->\n\n<!-- Extra parameter that will be ignored -->\n{@render greeting(\"John\", \"Doe\", \"Mr.\")}\n<!-- Output: \"Hello, John Doe!\" -->\n```\n\nTo avoid issues with undefined parameters, you can provide default values in your snippet definition:\n\n```svelte\n{#snippet greeting(firstName, lastName = \"Anonymous\")}\n  <p>Hello, {firstName} {lastName}!</p>\n{/snippet}\n\n{@render greeting(\"John\")}\n<!-- Output: \"Hello, John Anonymous!\" -->\n```\n\nYou can also use destructuring with default values for more complex parameter handling:\n\n```svelte\n{#snippet userCard({name, age, email = \"N/A\", phone = \"N/A\"})}\n  <div class=\"card\">\n    <h3>{name}, {age}</h3>\n    <p>Email: {email}</p>\n    <p>Phone: {phone}</p>\n  </div>\n{/snippet}\n\n{@render userCard({name: \"John\", age: 30})}\n<!-- Email and phone will use the default \"N/A\" values -->\n```\n\nIt's generally a good practice to handle potential undefined values within your snippets to make them more robust."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"How can you use the `{@render ...}` tag with dynamic expressions, and what are some practical use cases for this?","answer":"The `{@render ...}` tag in Svelte 5 can work with dynamic expressions, not just static snippet references. This enables powerful dynamic UI composition patterns.\n\nHere's how you can use dynamic expressions with `{@render ...}`:\n\n```svelte\n<script>\n  // A map of different visualization snippets\n  let visualizations = {\n    bar: (data) => {\n      // Return the bar chart snippet\n      return barChart(data);\n    },\n    pie: (data) => {\n      // Return the pie chart snippet\n      return pieChart(data);\n    },\n    line: (data) => {\n      // Return the line chart snippet\n      return lineChart(data);\n    }\n  };\n  \n  let selectedViz = 'bar';\n  let data = [10, 20, 30, 40, 50];\n  \n  // Define the snippets\n  function barChart(data) {\n    return {\n      render() {\n        return {\n          t: {\n            // Bar chart template definition\n          }\n        };\n      }\n    };\n  }\n  \n  function pieChart(data) {\n    // Similar to barChart\n  }\n  \n  function lineChart(data) {\n    // Similar to barChart\n  }\n</script>\n\n<select bind:value={selectedViz}>\n  <option value=\"bar\">Bar Chart</option>\n  <option value=\"pie\">Pie Chart</option>\n  <option value=\"line\">Line Chart</option>\n</select>\n\n<!-- Dynamically render the selected visualization -->\n{@render visualizations[selectedViz](data)}\n```\n\nPractical use cases for dynamic rendering include:\n\n1. **Component libraries**: Create a component that can render different variants based on a prop:\n\n```svelte\n<script>\n  export let variant = 'default';\n  \n  const variants = {\n    default: defaultSnippet,\n    compact: compactSnippet,\n    expanded: expandedSnippet\n  };\n</script>\n\n{@render variants[variant]()}\n```\n\n2. **Conditional rendering based on complex logic**:\n\n```svelte\n<script>\n  export let user;\n  \n  function determineUserView(user) {\n    if (!user) return guestView;\n    if (user.isAdmin) return adminView;\n    if (user.subscription === 'premium') return premiumView;\n    return regularView;\n  }\n</script>\n\n{@render determineUserView(user)()}\n```\n\n3. **Plugin systems**:\n\n```svelte\n<script>\n  export let plugins = [];\n  export let data;\n  \n  function renderPlugins(plugins, data) {\n    // Find the first plugin that can handle this data\n    const matchingPlugin = plugins.find(p => p.canHandle(data));\n    return matchingPlugin ? matchingPlugin.render : defaultRenderer;\n  }\n</script>\n\n{@render renderPlugins(plugins, data)(data)}\n```\n\n4. **A/B testing**:\n\n```svelte\n<script>\n  import { getTestVariant } from './ab-testing';\n  \n  const testVariants = {\n    A: variantA,\n    B: variantB\n  };\n  \n  const currentVariant = getTestVariant('button-test');\n</script>\n\n{@render testVariants[currentVariant]()}\n```\n\nThe ability to use dynamic expressions with `{@render ...}` makes Svelte 5 snippets a powerful tool for creating flexible, composable UIs."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"How do snippets and the `{@render ...}` tag interact with Svelte's reactivity system?","answer":"Snippets and the `{@render ...}` tag in Svelte 5 are fully integrated with Svelte's reactivity system. This means that reactive variables used within snippets will trigger updates to the DOM when they change, just like in regular Svelte templates.\n\nHere's how snippets interact with reactivity:\n\n1. **Reactive variables in snippets**:\n```svelte\n<script>\n  let count = 0;\n</script>\n\n{#snippet counter()}\n  <div>\n    <p>Count: {count}</p>\n    <button on:click={() => count++}>Increment</button>\n  </div>\n{/snippet}\n\n{@render counter()}\n```\n\nIn this example, when the `count` variable changes, the snippet will automatically re-render to reflect the new value.\n\n2. **Reactive parameters**:\n```svelte\n<script>\n  let name = \"World\";\n</script>\n\n{#snippet greeting(name)}\n  <h1>Hello, {name}!</h1>\n{/snippet}\n\n<input bind:value={name} />\n{@render greeting(name)}\n```\n\nWhen the `name` input changes, the rendered snippet will update accordingly.\n\n3. **Reactive expressions in the `{@render ...}` tag**:\n```svelte\n<script>\n  let showDetails = false;\n  \n  function toggleDetails() {\n    showDetails = !showDetails;\n  }\n</script>\n\n{#snippet summary()}\n  <div>Summary view</div>\n{/snippet}\n\n{#snippet details()}\n  <div>Detailed view with lots of information</div>\n{/snippet}\n\n<button on:click={toggleDetails}>\n  {showDetails ? 'Show Less' : 'Show More'}\n</button>\n\n{@render (showDetails ? details : summary)()}\n```\n\nThe snippet being rendered will reactively change when `showDetails` changes.\n\n4. **Reactive updates within conditionally rendered snippets**:\n```svelte\n<script>\n  let user = null;\n  \n  // Simulate fetching a user\n  setTimeout(() => {\n    user = { name: 'Alice', role: 'Admin' };\n  }, 1000);\n</script>\n\n{#snippet userProfile(user)}\n  <div>\n    <h2>{user.name}</h2>\n    <p>Role: {user.role}</p>\n  </div>\n{/snippet}\n\n{#if user}\n  {@render userProfile(user)}\n{:else}\n  <p>Loading user...</p>\n{/if}\n```\n\nOnce `user` is populated, the condition will update and the snippet will be rendered.\n\n5. **Reactive updates to snippet selection**:\n```svelte\n<script>\n  let theme = 'light';\n  \n  const themeSnippets = {\n    light: lightTheme,\n    dark: darkTheme,\n    system: systemTheme\n  };\n  \n  $: currentThemeSnippet = themeSnippets[theme];\n</script>\n\n<select bind:value={theme}>\n  <option value=\"light\">Light</option>\n  <option value=\"dark\">Dark</option>\n  <option value=\"system\">System</option>\n</select>\n\n{@render currentThemeSnippet()}\n```\n\nThe `$:` reactive declaration ensures that when `theme` changes, `currentThemeSnippet` is updated, which in turn updates what's rendered.\n\nThis tight integration with Svelte's reactivity system makes snippets a powerful tool for building dynamic, responsive user interfaces."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"How can you use the `{@render ...}` tag with slots and composition patterns in Svelte 5?","answer":"In Svelte 5, the `{@render ...}` tag can be combined with slots and composition patterns to create flexible, composable components. This approach allows you to create higher-order components that can be customized through both props and snippets.\n\nHere are some patterns for using `{@render ...}` with slots and composition:\n\n1. **Passing snippets as props**:\n\n```svelte\n<!-- Card.svelte -->\n<script>\n  export let title = \"Card\";\n  export let headerContent = undefined;\n  export let footerContent = undefined;\n</script>\n\n<div class=\"card\">\n  <div class=\"card-header\">\n    {#if headerContent}\n      {@render headerContent()}\n    {:else}\n      <h3>{title}</h3>\n    {/if}\n  </div>\n  \n  <div class=\"card-body\">\n    <slot />\n  </div>\n  \n  {#if footerContent}\n    <div class=\"card-footer\">\n      {@render footerContent()}\n    </div>\n  {/if}\n</div>\n\n<!-- Usage -->\n<script>\n  import Card from './Card.svelte';\n  \n  let user = { name: 'John Doe', avatar: '/avatars/john.png' };\n  \n  function customHeader() {\n    return {\n      t: {\n        // Template for custom header with user avatar\n      }\n    };\n  }\n  \n  function customFooter() {\n    return {\n      t: {\n        // Template for custom footer with actions\n      }\n    };\n  }\n</script>\n\n<Card \n  title=\"User Profile\"\n  headerContent={customHeader}\n  footerContent={customFooter}\n>\n  <p>Content about {user.name}</p>\n</Card>\n```\n\n2. **Slot content with snippets**:\n\n```svelte\n<!-- List.svelte -->\n<script>\n  export let items = [];\n  export let renderItem = undefined;\n</script>\n\n<ul>\n  {#each items as item, i}\n    <li>\n      {#if renderItem}\n        {@render renderItem(item, i)}\n      {:else}\n        {item}\n      {/if}\n    </li>\n  {/each}\n</ul>\n\n<!-- Usage -->\n<script>\n  import List from './List.svelte';\n  \n  let users = [\n    { id: 1, name: 'Alice', role: 'Admin' },\n    { id: 2, name: 'Bob', role: 'User' },\n    { id: 3, name: 'Charlie', role: 'Editor' }\n  ];\n  \n  function userItem(user, index) {\n    return {\n      t: {\n        // Template for rendering a user\n      }\n    };\n  }\n</script>\n\n<List items={users} renderItem={userItem} />\n```\n\n3. **Combining slots and snippets for layout components**:\n\n```svelte\n<!-- Layout.svelte -->\n<script>\n  export let sidebar = undefined;\n  export let header = undefined;\n  export let footer = undefined;\n</script>\n\n<div class=\"layout\">\n  {#if header}\n    <header>\n      {@render header()}\n    </header>\n  {/if}\n  \n  <div class=\"content-area\">\n    {#if sidebar}\n      <aside>\n        {@render sidebar()}\n      </aside>\n    {/if}\n    \n    <main>\n      <slot />\n    </main>\n  </div>\n  \n  {#if footer}\n    <footer>\n      {@render footer()}\n    </footer>\n  {/if}\n</div>\n\n<!-- Usage -->\n<script>\n  import Layout from './Layout.svelte';\n  \n  function appHeader() {\n    return {\n      t: {\n        // Template for app header\n      }\n    };\n  }\n  \n  function appSidebar() {\n    return {\n      t: {\n        // Template for app sidebar\n      }\n    };\n  }\n  \n  function appFooter() {\n    return {\n      t: {\n        // Template for app footer\n      }\n    };\n  }\n</script>\n\n<Layout\n  header={appHeader}\n  sidebar={appSidebar}\n  footer={appFooter}\n>\n  <h1>Main Content</h1>\n  <p>This is the main content area of the application.</p>\n</Layout>\n```\n\n4. **Render props pattern**:\n\n```svelte\n<!-- DataFetcher.svelte -->\n<script>\n  export let url;\n  export let loading = undefined;\n  export let error = undefined;\n  export let empty = undefined;\n  \n  let data = null;\n  let isLoading = true;\n  let errorMessage = null;\n  \n  async function fetchData() {\n    isLoading = true;\n    try {\n      const response = await fetch(url);\n      if (!response.ok) throw new Error('Failed to fetch');\n      data = await response.json();\n    } catch (err) {\n      errorMessage = err.message;\n    } finally {\n      isLoading = false;\n    }\n  }\n  \n  $: if (url) fetchData();\n</script>\n\n{#if isLoading}\n  {#if loading}\n    {@render loading()}\n  {:else}\n    <p>Loading...</p>\n  {/if}\n{:else if errorMessage}\n  {#if error}\n    {@render error(errorMessage)}\n  {:else}\n    <p>Error: {errorMessage}</p>\n  {/if}\n{:else if !data || data.length === 0}\n  {#if empty}\n    {@render empty()}\n  {:else}\n    <p>No data available</p>\n  {/if}\n{:else}\n  <slot {data} />\n{/if}\n\n<!-- Usage -->\n<script>\n  import DataFetcher from './DataFetcher.svelte';\n  \n  function loadingSpinner() {\n    return {\n      t: {\n        // Template for custom loading spinner\n      }\n    };\n  }\n  \n  function errorDisplay(message) {\n    return {\n      t: {\n        // Template for custom error display\n      }\n    };\n  }\n  \n  function emptyState() {\n    return {\n      t: {\n        // Template for empty state\n      }\n    };\n  }\n</script>\n\n<DataFetcher \n  url=\"/api/users\"\n  loading={loadingSpinner}\n  error={errorDisplay}\n  empty={emptyState}\n>\n  <svelte:fragment let:data>\n    <ul>\n      {#each data as user}\n        <li>{user.name}</li>\n      {/each}\n    </ul>\n  </svelte:fragment>\n</DataFetcher>\n```\n\nThese patterns demonstrate how `{@render ...}` and snippets can be combined with Svelte's slot system to create highly composable and flexible components."}
{"source":"docs/svelte/03-template-syntax/07-@render.md","question":"What are the limitations of the `{@render ...}` tag in Svelte 5, and how do they compare to other templating approaches?","answer":"The `{@render ...}` tag in Svelte 5 has several limitations and considerations that developers should be aware of when deciding between different templating approaches:\n\n1. **Snippet Scope Limitations**:\n   Snippets have access to the component's scope where they're defined, but they can't directly access the scope of where they're rendered if passed as props to other components.\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n  \n  let parentVariable = \"I'm from parent\";\n  \n  function parentSnippet() {\n    return {\n      t: {\n        // This can access parentVariable\n        // But can't access childVariable when rendered in ChildComponent\n      }\n    };\n  }\n</script>\n\n<ChildComponent snippet={parentSnippet} />\n\n<!-- ChildComponent.svelte -->\n<script>\n  export let snippet;\n  let childVariable = \"I'm from child\";\n</script>\n\n{@render snippet()}\n<!-- The rendered snippet can't access childVariable -->\n```\n\n2. **No Direct Two-Way Binding**:\n   Unlike with slots, there's no direct way to pass data back from a rendered snippet to its parent scope.\n\n3. **Debugging Complexity**:\n   Errors in snippets might be harder to debug since they're more abstracted than regular template code.\n\n4. **Performance Considerations**:\n   While generally efficient, excessive use of snippets and dynamic rendering could potentially impact performance in very complex applications.\n\n5. **Limited IDE Support**:\n   As a newer feature, IDE and tooling support for snippets might be less mature than for other Svelte features.\n\nComparison with other templating approaches:\n\n1. **vs. Components**:\n   - Components are more encapsulated and reusable across the application\n   - Components have clearer input/output contracts through props and events\n   - Snippets are lighter-weight and have access to parent scope\n   - Components require separate files, while snippets are defined inline\n\n```svelte\n<!-- Using a component -->\n<script>\n  import Counter from './Counter.svelte';\n</script>\n\n<Counter initial={5} />\n\n<!-- Using a snippet -->\n<script>\n  let count = 5;\n  \n  function increment() {\n    count++;\n  }\n</script>\n\n{#snippet counter()}\n  <div>\n    <p>Count: {count}</p>\n    <button on:click={increment}>Increment</button>\n  </div>\n{/snippet}\n\n{@render counter()}\n```\n\n2. **vs. Slots**:\n   - Slots are designed for parent-to-child content projection\n   - Slots can access both parent and child context using `let:` directives\n   - Snippets are more focused on reusing template fragments within a component\n   - Slots require component boundaries, snippets don't\n\n```svelte\n<!-- Using slots -->\n<script>\n  import Card from './Card.svelte';\n</script>\n\n<Card>\n  <svelte:fragment slot=\"header\">\n    <h2>Card Title</h2>\n  </svelte:fragment>\n  \n  <p>Card content</p>\n  \n  <svelte:fragment slot=\"footer\">\n    <button>Save</button>\n  </svelte:fragment>\n</Card>\n\n<!-- Using snippets -->\n<script>\n  function header() {\n    return {\n      t: {\n        // Header template\n      }\n    };\n  }\n  \n  function footer() {\n    return {\n      t: {\n        // Footer template\n      }\n    };\n  }\n</script>\n\n<div class=\"card\">\n  <div class=\"card-header\">\n    {@render header()}\n  </div>\n  \n  <div class=\"card-body\">\n    <p>Card content</p>\n  </div>\n  \n  <div class=\"card-footer\">\n    {@render footer()}\n  </div>\n</div>\n```\n\n3. **vs. Inline Functions**:\n   - Inline functions returning HTML strings lack Svelte's reactivity and event handling\n   - Snippets are properly integrated with Svelte's reactivity system\n   - Snippets provide better syntax highlighting and template validation\n\n```svelte\n<!-- Using an inline function (anti-pattern) -->\n<script>\n  function renderGreeting(name) {\n    return `<p>Hello, ${name}!</p>`;\n  }\n</script>\n\n<div>\n  {@html renderGreeting(\"World\")}\n</div>\n\n<!-- Using a snippet -->\n<script>\n  function greeting(name) {\n    return {\n      t: {\n        // Greeting template\n      }\n    };\n  }\n</script>\n\n<div>\n  {@render greeting(\"World\")}\n</div>\n```\n\nThe `{@render ...}` tag and snippets in Svelte 5 fill an important niche between full components and simpler templating approaches, offering a balance of reusability, flexibility, and integration with Svelte's reactivity system. Understanding their limitations helps developers choose the right approach for each specific use case."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"What is the purpose of the `{@html ...}` tag in Svelte, and how is it properly used in a component?","answer":"The `{@html ...}` tag in Svelte is used to inject raw HTML content directly into a component. This is useful when you need to render HTML that comes from an external source, like a CMS or API response.\n\nTo use it, you simply wrap your HTML content expression with the `{@html ...}` syntax:\n\n```svelte\n<article>\n  {@html content}\n</article>\n```\n\nIn this example, the variable `content` should contain a string of HTML that will be rendered directly into the DOM. The content is not sanitized by Svelte, so you should be careful to ensure that the HTML is from a trusted source to avoid XSS (Cross-Site Scripting) vulnerabilities.\n\nIt's important to note that the HTML injected this way bypasses Svelte's template compilation process, meaning it's rendered as-is without any additional processing or reactivity."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"What are the security implications of using the `{@html ...}` tag, and what precautions should developers take?","answer":"Using the `{@html ...}` tag in Svelte comes with significant security implications because it renders raw HTML directly into the DOM without any sanitization. This creates a potential vector for Cross-Site Scripting (XSS) attacks if the HTML content comes from untrusted sources.\n\nDevelopers should take the following precautions when using `{@html ...}`:\n\n1. Only use it with content from trusted sources, such as your own database or CMS.\n2. If the content comes from user input or third-party APIs, sanitize it before rendering using a library like DOMPurify.\n3. Consider alternatives like markdown renderers that have built-in sanitization if you're displaying user-generated content.\n\nExample of proper usage with sanitization:\n\n```svelte\n<script>\n  import DOMPurify from 'dompurify';\n  \n  let userInput = '<script>alert(\"XSS attack!\")</script><p>User content</p>';\n  $: sanitizedContent = DOMPurify.sanitize(userInput);\n</script>\n\n<div>\n  {@html sanitizedContent}\n</div>\n```\n\nRemember that the security of your application is at risk if you don't properly sanitize HTML content before using the `{@html ...}` tag."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"How does Svelte handle styling for content rendered with the `{@html ...}` tag, and what's the recommended approach for styling such content?","answer":"Content rendered with the `{@html ...}` tag is \"invisible\" to Svelte's component compilation process. This means that Svelte's scoped styling system cannot directly target elements within the injected HTML.\n\nIf you try to style elements inside HTML content with standard scoped styles, it won't work:\n\n```svelte\n<article>\n  {@html content}\n</article>\n\n<style>\n  article {\n    a { color: hotpink }\n    img { width: 100% }\n  }\n</style>\n```\n\nIn the example above, the styles for `a` and `img` will be regarded as unused and won't apply to elements inside the injected HTML.\n\nThe recommended approach is to use the `:global` modifier to target everything inside the container element:\n\n```svelte\n<article>\n  {@html content}\n</article>\n\n<style>\n  article:global {\n    a { color: hotpink }\n    img { width: 100% }\n  }\n</style>\n```\n\nWith this approach, the styles will apply to all `a` and `img` elements inside the `article`, including those injected via `{@html ...}`. Remember that using `:global` breaks out of Svelte's style scoping, so these styles could potentially affect other parts of your application if the selectors match."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"Can the `{@html ...}` tag be used to render Svelte components or Svelte-specific syntax? Explain why or why not.","answer":"No, the `{@html ...}` tag cannot be used to render Svelte components or Svelte-specific syntax. This is a fundamental limitation of how the `{@html ...}` tag works in Svelte.\n\nWhen you use `{@html ...}`, Svelte injects the raw HTML directly into the DOM without compiling or processing it through Svelte's template compiler. This means:\n\n1. Svelte component tags within the HTML string won't be recognized as components\n2. Svelte directives like `{#if}`, `{#each}`, etc. won't be processed\n3. Reactive bindings, event handlers, and other Svelte-specific features won't work\n\nFor example, this won't work as expected:\n\n```svelte\n<script>\n  import Button from './Button.svelte';\n  \n  let htmlContent = '<Button on:click={() => alert(\"Hello\")}>Click me</Button>';\n</script>\n\n<div>\n  {@html htmlContent}\n</div>\n```\n\nThe `Button` component won't be rendered properly - it will just appear as a custom HTML element without any of the component's functionality.\n\nIf you need to dynamically render Svelte components, you should use Svelte's built-in component features like the `svelte:component` element or conditional rendering with `{#if}` blocks instead."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"What is the correct way to handle multi-part HTML injection in Svelte, and why doesn't concatenating HTML fragments with `{@html}` work?","answer":"When working with multi-part HTML in Svelte, you need to concatenate the HTML fragments into a single string before using the `{@html ...}` tag. Trying to use multiple `{@html ...}` tags in sequence to build HTML structure won't work as expected.\n\nFor example, this approach is incorrect and will not compile or render properly:\n\n```svelte\n{@html '<div>'}content{@html '</div>'}\n```\n\nThis doesn't work because each `{@html ...}` tag needs to contain valid standalone HTML. In the example above, `'<div>'` by itself is not valid HTML because it's an unclosed tag.\n\nThe correct approach is to combine all HTML parts into a single valid HTML string:\n\n```svelte\n<script>\n  let startTag = '<div>';\n  let content = 'This is my content';\n  let endTag = '</div>';\n  \n  $: fullHtml = startTag + content + endTag;\n</script>\n\n<div>\n  {@html fullHtml}\n</div>\n```\n\nAlternatively, if you're trying to wrap dynamic content with static HTML elements, you can use Svelte's regular template syntax instead:\n\n```svelte\n<div>\n  {content}\n</div>\n```\n\nThis approach is generally preferred when possible, as it allows Svelte to properly handle the DOM structure and apply its reactivity system."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"How can you conditionally apply styles to HTML content injected with the `{@html ...}` tag based on application state?","answer":"Since content rendered with `{@html ...}` is invisible to Svelte's styling system, conditionally styling this content requires some creative approaches. Here are a few strategies:\n\n1. **Use CSS custom properties (variables) controlled by Svelte:**\n\n```svelte\n<script>\n  let isHighlighted = false;\n  let htmlContent = '<p>This is some <span class=\"highlight\">important</span> content</p>';\n</script>\n\n<div class=\"content-container\" style=\"--highlight-color: {isHighlighted ? 'yellow' : 'transparent'}\">\n  {@html htmlContent}\n</div>\n\n<button on:click={() => isHighlighted = !isHighlighted}>\n  Toggle Highlight\n</button>\n\n<style>\n  .content-container:global {\n    .highlight {\n      background-color: var(--highlight-color);\n      transition: background-color 0.3s;\n    }\n  }\n</style>\n```\n\n2. **Apply different CSS classes to the container element:**\n\n```svelte\n<script>\n  let theme = 'light';\n  let htmlContent = '<h2>Article Title</h2><p>Article content...</p>';\n</script>\n\n<div class=\"article-container {theme}\">\n  {@html htmlContent}\n</div>\n\n<button on:click={() => theme = theme === 'light' ? 'dark' : 'light'}>\n  Toggle Theme\n</button>\n\n<style>\n  .article-container:global {\n    h2, p {\n      color: black;\n      transition: color 0.3s, background-color 0.3s;\n    }\n  }\n  \n  .dark:global {\n    h2, p {\n      color: white;\n      background-color: #333;\n    }\n  }\n</style>\n```\n\n3. **Dynamically construct the HTML with inline styles:**\n\n```svelte\n<script>\n  let textColor = 'blue';\n  \n  $: styledHtml = `\n    <div style=\"color: ${textColor}\">\n      <h3>Dynamically Styled Content</h3>\n      <p>This content will change color.</p>\n    </div>\n  `;\n</script>\n\n<div>\n  {@html styledHtml}\n</div>\n\n<input type=\"color\" bind:value={textColor}>\n```\n\nThese approaches allow you to conditionally style injected HTML content while maintaining the reactivity of your Svelte application."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"What are some alternatives to using the `{@html ...}` tag in Svelte, and when might they be more appropriate?","answer":"While the `{@html ...}` tag is useful for injecting raw HTML, there are several alternatives that might be more appropriate depending on your use case:\n\n1. **Markdown Renderers:**\n   For content that follows markdown syntax, using a markdown parser like `marked` can be safer and more maintainable:\n\n```svelte\n<script>\n  import { marked } from 'marked';\n  \n  let markdownContent = '# Hello\\n\\nThis is **bold** text with a [link](https://svelte.dev)';\n  $: htmlContent = marked(markdownContent);\n</script>\n\n<div>\n  {@html htmlContent}\n</div>\n```\n\n2. **Rich Text Editors with Sanitization:**\n   Libraries like ProseMirror, TipTap, or CKEditor provide rich text editing with safe HTML output:\n\n```svelte\n<script>\n  import { sanitize } from 'some-sanitizer-library';\n  import RichTextEditor from './RichTextEditor.svelte';\n  \n  let content = '';\n  \n  function handleContentUpdate(event) {\n    content = sanitize(event.detail.content);\n  }\n</script>\n\n<RichTextEditor on:update={handleContentUpdate} />\n\n<div class=\"preview\">\n  {@html content}\n</div>\n```\n\n3. **Structured Component Approach:**\n   Instead of injecting HTML, transform the content into a structured format that can be rendered with Svelte components:\n\n```svelte\n<script>\n  import Heading from './Heading.svelte';\n  import Paragraph from './Paragraph.svelte';\n  \n  let content = [\n    { type: 'heading', level: 1, text: 'Article Title' },\n    { type: 'paragraph', text: 'This is the first paragraph.' }\n  ];\n</script>\n\n{#each content as block}\n  {#if block.type === 'heading'}\n    <Heading level={block.level}>{block.text}</Heading>\n  {:else if block.type === 'paragraph'}\n    <Paragraph>{block.text}</Paragraph>\n  {/if}\n{/each}\n```\n\n4. **Web Components:**\n   If you need to embed interactive components from other frameworks:\n\n```svelte\n<script>\n  import '@shoelace-style/shoelace/dist/components/rating/rating.js';\n  \n  let rating = 3;\n</script>\n\n<div>\n  <p>Rate this article:</p>\n  <sl-rating value={rating} on:sl-change={(e) => rating = e.target.value}></sl-rating>\n</div>\n```\n\nThese alternatives are more appropriate when:\n- You need better security (all provide better XSS protection)\n- You want to maintain styling consistency\n- You need interactive elements\n- You're working with structured content\n- You want to leverage Svelte's reactivity system\n\nThe `{@html ...}` tag is best reserved for cases where you have trusted HTML content that needs to be rendered as-is, such as from a CMS or internal API."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"How does the `{@html ...}` tag affect Svelte's performance and rendering process compared to regular Svelte templates?","answer":"The `{@html ...}` tag has several important implications for Svelte's performance and rendering process that developers should be aware of:\n\n1. **Bypasses Svelte's Virtual DOM:**\n   When using `{@html ...}`, Svelte bypasses its normal template compilation and directly injects the HTML into the DOM using `innerHTML`. This means:\n   - No virtual DOM diffing for this content\n   - The entire HTML content is replaced whenever the source string changes, even if only a small part changed\n\n2. **Reactivity Limitations:**\n   Content rendered with `{@html ...}` doesn't participate in Svelte's fine-grained reactivity system:\n\n```svelte\n<script>\n  let count = 0;\n  $: dynamicHtml = `<div>Count: ${count}</div>`;\n</script>\n\n<!-- This will completely replace the HTML on every count change -->\n<div>{@html dynamicHtml}</div>\n\n<button on:click={() => count++}>Increment</button>\n```\n\n3. **Event Handling:**\n   Event handlers cannot be attached declaratively to elements within the injected HTML. You would need to use delegation instead:\n\n```svelte\n<script>\n  let items = ['Apple', 'Banana', 'Cherry'];\n  \n  function handleClick(event) {\n    if (event.target.matches('.item')) {\n      alert(`Clicked on ${event.target.textContent}`);\n    }\n  }\n</script>\n\n<div on:click={handleClick}>\n  {@html items.map(item => `<div class=\"item\">${item}</div>`).join('')}\n</div>\n```\n\n4. **Rendering Performance:**\n   - Initial rendering might be faster for large chunks of static HTML since Svelte doesn't need to process each element\n   - Updates are less efficient since the entire HTML block is replaced rather than just what changed\n   - Memory usage might increase due to string concatenation for large HTML blocks\n\n5. **Component Lifecycle:**\n   Elements injected with `{@html ...}` don't trigger Svelte lifecycle events, and any component cleanup won't apply to them properly.\n\nFor most use cases, using Svelte's native templating is more efficient and safer:\n\n```svelte\n<!-- More efficient than {@html} for reactive content -->\n<div>\n  {#each items as item}\n    <div class=\"item\" on:click={() => alert(`Clicked on ${item}`)}>{item}</div>\n  {/each}\n</div>\n```\n\nThe `{@html ...}` tag should be used primarily for trusted, relatively static content where you don't need fine-grained reactivity or event handling, such as rendering content from a CMS or documentation system."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"Can you use the `{@html ...}` tag with reactive expressions in Svelte? If so, demonstrate how to create a component that safely displays user-provided HTML content with real-time preview capabilities.","answer":"Yes, you can use the `{@html ...}` tag with reactive expressions in Svelte. This allows you to create dynamic HTML content that updates whenever the underlying data changes. Here's how to create a component that safely displays user-provided HTML content with real-time preview capabilities:\n\n```svelte\n<script>\n  import DOMPurify from 'dompurify';\n  \n  let userInput = '<h1>Hello World</h1>\\n<p>This is a <strong>preview</strong> of my content.</p>';\n  let showPreview = true;\n  \n  // Reactive expression that sanitizes the HTML whenever userInput changes\n  $: sanitizedHtml = DOMPurify.sanitize(userInput, {\n    ALLOWED_TAGS: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'ul', 'ol', 'li', 'strong', 'em', 'a', 'br'],\n    ALLOWED_ATTR: ['href', 'target', 'rel']\n  });\n</script>\n\n<div class=\"editor-container\">\n  <div class=\"controls\">\n    <label>\n      <input type=\"checkbox\" bind:checked={showPreview}>\n      Show Preview\n    </label>\n  </div>\n  \n  <div class=\"editor-layout\">\n    <div class=\"input-panel\">\n      <h2>HTML Editor</h2>\n      <textarea \n        bind:value={userInput} \n        rows=\"10\" \n        placeholder=\"Enter your HTML here...\"\n      ></textarea>\n    </div>\n    \n    {#if showPreview}\n      <div class=\"preview-panel\">\n        <h2>Preview</h2>\n        <div class=\"preview-content\">\n          {@html sanitizedHtml}\n        </div>\n      </div>\n    {/if}\n  </div>\n</div>\n\n<style>\n  .editor-container {\n    font-family: system-ui, sans-serif;\n    max-width: 1000px;\n    margin: 0 auto;\n  }\n  \n  .controls {\n    margin-bottom: 1rem;\n  }\n  \n  .editor-layout {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 1rem;\n  }\n  \n  textarea {\n    width: 100%;\n    font-family: monospace;\n    padding: 0.5rem;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n  \n  .preview-panel {\n    border: 1px solid #eee;\n    border-radius: 4px;\n    padding: 0 1rem;\n    background-color: #f9f9f9;\n  }\n  \n  .preview-content:global {\n    h1, h2, h3, h4, h5, h6 {\n      color: #333;\n      margin-top: 1em;\n      margin-bottom: 0.5em;\n    }\n    \n    p {\n      margin-bottom: 1em;\n      line-height: 1.5;\n    }\n    \n    a {\n      color: #0066cc;\n      text-decoration: none;\n    }\n    \n    a:hover {\n      text-decoration: underline;\n    }\n    \n    strong {\n      font-weight: bold;\n    }\n    \n    em {\n      font-style: italic;\n    }\n  }\n  \n  @media (max-width: 768px) {\n    .editor-layout {\n      grid-template-columns: 1fr;\n    }\n  }\n</style>\n```\n\nKey features of this implementation:\n\n1. **Reactivity**: The `$: sanitizedHtml = DOMPurify.sanitize(userInput, {...})` reactive statement ensures that whenever `userInput` changes, the sanitized HTML is automatically updated.\n\n2. **Security**: We use DOMPurify to sanitize the user input, restricting the allowed HTML tags and attributes to minimize security risks.\n\n3. **Real-time Preview**: The preview updates instantly as the user types in the textarea due to Svelte's reactivity system.\n\n4. **Toggle Preview**: Users can show/hide the preview panel using a checkbox.\n\n5. **Styling**: We use `:global` to style the HTML content in the preview panel, ensuring styles are applied to the dynamically injected HTML.\n\n6. **Responsive Design**: The layout adjusts for smaller screens.\n\nThis component provides a safe way to work with user-provided HTML content while still leveraging Svelte's reactivity system. The same approach could be extended to create more complex WYSIWYG editors or documentation tools."}
{"source":"docs/svelte/03-template-syntax/08-@html.md","question":"How can you handle dynamic SVG content with the `{@html ...}` tag in Svelte, and what are the specific considerations for SVG compared to regular HTML?","answer":"Handling dynamic SVG content with the `{@html ...}` tag in Svelte requires some special considerations compared to regular HTML. SVG has its own namespace and stricter parsing rules, which can affect how it's rendered when injected via `{@html ...}`.\n\nHere's how to properly handle dynamic SVG content:\n\n```svelte\n<script>\n  // Simple SVG icon library\n  const icons = {\n    check: '<svg viewBox=\"0 0 24 24\" width=\"24\" height=\"24\"><path fill=\"currentColor\" d=\"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z\"></path></svg>',\n    close: '<svg viewBox=\"0 0 24 24\" width=\"24\" height=\"24\"><path fill=\"currentColor\" d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z\"></path></svg>',\n    info: '<svg viewBox=\"0 0 24 24\" width=\"24\" height=\"24\"><path fill=\"currentColor\" d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z\"></path></svg>'\n  };\n  \n  let selectedIcon = 'check';\n  let iconColor = '#00aa00';\n  let iconSize = 24;\n  \n  // Reactive SVG content with dynamic attributes\n  $: svgContent = icons[selectedIcon]\n    .replace('width=\"24\"', `width=\"${iconSize}\"`)\n    .replace('height=\"24\"', `height=\"${iconSize}\"`)\n    .replace('currentColor', iconColor);\n  \n  // Generate a dynamic SVG chart\n  function generateBarChart(data) {\n    const width = 300;\n    const height = 150;\n    const barWidth = width / data.length;\n    const maxValue = Math.max(...data);\n    \n    let bars = '';\n    data.forEach((value, index) => {\n      const barHeight = (value / maxValue) * height;\n      const x = index * barWidth;\n      const y = height - barHeight;\n      bars += `<rect x=\"${x}\" y=\"${y}\" width=\"${barWidth - 2}\" height=\"${barHeight}\" fill=\"#3498db\" />`;\n    });\n    \n    return `\n      <svg width=\"${width}\" height=\"${height}\" viewBox=\"0 0 ${width} ${height}\">\n        ${bars}\n      </svg>\n    `;\n  }\n  \n  let chartData = [5, 8, 12, 18, 9, 15, 6];\n  $: chartSvg = generateBarChart(chartData);\n</script>\n\n<div class=\"icon-controls\">\n  <div class=\"icon-selector\">\n    <label>\n      Icon:\n      <select bind:value={selectedIcon}>\n        <option value=\"check\">Check</option>\n        <option value=\"close\">Close</option>\n        <option value=\"info\">Info</option>\n      </select>\n    </label>\n  </div>\n  \n  <div class=\"icon-properties\">\n    <label>\n      Color:\n      <input type=\"color\" bind:value={iconColor}>\n    </label>\n    \n    <label>\n      Size:\n      <input type=\"range\" min=\"16\" max=\"64\" bind:value={iconSize}>\n      {iconSize}px\n    </label>\n  </div>\n</div>\n\n<div class=\"icon-display\">\n  <div class=\"icon-wrapper\">\n    {@html svgContent}\n  </div>\n</div>\n\n<div class=\"chart-section\">\n  <h3>Dynamic SVG Chart</h3>\n  <div class=\"chart-container\">\n    {@html chartSvg}\n  </div>\n  \n  <div class=\"chart-controls\">\n    <button on:click={() => chartData = chartData.map(() => Math.floor(Math.random() * 20) + 1)}>\n      Randomize Data\n    </button>\n  </div>\n</div>\n\n<style>\n  .icon-controls {\n    margin-bottom: 1rem;\n    display: flex;\n    gap: 1rem;\n    flex-wrap: wrap;\n  }\n  \n  .icon-properties {\n    display: flex;\n    gap: 1rem;\n  }\n  \n  .icon-display {\n    padding: 2rem;\n    border: 1px dashed #ccc;\n    border-radius: 4px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  \n  .chart-section {\n    margin-top: 2rem;\n  }\n  \n  .chart-container {\n    border: 1px solid #eee;\n    border-radius: 4px;\n    padding: 1rem;\n    background-color: #f9f9f9;\n  }\n  \n  .chart-controls {\n    margin-top: 1rem;\n  }\n</style>\n```\n\n**Special considerations for SVG compared to regular HTML:**\n\n1. **SVG Namespace**:\n   SVG elements need to be within an SVG namespace. When using `{@html ...}` to inject SVG content:\n   - Make sure the outer element is `<svg>` with appropriate attributes\n   - Include the proper `viewBox` attribute for scaling\n   - Use a container with appropriate dimensions\n\n2. **Attribute Case Sensitivity**:\n   SVG attributes are case-sensitive, unlike HTML. For example, `viewbox` won't work, it must be `viewBox`.\n\n3. **String Manipulation Limitations**:\n   As shown in the example, we're using string replacement to modify SVG attributes. This is less robust than using DOM methods:\n   ```javascript\n   // Be careful with string replacements like this:\n   $: svgContent = icons[selectedIcon]\n     .replace('width=\"24\"', `width=\"${iconSize}\"`)\n     .replace('currentColor', iconColor);\n   ```\n\n4. **Self-closing Tags**:\n   SVG allows self-closing tags (like `<path />`), which must be properly formatted to avoid parsing issues.\n\n5. **Styling Considerations**:\n   SVG has its own styling attributes and properties:\n   - `fill` and `stroke` instead of `background-color` and `border-color`\n   - Can use `currentColor` to inherit color from CSS\n   - CSS properties like `color` affect `fill` when using `currentColor`\n\n6. **Performance with Complex SVGs**:\n   Complex SVGs with many elements can cause performance issues when frequently updated. Consider:\n   - Optimizing SVGs before injection (removing unnecessary elements/attributes)\n   - Using SVG sprites for static icons instead of dynamic generation\n   - For very complex visualizations, consider using a dedicated SVG library\n\n7. **Accessibility**:\n   Dynamically injected SVGs may need additional attributes for accessibility:\n   - Add `role=\"img\"` \n   - Include `aria-label` or `<title>` elements\n\nFor more complex SVG interactions or animations, consider using a dedicated SVG library like D3.js or using inline SVG in your Svelte template instead of the `{@html ...}` tag, as this gives you better control and integration with Svelte's reactivity system."}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"What is the purpose of the `{@const}` tag in Svelte and where can it be used?","answer":"The `{@const}` tag in Svelte is used to define a local constant within a template. Its main purpose is to allow you to compute and store values locally in your template without having to define them in your component's script section.\n\nThe `{@const}` tag can only be used as an immediate child of:\n1. A block (such as `{#if ...}`, `{#each ...}`, `{#snippet ...}`, etc.)\n2. A component (`<Component />`)\n3. A `<svelte:boundary>` element\n\nThis constraint ensures that constants are scoped appropriately within your template.\n\nHere's an example of using `{@const}` within an `{#each}` block:\n\n```svelte\n<script>\n  let rectangles = [\n    { width: 4, height: 3 },\n    { width: 6, height: 2 },\n    { width: 5, height: 5 }\n  ];\n</script>\n\n<ul>\n  {#each rectangles as rect}\n    {@const area = rect.width * rect.height}\n    {@const perimeter = 2 * (rect.width + rect.height)}\n    \n    <li>\n      Rectangle: {rect.width} Ã {rect.height}\n      <br>Area: {area}\n      <br>Perimeter: {perimeter}\n    </li>\n  {/each}\n</ul>\n```\n\nIn this example, we compute the `area` and `perimeter` values once for each rectangle and can then reuse these values multiple times within the block."}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"How does the `{@const}` tag improve performance in Svelte templates, especially in loops?","answer":"The `{@const}` tag can significantly improve performance in Svelte templates, especially within loops, by avoiding redundant computations. When you use `{@const}` to define a value within an `{#each}` block, the computation is performed only once per iteration rather than every time the value is referenced.\n\nConsider this example without using `{@const}`:\n\n```svelte\n<script>\n  let products = [\n    { name: 'Laptop', price: 999, discount: 0.15 },\n    { name: 'Phone', price: 699, discount: 0.1 },\n    { name: 'Tablet', price: 399, discount: 0.05 }\n  ];\n</script>\n\n<ul>\n  {#each products as product}\n    <li>\n      <h3>{product.name}</h3>\n      <p>Original price: ${product.price}</p>\n      <p>Discounted price: ${product.price * (1 - product.discount)}</p>\n      <p>You save: ${product.price * product.discount}</p>\n    </li>\n  {/each}\n</ul>\n```\n\nIn this example, the expressions `product.price * (1 - product.discount)` and `product.price * product.discount` are calculated separately each time they're referenced. If the template is re-rendered, these calculations happen again.\n\nNow with `{@const}`:\n\n```svelte\n<ul>\n  {#each products as product}\n    {@const discountedPrice = product.price * (1 - product.discount)}\n    {@const savings = product.price * product.discount}\n    \n    <li>\n      <h3>{product.name}</h3>\n      <p>Original price: ${product.price}</p>\n      <p>Discounted price: ${discountedPrice}</p>\n      <p>You save: ${savings}</p>\n    </li>\n  {/each}\n</ul>\n```\n\nThe performance benefits are:\n1. **Reduced computation**: The expressions are evaluated only once per iteration\n2. **Improved readability**: The code is cleaner and the intent is clearer\n3. **Optimized updates**: When Svelte updates the DOM, it doesn't need to recalculate these values if the underlying data hasn't changed\n\nThis optimization becomes more important when the computations are more complex or when the expressions are used multiple times within the block."}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"What's the difference between using `{@const}` in a template versus declaring a variable in the `<script>` section?","answer":"Using `{@const}` in a template versus declaring a variable in the `<script>` section represents different scoping and lifecycle approaches in Svelte:\n\n**Variables in the `<script>` section:**\n- Are component-wide in scope\n- Can be reactive (with `$:`)\n- Can be mutated (unless declared with `const`)\n- Exist for the entire lifecycle of the component\n- Can be exported as props\n- Can be referenced anywhere in the component\n\n**Constants declared with `{@const}`:**\n- Are block-scoped (limited to the block where they're defined)\n- Are computed freshly for each instance of the block (e.g., each iteration in an `{#each}` loop)\n- Cannot be mutated (they're constants)\n- Only exist within their containing block\n- Cannot be exported or accessed outside their block\n- Help keep logic close to where it's used\n\nHere's a comparison example:\n\n```svelte\n<script>\n  let items = [\n    { id: 1, value: 10 },\n    { id: 2, value: 20 },\n    { id: 3, value: 30 }\n  ];\n  \n  // Component-wide constant\n  const multiplier = 2;\n  \n  // Component-wide computed value\n  $: totalValue = items.reduce((sum, item) => sum + item.value, 0);\n</script>\n\n<div>\n  <p>Total value: {totalValue}</p>\n  \n  <ul>\n    {#each items as item}\n      {@const doubledValue = item.value * multiplier}\n      {@const isHighValue = doubledValue > 30}\n      \n      <li class={isHighValue ? 'high-value' : ''}>\n        Item #{item.id}: {item.value} Ã {multiplier} = {doubledValue}\n      </li>\n    {/each}\n  </ul>\n</div>\n```\n\nIn this example:\n- `multiplier` and `totalValue` are component-wide and can be used anywhere\n- `doubledValue` and `isHighValue` are scoped to each iteration of the `{#each}` loop\n- Each item gets its own independent instances of these constants\n\nUse `{@const}` when:\n1. The value is only needed within a specific block\n2. The value needs to be computed separately for each iteration of a loop\n3. You want to avoid redundant calculations\n4. You want to keep the logic close to where it's used\n\nUse script variables when:\n1. The value is needed throughout the component\n2. The value should be reactive across the entire component\n3. The value needs to be exported or passed to other components\n4. The value may need to be mutated"}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"Can you use `{@const}` to define constants based on reactive values, and how does Svelte handle updates to those values?","answer":"Yes, you can use `{@const}` to define constants based on reactive values in Svelte. When the reactive values change, Svelte will automatically recalculate the constant during the next render cycle for the affected block.\n\nHere's how it works:\n\n```svelte\n<script>\n  let count = 0;\n  let multiplier = 2;\n  \n  function increment() {\n    count += 1;\n  }\n  \n  function updateMultiplier() {\n    multiplier += 1;\n  }\n</script>\n\n<button on:click={increment}>Increment Count ({count})</button>\n<button on:click={updateMultiplier}>Increase Multiplier ({multiplier})</button>\n\n{#if count > 0}\n  {@const squared = count * count}\n  {@const multiplied = count * multiplier}\n  \n  <p>Count: {count}</p>\n  <p>Count squared: {squared}</p>\n  <p>Count Ã Multiplier: {multiplied}</p>\n{/if}\n```\n\nIn this example:\n1. The constants `squared` and `multiplied` are based on reactive values (`count` and `multiplier`)\n2. When `count` or `multiplier` change, Svelte will re-render the `{#if}` block\n3. During re-rendering, the `{@const}` expressions are recalculated with the new values\n4. The updated constants are then used in the template\n\nIt's important to understand that:\n- The constants themselves are not reactive - they're recalculated when their containing block is re-rendered\n- If multiple constants depend on the same reactive value, all will be recalculated when that value changes\n- Constants are calculated during the render phase, not as a separate reactive update\n\nThis approach is particularly useful in loops where you want to derive values from changing data:\n\n```svelte\n<script>\n  let products = [\n    { id: 1, name: 'Laptop', price: 999 },\n    { id: 2, name: 'Phone', price: 699 },\n    { id: 3, name: 'Tablet', price: 399 }\n  ];\n  \n  let taxRate = 0.08;\n  \n  function increasePrices() {\n    products = products.map(p => ({\n      ...p,\n      price: Math.round(p.price * 1.1) // 10% increase\n    }));\n  }\n  \n  function updateTaxRate() {\n    taxRate = taxRate + 0.01;\n  }\n</script>\n\n<button on:click={increasePrices}>Increase Prices</button>\n<button on:click={updateTaxRate}>Increase Tax Rate ({(taxRate * 100).toFixed(0)}%)</button>\n\n<ul>\n  {#each products as product (product.id)}\n    {@const priceWithTax = product.price * (1 + taxRate)}\n    {@const taxAmount = product.price * taxRate}\n    \n    <li>\n      <h3>{product.name}</h3>\n      <p>Base price: ${product.price.toFixed(2)}</p>\n      <p>Tax amount: ${taxAmount.toFixed(2)}</p>\n      <p>Total price: ${priceWithTax.toFixed(2)}</p>\n    </li>\n  {/each}\n</ul>\n```\n\nIn this example, whenever `products` or `taxRate` changes, the affected constants will be recalculated during the next render cycle, ensuring that the displayed information is always up to date."}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"What are the syntax constraints when using the `{@const}` tag in Svelte templates?","answer":"The `{@const}` tag in Svelte has several syntax constraints and rules that must be followed:\n\n1. **Placement restrictions**: `{@const}` can only be used as an immediate child of:\n   - A block (`{#if ...}`, `{#each ...}`, `{#key ...}`, `{#await ...}`, `{#snippet ...}`)\n   - A component (`<Component />`)\n   - A `<svelte:boundary>` element\n\n2. **Constant naming**: Must follow JavaScript variable naming rules:\n   - Must start with a letter, underscore (_), or dollar sign ($)\n   - Can contain letters, numbers, underscores, or dollar signs\n   - Cannot be a JavaScript reserved keyword\n\n3. **Constant declaration**: Must use the format `{@const name = expression}`\n   - Multiple constants require multiple `{@const}` tags\n   - Cannot declare multiple constants in a single tag\n\n4. **Value assignment**: Must be an expression that can be evaluated immediately\n   - Can use any JavaScript expression that evaluates to a value\n   - Can reference variables and other constants in scope\n   - Cannot use await or async operations directly\n\nHere are examples of valid and invalid usages:\n\n**Valid:**\n\n```svelte\n{#if user}\n  {@const fullName = user.firstName + ' ' + user.lastName}\n  <h1>Hello, {fullName}!</h1>\n{/if}\n\n{#each items as item}\n  {@const total = item.price * item.quantity}\n  <div>{item.name}: ${total}</div>\n{/each}\n\n<MyComponent>\n  {@const greeting = \"Hello there\"}\n  <p>{greeting}</p>\n</MyComponent>\n\n<svelte:boundary>\n  {@const now = new Date().toLocaleTimeString()}\n  <p>Current time: {now}</p>\n</svelte:boundary>\n```\n\n**Invalid:**\n\n```svelte\n<!-- Invalid: Not inside a block, component, or svelte:boundary -->\n{@const x = 1}\n<p>{x}</p>\n\n{#if user}\n  <div>\n    <!-- Invalid: Not an immediate child of the block -->\n    {@const name = user.name}\n    <p>{name}</p>\n  </div>\n{/if}\n\n{#each items as item}\n  <!-- Invalid: Cannot declare multiple constants in one tag -->\n  {@const price = item.price, total = price * item.quantity}\n  <div>{item.name}: ${total}</div>\n{/each}\n```\n\nHere's a more complex example showing proper nesting and usage:\n\n```svelte\n<script>\n  let users = [\n    { id: 1, name: 'Alice', roles: ['admin', 'user'] },\n    { id: 2, name: 'Bob', roles: ['user'] },\n    { id: 3, name: 'Charlie', roles: ['moderator', 'user'] }\n  ];\n</script>\n\n{#each users as user (user.id)}\n  {@const isAdmin = user.roles.includes('admin')}\n  {@const isModerator = user.roles.includes('moderator')}\n  \n  <div class=\"user-card\">\n    <h3>{user.name}</h3>\n    \n    {#if isAdmin || isModerator}\n      {@const roleLabel = isAdmin ? 'Administrator' : 'Moderator'}\n      <span class=\"badge\">{roleLabel}</span>\n    {/if}\n    \n    <ul>\n      {#each user.roles as role}\n        {@const roleDisplay = role.charAt(0).toUpperCase() + role.slice(1)}\n        <li>{roleDisplay}</li>\n      {/each}\n    </ul>\n  </div>\n{/each}\n```\n\nIn this example, constants are properly defined as immediate children of their respective blocks, following all the syntax constraints required by Svelte."}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"How can you use the `{@const}` tag to optimize complex calculations in Svelte templates, especially with nested structures?","answer":"The `{@const}` tag is particularly valuable for optimizing complex calculations in Svelte templates, especially with nested structures. By computing values once and storing them as constants, you can avoid redundant calculations and improve both performance and readability.\n\nHere's how you can effectively use `{@const}` for optimization:\n\n### 1. Optimizing Nested Loops\n\n```svelte\n<script>\n  let departments = [\n    {\n      name: 'Engineering',\n      teams: [\n        { name: 'Frontend', employees: 12, projects: 5 },\n        { name: 'Backend', employees: 15, projects: 4 },\n        { name: 'DevOps', employees: 8, projects: 3 }\n      ]\n    },\n    {\n      name: 'Marketing',\n      teams: [\n        { name: 'Digital', employees: 6, projects: 8 },\n        { name: 'Events', employees: 4, projects: 12 }\n      ]\n    }\n  ];\n</script>\n\n<div class=\"organization\">\n  {#each departments as department}\n    {@const totalEmployees = department.teams.reduce((sum, team) => sum + team.employees, 0)}\n    {@const totalProjects = department.teams.reduce((sum, team) => sum + team.projects, 0)}\n    \n    <div class=\"department\">\n      <h2>{department.name}</h2>\n      <p>Total Employees: {totalEmployees}</p>\n      <p>Total Projects: {totalProjects}</p>\n      <p>Projects per Employee: {(totalProjects / totalEmployees).toFixed(2)}</p>\n      \n      <div class=\"teams\">\n        {#each department.teams as team}\n          {@const employeeProjectRatio = (team.projects / team.employees).toFixed(2)}\n          {@const isHighWorkload = team.projects / team.employees > 0.8}\n          \n          <div class=\"team\" class:high-workload={isHighWorkload}>\n            <h3>{team.name}</h3>\n            <p>Employees: {team.employees}</p>\n            <p>Projects: {team.projects}</p>\n            <p>Projects per Employee: {employeeProjectRatio}</p>\n          </div>\n        {/each}\n      </div>\n    </div>\n  {/each}\n</div>\n```\n\nIn this example:\n- We calculate department totals once using `{@const}` at the department level\n- We calculate team-specific ratios once per team\n- We determine styling conditions based on computed values\n\n### 2. Optimizing Complex Data Transformations\n\n```svelte\n<script>\n  let salesData = [\n    { region: 'North', Q1: 10000, Q2: 12000, Q3: 9000, Q4: 15000 },\n    { region: 'South', Q1: 8000, Q2: 9000, Q3: 11000, Q4: 13000 },\n    { region: 'East', Q1: 12000, Q2: 11000, Q3: 10000, Q4: 14000 },\n    { region: 'West', Q1: 9000, Q2: 10000, Q3: 12000, Q4: 16000 }\n  ];\n</script>\n\n<table>\n  <thead>\n    <tr>\n      <th>Region</th>\n      <th>Q1</th>\n      <th>Q2</th>\n      <th>Q3</th>\n      <th>Q4</th>\n      <th>Total</th>\n      <th>Average</th>\n      <th>Best Quarter</th>\n    </tr>\n  </thead>\n  <tbody>\n    {#each salesData as region}\n      {@const quarters = ['Q1', 'Q2', 'Q3', 'Q4']}\n      {@const total = region.Q1 + region.Q2 + region.Q3 + region.Q4}\n      {@const average = total / 4}\n      {@const bestQuarter = quarters.reduce((best, q) => \n        region[q] > region[best] ? q : best, 'Q1')}\n      {@const bestValue = region[bestQuarter]}\n      \n      <tr>\n        <td>{region.region}</td>\n        <td class={region.Q1 === bestValue ? 'best' : ''}>${region.Q1}</td>\n        <td class={region.Q2 === bestValue ? 'best' : ''}>${region.Q2}</td>\n        <td class={region.Q3 === bestValue ? 'best' : ''}>${region.Q3}</td>\n        <td class={region.Q4 === bestValue ? 'best' : ''}>${region.Q4}</td>\n        <td>${total}</td>\n        <td>${average.toFixed(2)}</td>\n        <td>{bestQuarter} (${bestValue})</td>\n      </tr>\n    {/each}\n  </tbody>\n  <tfoot>\n    {@const totals = {\n      Q1: salesData.reduce((sum, r) => sum + r.Q1, 0),\n      Q2: salesData.reduce((sum, r) => sum + r.Q2, 0),\n      Q3: salesData.reduce((sum, r) => sum + r.Q3, 0),\n      Q4: salesData.reduce((sum, r) => sum + r.Q4, 0)\n    }}\n    {@const grandTotal = totals.Q1 + totals.Q2 + totals.Q3 + totals.Q4}\n    \n    <tr>\n      <th>All Regions</th>\n      <td>${totals.Q1}</td>\n      <td>${totals.Q2}</td>\n      <td>${totals.Q3}</td>\n      <td>${totals.Q4}</td>\n      <td>${grandTotal}</td>\n      <td>${(grandTotal / (4 * salesData.length)).toFixed(2)}</td>\n      <td></td>\n    </tr>\n  </tfoot>\n</table>\n```\n\n### 3. Optimizing Conditional Rendering with Complex Logic\n\n```svelte\n<script>\n  let users = [\n    {\n      id: 1,\n      name: 'Alice Johnson',\n      permissions: ['read', 'write', 'admin'],\n      activity: { lastLogin: '2023-04-15', posts: 27, comments: 142 }\n    },\n    {\n      id: 2,\n      name: 'Bob Smith',\n      permissions: ['read', 'write'],\n      activity: { lastLogin: '2023-04-10', posts: 14, comments: 35 }\n    },\n    {\n      id: 3,\n      name: 'Carol Williams',\n      permissions: ['read'],\n      activity: { lastLogin: '2023-03-22', posts: 3, comments: 28 }\n    }\n  ];\n  \n  const today = new Date();\n</script>\n\n<div class=\"user-list\">\n  {#each users as user}\n    {@const isAdmin = user.permissions.includes('admin')}\n    {@const canWrite = user.permissions.includes('write')}\n    {@const lastLoginDate = new Date(user.activity.lastLogin)}\n    {@const daysSinceLogin = Math.floor((today - lastLoginDate) / (1000 * 60 * 60 * 24))}\n    {@const isActive = daysSinceLogin < 14}\n    {@const engagementScore = user.activity.posts * 5 + user.activity.comments}\n    {@const engagementLevel = \n      engagementScore > 200 ? 'High' :\n      engagementScore > 100 ? 'Medium' : 'Low'}\n    \n    <div class=\"user-card\" class:admin={isAdmin} class:active={isActive}>\n      <h3>{user.name}</h3>\n      \n      <div class=\"permissions\">\n        Access level: \n        {#if isAdmin}\n          <span class=\"badge admin\">Administrator</span>\n        {:else if canWrite}\n          <span class=\"badge writer\">Content Creator</span>\n        {:else}\n          <span class=\"badge reader\">Reader</span>\n        {/if}\n      </div>\n      \n      <div class=\"activity\">\n        <p>Last active: {daysSinceLogin} days ago</p>\n        <p>Engagement: {engagementLevel} ({engagementScore} points)</p>\n        \n        {#if !isActive && canWrite}\n          {@const remainingDays = 30 - daysSinceLogin}\n          <p class=\"warning\">\n            {#if remainingDays > 0}\n              Writing privileges expire in {remainingDays} days due to inactivity\n            {:else}\n              Writing privileges expired due to inactivity\n            {/if}\n          </p>\n        {/if}\n      </div>\n    </div>\n  {/each}\n</div>\n```\n\n### Benefits of This Approach:\n\n1. **Performance optimization**: Complex calculations like `engagementScore` or finding the best quarter are performed only once per iteration\n2. **DRY principle**: Calculated values are defined once and reused multiple times\n3. **Readability**: Logic is separated from presentation, making the template easier to understand\n4. **Maintainability**: Changes to calculation logic can be made in one place\n5. **Reduced errors**: Less chance of calculation inconsistencies when the same value is needed in multiple places\n\nThese examples demonstrate how `{@const}` can be used to optimize complex templates, particularly those with nested structures, complex calculations, or values that are referenced multiple times."}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"How does the scoping of `{@const}` work within nested blocks in Svelte templates?","answer":"The scoping of `{@const}` in Svelte follows a hierarchical pattern similar to JavaScript lexical scoping. Constants defined with `{@const}` are accessible within their own block and any nested blocks, but not in parent or sibling blocks.\n\nHere's a detailed explanation of how `{@const}` scoping works:\n\n### Basic Scoping Rules\n\n1. Constants are accessible within the block where they're defined\n2. Constants are accessible in all nested child blocks\n3. Constants are not accessible in parent blocks\n4. Constants are not accessible in sibling blocks\n5. Inner blocks can define constants with the same name as outer blocks (shadowing)\n\n### Examples of Scoping Behavior\n\n```svelte\n<script>\n  let items = [\n    { id: 1, name: 'Apple', category: 'Fruit', price: 1.2 },\n    { id: 2, name: 'Banana', category: 'Fruit', price: 0.8 },\n    { id: 3, name: 'Carrot', category: 'Vegetable', price: 0.7 },\n    { id: 4, name: 'Potato', category: 'Vegetable', price: 0.5 }\n  ];\n  \n  let showDetails = true;\n</script>\n\n{#if items.length > 0}\n  {@const totalItems = items.length}\n  {@const categories = [...new Set(items.map(item => item.category))]}\n  \n  <p>We have {totalItems} items in {categories.length} categories.</p>\n  \n  {#each categories as category}\n    {@const categoryItems = items.filter(item => item.category === category)}\n    {@const itemCount = categoryItems.length}\n    {@const totalPrice = categoryItems.reduce((sum, item) => sum + item.price, 0)}\n    \n    <div class=\"category\">\n      <h3>{category} ({itemCount} items)</h3>\n      <p>Total price: ${totalPrice.toFixed(2)}</p>\n      \n      {#if showDetails}\n        <ul>\n          {#each categoryItems as item}\n            {@const discountedPrice = item.price * 0.9}\n            \n            <li>\n              {item.name} - ${item.price.toFixed(2)}\n              {#if item.price > 1}\n                {@const savings = item.price - discountedPrice}\n                <span class=\"discount\">\n                  Sale price: ${discountedPrice.toFixed(2)} (Save ${savings.toFixed(2)})\n                </span>\n              {/if}\n            </li>\n          {/each}\n        </ul>\n      {/if}\n    </div>\n  {/each}\n{:else}\n  <p>No items available.</p>\n{/if}\n```\n\nIn this example:\n\n1. `totalItems` and `categories` are defined in the outermost `{#if}` block\n   - They are accessible anywhere within this `{#if}` block and its nested blocks\n   - They are not accessible in the `{:else}` block (which is a sibling)\n\n2. `categoryItems`, `itemCount`, and `totalPrice` are defined in each `{#each categories}` iteration\n   - They are scoped to their specific category iteration\n   - Each category has its own independent values\n   - They can access outer constants like `totalItems`\n   - They are not accessible outside their specific iteration\n\n3. `discountedPrice` is defined in each `{#each categoryItems}` iteration\n   - It's scoped to a specific item within a specific category\n   - It can access all outer constants\n   - Each item has its own independent value\n\n4. `savings` is defined only in the `{#if item.price > 1}` block\n   - It's only accessible within this condition\n   - It's calculated independently for each qualifying item\n\n### Shadowing\n\nSvelte allows inner blocks to define constants with the same name as constants in outer blocks, which is known as \"shadowing\":\n\n```svelte\n{#if user}\n  {@const name = user.fullName}\n  \n  <div>Full name: {name}</div>\n  \n  {#if user.nickname}\n    {@const name = user.nickname} <!-- Shadows the outer 'name' -->\n    <div>Nickname: {name}</div>\n  {/if}\n  \n  <div>Back to full name: {name}</div> <!-- Uses the outer 'name' -->\n{/if}\n```\n\nIn this example:\n- The outer `name` constant is set to `user.fullName`\n- Inside the nested `{#if}`, a new `name` constant is defined with the value `user.nickname`\n- This inner `name` shadows the outer one, but only within its own block\n- After the nested block ends, references to `name` use the outer constant again\n\n### Practical Implications of Scoping\n\n1. **Isolation**: Each block iteration gets its own independent constants, preventing accidental interference\n2. **Clarity**: Scoping helps keep constants close to where they're used\n3. **Performance**: Scoped constants are calculated only when needed\n4. **Reusability**: The same constant name can be reused in different contexts\n5. **Progressive disclosure**: Complex calculations can be organized hierarchically\n\nUnderstanding these scoping rules helps you organize your template logic effectively and avoid unexpected behavior when working with constants in nested structures."}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"Can you explain how to use `{@const}` within the `{#snippet}` block in Svelte 5, and what are the benefits of this approach?","answer":"Using `{@const}` within the `{#snippet}` block in Svelte 5 is a powerful pattern that combines two of Svelte's template features to create reusable, optimized template fragments with local calculations. This approach is particularly useful in Svelte 5, which introduced the new snippet feature.\n\n### Basic Usage of `{@const}` in Snippets\n\nA snippet in Svelte 5 is a reusable piece of template that can be defined and called within a component. When combined with `{@const}`, you can perform calculations once per snippet invocation:\n\n```svelte\n<script>\n  let products = [\n    { id: 1, name: 'Laptop', price: 999, features: ['8GB RAM', '256GB SSD', '15\" Screen'] },\n    { id: 2, name: 'Phone', price: 699, features: ['6GB RAM', '128GB Storage', '6.1\" Screen'] },\n    { id: 3, name: 'Tablet', price: 499, features: ['4GB RAM', '64GB Storage', '10\" Screen'] }\n  ];\n  \n  let taxRate = 0.08;\n</script>\n\n{#snippet productCard(product)}\n  {@const priceWithTax = product.price * (1 + taxRate)}\n  {@const taxAmount = product.price * taxRate}\n  {@const hasMultipleFeatures = product.features.length > 1}\n  \n  <div class=\"product-card\">\n    <h3>{product.name}</h3>\n    <div class=\"pricing\">\n      <p>Base price: ${product.price.toFixed(2)}</p>\n      <p>Tax: ${taxAmount.toFixed(2)}</p>\n      <p class=\"total\">Total: ${priceWithTax.toFixed(2)}</p>\n    </div>\n    \n    {#if hasMultipleFeatures}\n      <div class=\"features\">\n        <h4>Key Features:</h4>\n        <ul>\n          {#each product.features as feature}\n            <li>{feature}</li>\n          {/each}\n        </ul>\n      </div>\n    {/if}\n  </div>\n{/snippet}\n\n<div class=\"product-list\">\n  {#each products as product (product.id)}\n    {#if product.price > 0}\n      {@render productCard(product)}\n    {/if}\n  {/each}\n</div>\n\n<div class=\"featured-product\">\n  <h2>Featured Product</h2>\n  {@render productCard(products[0])}\n</div>\n```\n\n### Benefits of Using `{@const}` within Snippets\n\n1. **Encapsulated Logic**: Calculations specific to the snippet are contained within it, keeping related logic together.\n\n2. **DRY (Don't Repeat Yourself)**: Define the snippet once and reuse it multiple times, with calculations performed for each usage.\n\n3. **Optimized Rendering**: Each calculation is performed only once per snippet invocation, even if the calculated value is used multiple times within the snippet.\n\n4. **Improved Readability**: By computing values at the top of the snippet, the rest of the template can focus on presentation rather than calculation.\n\n5. **Contextual Calculation**: Each invocation of the snippet gets its own fresh calculations based on the current parameters.\n\n### Advanced Example: Using `{@const}` with Parameterized Snippets\n\nYou can create even more flexible snippets by passing multiple parameters and using `{@const}` to derive additional values:\n\n```svelte\n<script>\n  let users = [\n    { id: 1, name: 'Alice', role: 'admin', lastActive: '2023-04-01' },\n    { id: 2, name: 'Bob', role: 'user', lastActive: '2023-04-10' },\n    { id: 3, name: 'Charlie', role: 'moderator', lastActive: '2023-03-15' }\n  ];\n  \n  const now = new Date();\n  \n  function formatDate(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString();\n  }\n</script>\n\n{#snippet userProfile(user, showActivity = false, highlightInactive = true)}\n  {@const lastActiveDate = new Date(user.lastActive)}\n  {@const daysSinceActive = Math.floor((now - lastActiveDate) / (1000 * 60 * 60 * 24))}\n  {@const isInactive = daysSinceActive > 14}\n  {@const roleDisplay = {\n    'admin': 'Administrator',\n    'moderator': 'Moderator',\n    'user': 'Regular User'\n  }[user.role] || 'Unknown Role'}\n  \n  <div class=\"user-profile\" class:inactive={isInactive && highlightInactive}>\n    <h3>{user.name}</h3>\n    <div class=\"role-badge\">{roleDisplay}</div>\n    \n    {#if showActivity}\n      <div class=\"activity-info\">\n        <p>Last active: {formatDate(user.lastActive)} ({daysSinceActive} days ago)</p>\n        \n        {#if isInactive}\n          {@const remainingGraceDays = 30 - daysSinceActive}\n          <p class=\"warning\">\n            {#if remainingGraceDays > 0}\n              Account will be suspended in {remainingGraceDays} days due to inactivity\n            {:else}\n              Account eligible for suspension due to inactivity\n            {/if}\n          </p>\n        {/if}\n      </div>\n    {/if}\n  </div>\n{/snippet}\n\n<div class=\"user-list\">\n  <h2>All Users</h2>\n  {#each users as user (user.id)}\n    {@render userProfile(user)}\n  {/each}\n</div>\n\n<div class=\"detailed-view\">\n  <h2>Active Users (Detailed)</h2>\n  {#each users.filter(u => new Date(u.lastActive) > new Date(now - 14 * 24 * 60 * 60 * 1000)) as user (user.id)}\n    {@render userProfile(user, true, false)}\n  {/each}\n</div>\n```\n\n### Combining with Control Flow Inside Snippets\n\nYou can also use other Svelte control flow structures inside snippets, each with their own `{@const}` declarations:\n\n```svelte\n{#snippet dataTable(items, columns, sortable = false)}\n  {@const hasItems = items.length > 0}\n  \n  <table class=\"data-table\" class:sortable>\n    <thead>\n      <tr>\n        {#each columns as column}\n          <th>{column.label}</th>\n        {/each}\n      </tr>\n    </thead>\n    <tbody>\n      {#if hasItems}\n        {#each items as item (item.id)}\n          <tr>\n            {#each columns as column}\n              {@const value = item[column.key]}\n              {@const formattedValue = column.format ? column.format(value) : value}\n              \n              <td class={column.class || ''}>\n                {formattedValue}\n              </td>\n            {/each}\n          </tr>\n        {/each}\n      {:else}\n        <tr>\n          <td colspan={columns.length} class=\"empty-state\">\n            No data available\n          </td>\n        </tr>\n      {/if}\n    </tbody>\n  </table>\n{/snippet}\n```\n\nThis pattern of combining `{@const}` with snippets in Svelte 5 creates a powerful way to build reusable, efficient template fragments that encapsulate both presentation and the calculations needed to support that presentation."}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"What are the limitations of the `{@const}` tag, and when should you avoid using it in favor of other approaches?","answer":"While the `{@const}` tag is a powerful feature in Svelte, it has several limitations and there are scenarios where alternative approaches might be more appropriate. Understanding these limitations helps you make better decisions about when and how to use `{@const}` in your templates.\n\n### Limitations of the `{@const}` Tag\n\n1. **Placement Restrictions**\n   The `{@const}` tag can only be used as an immediate child of:\n   - A block (`{#if ...}`, `{#each ...}`, etc.)\n   - A component (`<Component />`)\n   - A `<svelte:boundary>` element\n\n   It cannot be placed directly in the template outside these contexts or nested within regular HTML elements.\n\n2. **No Multi-Declaration Support**\n   Unlike JavaScript's `const` keyword, you cannot declare multiple constants in a single `{@const}` tag:\n   ```svelte\n   <!-- This is not valid -->\n   {@const x = 1, y = 2}\n   ```\n\n3. **Immutability**\n   Constants defined with `{@const}` cannot be reassigned or mutated. While this is generally a good practice, it can be limiting in some scenarios.\n\n4. **No Asynchronous Evaluation**\n   The expressions in `{@const}` are evaluated synchronously during rendering. You cannot use `await` directly within the expression.\n\n5. **No Reactive Declarations**\n   Unlike `$:` reactive statements in the `<script>` section, `{@const}` declarations are not reactive themselves. They are recalculated only when their containing block is re-rendered.\n\n6. **Scoping Limitations**\n   Constants are scoped to their containing block and not accessible outside it, which can be limiting when you need to share values across different parts of the template.\n\n### When to Avoid Using `{@const}`\n\n1. **When You Need Component-Wide Access**\n   If a value needs to be accessed throughout the component (not just in a specific block), define it in the `<script>` section instead:\n\n   ```svelte\n   <script>\n     // Better for component-wide values\n     const apiBaseUrl = 'https://api.example.com';\n     \n     // Better as a reactive declaration if it depends on other values\n     $: totalPrice = items.reduce((sum, item) => sum + item.price, 0);\n   </script>\n   ```\n\n2. **For Reactive Values That Update Independently**\n   When you need a value to update reactively in response to changes, regardless of whether its containing block is re-rendered, use a reactive declaration:\n\n   ```svelte\n   <script>\n     let width = 100;\n     let height = 50;\n     \n     // Updates whenever width or height changes\n     $: area = width * height;\n   </script>\n   \n   <input bind:value={width} type=\"number\">\n   <input bind:value={height} type=\"number\">\n   <p>Area: {area}</p>\n   ```\n\n3. **For Complex Logic or Side Effects**\n   If you need to include complex logic, conditionals, or side effects, use the script section:\n\n   ```svelte\n   <script>\n     let user = { name: 'Alice', role: 'admin' };\n     \n     // Complex logic with side effects belongs in the script\n     $: {\n       if (user.role === 'admin') {\n         console.log('Admin user detected');\n         loadAdminFeatures();\n       }\n     }\n   </script>\n   ```\n\n4. **When Defining Reusable Functions**\n   If you need to define functions that will be used in multiple places, put them in the script:\n\n   ```svelte\n   <script>\n     // Better in the script section\n     function formatCurrency(value) {\n       return new Intl.NumberFormat('en-US', {\n         style: 'currency',\n         currency: 'USD'\n       }).format(value);\n     }\n   </script>\n   ```\n\n5. **For Component Props or Exported Values**\n   When you need to expose values to parent components, use props in the script section:\n\n   ```svelte\n   <script>\n     // These need to be in the script section to be exported\n     export let title;\n     export let showDetails = false;\n   </script>\n   ```\n\n6. **When You Need to Mutate the Value**\n   If you need to modify the value later, use `let` in the script section:\n\n   ```svelte\n   <script>\n     let counter = 0;\n     \n     function increment() {\n       counter++;\n     }\n   </script>\n   ```\n\n### Comparison with Alternatives\n\nHere's a comparison between `{@const}` and alternative approaches:\n\n```svelte\n<script>\n  let items = [\n    { id: 1, name: 'Product A', price: 10 },\n    { id: 2, name: 'Product B', price: 20 },\n    { id: 3, name: 'Product C', price: 30 }\n  ];\n  \n  // Component-wide constant (use when needed throughout the component)\n  const TAX_RATE = 0.08;\n  \n  // Reactive declaration (use when value should update automatically)\n  $: totalBeforeTax = items.reduce((sum, item) => sum + item.price, 0);\n  $: totalAfterTax = totalBeforeTax * (1 + TAX_RATE);\n  \n  // Helper function (use for reusable logic)\n  function calculateDiscount(price, rate = 0.1) {\n    return price * (1 - rate);\n  }\n</script>\n\n<div>\n  <h2>Order Summary</h2>\n  <p>Subtotal: ${totalBeforeTax.toFixed(2)}</p>\n  <p>Tax: ${(totalBeforeTax * TAX_RATE).toFixed(2)}</p>\n  <p>Total: ${totalAfterTax.toFixed(2)}</p>\n  \n  <h3>Items</h3>\n  <ul>\n    {#each items as item (item.id)}\n      <!-- Block-scoped constant (use for values specific to this iteration) -->\n      {@const discountedPrice = calculateDiscount(item.price)}\n      {@const savings = item.price - discountedPrice}\n      \n      <li>\n        {item.name} - ${item.price.toFixed(2)}\n        <span class=\"discount\">\n          Sale price: ${discountedPrice.toFixed(2)} (Save ${savings.toFixed(2)})\n        </span>\n      </li>\n    {/each}\n  </ul>\n</div>\n```\n\nIn summary, while `{@const}` is excellent for optimizing template-specific calculations and improving readability, it should be used judiciously alongside other Svelte features like reactive declarations, component props, and helper functions based on the specific requirements of your code."}
{"source":"docs/svelte/03-template-syntax/09-@const.md","question":"How can you effectively combine `{@const}` with other Svelte template features like keyed `{#each}` blocks and reactive statements to optimize performance?","answer":"Combining `{@const}` with other Svelte template features creates powerful patterns for optimizing performance. By strategically using `{@const}` alongside keyed `{#each}` blocks, reactive statements, and other Svelte features, you can build templates that are both efficient and maintainable.\n\n### Combining `{@const}` with Keyed `{#each}` Blocks\n\nKeyed `{#each}` blocks help Svelte track which items have changed, added, or removed. When combined with `{@const}`, you can optimize both rendering and computation:\n\n```svelte\n<script>\n  let products = [\n    { id: 'p1', name: 'Laptop', basePrice: 999, discount: 0.1, stock: 23 },\n    { id: 'p2', name: 'Phone', basePrice: 699, discount: 0.05, stock: 42 },\n    { id: 'p3', name: 'Tablet', basePrice: 499, discount: 0.15, stock: 15 }\n  ];\n  \n  let taxRate = 0.08;\n  \n  function addProduct() {\n    const newProduct = { \n      id: 'p' + (products.length + 1), \n      name: 'New Product', \n      basePrice: 299, \n      discount: 0.1, \n      stock: 10 \n    };\n    products = [...products, newProduct];\n  }\n  \n  function updatePrices() {\n    products = products.map(p => ({\n      ...p,\n      basePrice: p.basePrice * 1.05 // 5% price increase\n    }));\n  }\n</script>\n\n<button on:click={addProduct}>Add Product</button>\n<button on:click={updatePrices}>Increase Prices</button>\n\n<div class=\"product-grid\">\n  {#each products as product (product.id)}\n    {@const discountAmount = product.basePrice * product.discount}\n    {@const discountedPrice = product.basePrice - discountAmount}\n    {@const finalPrice = discountedPrice * (1 + taxRate)}\n    {@const isLowStock = product.stock < 20}\n    \n    <div class=\"product-card\" class:low-stock={isLowStock}>\n      <h3>{product.name}</h3>\n      <div class=\"pricing\">\n        <p class=\"original-price\">${product.basePrice.toFixed(2)}</p>\n        <p class=\"discount\">-${discountAmount.toFixed(2)} ({product.discount * 100}% off)</p>\n        <p class=\"price\">${discountedPrice.toFixed(2)}</p>\n        <p class=\"final-price\">Final price: ${finalPrice.toFixed(2)} (incl. tax)</p>\n      </div>\n      <div class=\"stock\" class:warning={isLowStock}>\n        {product.stock} in stock\n        {#if isLowStock}\n          <span class=\"stock-warning\">Low stock!</span>\n        {/if}\n      </div>\n    </div>\n  {/each}\n</div>\n```\n\nIn this example:\n- The `(product.id)` key ensures Svelte efficiently updates only changed items\n- `{@const}` calculations are performed only for affected items when products change\n- The combination ensures optimal performance even when adding or updating products\n\n### Combining `{@const}` with Reactive Statements\n\nWhile `{@const}` handles template-level calculations, reactive statements in the script section can prepare data that multiple template sections might need:\n\n```svelte\n<script>\n  let orders = [\n    { id: 1, customer: 'Alice', items: [\n      { product: 'Laptop', price: 999, quantity: 1 },\n      { product: 'Mouse', price: 25, quantity: 2 }\n    ]},\n    { id: 2, customer: 'Bob', items: [\n      { product: 'Tablet', price: 499, quantity: 1 },\n      { product: 'Keyboard', price: 45, quantity: 1 }\n    ]}\n  ];\n  \n  // Reactive calculations for component-wide data\n  $: totalOrderValue = orders.reduce((sum, order) => \n    sum + order.items.reduce((itemSum, item) => \n      itemSum + (item.price * item.quantity), 0), 0);\n      \n  $: averageOrderValue = orders.length ? totalOrderValue / orders.length : 0;\n  \n  $: orderSummary = orders.map(order => {\n    const orderTotal = order.items.reduce((sum, item) => \n      sum + (item.price * item.quantity), 0);\n    return {\n      id: order.id,\n      customer: order.customer,\n      itemCount: order.items.length,\n      total: orderTotal\n    };\n  });\n</script>\n\n<div class=\"dashboard\">\n  <div class=\"summary\">\n    <h2>Order Summary</h2>\n    <p>Total Orders: {orders.length}</p>\n    <p>Total Value: ${totalOrderValue.toFixed(2)}</p>\n    <p>Average Order: ${averageOrderValue.toFixed(2)}</p>\n  </div>\n  \n  <div class=\"order-list\">\n    <h2>Orders</h2>\n    {#each orderSummary as order (order.id)}\n      <div class=\"order-card\">\n        <h3>Order #{order.id}</h3>\n        <p>Customer: {order.customer}</p>\n        <p>Items: {order.itemCount}</p>\n        <p>Total: ${order.total.toFixed(2)}</p>\n        \n        <button>View Details</button>\n      </div>\n    {/each}\n  </div>\n  \n  <div class=\"order-details\">\n    <h2>Order Details</h2>\n    {#each orders as order (order.id)}\n      <details>\n        <summary>Order #{order.id} - {order.customer}</summary>\n        \n        <table>\n          <thead>\n            <tr>\n              <th>Product</th>\n              <th>Price</th>\n              <th>Quantity</th>\n              <th>Subtotal</th>\n            </tr>\n          </thead>\n          <tbody>\n            {#each order.items as item}\n              {@const subtotal = item.price * item.quantity}\n              {@const isHighValue = subtotal > 500}\n              \n              <tr class:high-value={isHighValue}>\n                <td>{item.product}</td>\n                <td>${item.price.toFixed(2)}</td>\n                <td>{item.quantity}</td>\n                <td>${subtotal.toFixed(2)}</td>\n              </tr>\n            {/each}\n          </tbody>\n          <tfoot>\n            {@const orderTotal = order.items.reduce((sum, item) => \n              sum + (item.price * item.quantity), 0)}\n            {@const shipping = orderTotal > 1000 ? 0 : 25}\n            \n            <tr>\n              <td colspan=\"3\">Subtotal</td>\n              <td>${orderTotal.toFixed(2)}</td>\n            </tr>\n            <tr>\n              <td colspan=\"3\">Shipping</td>\n              <td>${shipping.toFixed(2)}</td>\n            </tr>\n            <tr class=\"total\">\n              <td colspan=\"3\">Total</td>\n              <td>${(orderTotal + shipping).toFixed(2)}</td>\n            </tr>\n          </tfoot>\n        </table>\n      </details>\n    {/each}\n  </div>\n</div>\n```\n\nIn this example:\n- Reactive statements (`$:`) calculate component-wide values and prepare data structures\n- `{@const}` handles calculations specific to template blocks\n- The combination provides optimal performance by computing values at the appropriate level\n\n### Advanced Performance Optimization: Combining with `{#key}`\n\nThe `{#key}` block in Svelte recreates its contents when the key changes. Combined with `{@const}`, you can optimize expensive calculations to run only when specific values change:\n\n```svelte\n<script>\n  let selectedProductId = 'p1';\n  let quantity = 1;\n  \n  let products = {\n    p1: { name: 'Basic Widget', price: 10, weight: 1 },\n    p2: { name: 'Premium Widget', price: 25, weight: 2 },\n    p3: { name: 'Deluxe Widget', price: 50, weight: 3 }\n  };\n  \n  function selectProduct(id) {\n    selectedProductId = id;\n  }\n</script>\n\n<div class=\"product-selector\">\n  <div class=\"options\">\n    {#each Object.entries(products) as [id, product]}\n      <button \n        class:selected={id === selectedProductId}\n        on:click={() => selectProduct(id)}\n      >\n        {product.name}\n      </button>\n    {/each}\n  </div>\n  \n  <div class=\"quantity\">\n    <label>\n      Quantity:\n      <input type=\"number\" bind:value={quantity} min=\"1\" max=\"100\">\n    </label>\n  </div>\n\n  {#key selectedProductId}\n    {@const product = products[selectedProductId]}\n    {@const basePrice = product.price}\n    \n    <div class=\"product-details\">\n      <h3>{product.name}</h3>\n      <p>Price: ${basePrice.toFixed(2)}</p>\n      \n      {#key quantity}\n        {@const subtotal = basePrice * quantity}\n        {@const bulkDiscount = quantity >= 10 ? 0.1 : 0}\n        {@const volumeDiscount = quantity >= 25 ? 0.15 : bulkDiscount}\n        {@const discountAmount = subtotal * volumeDiscount}\n        {@const finalPrice = subtotal - discountAmount}\n        {@const shippingWeight = product.weight * quantity}\n        {@const shippingCost = shippingWeight * 2}\n        \n        <div class=\"order-summary\">\n          <p>Subtotal: ${subtotal.toFixed(2)}</p>\n          \n          {#if volumeDiscount > 0}\n            <p class=\"discount\">\n              Discount ({volumeDiscount * 100}%): -${discountAmount.toFixed(2)}\n            </p>\n          {/if}\n          \n          <p>Price after discount: ${finalPrice.toFixed(2)}</p>\n          <p>Shipping (${shippingWeight.toFixed(1)} lbs): ${shippingCost.toFixed(2)}</p>\n          <p class=\"total\">Total: ${(finalPrice + shippingCost).toFixed(2)}</p>\n        </div>\n      {/key}\n    </div>\n  {/key}\n</div>\n```\n\nIn this example:\n- The outer `{#key selectedProductId}` block recalculates product-specific constants only when the product changes\n- The inner `{#key quantity}` block recalculates quantity-dependent values only when the quantity changes\n- `{@const}` defines the values that are calculated within each key block\n- This nested approach ensures optimal performance by minimizing recalculations\n\n### Best Practices for Combining Features\n\n1. **Use reactive statements for component-wide values**\n   ```svelte\n   <script>\n     $: totalItems = items.length;\n     $: isEmpty = totalItems === 0;\n   </script>\n   ```\n\n2. **Use keyed `{#each}` for efficient list rendering**\n   ```svelte\n   {#each items as item (item.id)}\n     <!-- content -->\n   {/each}\n   ```\n\n3. **Use `{@const}` for block-specific calculations**\n   ```svelte\n   {#each items as item (item.id)}\n     {@const itemTotal = item.price * item.quantity}\n     <!-- use itemTotal multiple times -->\n   {/each}\n   ```\n\n4. **Use `{#key}` for isolating reactive dependencies**\n   ```svelte\n   {#key selectedFilter}\n     {@const filteredItems = applyFilter(items, selectedFilter)}\n     <!-- filtered content -->\n   {/key}\n   ```\n\n5. **Combine all techniques for maximum optimization**\n   ```svelte\n   <script>\n     // Component-wide reactive calculations\n     $: visibleCategories = [...new Set(items.map(item => item.category))];\n   </script>\n   \n   {#each visibleCategories as category (category)}\n     {#key category}\n       {@const categoryItems = items.filter(item => item.category === category)}\n       {@const categoryTotal = categoryItems.reduce((sum, item) => sum + item.price, 0)}\n       \n       <div class=\"category\">\n         <h3>{category}</h3>\n         <p>Items: {categoryItems.length}</p>\n         <p>Total: ${categoryTotal.toFixed(2)}</p>\n         \n         {#each categoryItems as item (item.id)}\n           {@const itemDiscount = item.price * (item.discountRate || 0)}\n           {@const finalPrice = item.price - itemDiscount}\n           \n           <div class=\"item\">\n             <!-- item details -->\n           </div>\n         {/each}\n       </div>\n     {/key}\n   {/each}\n   ```\n\nBy strategically combining `{@const}` with keyed blocks, reactive statements, and other Svelte features, you can create templates that are both highly performant and maintainable, ensuring calculations happen at the right scope and only when necessary."}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"What is the purpose of the `{@debug ...}` tag in Svelte, and how does it differ from using `console.log()`?","answer":"The `{@debug ...}` tag in Svelte provides a specialized debugging tool that offers advantages over traditional `console.log()` statements. Its primary purpose is to monitor specific variables and log their values whenever they change. \n\nThe key differences from `console.log()` are:\n1. It automatically triggers when the specified variables change, without you having to place logs at specific points in your code\n2. It pauses code execution if you have developer tools open, similar to a breakpoint\n3. It's integrated with Svelte's reactivity system, so it's aware of Svelte's state changes\n\nFor example:\n```svelte\n<script>\n  let user = {\n    firstname: 'Ada',\n    lastname: 'Lovelace'\n  };\n</script>\n\n{@debug user}\n\n<h1>Hello {user.firstname}!</h1>\n```\n\nIn this example, whenever the `user` object changes, Svelte will log the current value and pause execution if devtools are open, making it easier to inspect the state at that exact moment."}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"What syntax restrictions apply to the `{@debug ...}` tag in Svelte?","answer":"The `{@debug ...}` tag in Svelte has specific syntax restrictions that developers need to be aware of. It only accepts a comma-separated list of variable names, not arbitrary expressions or complex operations.\n\nValid syntax includes:\n```svelte\n{@debug user}\n{@debug user1, user2, user3}\n```\n\nThe following examples will NOT compile because they contain expressions rather than simple variable names:\n```svelte\n{@debug user.firstname}     // Property access not allowed\n{@debug myArray[0]}         // Array indexing not allowed\n{@debug !isReady}           // Logical operations not allowed\n{@debug typeof user === 'object'}  // Comparisons not allowed\n```\n\nThese restrictions exist because the `{@debug ...}` tag is designed to track specific variables in their entirety, not computed values or partial properties. If you need to debug specific properties or expressions, you would need to create separate variables for them or use traditional console logging."}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"What happens when you use the `{@debug}` tag without any arguments in a Svelte component?","answer":"When you use the `{@debug}` tag without any arguments in a Svelte component, it inserts a `debugger` statement that gets triggered whenever *any* state in the component changes, rather than monitoring specific variables.\n\n```svelte\n<script>\n  let count = 0;\n  let name = \"Svelte\";\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n\n{@debug}\n\n<button on:click={increment}>Increment</button>\n<p>Count: {count}</p>\n<p>Name: {name}</p>\n```\n\nIn this example, the debugger will pause execution whenever either `count` or `name` changes. This is useful for general debugging when you want to inspect the component state after any change occurs, without having to specify which variables to watch.\n\nThis \"catch-all\" approach is particularly helpful when:\n1. You're not sure which state is causing an issue\n2. You want to observe the timing of all state changes\n3. You're debugging complex components with many interrelated state variables\n\nHowever, it should be used sparingly in production code as it will trigger frequently in components with many reactive variables."}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"How would you debug multiple variables simultaneously using the `{@debug ...}` tag?","answer":"To debug multiple variables simultaneously using the `{@debug ...}` tag, you can provide a comma-separated list of variable names. This allows you to monitor changes to several variables at once without needing multiple debug tags.\n\n```svelte\n<script>\n  let count = 0;\n  let doubleCount = 0;\n  let name = \"Svelte\";\n  \n  $: doubleCount = count * 2;\n  \n  function increment() {\n    count += 1;\n  }\n  \n  function updateName(newName) {\n    name = newName;\n  }\n</script>\n\n{@debug count, doubleCount, name}\n\n<button on:click={increment}>Increment</button>\n<button on:click={() => updateName(\"Svelte 5\")}>Update Name</button>\n<p>Count: {count}</p>\n<p>Double Count: {doubleCount}</p>\n<p>Name: {name}</p>\n```\n\nIn this example, the debugger will be triggered whenever any of the three variables (`count`, `doubleCount`, or `name`) changes. The console will show the current values of all three variables, making it easier to understand their relationships and how they change together.\n\nThis approach is particularly useful when:\n1. You're tracking related variables that should change together\n2. You're debugging derived values (like `doubleCount` in this example)\n3. You want to reduce clutter by using a single debug statement instead of multiple ones"}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"In what part of a Svelte component should the `{@debug ...}` tag be placed, and does its position matter?","answer":"The `{@debug ...}` tag can be placed anywhere within the markup section of a Svelte component (outside the `<script>` and `<style>` blocks). Its position in the template doesn't affect when it gets triggered - it will always monitor the specified variables regardless of where it appears in the markup.\n\n```svelte\n<script>\n  let user = {\n    firstname: 'Ada',\n    lastname: 'Lovelace'\n  };\n</script>\n\n<!-- The debug tag can be at the beginning -->\n{@debug user}\n\n<h1>Hello {user.firstname}!</h1>\n\n<!-- Or in the middle of your markup -->\n<div>\n  {@debug user}\n  <p>Last name: {user.lastname}</p>\n</div>\n\n<!-- Or at the end -->\n<button on:click={() => user.firstname = 'Grace'}>\n  Change to Grace\n</button>\n{@debug user}\n```\n\nAll three `{@debug user}` tags in this example will behave identically - they'll trigger whenever the `user` object changes, regardless of their position in the template.\n\nWhile the position doesn't matter functionally, there are some best practices to consider:\n1. Place debug tags near the elements that use the variables being debugged for better code readability\n2. Group debug tags together at the top of your template when debugging multiple sets of variables\n3. Remember that the tags will appear in your rendered DOM during development, so consider their placement for a cleaner development experience"}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"How does the `{@debug ...}` tag interact with Svelte's reactivity system, particularly with derived values?","answer":"The `{@debug ...}` tag in Svelte is deeply integrated with Svelte's reactivity system. It monitors the specified variables and triggers whenever Svelte detects a change to those variables. This makes it particularly useful for understanding reactive updates and derived values.\n\nWhen working with derived values (using the `$:` syntax), the `{@debug ...}` tag can help visualize the reactive flow:\n\n```svelte\n<script>\n  let count = 0;\n  let multiplier = 2;\n  \n  // Derived values\n  $: doubled = count * multiplier;\n  $: message = count > 5 ? \"Count is high\" : \"Count is low\";\n  \n  function increment() {\n    count += 1;\n  }\n  \n  function updateMultiplier(value) {\n    multiplier = value;\n  }\n</script>\n\n{@debug count, doubled, message}\n\n<button on:click={increment}>Increment</button>\n<input type=\"number\" bind:value={multiplier} min=\"1\" max=\"10\" />\n\n<p>Count: {count}</p>\n<p>Doubled: {doubled}</p>\n<p>{message}</p>\n```\n\nIn this example, the debug tag will trigger in several scenarios:\n1. When `count` changes directly through the `increment` function\n2. When `multiplier` changes through the input binding\n3. When `doubled` changes as a result of either `count` or `multiplier` changing\n4. When `message` changes as a result of `count` crossing the threshold of 5\n\nThis allows you to observe the cascade of reactive updates. Note that even though we're debugging derived values (`doubled` and `message`), we can only list the variable names in the debug tag, not the expressions that define them.\n\nThe `{@debug ...}` tag is particularly valuable for understanding complex reactivity chains and diagnosing issues where derived values aren't updating as expected."}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"What are the limitations of the `{@debug ...}` tag when working with nested properties or complex data structures?","answer":"The `{@debug ...}` tag in Svelte has significant limitations when working with nested properties or complex data structures. The primary limitation is that you can only debug top-level variables, not specific properties or nested values.\n\nFor example, with a complex user object:\n\n```svelte\n<script>\n  let user = {\n    name: {\n      first: 'Ada',\n      last: 'Lovelace'\n    },\n    contacts: [\n      { type: 'email', value: 'ada@example.com' },\n      { type: 'phone', value: '123-456-7890' }\n    ],\n    preferences: {\n      theme: 'dark',\n      notifications: true\n    }\n  };\n</script>\n\n{@debug user}\n\n<h1>Hello {user.name.first}!</h1>\n```\n\nIn this case, `{@debug user}` will show the entire user object whenever any part of it changes. You cannot do something like `{@debug user.name.first}` or `{@debug user.contacts[0].value}` to monitor specific nested properties.\n\nThis creates several challenges:\n\n1. **Verbosity**: When debugging a large object, the console output can be overwhelming since the entire object is logged, not just the changed properties.\n\n2. **Specificity**: It's harder to focus on specific nested properties you're interested in.\n\n3. **Performance**: For very large objects, constantly logging the entire structure can impact performance during development.\n\nTo work around these limitations, you have several options:\n\n1. **Create separate variables for nested properties you want to debug:**\n```svelte\n<script>\n  let user = {\n    name: {\n      first: 'Ada',\n      last: 'Lovelace'\n    }\n  };\n  \n  // Extract the property you want to debug\n  let firstName = user.name.first;\n  \n  // Keep it in sync with the original\n  $: firstName = user.name.first;\n</script>\n\n{@debug firstName}\n\n<h1>Hello {firstName}!</h1>\n```\n\n2. **Use traditional console logging at specific points:**\n```svelte\n<script>\n  let user = {\n    name: {\n      first: 'Ada'\n    }\n  };\n  \n  $: console.log('First name changed:', user.name.first);\n  \n  function updateName() {\n    user.name.first = 'Grace';\n  }\n</script>\n\n<button on:click={updateName}>Update Name</button>\n```\n\n3. **Use the `{@debug}` tag without arguments to catch all changes and inspect in devtools:**\n```svelte\n<script>\n  let user = { /* complex object */ };\n</script>\n\n{@debug}\n```"}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"How can the `{@debug ...}` tag be effectively used during component development and what are best practices for removing it before production?","answer":"The `{@debug ...}` tag is a powerful tool during Svelte component development, but it should be used strategically and removed before deploying to production. Here are effective usage patterns and best practices:\n\n### Effective Usage During Development\n\n1. **Start with broad debugging and narrow down:**\n```svelte\n<script>\n  let formData = { username: '', email: '', password: '' };\n  let validationErrors = { username: null, email: null, password: null };\n  let isSubmitting = false;\n</script>\n\n<!-- First, debug everything -->\n{@debug}\n\n<!-- Then narrow down to specific variables causing issues -->\n{@debug formData, validationErrors}\n\n<!-- Finally, focus on just the problematic variable -->\n{@debug validationErrors}\n```\n\n2. **Debug at critical points in your component lifecycle:**\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let data = [];\n  let isLoading = true;\n  let error = null;\n  \n  onMount(async () => {\n    try {\n      const response = await fetch('/api/data');\n      data = await response.json();\n    } catch (e) {\n      error = e;\n    } finally {\n      isLoading = false;\n    }\n  });\n</script>\n\n{@debug isLoading, data, error}\n```\n\n3. **Debug form interactions:**\n```svelte\n<script>\n  let formValues = { name: '', email: '' };\n  let isValid = false;\n  \n  $: isValid = formValues.name.length > 0 && formValues.email.includes('@');\n</script>\n\n{@debug formValues, isValid}\n\n<form>\n  <input bind:value={formValues.name} placeholder=\"Name\" />\n  <input bind:value={formValues.email} placeholder=\"Email\" />\n  <button disabled={!isValid}>Submit</button>\n</form>\n```\n\n### Best Practices for Removing Before Production\n\n1. **Comment-based system for easy removal:**\n```svelte\n<script>\n  let user = { name: 'Ada' };\n  \n  // DEBUG: Remove before production\n  $: console.log('User updated:', user);\n</script>\n\n{/* DEBUG: Remove before production */}\n{@debug user}\n```\n\n2. **Use environment variables to conditionally include debugging:**\n```svelte\n<script>\n  import { dev } from '$app/environment'; // SvelteKit environment helper\n  \n  let count = 0;\n</script>\n\n{#if dev}\n  {@debug count}\n{/if}\n```\n\n3. **Use build-time preprocessors or ESLint rules** to detect and warn about debug tags in production builds.\n\n4. **Create a debugging component** that only renders in development:\n```svelte\n<!-- Debug.svelte -->\n<script>\n  export let variables = [];\n  import { dev } from '$app/environment';\n</script>\n\n{#if dev}\n  {#each Object.entries(variables) as [name, value]}\n    {@debug value}\n  {/each}\n{/if}\n```\n\n```svelte\n<!-- YourComponent.svelte -->\n<script>\n  import Debug from './Debug.svelte';\n  \n  let count = 0;\n  let name = 'Svelte';\n</script>\n\n<Debug variables={{ count, name }} />\n```\n\n5. **Add debug removal to your CI/CD pipeline** to ensure debug tags don't make it to production.\n\nBy following these practices, you can use the `{@debug ...}` tag effectively during development while ensuring it doesn't impact your production application's performance or expose sensitive information."}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"How does the `{@debug ...}` tag behave differently when used inside conditional blocks or loops in Svelte?","answer":"The `{@debug ...}` tag behaves in specific ways when used inside conditional blocks (`{#if}`, `{:else if}`, `{:else}`) or loops (`{#each}`, `{#await}`) in Svelte. Understanding these behaviors is important for effective debugging of complex components.\n\n### Inside Conditional Blocks\n\nWhen placed inside a conditional block, the `{@debug ...}` tag only monitors variables when that block is rendered:\n\n```svelte\n<script>\n  let count = 0;\n  let threshold = 5;\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n\n{#if count < threshold}\n  {@debug count}\n  <p>Count is below threshold: {count}</p>\n{:else}\n  {@debug count}\n  <p>Count is at or above threshold: {count}</p>\n{/if}\n\n<button on:click={increment}>Increment</button>\n```\n\nIn this example:\n- The first `{@debug count}` only triggers when `count < threshold`\n- The second `{@debug count}` only triggers when `count >= threshold`\n- When the condition changes, one debug tag stops monitoring while the other begins\n\nThis can be useful for debugging specific states of your component, but it also means you might miss some updates if the condition changes frequently.\n\n### Inside Loops\n\nWhen used inside a loop, the `{@debug ...}` tag creates separate debug points for each iteration:\n\n```svelte\n<script>\n  let items = [\n    { id: 1, name: 'Apple' },\n    { id: 2, name: 'Banana' },\n    { id: 3, name: 'Cherry' }\n  ];\n  \n  function addItem() {\n    items = [...items, { id: items.length + 1, name: 'New Item' }];\n  }\n  \n  function updateItem(id, newName) {\n    items = items.map(item => \n      item.id === id ? { ...item, name: newName } : item\n    );\n  }\n</script>\n\n<ul>\n  {#each items as item (item.id)}\n    <li>\n      {@debug item}\n      {item.name}\n      <button on:click={() => updateItem(item.id, item.name + '!')}>\n        Update\n      </button>\n    </li>\n  {/each}\n</ul>\n\n<button on:click={addItem}>Add Item</button>\n```\n\nIn this example:\n- A separate `{@debug item}` instance is created for each item in the array\n- Each debug tag only monitors changes to its specific item\n- When items are added or removed, debug tags are created or destroyed accordingly\n\nThis allows for granular debugging of specific items in a list, but can lead to many debug points if your list is large.\n\n### Inside Await Blocks\n\nThe `{@debug ...}` tag is particularly useful inside `{#await}` blocks for debugging asynchronous operations:\n\n```svelte\n<script>\n  let promise = fetchData();\n  \n  async function fetchData() {\n    const response = await fetch('/api/data');\n    return await response.json();\n  }\n  \n  function refreshData() {\n    promise = fetchData();\n  }\n</script>\n\n{#await promise}\n  {@debug promise}\n  <p>Loading...</p>\n{:then data}\n  {@debug data}\n  <ul>\n    {#each data as item}\n      <li>{item.name}</li>\n    {/each}\n  </ul>\n{:catch error}\n  {@debug error}\n  <p>Error: {error.message}</p>\n{/await}\n\n<button on:click={refreshData}>Refresh</button>\n```\n\nIn this example:\n- The first debug tag monitors the promise itself\n- The second debug tag monitors the resolved data\n- The third debug tag monitors any errors that occur\n\nThis pattern is excellent for debugging async flows and understanding the data at each stage of the promise lifecycle."}
{"source":"docs/svelte/03-template-syntax/10-@debug.md","question":"How does the `{@debug ...}` tag interact with Svelte's component lifecycle, and can it be used to debug component initialization and cleanup?","answer":"The `{@debug ...}` tag in Svelte interacts with the component lifecycle in specific ways that can be leveraged to debug component initialization, updates, and cleanup. Understanding this interaction helps developers gain insights into component behavior throughout its lifecycle.\n\n### Component Initialization\n\nThe `{@debug ...}` tag becomes active as soon as the component is mounted and the initial values of the monitored variables are established:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let initialized = false;\n  let mountTime = null;\n  \n  onMount(() => {\n    initialized = true;\n    mountTime = new Date();\n    return () => {\n      console.log('Component unmounted');\n    };\n  });\n</script>\n\n{@debug initialized, mountTime}\n\n<div>\n  {#if initialized}\n    <p>Component initialized at: {mountTime.toLocaleTimeString()}</p>\n  {:else}\n    <p>Component initializing...</p>\n  {/if}\n</div>\n```\n\nIn this example, the `{@debug ...}` tag will show the initial values (`initialized = false, mountTime = null`) and then trigger again when these values change during the `onMount` lifecycle hook.\n\n### Debugging Component Lifecycle Events\n\nWhile the `{@debug ...}` tag doesn't directly hook into lifecycle events, you can use it in conjunction with lifecycle-tracking variables:\n\n```svelte\n<script>\n  import { onMount, beforeUpdate, afterUpdate, onDestroy } from 'svelte';\n  \n  let lifecycle = {\n    mounted: false,\n    updateCount: 0,\n    lastUpdateTime: null,\n    destroying: false\n  };\n  \n  let props = {\n    name: 'Svelte Component',\n    value: 0\n  };\n  \n  onMount(() => {\n    lifecycle.mounted = true;\n  });\n  \n  beforeUpdate(() => {\n    lifecycle.updateCount++;\n    lifecycle.lastUpdateTime = new Date();\n  });\n  \n  onDestroy(() => {\n    lifecycle.destroying = true;\n  });\n  \n  function incrementValue() {\n    props.value += 1;\n  }\n</script>\n\n{@debug lifecycle}\n{@debug props}\n\n<div>\n  <h2>{props.name}</h2>\n  <p>Value: {props.value}</p>\n  <p>Update count: {lifecycle.updateCount}</p>\n  {#if lifecycle.lastUpdateTime}\n    <p>Last updated: {lifecycle.lastUpdateTime.toLocaleTimeString()}</p>\n  {/if}\n  <button on:click={incrementValue}>Update</button>\n</div>\n```\n\nThis approach allows you to monitor how different lifecycle events affect your component's state.\n\n### Debugging Prop Changes\n\nYou can use the `{@debug ...}` tag to monitor props passed to a component:\n\n```svelte\n<!-- ChildComponent.svelte -->\n<script>\n  export let name = 'Default';\n  export let count = 0;\n  \n  let internalState = 'Initial';\n  \n  $: {\n    console.log(`Prop 'count' changed to ${count}`);\n    if (count > 5) {\n      internalState = 'High Count';\n    } else {\n      internalState = 'Low Count';\n    }\n  }\n</script>\n\n{@debug name, count, internalState}\n\n<div>\n  <h3>{name}</h3>\n  <p>Count: {count}</p>\n  <p>State: {internalState}</p>\n</div>\n```\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n  \n  let childName = 'Child Component';\n  let childCount = 0;\n  \n  function incrementChild() {\n    childCount += 1;\n  }\n  \n  function changeName() {\n    childName = childName === 'Child Component' \n      ? 'Updated Component' \n      : 'Child Component';\n  }\n</script>\n\n<ChildComponent name={childName} count={childCount} />\n<button on:click={incrementChild}>Increment Child Count</button>\n<button on:click={changeName}>Change Child Name</button>\n```\n\n### Debugging Cleanup and Component Destruction\n\nWhile the `{@debug ...}` tag won't trigger during unmounting (as the component is being removed from the DOM), you can use it to monitor variables that indicate impending destruction:\n\n```svelte\n<script>\n  import { onDestroy } from 'svelte';\n  \n  let isDestroying = false;\n  let cleanupTasks = {\n    disconnectDB: false,\n    clearCache: false,\n    saveState: false\n  };\n  \n  onDestroy(() => {\n    isDestroying = true;\n    \n    // Simulate cleanup tasks\n    cleanupTasks.disconnectDB = true;\n    cleanupTasks.clearCache = true;\n    cleanupTasks.saveState = true;\n    \n    console.log('Component destroyed, cleanup complete', cleanupTasks);\n  });\n</script>\n\n{@debug isDestroying, cleanupTasks}\n\n<div>\n  <h2>Component Status</h2>\n  <p>Destroying: {isDestroying ? 'Yes' : 'No'}</p>\n  <pre>{JSON.stringify(cleanupTasks, null, 2)}</pre>\n</div>\n```\n\n### Limitations with Lifecycle Debugging\n\nIt's important to note some limitations when using `{@debug ...}` for lifecycle debugging:\n\n1. The `{@debug ...}` tag won't trigger during the unmounting phase since the component is being removed\n2. Very rapid lifecycle events might cause multiple debug triggers in quick succession\n3. The tag can't directly hook into lifecycle methods - it only monitors variable changes\n\nFor more comprehensive lifecycle debugging, combining the `{@debug ...}` tag with strategic console logging in lifecycle hooks provides the most complete picture of component behavior."}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"Explain the concept of data flow in Svelte 5 and how the `bind:` directive changes this flow. What is the syntax for binding and when can you use the shorthand format?","answer":"In Svelte 5, data ordinarily flows downward from parent to child components. This is the standard unidirectional data flow pattern common in many modern frameworks. The `bind:` directive, however, allows data to flow bidirectionally - both from parent to child and from child back to parent.\n\nThe general syntax for binding is `bind:property={expression}`, where `expression` is an lvalue (a variable or object property that can appear on the left side of an assignment). \n\nYou can use a shorthand format when the property name and the variable name are identical. For example, these two are equivalent:\n\n```svelte\n<input bind:value={value} />\n<input bind:value />\n```\n\nBehind the scenes, Svelte creates an event listener that updates the bound value whenever it changes. If an element already has a listener for the same event, that listener will be fired before the bound value is updated.\n\nMost bindings in Svelte are two-way, meaning changes to the value will affect the element and vice versa. However, some bindings (like dimension bindings) are readonly, meaning changing their value programmatically will have no effect on the element."}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"How do function bindings work in Svelte 5? Provide examples for both two-way and readonly bindings.","answer":"Function bindings in Svelte 5 (available in version 5.9.0 and newer) allow you to perform validation and transformation on bound values using the syntax `bind:property={get, set}`, where `get` and `set` are functions.\n\nFor two-way bindings, you provide both a getter and setter function:\n\n```svelte\n<script>\n  let value = $state('HELLO WORLD');\n</script>\n\n<input bind:value={\n  () => value,\n  (v) => value = v.toLowerCase()\n}/>\n\n<p>The value is: {value}</p>\n```\n\nIn this example, the input will display the current value of the `value` variable, but whenever the user types something, the setter function will transform it to lowercase before updating the `value` variable.\n\nFor readonly bindings (like dimension bindings), you use `null` as the getter and provide only a setter function:\n\n```svelte\n<script>\n  let width;\n  let height;\n  \n  function redraw(newValue) {\n    console.log(`Dimension changed to ${newValue}`);\n    // Perform some operation when dimensions change\n  }\n</script>\n\n<div\n  bind:clientWidth={null, redraw}\n  bind:clientHeight={null, redraw}\n>\n  Resize me!\n</div>\n\n<p>Width: {width}px, Height: {height}px</p>\n```\n\nIn this case, Svelte will call the `redraw` function whenever the `clientWidth` or `clientHeight` changes, but you can't programmatically change these values since they're readonly properties."}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"How do form input bindings work in Svelte 5? Explain the different types of input bindings with examples.","answer":"Svelte 5 offers several ways to bind to form inputs, making it easy to work with user input. Here are the main types of input bindings:\n\n### 1. Text Input Binding (`bind:value`)\n\nFor standard text inputs, you can bind to the `value` property:\n\n```svelte\n<script>\n  let name = $state('');\n</script>\n\n<input bind:value={name} />\n<p>Hello, {name || 'stranger'}!</p>\n```\n\n### 2. Numeric Input Binding\n\nFor number inputs (`type=\"number\"` or `type=\"range\"`), Svelte automatically coerces the value to a number:\n\n```svelte\n<script>\n  let age = $state(25);\n  let volume = $state(50);\n</script>\n\n<label>\n  Age: <input type=\"number\" bind:value={age} min=\"0\" max=\"120\" />\n</label>\n\n<label>\n  Volume: <input type=\"range\" bind:value={volume} min=\"0\" max=\"100\" />\n</label>\n\n<p>In 10 years, you'll be {age + 10} years old.</p>\n<p>Volume level: {volume}%</p>\n```\n\nIf the input is empty or invalid, the bound value becomes `undefined`.\n\n### 3. Checkbox Binding (`bind:checked`)\n\nFor checkboxes, use `bind:checked`:\n\n```svelte\n<script>\n  let agreed = $state(false);\n  let wantNewsletter = $state(false);\n</script>\n\n<label>\n  <input type=\"checkbox\" bind:checked={agreed} />\n  I agree to the terms and conditions\n</label>\n\n<label>\n  <input type=\"checkbox\" bind:checked={wantNewsletter} />\n  Subscribe to newsletter\n</label>\n\n<button disabled={!agreed}>Submit</button>\n```\n\n### 4. Radio Button Groups (`bind:group`)\n\nRadio buttons can be grouped together with `bind:group`:\n\n```svelte\n<script>\n  let favoriteColor = $state('blue');\n</script>\n\n<label>\n  <input type=\"radio\" bind:group={favoriteColor} value=\"red\" />\n  Red\n</label>\n\n<label>\n  <input type=\"radio\" bind:group={favoriteColor} value=\"green\" />\n  Green\n</label>\n\n<label>\n  <input type=\"radio\" bind:group={favoriteColor} value=\"blue\" />\n  Blue\n</label>\n\n<p>Your favorite color is {favoriteColor}</p>\n```\n\n### 5. Checkbox Groups (`bind:group`)\n\nCheckbox groups bind to an array:\n\n```svelte\n<script>\n  let selectedFruits = $state([]);\n</script>\n\n<label>\n  <input type=\"checkbox\" bind:group={selectedFruits} value=\"apple\" />\n  Apple\n</label>\n\n<label>\n  <input type=\"checkbox\" bind:group={selectedFruits} value=\"banana\" />\n  Banana\n</label>\n\n<label>\n  <input type=\"checkbox\" bind:group={selectedFruits} value=\"orange\" />\n  Orange\n</label>\n\n<p>You selected: {selectedFruits.join(', ') || 'none'}</p>\n```\n\n### 6. File Input Binding (`bind:files`)\n\nFor file inputs, you can bind to the `files` property:\n\n```svelte\n<script>\n  let files = $state();\n  \n  function clear() {\n    files = new DataTransfer().files; // Empty FileList\n  }\n  \n  $effect(() => {\n    if (files && files.length > 0) {\n      console.log(`Selected ${files.length} files`);\n    }\n  });\n</script>\n\n<input type=\"file\" bind:files multiple />\n<button onclick={clear}>Clear selection</button>\n```\n\nNote that since Svelte 5.6.0, inputs with `defaultValue` or `defaultChecked` attributes that are part of a form will revert to those values when the form is reset."}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"How do select element bindings work in Svelte 5? Explain the differences between single and multiple select bindings with examples.","answer":"Svelte 5 provides powerful binding capabilities for `<select>` elements, handling both single and multiple selections.\n\n### Single Select Binding\n\nFor a standard single-select dropdown, you can bind to the `value` property:\n\n```svelte\n<script>\n  let selectedCountry = $state('usa');\n  \n  // Can bind to any value type, not just strings\n  const countries = [\n    { id: 'usa', name: 'United States' },\n    { id: 'can', name: 'Canada' },\n    { id: 'mex', name: 'Mexico' }\n  ];\n</script>\n\n<select bind:value={selectedCountry}>\n  {#each countries as country}\n    <option value={country.id}>{country.name}</option>\n  {/each}\n</select>\n\n<p>Selected country: {countries.find(c => c.id === selectedCountry)?.name}</p>\n```\n\nThe `bind:value` corresponds to the `value` property of the selected `<option>`. Importantly, in Svelte, this value can be any JavaScript value (objects, arrays, etc.), not just strings as is typically the case in standard DOM operations.\n\n### Multiple Select Binding\n\nFor a `<select>` with the `multiple` attribute, the bound variable is an array containing the values of all selected options:\n\n```svelte\n<script>\n  let selectedTechnologies = $state(['svelte']);\n  \n  const technologies = [\n    { id: 'svelte', name: 'Svelte' },\n    { id: 'react', name: 'React' },\n    { id: 'vue', name: 'Vue' },\n    { id: 'angular', name: 'Angular' }\n  ];\n</script>\n\n<select multiple bind:value={selectedTechnologies}>\n  {#each technologies as tech}\n    <option value={tech.id}>{tech.name}</option>\n  {/each}\n</select>\n\n<p>\n  Selected technologies: \n  {selectedTechnologies.map(id => technologies.find(t => t.id === id)?.name).join(', ')}\n</p>\n```\n\n### Simplified Option Values\n\nWhen the `value` of an `<option>` matches its text content, you can omit the value attribute for cleaner code:\n\n```svelte\n<script>\n  let selectedFruit = $state('Apple');\n</script>\n\n<select bind:value={selectedFruit}>\n  <option>Apple</option>\n  <option>Banana</option>\n  <option>Cherry</option>\n</select>\n\n<p>You selected: {selectedFruit}</p>\n```\n\n### Default Values with `selected` Attribute\n\nYou can give a `<select>` a default value by adding a `selected` attribute to the `<option>` that should be initially selected:\n\n```svelte\n<script>\n  let selectedColor = $state();\n</script>\n\n<form>\n  <select bind:value={selectedColor}>\n    <option value=\"red\">Red</option>\n    <option value=\"green\" selected>Green</option>\n    <option value=\"blue\">Blue</option>\n  </select>\n  \n  <input type=\"reset\" value=\"Reset\">\n</form>\n\n<p>Selected color: {selectedColor}</p>\n```\n\nIn this example, \"Green\" will be the default selection. When the form is reset, it will revert to \"Green\" as well. Note that for the initial render, the value of the binding (`selectedColor`) takes precedence if it's not `undefined`."}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"How do you bind to media elements like `<audio>` and `<video>` in Svelte 5? What properties can you bind to and which ones are two-way versus readonly?","answer":"Svelte 5 provides specialized bindings for media elements like `<audio>` and `<video>`, giving you fine-grained control over media playback.\n\n### Audio Element Bindings\n\nThe `<audio>` element supports eleven bindings, divided into two-way and readonly bindings:\n\n**Two-way bindings** (you can both read and modify these):\n- `currentTime` - Current playback position in seconds\n- `playbackRate` - Playback speed (1 is normal speed)\n- `paused` - Whether the audio is paused\n- `volume` - Audio volume (between 0 and 1)\n- `muted` - Whether the audio is muted\n\n**Readonly bindings** (you can only read these):\n- `duration` - Total length of the audio in seconds\n- `buffered` - TimeRanges object representing buffered parts\n- `seekable` - TimeRanges object representing seekable parts\n- `seeking` - Whether the user is currently seeking\n- `ended` - Whether playback has reached the end\n- `readyState` - The readiness state of the audio\n\nHere's an example of a custom audio player using these bindings:\n\n```svelte\n<script>\n  let audioSrc = 'https://example.com/audio.mp3';\n  \n  // Bindable properties\n  let currentTime = $state(0);\n  let duration = $state(0);\n  let paused = $state(true);\n  let volume = $state(1);\n  let muted = $state(false);\n  \n  // Derived values\n  $effect(() => {\n    const progress = duration ? (currentTime / duration) * 100 : 0;\n    console.log(`Playback progress: ${progress.toFixed(1)}%`);\n  });\n  \n  function formatTime(seconds) {\n    if (isNaN(seconds)) return '0:00';\n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60).toString().padStart(2, '0');\n    return `${mins}:${secs}`;\n  }\n</script>\n\n<div class=\"audio-player\">\n  <audio \n    src={audioSrc}\n    bind:currentTime\n    bind:duration\n    bind:paused\n    bind:volume\n    bind:muted\n  ></audio>\n  \n  <div class=\"controls\">\n    <button onclick={() => paused = !paused}>\n      {paused ? 'Play' : 'Pause'}\n    </button>\n    \n    <input \n      type=\"range\" \n      min=\"0\" \n      max={duration || 100}\n      step=\"0.1\"\n      bind:value={currentTime}\n    />\n    \n    <span>{formatTime(currentTime)} / {formatTime(duration)}</span>\n    \n    <button onclick={() => muted = !muted}>\n      {muted ? 'Unmute' : 'Mute'}\n    </button>\n    \n    <input \n      type=\"range\" \n      min=\"0\" \n      max=\"1\" \n      step=\"0.01\"\n      bind:value={volume}\n    />\n  </div>\n</div>\n```\n\n### Video Element Bindings\n\nThe `<video>` element has all the same bindings as the `<audio>` element, plus two additional readonly bindings:\n\n- `videoWidth` - The intrinsic width of the video in pixels\n- `videoHeight` - The intrinsic height of the video in pixels\n\nHere's an example of a responsive video player that maintains aspect ratio:\n\n```svelte\n<script>\n  let videoSrc = 'https://example.com/video.mp4';\n  \n  // Standard media bindings\n  let currentTime = $state(0);\n  let duration = $state(0);\n  let paused = $state(true);\n  \n  // Video-specific bindings\n  let videoWidth = $state(0);\n  let videoHeight = $state(0);\n  \n  // Calculate aspect ratio\n  let aspectRatio = $derived(\n    videoWidth && videoHeight ? videoWidth / videoHeight : 16/9\n  );\n</script>\n\n<div class=\"video-container\" style=\"aspect-ratio: {aspectRatio}\">\n  <video \n    src={videoSrc}\n    bind:currentTime\n    bind:duration\n    bind:paused\n    bind:videoWidth\n    bind:videoHeight\n    controls\n  ></video>\n</div>\n\n<div class=\"custom-controls\">\n  <p>Video dimensions: {videoWidth}Ã{videoHeight}</p>\n  <p>Progress: {((currentTime / duration) * 100).toFixed(1)}%</p>\n  <button onclick={() => currentTime = 0}>Restart</button>\n  <button onclick={() => paused = !paused}>\n    {paused ? 'Play' : 'Pause'}\n  </button>\n</div>\n```\n\nThese bindings make it easy to create custom media players or to synchronize media playback with other components or visualizations in your Svelte application."}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"What are contenteditable bindings in Svelte 5 and how do they differ from each other? Provide examples of their usage.","answer":"Svelte 5 provides bindings for elements with the `contenteditable` attribute, allowing you to create editable content areas like rich text editors. There are three different contenteditable bindings available, each with slightly different behavior:\n\n1. `innerHTML` - Binds to the HTML content including all tags\n2. `innerText` - Binds to the visible text content, respecting line breaks and spacing as displayed\n3. `textContent` - Binds to the raw text content, ignoring presentation\n\n### `innerHTML` Binding\n\nThe `innerHTML` binding preserves all HTML tags and is useful when you want to allow rich text editing:\n\n```svelte\n<script>\n  let html = $state('<p>This is <strong>rich</strong> text content.</p>');\n  \n  function resetContent() {\n    html = '<p>Reset to default content.</p>';\n  }\n</script>\n\n<div \n  contenteditable=\"true\" \n  bind:innerHTML={html}\n  style=\"border: 1px solid #ccc; padding: 8px; min-height: 100px;\"\n></div>\n\n<div class=\"controls\">\n  <button onclick={resetContent}>Reset Content</button>\n</div>\n\n<div class=\"preview\">\n  <h3>Current HTML:</h3>\n  <pre>{html}</pre>\n</div>\n```\n\nWith this binding, if the user adds formatting (like bold text, lists, etc.), those HTML tags will be preserved in the `html` variable.\n\n### `innerText` Binding\n\nThe `innerText` binding focuses on the visible text content and preserves line breaks and spacing as they appear visually:\n\n```svelte\n<script>\n  let text = $state('This text preserves\\nline breaks\\nas they appear visually.');\n</script>\n\n<div \n  contenteditable=\"true\" \n  bind:innerText={text}\n  style=\"border: 1px solid #ccc; padding: 8px; min-height: 100px; white-space: pre-wrap;\"\n></div>\n\n<div class=\"preview\">\n  <h3>Current Text:</h3>\n  <pre>{text}</pre>\n</div>\n```\n\nThe `innerText` binding will respect line breaks and preserve formatting like spaces and tabs as they visually appear. However, it won't preserve HTML tags - if the user adds formatting, only the plain text will be captured.\n\n### `textContent` Binding\n\nThe `textContent` binding captures the raw text content without preserving visual formatting:\n\n```svelte\n<script>\n  let content = $state('This is raw text content.\\nLine breaks are preserved but not visual spacing.');\n</script>\n\n<div \n  contenteditable=\"true\" \n  bind:textContent={content}\n  style=\"border: 1px solid #ccc; padding: 8px; min-height: 100px; white-space: pre-wrap;\"\n></div>\n\n<div class=\"preview\">\n  <h3>Raw Content:</h3>\n  <pre>{content}</pre>\n</div>\n```\n\nThe key differences between these bindings can be illustrated with an example:\n\n```svelte\n<script>\n  let htmlContent = $state('<p>Hello <strong>world</strong></p>');\n  let textContent = $state('');\n  let innerTextContent = $state('');\n  \n  // Copy the same content to all three bindings\n  function copyHtmlToAll() {\n    textContent = htmlContent;\n    innerTextContent = htmlContent;\n  }\n</script>\n\n<div>\n  <h3>innerHTML:</h3>\n  <div \n    contenteditable=\"true\" \n    bind:innerHTML={htmlContent}\n    style=\"border: 1px solid #ccc; padding: 8px;\"\n  ></div>\n  <pre>{htmlContent}</pre>\n</div>\n\n<div>\n  <h3>textContent:</h3>\n  <div \n    contenteditable=\"true\" \n    bind:textContent={textContent}\n    style=\"border: 1px solid #ccc; padding: 8px;\"\n  ></div>\n  <pre>{textContent}</pre>\n</div>\n\n<div>\n  <h3>innerText:</h3>\n  <div \n    contenteditable=\"true\" \n    bind:innerText={innerTextContent}\n    style=\"border: 1px solid #ccc; padding: 8px;\"\n  ></div>\n  <pre>{innerTextContent}</pre>\n</div>\n\n<button onclick={copyHtmlToAll}>Copy HTML to all</button>\n```\n\nAfter clicking the button, you'll see that:\n- The `innerHTML` binding displays formatted text with \"world\" in bold\n- The `textContent` binding shows the raw HTML tags as plain text\n- The `innerText` binding shows the HTML tags as plain text, but preserves visual line breaks\n\nThese bindings are useful for different use cases:\n- `innerHTML`: Rich text editors, WYSIWYG editors\n- `innerText`: Simple text editors that need to preserve visual formatting\n- `textContent`: Plain text editors or when you need to strip all formatting"}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"How do dimension bindings work in Svelte 5? What are the available dimension properties you can bind to, and what are some practical use cases?","answer":"Svelte 5 provides dimension bindings that allow you to access the size measurements of DOM elements. These bindings are readonly, meaning you can read the values but not set them programmatically.\n\n### Available Dimension Bindings\n\nAll visible elements support the following dimension bindings:\n\n1. `clientWidth` - The inner width of an element in pixels, including padding but not the scrollbar, border, or margin\n2. `clientHeight` - The inner height of an element in pixels, including padding but not the scrollbar, border, or margin\n3. `offsetWidth` - The visible width of an element in pixels, including padding, border, and scrollbar (if present)\n4. `offsetHeight` - The visible height of an element in pixels, including padding, border, and scrollbar (if present)\n\nThese dimensions are measured using a `ResizeObserver` behind the scenes, which means they'll update automatically whenever the element's size changes.\n\n### Basic Example\n\n```svelte\n<script>\n  let width = $state(0);\n  let height = $state(0);\n</script>\n\n<div\n  bind:offsetWidth={width}\n  bind:offsetHeight={height}\n  style=\"resize: both; overflow: auto; padding: 20px; border: 2px solid #ccc; min-height: 100px; min-width: 100px;\"\n>\n  This div is resizable. Try dragging the bottom-right corner.\n</div>\n\n<p>Current dimensions: {width}px Ã {height}px</p>\n```\n\n### Practical Use Cases\n\n#### 1. Responsive Charts\n\nOne common use case is creating responsive data visualizations:\n\n```svelte\n<script>\n  import { createChart } from './chart-library.js';\n  \n  let chartWidth = $state(0);\n  let chartHeight = $state(0);\n  let chartContainer;\n  \n  // Create or update chart when dimensions change\n  $effect(() => {\n    if (chartContainer && chartWidth > 0 && chartHeight > 0) {\n      createChart(chartContainer, {\n        width: chartWidth,\n        height: chartHeight,\n        data: [10, 20, 30, 25, 15]\n      });\n    }\n  });\n</script>\n\n<div \n  class=\"chart-container\"\n  bind:this={chartContainer}\n  bind:clientWidth={chartWidth}\n  bind:clientHeight={chartHeight}\n  style=\"width: 100%; height: 300px;\"\n></div>\n```\n\n#### 2. Responsive Grid Layouts\n\nYou can use dimension bindings to calculate how many items to show in a responsive grid:\n\n```svelte\n<script>\n  let containerWidth = $state(0);\n  let itemWidth = 200; // Fixed item width\n  \n  // Calculate number of columns based on container width\n  let columns = $derived(Math.floor(containerWidth / itemWidth) || 1);\n  \n  let items = Array.from({ length: 20 }, (_, i) => ({\n    id: i,\n    title: `Item ${i + 1}`\n  }));\n</script>\n\n<div \n  class=\"grid-container\"\n  bind:clientWidth={containerWidth}\n  style=\"display: grid; grid-template-columns: repeat({columns}, 1fr); gap: 16px;\"\n>\n  {#each items as item}\n    <div class=\"grid-item\">\n      <h3>{item.title}</h3>\n      <p>Width per item: {containerWidth / columns}px</p>\n    </div>\n  {/each}\n</div>\n```\n\n#### 3. Canvas Sizing\n\nDimension bindings are particularly useful for canvas elements, which need their dimensions set explicitly:\n\n```svelte\n<script>\n  let canvasWidth = $state(0);\n  let canvasHeight = $state(0);\n  let canvas;\n  \n  // Resize canvas and redraw when dimensions change\n  $effect(() => {\n    if (canvas && canvasWidth > 0 && canvasHeight > 0) {\n      // Set canvas dimensions to match container\n      canvas.width = canvasWidth * window.devicePixelRatio;\n      canvas.height = canvasHeight * window.devicePixelRatio;\n      \n      // Scale context to account for device pixel ratio\n      const ctx = canvas.getContext('2d');\n      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);\n      \n      // Draw something\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      ctx.fillStyle = 'purple';\n      ctx.fillRect(\n        canvasWidth / 4, \n        canvasHeight / 4, \n        canvasWidth / 2, \n        canvasHeight / 2\n      );\n    }\n  });\n</script>\n\n<div \n  class=\"canvas-container\"\n  bind:clientWidth={canvasWidth}\n  bind:clientHeight={canvasHeight}\n  style=\"width: 100%; height: 300px; background: #f0f0f0;\"\n>\n  <canvas \n    bind:this={canvas}\n    style=\"width: 100%; height: 100%;\"\n  ></canvas>\n</div>\n```\n\n#### 4. Function Bindings with Dimensions\n\nUsing Svelte 5.9.0's function bindings, you can respond to dimension changes without storing the actual values:\n\n```svelte\n<script>\n  function handleResize(newSize) {\n    console.log(`Element resized to ${newSize}px`);\n    // Perform some operation when size changes\n  }\n</script>\n\n<div\n  bind:clientWidth={null, handleResize}\n  bind:clientHeight={null, handleResize}\n  style=\"resize: both; overflow: auto; min-height: 100px; min-width: 100px; border: 1px solid #ccc;\"\n>\n  Resize me!\n</div>\n```\n\nIn this example, the `handleResize` function will be called whenever either dimension changes, but we don't actually store the values in variables."}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"What is `bind:this` in Svelte 5, and how can it be used with both DOM elements and components? Provide examples demonstrating its practical applications.","answer":"The `bind:this` directive in Svelte 5 allows you to get a reference to a DOM node or component instance. This is extremely useful when you need to interact with the DOM directly or call methods on component instances.\n\n### Binding to DOM Elements\n\nWhen used with a DOM element, `bind:this` gives you a reference to the actual DOM node, which you can then manipulate directly:\n\n```svelte\n<script>\n  /** @type {HTMLCanvasElement} */\n  let canvas;\n  \n  $effect(() => {\n    // This code runs after the component is mounted and canvas is defined\n    if (canvas) {\n      const ctx = canvas.getContext('2d');\n      ctx.fillStyle = 'red';\n      ctx.fillRect(10, 10, 100, 100);\n    }\n  });\n  \n  function clearCanvas() {\n    if (canvas) {\n      const ctx = canvas.getContext('2d');\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n  }\n</script>\n\n<canvas \n  bind:this={canvas} \n  width=\"300\" \n  height=\"200\"\n  style=\"border: 1px solid #ccc;\"\n></canvas>\n\n<button onclick={clearCanvas}>Clear Canvas</button>\n```\n\nImportant note: The value will be `undefined` until the component is mounted, which is why you should read it inside an effect or an event handler, but not during component initialization.\n\n### Practical DOM Element Examples\n\n#### 1. Managing Focus\n\n```svelte\n<script>\n  let nameInput;\n  \n  function focusNameInput() {\n    nameInput.focus();\n  }\n  \n  // Auto-focus when component mounts\n  $effect(() => {\n    focusNameInput();\n  });\n</script>\n\n<form>\n  <label>\n    Name:\n    <input bind:this={nameInput} />\n  </label>\n  \n  <button type=\"button\" onclick={focusNameInput}>\n    Focus Name Input\n  </button>\n</form>\n```\n\n#### 2. Working with Third-Party Libraries\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  import mapLibrary from 'some-map-library';\n  \n  let mapContainer;\n  let map;\n  \n  onMount(() => {\n    // Initialize map only after the component is mounted\n    map = mapLibrary.create(mapContainer, {\n      center: [37.7749, -122.4194],\n      zoom: 12\n    });\n    \n    return () => {\n      // Clean up when component is destroyed\n      map.destroy();\n    };\n  });\n  \n  function zoomIn() {\n    if (map) map.setZoom(map.getZoom() + 1);\n  }\n  \n  function zoomOut() {\n    if (map) map.setZoom(map.getZoom() - 1);\n  }\n</script>\n\n<div \n  bind:this={mapContainer} \n  style=\"width: 100%; height: 400px;\"\n></div>\n\n<div class=\"controls\">\n  <button onclick={zoomIn}>Zoom In</button>\n  <button onclick={zoomOut}>Zoom Out</button>\n</div>\n```\n\n### Binding to Component Instances\n\nWhen used with a component, `bind:this` gives you a reference to the component instance, allowing you to call exported methods or access exported properties:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import Counter from './Counter.svelte';\n  \n  let counterInstance;\n  \n  function resetCounter() {\n    counterInstance.reset();\n  }\n  \n  function increment10Times() {\n    for (let i = 0; i < 10; i++) {\n      counterInstance.increment();\n    }\n  }\n</script>\n\n<Counter bind:this={counterInstance} />\n\n<button onclick={resetCounter}>Reset</button>\n<button onclick={increment10Times}>+10</button>\n```\n\n```svelte\n<!-- Counter.svelte -->\n<script>\n  let count = $state(0);\n  \n  // These methods will be available on the component instance\n  export function reset() {\n    count = 0;\n  }\n  \n  export function increment() {\n    count++;\n  }\n  \n  export function decrement() {\n    count--;\n  }\n</script>\n\n<div>\n  <button onclick={() => decrement()}>-</button>\n  <span>{count}</span>\n  <button onclick={() => increment()}>+</button>\n</div>\n```\n\n### Practical Component Instance Examples\n\n#### 1. Modal Control\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import Modal from './Modal.svelte';\n  \n  let modal;\n  \n  function showModal() {\n    modal.open();\n  }\n</script>\n\n<button onclick={showModal}>Open Modal</button>\n\n<Modal \n  bind:this={modal}\n  title=\"Important Information\"\n>\n  <p>This is some important content for the modal.</p>\n</Modal>\n```\n\n```svelte\n<!-- Modal.svelte -->\n<script>\n  let isOpen = $state(false);\n  \n  export let title = '';\n  \n  export function open() {\n    isOpen = true;\n  }\n  \n  export function close() {\n    isOpen = false;\n  }\n</script>\n\n{#if isOpen}\n  <div class=\"modal-backdrop\">\n    <div class=\"modal\">\n      <header>\n        <h2>{title}</h2>\n        <button onclick={() => close()}>Ã</button>\n      </header>\n      <div class=\"modal-content\">\n        <slot></slot>\n      </div>\n      <footer>\n        <button onclick={() => close()}>Close</button>\n      </footer>\n    </div>\n  </div>\n{/if}\n\n<style>\n  /* Modal styling */\n</style>\n```\n\n#### 2. Form Validation\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import Form from './Form.svelte';\n  \n  let form;\n  \n  function handleSubmit() {\n    if (form.validate()) {\n      // Submit form data\n      console.log('Form data:', form.getData());\n    } else {\n      alert('Please fix the errors in the form');\n    }\n  }\n</script>\n\n<Form bind:this={form}>\n  <!-- Form fields -->\n</Form>\n\n<button onclick={handleSubmit}>Submit</button>\n```\n\n```svelte\n<!-- Form.svelte -->\n<script>\n  let formData = $state({\n    name: '',\n    email: '',\n    message: ''\n  });\n  \n  let errors = $state({});\n  \n  export function validate() {\n    errors = {};\n    \n    if (!formData.name) {\n      errors.name = 'Name is required';\n    }\n    \n    if (!formData.email) {\n      errors.email = 'Email is required';\n    } else if (!/\\S+@\\S+\\.\\S+/.test(formData.email)) {\n      errors.email = 'Email is invalid';\n    }\n    \n    if (!formData.message) {\n      errors.message = 'Message is required';\n    }\n    \n    return Object.keys(errors).length === 0;\n  }\n  \n  export function getData() {\n    return { ...formData };\n  }\n</script>\n\n<form>\n  <div>\n    <label for=\"name\">Name</label>\n    <input id=\"name\" bind:value={formData.name} />\n    {#if errors.name}<span class=\"error\">{errors.name}</span>{/if}\n  </div>\n  \n  <div>\n    <label for=\"email\">Email</label>\n    <input id=\"email\" type=\"email\" bind:value={formData.email} />\n    {#if errors.email}<span class=\"error\">{errors.email}</span>{/if}\n  </div>\n  \n  <div>\n    <label for=\"message\">Message</label>\n    <textarea id=\"message\" bind:value={formData.message}></textarea>\n    {#if errors.message}<span class=\"error\">{errors.message}</span>{/if}\n  </div>\n  \n  <slot></slot>\n</form>\n```\n\nThe `bind:this` directive is a powerful tool in Svelte 5 that bridges the gap between declarative and imperative programming, allowing you to leverage the best of both approaches."}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"How do you implement component property bindings in Svelte 5? Explain the concept of bindable properties and how to declare them using the `$bindable` rune.","answer":"In Svelte 5, component property bindings allow for two-way data flow between parent and child components. While Svelte props are reactive by default, that reactivity only flows downward from parent to child. Using the `bind:` directive with component props enables changes from within the child component to flow back up to the parent.\n\n### Declaring Bindable Properties\n\nTo make a property bindable in Svelte 5, you use the `$bindable` rune when declaring your component props:\n\n```svelte\n<script>\n  // Basic bindable property\n  let { count = $bindable(0) } = $props();\n  \n  // You can also have read-only properties\n  let { readonlyProp } = $props();\n  \n  function increment() {\n    count++;  // This change will propagate to the parent if bound\n  }\n</script>\n\n<button onclick={increment}>\n  Count: {count}\n</button>\n```\n\nThe `$bindable` rune marks a property as bindable, meaning it _can_ be used with `bind:`, but it doesn't have to be. When a property is declared with `$bindable`, it creates a two-way binding channel that allows changes made to the property inside the child component to flow back up to the parent.\n\n### Using Bindable Properties\n\nHere's how you would use the component with a bindable property:\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import Counter from './Counter.svelte';\n  \n  let myCount = $state(0);\n  \n  function resetCount() {\n    myCount = 0;\n  }\n</script>\n\n<Counter bind:count={myCount} />\n\n<div>\n  <p>Parent has count: {myCount}</p>\n  <button onclick={resetCount}>Reset from parent</button>\n</div>\n```\n\n### Bindable Properties with Fallback Values\n\nBindable properties can have fallback values that apply when the property is not bound:\n\n```svelte\n<script>\n  // Bindable with fallback value\n  let { username = $bindable('Guest') } = $props();\n  \n  function updateUsername(newName) {\n    username = newName;  // This change will propagate to parent if bound\n  }\n</script>\n\n<div>\n  <p>Current user: {username}</p>\n  <button onclick={() => updateUsername('John')}>\n    Set to John\n  </button>\n</div>\n```\n\nWhen used without binding, the fallback value applies:\n\n```svelte\n<!-- Uses fallback value 'Guest' -->\n<UserProfile />\n```\n\nWhen used with binding, the parent's value takes precedence:\n\n```svelte\n<script>\n  let currentUser = $state('Admin');\n</script>\n\n<!-- Uses 'Admin' from parent -->\n<UserProfile bind:username={currentUser} />\n```\n\n### Binding Behavior and Fallback Values\n\nIt's important to understand how fallback values work with bindings:\n\n1. The fallback value _only_ applies when the property is _not_ bound.\n2. When the property is bound and a fallback value is present, the parent is expected to provide a value other than `undefined`, or a runtime error will be thrown.\n\nThis prevents hard-to-reason-about situations where it's unclear which value should apply.\n\n### Complex Example: Form Field Component\n\nHere's a more complex example of a reusable form field component with bindable properties:\n\n```svelte\n<!-- FormField.svelte -->\n<script>\n  let { \n    label = '',\n    value = $bindable(''),\n    error = $bindable(''),\n    required = false,\n    type = 'text',\n    placeholder = ''\n  } = $props();\n  \n  function handleInput(e) {\n    value = e.target.value;\n    \n    // Validate if required\n    if (required && !value) {\n      error = `${label} is required`;\n    } else {\n      error = '';\n    }\n  }\n</script>\n\n<div class=\"form-field\">\n  <label>\n    {label} {required ? '*' : ''}\n    <input \n      {type}\n      {placeholder}\n      {required}\n      value={value}\n      oninput={handleInput}\n    />\n  </label>\n  \n  {#if error}\n    <p class=\"error\">{error}</p>\n  {/if}\n</div>\n```\n\nUsing this component in a form:\n\n```svelte\n<!-- ContactForm.svelte -->\n<script>\n  import FormField from './FormField.svelte';\n  \n  let name = $state('');\n  let email = $state('');\n  let nameError = $state('');\n  let emailError = $state('');\n  \n  function validateForm() {\n    let valid = true;\n    \n    if (!name) {\n      nameError = 'Name is required';\n      valid = false;\n    }\n    \n    if (!email) {\n      emailError = 'Email is required';\n      valid = false;\n    } else if (!/\\S+@\\S+\\.\\S+/.test(email)) {\n      emailError = 'Email is invalid';\n      valid = false;\n    }\n    \n    return valid;\n  }\n  \n  function handleSubmit() {\n    if (validateForm()) {\n      alert(`Submitting: ${name}, ${email}`);\n      // Submit to server...\n    }\n  }\n</script>\n\n<form onsubmit|preventDefault={handleSubmit}>\n  <FormField \n    label=\"Name\"\n    required={true}\n    bind:value={name}\n    bind:error={nameError}\n    placeholder=\"Enter your name\"\n  />\n  \n  <FormField \n    label=\"Email\"\n    type=\"email\"\n    required={true}\n    bind:value={email}\n    bind:error={emailError}\n    placeholder=\"Enter your email\"\n  />\n  \n  <button type=\"submit\">Submit</button>\n</form>\n```\n\nIn this example:\n- Both the `value` and `error` properties are bindable\n- Changes to `value` within the `FormField` component (through user input) flow back to the parent\n- The parent can also set `error` messages during form validation\n- The child component can update `error` based on its own validation logic\n\n### Multiple Bindable Properties\n\nA component can have multiple bindable properties:\n\n```svelte\n<!-- RangeSelector.svelte -->\n<script>\n  let { \n    min = $bindable(0),\n    max = $bindable(100),\n    minValue = $bindable(25),\n    maxValue = $bindable(75)\n  } = $props();\n  \n  // Ensure minValue doesn't exceed maxValue\n  function updateMinValue(value) {\n    minValue = Math.min(value, maxValue);\n  }\n  \n  // Ensure maxValue doesn't go below minValue\n  function updateMaxValue(value) {\n    maxValue = Math.max(value, minValue);\n  }\n</script>\n\n<div class=\"range-selector\">\n  <div>\n    <label>\n      Min: \n      <input \n        type=\"number\" \n        bind:value={min} \n        max={max} \n      />\n    </label>\n    \n    <label>\n      Max: \n      <input \n        type=\"number\" \n        bind:value={max} \n        min={min} \n      />\n    </label>\n  </div>\n  \n  <div>\n    <label>\n      Min Value: \n      <input \n        type=\"range\" \n        min={min} \n        max={max} \n        value={minValue}\n        oninput={(e) => updateMinValue(Number(e.target.value))}\n      />\n      {minValue}\n    </label>\n    \n    <label>\n      Max Value: \n      <input \n        type=\"range\" \n        min={min} \n        max={max} \n        value={maxValue}\n        oninput={(e) => updateMaxValue(Number(e.target.value))}\n      />\n      {maxValue}\n    </label>\n  </div>\n</div>\n```\n\nUsing this component:\n\n```svelte\n<script>\n  import RangeSelector from './RangeSelector.svelte';\n  \n  let priceMin = $state(10);\n  let priceMax = $state(50);\n  let priceRange = $state([0, 100]);\n  \n  $effect(() => {\n    console.log(`Price range: $${priceMin} - $${priceMax}`);\n  });\n</script>\n\n<RangeSelector \n  bind:min={priceRange[0]}\n  bind:max={priceRange[1]}\n  bind:minValue={priceMin}\n  bind:maxValue={priceMax}\n/>\n\n<p>Selected price range: ${priceMin} - ${priceMax}</p>\n```\n\nThis powerful pattern allows for complex two-way data flow while maintaining clear boundaries between components."}
{"source":"docs/svelte/03-template-syntax/11-bind.md","question":"What are the available media element bindings in Svelte 5, and how can you use them to create a custom media player? Provide a comprehensive example with both audio and video elements.","answer":"Svelte 5 offers specialized bindings for media elements (`<audio>` and `<video>`), making it straightforward to create custom media players with fine-grained control over playback. Let's explore the available bindings and create a comprehensive example.\n\n### Available Media Element Bindings\n\nBoth `<audio>` and `<video>` elements share many bindings, with `<video>` having a couple of additional ones.\n\n#### Two-way bindings (can be both read and set):\n\n1. `currentTime` - Current playback position in seconds\n2. `playbackRate` - Playback speed (1 is normal, 0.5 is half speed, 2 is double speed)\n3. `paused` - Whether the media is paused\n4. `volume` - Audio volume (between 0 and 1)\n5. `muted` - Whether the audio is muted\n\n#### Readonly bindings (can only be read):\n\n1. `duration` - Total length of the media in seconds\n2. `buffered` - TimeRanges object representing buffered parts\n3. `seekable` - TimeRanges object representing seekable parts\n4. `seeking` - Whether the user is currently seeking\n5. `ended` - Whether playback has reached the end\n6. `readyState` - The readiness state of the media\n\n#### Video-specific readonly bindings:\n\n1. `videoWidth` - The intrinsic width of the video in pixels\n2. `videoHeight` - The intrinsic height of the video in pixels\n\n### Comprehensive Media Player Example\n\nLet's create a full-featured media player component that works with both audio and video:\n\n```svelte\n<!-- MediaPlayer.svelte -->\n<script>\n  // Props\n  let {\n    src = '',\n    type = 'video', // 'video' or 'audio'\n    poster = '',    // For video\n    autoplay = false,\n    controls = false // Whether to show native controls\n  } = $props();\n  \n  // Media state\n  let media;\n  let currentTime = $state(0);\n  let duration = $state(0);\n  let paused = $state(true);\n  let volume = $state(1);\n  let muted = $state(false);\n  let playbackRate = $state(1);\n  let buffered = $state(null);\n  let seeking = $state(false);\n  let ended = $state(false);\n  \n  // Video-specific state\n  let videoWidth = $state(0);\n  let videoHeight = $state(0);\n  \n  // Derived values\n  let progress = $derived(duration ? (currentTime / duration) * 100 : 0);\n  let formattedCurrentTime = $derived(formatTime(currentTime));\n  let formattedDuration = $derived(formatTime(duration));\n  let aspectRatio = $derived(\n    type === 'video' && videoWidth && videoHeight \n      ? videoWidth / videoHeight \n      : 16/9\n  );\n  \n  // Buffering information\n  let bufferedProgress = $derived(() => {\n    if (!buffered || !duration) return 0;\n    \n    for (let i = 0; i < buffered.length; i++) {\n      if (buffered.start(i) <= currentTime && currentTime <= buffered.end(i)) {\n        return (buffered.end(i) / duration) * 100;\n      }\n    }\n    return 0;\n  });\n  \n  // Helper functions\n  function formatTime(seconds) {\n    if (isNaN(seconds) || !isFinite(seconds)) return '0:00';\n    \n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60).toString().padStart(2, '0');\n    \n    if (mins < 60) {\n      return `${mins}:${secs}`;\n    } else {\n      const hours = Math.floor(mins / 60);\n      const remainingMins = Math.floor(mins % 60).toString().padStart(2, '0');\n      return `${hours}:${remainingMins}:${secs}`;\n    }\n  }\n  \n  // Playback controls\n  function togglePlay() {\n    paused = !paused;\n  }\n  \n  function toggleMute() {\n    muted = !muted;\n  }\n  \n  function seek(e) {\n    if (duration) {\n      const rect = e.currentTarget.getBoundingClientRect();\n      const percent = (e.clientX - rect.left) / rect.width;\n      currentTime = percent * duration;\n    }\n  }\n  \n  function skip(seconds) {\n    currentTime = Math.max(0, Math.min(duration, currentTime + seconds));\n  }\n  \n  function setPlaybackRate(rate) {\n    playbackRate = rate;\n  }\n  \n  // Keyboard shortcuts\n  function handleKeydown(e) {\n    if (document.activeElement.tagName === 'INPUT') return;\n    \n    switch (e.key) {\n      case ' ':\n      case 'k':\n        e.preventDefault();\n        togglePlay();\n        break;\n      case 'm':\n        toggleMute();\n        break;\n      case 'ArrowRight':\n        skip(10);\n        break;\n      case 'ArrowLeft':\n        skip(-10);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        const percent = parseInt(e.key) * 10;\n        currentTime = (percent / 100) * duration;\n        break;\n    }\n  }\n  \n  // Listen for keyboard events\n  $effect(() => {\n    window.addEventListener('keydown', handleKeydown);\n    return () => {\n      window.removeEventListener('keydown', handleKeydown);\n    };\n  });\n  \n  // Auto-restart when ended\n  $effect(() => {\n    if (ended) {\n      // Reset to beginning\n      currentTime = 0;\n      // Keep paused state as is\n    }\n  });\n</script>\n\n<div \n  class=\"media-player\"\n  class:video-player={type === 'video'}\n  class:audio-player={type === 'audio'}\n  style:--aspect-ratio={aspectRatio}\n>\n  {#if type === 'video'}\n    <div class=\"video-container\">\n      <video\n        {src}\n        {poster}\n        {autoplay}\n        {controls}\n        bind:this={media}\n        bind:currentTime\n        bind:duration\n        bind:paused\n        bind:volume\n        bind:muted\n        bind:playbackRate\n        bind:buffered\n        bind:seeking\n        bind:ended\n        bind:videoWidth\n        bind:videoHeight\n      ></video>\n      \n      {#if !controls}\n        <!-- Custom video overlay controls -->\n        <button \n          class=\"big-play-button\"\n          class:hidden={!paused}\n          onclick={togglePlay}\n          aria-label={paused ? 'Play' : 'Pause'}\n        >\n          {paused ? 'â¶' : 'â¸'}\n        </button>\n      {/if}\n    </div>\n  {:else}\n    <audio\n      {src}\n      {autoplay}\n      {controls}\n      bind:this={media}\n      bind:currentTime\n      bind:duration\n      bind:paused\n      bind:volume\n      bind:muted\n      bind:playbackRate\n      bind:buffered\n      bind:seeking\n      bind:ended\n    ></audio>\n    \n    {#if !controls}\n      <!-- Audio visualization or album art could go here -->\n      <div class=\"audio-visualization\">\n        <div class=\"album-art\">\n          <div class=\"play-indicator\" class:playing={!paused}>\n            {paused ? 'â¶' : 'â¸'}\n          </div>\n        </div>\n      </div>\n    {/if}\n  {/if}\n  \n  {#if !controls}\n    <div class=\"custom-controls\">\n      <!-- Progress bar -->\n      <div class=\"progress-container\" onclick={seek}>\n        <div class=\"progress-bar\">\n          <div class=\"buffered-progress\" style=\"width: {bufferedProgress}%\"></div>\n          <div class=\"playback-progress\" style=\"width: {progress}%\"></div>\n        </div>\n        <div class=\"progress-handle\" style=\"left: {progress}%\"></div>\n      </div>\n      \n      <!-- Time display -->\n      <div class=\"time-display\">\n        <span>{formattedCurrentTime}</span>\n        <span>/</span>\n        <span>{formattedDuration}</span>\n      </div>\n      \n      <!-- Control buttons -->\n      <div class=\"control-buttons\">\n        <button onclick={() => skip(-10)} aria-label=\"Rewind 10 seconds\">\n          âª 10s\n        </button>\n        \n        <button onclick={togglePlay} aria-label={paused ? 'Play' : 'Pause'}>\n          {paused ? 'â¶' : 'â¸'}\n        </button>\n        \n        <button onclick={() => skip(10)} aria-label=\"Forward 10 seconds\">\n          10s â©\n        </button>\n        \n        <div class=\"volume-control\">\n          <button onclick={toggleMute} aria-label={muted ? 'Unmute' : 'Mute'}>\n            {muted ? 'ð' : 'ð'}\n          </button>\n          \n          <input \n            type=\"range\" \n            min=\"0\" \n            max=\"1\" \n            step=\"0.01\" \n            value={volume}\n            oninput={(e) => volume = parseFloat(e.target.value)}\n            disabled={muted}\n          />\n        </div>\n        \n        <div class=\"playback-rate-control\">\n          <select \n            value={playbackRate}\n            onchange={(e) => setPlaybackRate(parseFloat(e.target.value))}\n          >\n            <option value=\"0.25\">0.25x</option>\n            <option value=\"0.5\">0.5x</option>\n            <option value=\"0.75\">0.75x</option>\n            <option value=\"1\">1x</option>\n            <option value=\"1.25\">1.25x</option>\n            <option value=\"1.5\">1.5x</option>\n            <option value=\"1.75\">1.75x</option>\n            <option value=\"2\">2x</option>\n          </select>\n        </div>\n        \n        {#if type === 'video'}\n          <button onclick={() => media.requestFullscreen()} aria-label=\"Fullscreen\">\n            â¶\n          </button>\n        {/if}\n      </div>\n    </div>\n  {/if}\n</div>\n\n<style>\n  .media-player {\n    width: 100%;\n    max-width: 800px;\n    background: #000;\n    color: white;\n    border-radius: 4px;\n    overflow: hidden;\n  }\n  \n  .video-player {\n    aspect-ratio: var(--aspect-ratio, 16/9);\n  }\n  \n  .video-container {\n    position: relative;\n    width: 100%;\n    height: 100%;\n  }\n  \n  video {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n  }\n  \n  audio {\n    width: 100%;\n  }\n  \n  .custom-controls {\n    background: rgba(0, 0, 0, 0.7);\n    padding: 10px;\n    transition: opacity 0.3s;\n  }\n  \n  .progress-container {\n    position: relative;\n    height: 8px;\n    background: #444;\n    cursor: pointer;\n    margin-bottom: 10px;\n  }\n  \n  .progress-bar {\n    position: relative;\n    height: 100%;\n    width: 100%;\n  }\n  \n  .buffered-progress {\n    position: absolute;\n    height: 100%;\n    background: #666;\n  }\n  \n  .playback-progress {\n    position: absolute;\n    height: 100%;\n    background: #f00;\n  }\n  \n  .progress-handle {\n    position: absolute;\n    top: 50%;\n    transform: translate(-50%, -50%);\n    width: 12px;\n    height: 12px;\n    background: white;\n    border-radius: 50%;\n    pointer-events: none;\n  }\n  \n  .control-buttons {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n  \n  .time-display {\n    font-family: monospace;\n    margin-bottom: 10px;\n  }\n  \n  .volume-control {\n    display: flex;\n    align-items: center;\n    gap: 5px;\n  }\n  \n  .big-play-button {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    font-size: 48px;\n    background: rgba(0, 0, 0, 0.5);\n    color: white;\n    border: none;\n    border-radius: 50%;\n    width: 80px;\n    height: 80px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n  }\n  \n  .hidden {\n    display: none;\n  }\n  \n  .audio-visualization {\n    height: 200px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: linear-gradient(to bottom, #333, #111);\n  }\n  \n  .album-art {\n    width: 150px;\n    height: 150px;\n    background: #555;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n  }\n  \n  .play-indicator {\n    font-size: 48px;\n  }\n  \n  .playing {\n    animation: pulse 1s infinite alternate;\n  }\n  \n  @keyframes pulse {\n    from { transform: scale(1); }\n    to { transform: scale(1.1); }\n  }\n</style>\n```\n\n### Using the MediaPlayer Component\n\nHere's how you would use this comprehensive media player in an application:\n\n```svelte\n<script>\n  import MediaPlayer from './MediaPlayer.svelte';\n  \n  const videoSrc = 'https://example.com/video.mp4';\n  const audioSrc = 'https://example.com/audio.mp3';\n  \n  let showVideo = $state(true);\n  \n  function toggleMediaType() {\n    showVideo = !showVideo;\n  }\n</script>\n\n<div class=\"app\">\n  <h1>Custom Media Player</h1>\n  \n  <button onclick={toggleMediaType}>\n    Switch to {showVideo ? 'Audio' : 'Video'} Player\n  </button>\n  \n  {#if showVideo}\n    <h2>Video Player</h2>\n    <MediaPlayer \n      src={videoSrc}\n      type=\"video\"\n      poster=\"https://example.com/poster.jpg\"\n    />\n    \n    <div class=\"info\">\n      <h3>Keyboard Controls:</h3>\n      <ul>\n        <li><strong>Space or K:</strong> Play/Pause</li>\n        <li><strong>M:</strong> Mute/Unmute</li>\n        <li><strong>Left Arrow:</strong> Rewind 10s</li>\n        <li><strong>Right Arrow:</strong> Forward 10s</li>\n        <li><strong>0-9:</strong> Jump to percentage (0 = start, 5 = middle, 9 = 90%)</li>\n      </ul>\n    </div>\n  {:else}\n    <h2>Audio Player</h2>\n    <MediaPlayer \n      src={audioSrc}\n      type=\"audio\"\n    />\n  {/if}\n</div>\n\n<style>\n  .app {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 20px;\n    font-family: system-ui, sans-serif;\n  }\n  \n  .info {\n    margin-top: 20px;\n    padding: 15px;\n    background: #f5f5f5;\n    border-radius: 4px;\n  }\n</style>\n```\n\n### Key Features of This Implementation\n\n1. **Comprehensive Bindings**: Utilizes all available media bindings for both audio and video elements.\n\n2. **Responsive Design**: The video player maintains proper aspect ratio based on the video's dimensions.\n\n3. **Custom Controls**: Implements a full set of custom controls while allowing fallback to native controls.\n\n4. **Progress Tracking**: Shows both playback progress and buffering progress.\n\n5. **Keyboard Shortcuts**: Implements common keyboard shortcuts for media playback.\n\n6. **Playback Rate Control**: Allows changing the playback speed.\n\n7. **Volume Control**: Provides volume adjustment and mute functionality.\n\n8. **Time Display**: Shows formatted current time and duration.\n\n9. **Seeking**: Enables clicking on the progress bar to seek to a specific position.\n\n10. **Fullscreen Support**: For video playback, offers a fullscreen button.\n\n11. **Auto-restart**: Automatically resets to the beginning when playback ends.\n\n12. **Visual Feedback**: Different visual states for playing/paused and muted/unmuted.\n\nThis comprehensive example demonstrates how Svelte 5's media bindings make it straightforward to create feature-rich custom media players with minimal code. The bindings handle all the complex state synchronization between your Svelte component and the underlying media elements, allowing you to focus on building a great user experience."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"What is an action in Svelte 5 and how is it implemented using the `use:` directive?","answer":"In Svelte 5, an action is a function that is called when an element is mounted to the DOM. Actions allow you to interact directly with DOM elements, which is useful for integrating with third-party libraries, adding custom event handlers, or implementing reusable DOM manipulation logic.\n\nActions are implemented using the `use:` directive in your Svelte templates. The basic structure of an action looks like this:\n\n```svelte\n<script>\n  /** @type {import('svelte/action').Action} */\n  function myaction(node) {\n    // The node has been mounted in the DOM\n    // You can now interact with it directly\n    \n    $effect(() => {\n      // Setup code goes here\n      console.log('Element mounted:', node);\n      \n      // Any cleanup logic goes in the return function\n      return () => {\n        // Teardown code goes here\n        console.log('Element unmounted:', node);\n      };\n    });\n  }\n</script>\n\n<div use:myaction>This element has an action applied to it</div>\n```\n\nThe action function receives the DOM node as its first parameter, which you can then manipulate. In Svelte 5, actions typically use the `$effect` rune to manage setup and teardown logic. The `$effect` callback runs when the component is mounted, and the returned function runs when the component is unmounted, providing a clean way to handle lifecycle events for the element.\n\nActions are only called once during the component's lifecycle and do not run during server-side rendering. This makes them perfect for browser-only operations like adding event listeners, initializing DOM libraries, or setting up animations."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"How can you pass parameters to a Svelte action, and what are the limitations regarding parameter changes?","answer":"You can pass parameters to a Svelte action by providing a value after the equals sign in the `use:` directive. The action function will receive this parameter as its second argument. Here's how to implement and use an action with parameters:\n\n```svelte\n<script>\n  /** @type {import('svelte/action').Action} */\n  function tooltip(node, text) {\n    // Access the node and the parameter\n    console.log(`Creating tooltip with text: ${text}`);\n    \n    $effect(() => {\n      // Setup tooltip functionality\n      const tooltipElement = document.createElement('div');\n      tooltipElement.textContent = text;\n      tooltipElement.style.display = 'none';\n      tooltipElement.className = 'tooltip';\n      \n      document.body.appendChild(tooltipElement);\n      \n      const showTooltip = () => {\n        const rect = node.getBoundingClientRect();\n        tooltipElement.style.left = `${rect.left}px`;\n        tooltipElement.style.top = `${rect.bottom + 5}px`;\n        tooltipElement.style.display = 'block';\n      };\n      \n      const hideTooltip = () => {\n        tooltipElement.style.display = 'none';\n      };\n      \n      node.addEventListener('mouseenter', showTooltip);\n      node.addEventListener('mouseleave', hideTooltip);\n      \n      return () => {\n        // Clean up\n        node.removeEventListener('mouseenter', showTooltip);\n        node.removeEventListener('mouseleave', hideTooltip);\n        document.body.removeChild(tooltipElement);\n      };\n    });\n  }\n  \n  let helpText = \"This is a helpful tooltip\";\n</script>\n\n<button use:tooltip={helpText}>Hover me</button>\n```\n\n**Important limitation**: In Svelte 5, the action function is only called once when the element is mounted. If the parameter value changes during the component's lifecycle, the action will **not** be called again with the new value.\n\nThis is a change from earlier versions of Svelte where actions could return an object with an `update` method that would be called whenever the parameter changed. In Svelte 5, the preferred approach is to use the `$effect` rune and handle reactivity there.\n\nIf you need to react to parameter changes, you would need to incorporate that logic within your component or use a different pattern."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"How do you properly type Svelte actions in TypeScript, and what are the type parameters available for the `Action` interface?","answer":"In Svelte 5, you can properly type actions using TypeScript by importing the `Action` interface from 'svelte/action'. This interface accepts three optional type parameters that allow you to specify the types for:\n\n1. The node type (defaults to `Element` if not specified)\n2. The parameter type\n3. Any custom event handlers created by the action\n\nHere's a detailed example of how to type an action:\n\n```svelte\n<script lang=\"ts\">\n  import type { Action } from 'svelte/action';\n  \n  /**\n   * @type {Action<\n   *   HTMLButtonElement,  // Restrict this action to button elements\n   *   string,             // The parameter is a string\n   *   {\n   *     onlongpress: (e: CustomEvent<{ duration: number }>) => void;\n   *   }\n   * >}\n   */\n  const longpress: Action<HTMLButtonElement, string, { onlongpress: (e: CustomEvent<{ duration: number }>) => void }> = (node, threshold = \"500\") => {\n    const thresholdMs = parseInt(threshold);\n    let timer: number;\n    let startTime: number;\n    \n    $effect(() => {\n      const handleMouseDown = () => {\n        startTime = Date.now();\n        timer = window.setTimeout(() => {\n          const duration = Date.now() - startTime;\n          node.dispatchEvent(\n            new CustomEvent('longpress', { \n              detail: { duration } \n            })\n          );\n        }, thresholdMs);\n      };\n      \n      const handleMouseUp = () => {\n        clearTimeout(timer);\n      };\n      \n      node.addEventListener('mousedown', handleMouseDown);\n      node.addEventListener('mouseup', handleMouseUp);\n      node.addEventListener('mouseleave', handleMouseUp);\n      \n      return () => {\n        clearTimeout(timer);\n        node.removeEventListener('mousedown', handleMouseDown);\n        node.removeEventListener('mouseup', handleMouseUp);\n        node.removeEventListener('mouseleave', handleMouseUp);\n      };\n    });\n  };\n  \n  function handleLongPress(event: CustomEvent<{ duration: number }>) {\n    console.log(`Button was pressed for ${event.detail.duration}ms`);\n  }\n</script>\n\n<button \n  use:longpress={\"1000\"} \n  onlongpress={handleLongPress}\n>\n  Press and hold me\n</button>\n```\n\nBreaking down the type parameters:\n\n1. `HTMLButtonElement`: Restricts this action to only be used on button elements\n2. `string`: Specifies that the action parameter should be a string\n3. `{ onlongpress: (e: CustomEvent<{ duration: number }>) => void }`: Declares a custom event handler called 'onlongpress' that receives a CustomEvent with a detail property containing a duration number\n\nThis typing helps in several ways:\n- It provides autocompletion when using the action\n- It ensures you only apply the action to compatible elements\n- It enforces correct parameter types\n- It enables type checking for any custom events the action dispatches\n\nThe TypeScript compiler will now enforce these types, preventing errors like applying the action to incompatible elements or passing incorrect parameter types."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"What is the difference between handling action lifecycle in Svelte 5 using `$effect` versus the legacy approach with `update` and `destroy` methods?","answer":"Svelte 5 introduces a significant change in how action lifecycles are managed, transitioning from the object-based approach to using the new `$effect` rune. Let's compare both approaches:\n\n**Legacy Approach (Pre-Svelte 5):**\n```svelte\n<script>\n  function myaction(node, parameter) {\n    // Initial setup code\n    console.log('Action initialized with:', parameter);\n    \n    // Return an object with update and destroy methods\n    return {\n      update(newParameter) {\n        // This runs whenever the parameter changes\n        console.log('Parameter updated to:', newParameter);\n      },\n      destroy() {\n        // Cleanup code when element is unmounted\n        console.log('Action destroyed');\n      }\n    };\n  }\n  \n  let value = 'initial';\n</script>\n\n<div use:myaction={value}>...</div>\n<button on:click={() => value = 'updated'}>Update</button>\n```\n\n**Svelte 5 Approach with `$effect`:**\n```svelte\n<script>\n  /** @type {import('svelte/action').Action} */\n  function myaction(node, parameter) {\n    // Initial code that runs once when mounted\n    console.log('Action initialized with:', parameter);\n    \n    $effect(() => {\n      // Setup code\n      console.log('Effect running');\n      \n      // Return a cleanup function\n      return () => {\n        // Teardown code when element is unmounted\n        console.log('Effect cleanup');\n      };\n    });\n  }\n  \n  let value = 'initial';\n</script>\n\n<div use:myaction={value}>...</div>\n<button on:click={() => value = 'updated'}>Update</button>\n```\n\n**Key Differences:**\n\n1. **Parameter Reactivity:**\n   - Legacy: The `update` method automatically receives new parameter values when they change\n   - Svelte 5: The action function is called only once and does not automatically react to parameter changes\n\n2. **Cleanup Handling:**\n   - Legacy: Cleanup logic goes in a separate `destroy` method\n   - Svelte 5: Cleanup logic is returned from the `$effect` callback function\n\n3. **Lifecycle Management:**\n   - Legacy: Explicitly separates initialization, updates, and destruction\n   - Svelte 5: Uses the reactive `$effect` rune for managing the entire lifecycle\n\n4. **Code Organization:**\n   - Legacy: Returns an object with named methods\n   - Svelte 5: Uses the function structure of `$effect` with a returned cleanup function\n\n5. **Integration with Reactivity System:**\n   - Legacy: Uses a custom approach specific to actions\n   - Svelte 5: Aligns with the broader reactivity system through runes\n\nThe Svelte 5 approach with `$effect` is now the preferred method because:\n- It aligns with Svelte 5's overall reactivity model\n- It's more consistent with how other reactive code is written in Svelte 5\n- It leverages the runes system which is a core part of Svelte 5\n\nIf you need to react to parameter changes in Svelte 5, you would need to handle this differently, perhaps by using reactive statements within your component or by passing reactive values directly to functions called inside the `$effect`."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"How can you create and handle custom events in a Svelte action, and how would you type these events properly?","answer":"Svelte actions can dispatch custom events that components can listen to. This is particularly useful for creating reusable DOM interactions. Here's how to create and handle custom events in a Svelte action with proper TypeScript typing:\n\n```svelte\n<script lang=\"ts\">\n  import type { Action } from 'svelte/action';\n  \n  /**\n   * Drag action that dispatches custom events for drag start, move, and end\n   * @type {Action<\n   *   HTMLElement,\n   *   { enabled?: boolean },\n   *   {\n   *     ondragstart: (e: CustomEvent<{ x: number, y: number }>) => void;\n   *     ondragmove: (e: CustomEvent<{ x: number, y: number, dx: number, dy: number }>) => void;\n   *     ondragend: (e: CustomEvent<{ x: number, y: number }>) => void;\n   *   }\n   * >}\n   */\n  function draggable(node, options = { enabled: true }) {\n    let x = 0;\n    let y = 0;\n    let startX = 0;\n    let startY = 0;\n    \n    $effect(() => {\n      if (!options.enabled) return;\n      \n      const handleMouseDown = (event: MouseEvent) => {\n        // Prevent default behaviors\n        event.preventDefault();\n        \n        // Store starting position\n        startX = event.clientX;\n        startY = event.clientY;\n        \n        // Dispatch dragstart event\n        node.dispatchEvent(new CustomEvent('dragstart', {\n          detail: { x: startX, y: startY }\n        }));\n        \n        // Add document-level event listeners\n        window.addEventListener('mousemove', handleMouseMove);\n        window.addEventListener('mouseup', handleMouseUp);\n      };\n      \n      const handleMouseMove = (event: MouseEvent) => {\n        // Calculate movement\n        const currentX = event.clientX;\n        const currentY = event.clientY;\n        const dx = currentX - startX;\n        const dy = currentY - startY;\n        \n        // Update position\n        x += dx;\n        y += dy;\n        \n        // Dispatch dragmove event\n        node.dispatchEvent(new CustomEvent('dragmove', {\n          detail: { x: currentX, y: currentY, dx, dy }\n        }));\n        \n        // Update starting position for next move\n        startX = currentX;\n        startY = currentY;\n      };\n      \n      const handleMouseUp = (event: MouseEvent) => {\n        // Dispatch dragend event\n        node.dispatchEvent(new CustomEvent('dragend', {\n          detail: { x: event.clientX, y: event.clientY }\n        }));\n        \n        // Remove document-level event listeners\n        window.removeEventListener('mousemove', handleMouseMove);\n        window.removeEventListener('mouseup', handleMouseUp);\n      };\n      \n      // Add the initial mousedown listener\n      node.addEventListener('mousedown', handleMouseDown);\n      \n      // Clean up function\n      return () => {\n        node.removeEventListener('mousedown', handleMouseDown);\n        window.removeEventListener('mousemove', handleMouseMove);\n        window.removeEventListener('mouseup', handleMouseUp);\n      };\n    });\n  }\n  \n  // Handle the custom events\n  function onDragStart(e: CustomEvent<{ x: number, y: number }>) {\n    console.log('Drag started at:', e.detail.x, e.detail.y);\n  }\n  \n  function onDragMove(e: CustomEvent<{ x: number, y: number, dx: number, dy: number }>) {\n    console.log('Dragged by:', e.detail.dx, e.detail.dy);\n  }\n  \n  function onDragEnd(e: CustomEvent<{ x: number, y: number }>) {\n    console.log('Drag ended at:', e.detail.x, e.detail.y);\n  }\n  \n  let isDraggingEnabled = true;\n</script>\n\n<div \n  class=\"draggable-element\"\n  use:draggable={{ enabled: isDraggingEnabled }}\n  ondragstart={onDragStart}\n  ondragmove={onDragMove}\n  ondragend={onDragEnd}\n>\n  Drag me\n</div>\n\n<label>\n  <input type=\"checkbox\" bind:checked={isDraggingEnabled}>\n  Enable dragging\n</label>\n\n<style>\n  .draggable-element {\n    padding: 20px;\n    background-color: #f0f0f0;\n    cursor: grab;\n    display: inline-block;\n    user-select: none;\n  }\n</style>\n```\n\nKey aspects of creating and handling custom events in Svelte actions:\n\n1. **Dispatching Custom Events:**\n   - Use `node.dispatchEvent(new CustomEvent('eventname', { detail: data }))` to create and dispatch custom events\n   - The `detail` property can contain any data you want to pass with the event\n\n2. **Typing Custom Events:**\n   - In the third type parameter of the `Action` interface, define an object with properties named `on[eventname]`\n   - Each property should be a function type that accepts a `CustomEvent` with the appropriate detail type\n\n3. **Listening to Custom Events:**\n   - In your component, add attributes like `on[eventname]={handlerFunction}` to the element with the action\n   - The handler functions should be typed to accept the same `CustomEvent` type defined in the action\n\n4. **Event Naming Conventions:**\n   - Custom event names are typically lowercase\n   - Handler attributes in the component follow the pattern `on[eventname]`\n\n5. **Event Data:**\n   - Pass structured data in the `detail` property of the CustomEvent\n   - Use TypeScript interfaces or types to ensure consistent data structure\n\nThis pattern allows you to create reusable DOM interactions that components can respond to through a clean event-based API, with proper TypeScript typing to ensure type safety throughout."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"How can you implement an action that integrates a third-party library with Svelte components?","answer":"Integrating third-party libraries with Svelte components is one of the most common use cases for actions. Actions provide a clean way to initialize, configure, and clean up external libraries that operate directly on DOM elements. Here's a comprehensive example of implementing an action that integrates the popular Chart.js library:\n\n```svelte\n<script lang=\"ts\">\n  import type { Action } from 'svelte/action';\n  import Chart from 'chart.js/auto';\n  import type { ChartConfiguration, ChartType, ChartData, ChartOptions } from 'chart.js';\n  \n  /**\n   * Action to create and manage a Chart.js instance\n   * @type {Action<HTMLCanvasElement, {\n   *   type: ChartType,\n   *   data: ChartData,\n   *   options?: ChartOptions\n   * }>}\n   */\n  function chartjs(node, config) {\n    let chart: Chart | null = null;\n    \n    // We can't call this during SSR since Chart.js requires a browser environment\n    if (typeof window !== 'undefined') {\n      // Create the chart instance\n      chart = new Chart(node as HTMLCanvasElement, {\n        type: config.type,\n        data: config.data,\n        options: config.options || {}\n      });\n    }\n    \n    $effect(() => {\n      // If the chart instance exists and we're in a browser environment\n      if (chart) {\n        // Setup is already done when the chart was created\n        \n        // Return cleanup function\n        return () => {\n          // Properly destroy the Chart.js instance to prevent memory leaks\n          chart?.destroy();\n          chart = null;\n        };\n      }\n    });\n  }\n  \n  // Example data for our chart\n  const chartConfig = {\n    type: 'bar' as ChartType,\n    data: {\n      labels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'],\n      datasets: [{\n        label: '# of Votes',\n        data: [12, 19, 3, 5, 2, 3],\n        backgroundColor: [\n          'rgba(255, 99, 132, 0.2)',\n          'rgba(54, 162, 235, 0.2)',\n          'rgba(255, 206, 86, 0.2)',\n          'rgba(75, 192, 192, 0.2)',\n          'rgba(153, 102, 255, 0.2)',\n          'rgba(255, 159, 64, 0.2)'\n        ],\n        borderColor: [\n          'rgba(255, 99, 132, 1)',\n          'rgba(54, 162, 235, 1)',\n          'rgba(255, 206, 86, 1)',\n          'rgba(75, 192, 192, 1)',\n          'rgba(153, 102, 255, 1)',\n          'rgba(255, 159, 64, 1)'\n        ],\n        borderWidth: 1\n      }]\n    },\n    options: {\n      scales: {\n        y: {\n          beginAtZero: true\n        }\n      },\n      responsive: true,\n      maintainAspectRatio: false\n    }\n  };\n  \n  // Let's create a reactive variable to demonstrate updating the chart\n  let showAltData = false;\n  \n  $effect(() => {\n    // This is how you might update the chart data reactively\n    // Note: In Svelte 5, we can't directly update the chart from the action \n    // when parameters change, so we need to handle it differently\n    \n    // This is just for demonstration - in a real app you'd likely have a more\n    // complex data flow and might need to use a different approach\n    if (showAltData) {\n      chartConfig.data.datasets[0].data = [5, 10, 15, 20, 25, 30];\n    } else {\n      chartConfig.data.datasets[0].data = [12, 19, 3, 5, 2, 3];\n    }\n    \n    // We'd need to manually update the chart here if we want to react to data changes\n    // In a real application, you might handle this differently\n  });\n</script>\n\n<div class=\"chart-container\">\n  <canvas use:chartjs={chartConfig}></canvas>\n</div>\n\n<button on:click={() => showAltData = !showAltData}>\n  Toggle Data\n</button>\n\n<style>\n  .chart-container {\n    height: 400px;\n    width: 100%;\n    max-width: 800px;\n    margin: 0 auto;\n  }\n</style>\n```\n\n**Key considerations when integrating third-party libraries:**\n\n1. **Initialization:**\n   - Initialize the library in the action function, not in the `$effect`, to ensure it happens only once\n   - Pass configuration options as parameters to the action\n\n2. **Server-Side Rendering (SSR):**\n   - Check for browser environment with `typeof window !== 'undefined'` to avoid SSR issues\n   - Many third-party libraries require a browser environment and won't work during SSR\n\n3. **Cleanup:**\n   - Always implement proper cleanup in the return function of `$effect`\n   - This prevents memory leaks and ensures proper teardown when the component is unmounted\n\n4. **Handling Reactivity:**\n   - Since Svelte 5 actions don't automatically respond to parameter changes, you may need alternative approaches:\n     - Use `$effect` within your component to react to data changes\n     - Implement a separate update mechanism or rerender strategy\n     - Consider using a store or reactive variable that both the component and action can access\n\n5. **TypeScript Integration:**\n   - Import and use the library's type definitions\n   - Properly type the action parameters to ensure type safety\n\n6. **DOM Access:**\n   - The action has direct access to the DOM node, which makes it ideal for libraries that need to operate on specific elements\n\nThis pattern provides a clean separation of concerns: your Svelte component handles the data and state management, while the action handles the integration with the third-party library."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"What are the advantages of using actions in Svelte 5, and in what scenarios are they most useful?","answer":"Actions in Svelte 5 offer several significant advantages and are particularly useful in specific scenarios. Let's explore both the advantages and ideal use cases:\n\n### Advantages of Using Actions in Svelte 5\n\n1. **Direct DOM Access**\n   Actions provide a clean way to interact directly with DOM elements without cluttering your component logic. This separation of concerns keeps your component code focused on business logic rather than DOM manipulation.\n\n2. **Reusability**\n   Actions can be easily shared across components, promoting code reuse. You can create a library of actions for common DOM interactions that can be used throughout your application.\n\n3. **Encapsulation**\n   Actions encapsulate DOM-related logic, making your components more maintainable and easier to understand. Each action handles a specific concern without exposing implementation details.\n\n4. **Clean Lifecycle Management**\n   With the `$effect` rune, actions provide a clear pattern for setup and teardown logic, ensuring proper resource management and preventing memory leaks.\n\n5. **Third-Party Integration**\n   Actions provide an ideal interface for integrating third-party libraries that need to operate directly on DOM elements, keeping your components clean and framework-agnostic.\n\n6. **Type Safety**\n   When using TypeScript, actions can be fully typed, including their parameters and any custom events they dispatch, providing excellent developer experience and catching errors early.\n\n7. **Progressive Enhancement**\n   Actions only run in the browser (not during SSR), making them perfect for implementing progressive enhancement patterns where core functionality works without JavaScript, but additional features are added when JavaScript is available.\n\n8. **Separation from Component State**\n   Actions operate somewhat independently from component state, which can simplify reasoning about your application and reduce complexity.\n\n### Scenarios Where Actions Excel\n\n1. **Integrating Third-Party Libraries**\n   ```svelte\n   <script>\n     /** @type {import('svelte/action').Action} */\n     function mapbox(node, apiKey) {\n       // Initialize Mapbox on this node\n       const map = new mapboxgl.Map({\n         container: node,\n         style: 'mapbox://styles/mapbox/streets-v11',\n         accessToken: apiKey\n       });\n       \n       $effect(() => {\n         return () => map.remove();\n       });\n     }\n   </script>\n   \n   <div class=\"map-container\" use:mapbox={\"your-api-key\"} />\n   ```\n\n2. **Custom Event Handling**\n   ```svelte\n   <script>\n     /** @type {import('svelte/action').Action} */\n     function clickOutside(node) {\n       $effect(() => {\n         const handleClick = (event) => {\n           if (!node.contains(event.target)) {\n             node.dispatchEvent(new CustomEvent('outclick'));\n           }\n         };\n         \n         document.addEventListener('click', handleClick, true);\n         \n         return () => {\n           document.removeEventListener('click', handleClick, true);\n         };\n       });\n     }\n     \n     function handleOutsideClick() {\n       console.log('Clicked outside');\n     }\n   </script>\n   \n   <div use:clickOutside on:outclick={handleOutsideClick}>\n     Click outside me!\n   </div>\n   ```\n\n3. **Browser APIs that Require Cleanup**\n   ```svelte\n   <script>\n     /** @type {import('svelte/action').Action} */\n     function intersectionObserver(node, callback) {\n       $effect(() => {\n         const observer = new IntersectionObserver(callback);\n         observer.observe(node);\n         \n         return () => {\n           observer.disconnect();\n         };\n       });\n     }\n     \n     function handleIntersection(entries) {\n       if (entries[0].isIntersecting) {\n         console.log('Element is visible');\n       }\n     }\n   </script>\n   \n   <div use:intersectionObserver={handleIntersection}>\n     I'll log when I become visible!\n   </div>\n   ```\n\n4. **Accessibility Enhancements**\n   ```svelte\n   <script>\n     /** @type {import('svelte/action').Action} */\n     function trapFocus(node) {\n       $effect(() => {\n         const focusableElements = node.querySelectorAll(\n           'a[href], button, textarea, input[type=\"text\"], input[type=\"radio\"], input[type=\"checkbox\"], select'\n         );\n         \n         const firstElement = focusableElements[0];\n         const lastElement = focusableElements[focusableElements.length - 1];\n         \n         const handleKeyDown = (e) => {\n           if (e.key === 'Tab') {\n             if (e.shiftKey && document.activeElement === firstElement) {\n               e.preventDefault();\n               lastElement.focus();\n             } else if (!e.shiftKey && document.activeElement === lastElement) {\n               e.preventDefault();\n               firstElement.focus();\n             }\n           }\n         };\n         \n         node.addEventListener('keydown', handleKeyDown);\n         \n         return () => {\n           node.removeEventListener('keydown', handleKeyDown);\n         };\n       });\n     }\n   </script>\n   \n   <div class=\"modal\" use:trapFocus>\n     <button>First button</button>\n     <input type=\"text\" />\n     <button>Last button</button>\n   </div>\n   ```\n\n5. **DOM Measurements and Resizing**\n   ```svelte\n   <script>\n     /** @type {import('svelte/action').Action} */\n     function dimensions(node) {\n       let resizeObserver;\n       \n       $effect(() => {\n         resizeObserver = new ResizeObserver(entries => {\n           const { width, height } = entries[0].contentRect;\n           node.dispatchEvent(\n             new CustomEvent('resize', { detail: { width, height } })\n           );\n         });\n         \n         resizeObserver.observe(node);\n         \n         return () => {\n           resizeObserver.disconnect();\n         };\n       });\n     }\n     \n     function handleResize(event) {\n       console.log(`New dimensions: ${event.detail.width}x${event.detail.height}`);\n     }\n   </script>\n   \n   <div use:dimensions on:resize={handleResize}>\n     Resize me to see dimensions logged\n   </div>\n   ```\n\n6. **Animation and Transitions**\n   ```svelte\n   <script>\n     /** @type {import('svelte/action').Action} */\n     function fadeIn(node, { duration = 300, delay = 0 } = {}) {\n       $effect(() => {\n         node.style.opacity = '0';\n         node.style.transition = `opacity ${duration}ms ${delay}ms`;\n         \n         // Force a reflow to ensure the initial state is applied\n         void node.offsetHeight;\n         \n         node.style.opacity = '1';\n         \n         return () => {\n           node.style.opacity = '0';\n         };\n       });\n     }\n   </script>\n   \n   <div use:fadeIn={{ duration: 500, delay: 200 }}>\n     I'll fade in when mounted!\n   </div>\n   ```\n\n7. **Form Handling and Validation**\n   ```svelte\n   <script>\n     /** @type {import('svelte/action').Action} */\n     function validateInput(node, { pattern, errorMessage } = {}) {\n       $effect(() => {\n         const handleInput = () => {\n           const isValid = pattern ? pattern.test(node.value) : true;\n           \n           if (!isValid) {\n             node.setCustomValidity(errorMessage || 'Invalid input');\n             node.dispatchEvent(new CustomEvent('invalid', { \n               bubbles: true,\n               detail: { message: errorMessage }\n             }));\n           } else {\n             node.setCustomValidity('');\n           }\n         };\n         \n         node.addEventListener('input', handleInput);\n         \n         return () => {\n           node.removeEventListener('input', handleInput);\n         };\n       });\n     }\n     \n     function handleInvalid(event) {\n       console.log('Invalid input:', event.detail.message);\n     }\n   </script>\n   \n   <input \n     type=\"text\" \n     use:validateInput={{ \n       pattern: /^[A-Za-z]+$/, \n       errorMessage: 'Only letters allowed' \n     }}\n     on:invalid={handleInvalid}\n     placeholder=\"Letters only\"\n   />\n   ```\n\nActions in Svelte 5 shine when you need to work directly with the DOM, integrate with external libraries, or implement reusable DOM-related functionality. They provide a clean, encapsulated way to handle these concerns while keeping your component logic focused on its primary responsibilities."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"How can you implement an action that manages multiple DOM event listeners with proper cleanup?","answer":"Managing multiple DOM event listeners with proper cleanup is a common use case for Svelte actions. Here's a comprehensive example of an action that implements a draggable and resizable element with multiple event listeners and proper cleanup:\n\n```svelte\n<script lang=\"ts\">\n  import type { Action } from 'svelte/action';\n  \n  interface DragResizeOptions {\n    minWidth?: number;\n    minHeight?: number;\n    dragHandle?: string;\n    resizeHandle?: string;\n    constrain?: boolean;\n    onUpdate?: (dimensions: { x: number, y: number, width: number, height: number }) => void;\n  }\n  \n  /**\n   * Action that makes an element both draggable and resizable\n   * @type {Action<HTMLElement, DragResizeOptions>}\n   */\n  function dragResize(node, options: DragResizeOptions = {}) {\n    const {\n      minWidth = 100,\n      minHeight = 100,\n      dragHandle = '.drag-handle',\n      resizeHandle = '.resize-handle',\n      constrain = true,\n      onUpdate = () => {}\n    } = options;\n    \n    // State variables\n    let x = 0;\n    let y = 0;\n    let width = node.offsetWidth;\n    let height = node.offsetHeight;\n    let isDragging = false;\n    let isResizing = false;\n    let startX = 0;\n    let startY = 0;\n    let startWidth = 0;\n    let startHeight = 0;\n    \n    // Element references\n    let dragHandleElement: Element | null = null;\n    let resizeHandleElement: Element | null = null;\n    \n    // Apply initial styles\n    node.style.position = 'absolute';\n    node.style.width = `${width}px`;\n    node.style.height = `${height}px`;\n    node.style.transform = `translate(${x}px, ${y}px)`;\n    \n    // Initialize the element\n    function initialize() {\n      // Find handle elements\n      dragHandleElement = node.querySelector(dragHandle);\n      resizeHandleElement = node.querySelector(resizeHandle);\n      \n      // Update dimensions\n      width = node.offsetWidth;\n      height = node.offsetHeight;\n      \n      // Apply initial styles\n      updateElementStyle();\n    }\n    \n    // Update the element's style based on current state\n    function updateElementStyle() {\n      node.style.width = `${width}px`;\n      node.style.height = `${height}px`;\n      node.style.transform = `translate(${x}px, ${y}px)`;\n      \n      // Call the onUpdate callback\n      onUpdate({ x, y, width, height });\n    }\n    \n    // Start dragging\n    function startDrag(event: MouseEvent) {\n      // Only proceed if we're clicking on the drag handle\n      if (dragHandleElement && !dragHandleElement.contains(event.target as Node)) {\n        return;\n      }\n      \n      event.preventDefault();\n      \n      isDragging = true;\n      startX = event.clientX - x;\n      startY = event.clientY - y;\n      \n      // Add global event listeners\n      window.addEventListener('mousemove', handleDrag);\n      window.addEventListener('mouseup', stopDrag);\n    }\n    \n    // Handle dragging\n    function handleDrag(event: MouseEvent) {\n      if (!isDragging) return;\n      \n      let newX = event.clientX - startX;\n      let newY = event.clientY - startY;\n      \n      // Constrain to viewport if enabled\n      if (constrain) {\n        const parentRect = node.parentElement?.getBoundingClientRect() || { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };\n        \n        newX = Math.max(0, Math.min(newX, parentRect.width - width));\n        newY = Math.max(0, Math.min(newY, parentRect.height - height));\n      }\n      \n      x = newX;\n      y = newY;\n      \n      updateElementStyle();\n    }\n    \n    // Stop dragging\n    function stopDrag() {\n      isDragging = false;\n      \n      // Remove global event listeners\n      window.removeEventListener('mousemove', handleDrag);\n      window.removeEventListener('mouseup', stopDrag);\n    }\n    \n    // Start resizing\n    function startResize(event: MouseEvent) {\n      // Only proceed if we're clicking on the resize handle\n      if (resizeHandleElement && !resizeHandleElement.contains(event.target as Node)) {\n        return;\n      }\n      \n      event.preventDefault();\n      \n      isResizing = true;\n      startX = event.clientX;\n      startY = event.clientY;\n      startWidth = width;\n      startHeight = height;\n      \n      // Add global event listeners\n      window.addEventListener('mousemove', handleResize);\n      window.addEventListener('mouseup', stopResize);\n    }\n    \n    // Handle resizing\n    function handleResize(event: MouseEvent) {\n      if (!isResizing) return;\n      \n      const dx = event.clientX - startX;\n      const dy = event.clientY - startY;\n      \n      width = Math.max(minWidth, startWidth + dx);\n      height = Math.max(minHeight, startHeight + dy);\n      \n      updateElementStyle();\n    }\n    \n    // Stop resizing\n    function stopResize() {\n      isResizing = false;\n      \n      // Remove global event listeners\n      window.removeEventListener('mousemove', handleResize);\n      window.removeEventListener('mouseup', stopResize);\n    }\n    \n    // Initialize after the element is mounted\n    initialize();\n    \n    $effect(() => {\n      // Add the main mousedown listeners\n      node.addEventListener('mousedown', startDrag);\n      \n      if (resizeHandleElement) {\n        resizeHandleElement.addEventListener('mousedown', startResize);\n      }\n      \n      // Handle window resize events\n      const handleWindowResize = () => {\n        if (constrain) {\n          const parentRect = node.parentElement?.getBoundingClientRect() || { width: window.innerWidth, height: window.innerHeight };\n          \n          x = Math.min(x, parentRect.width - width);\n          y = Math.min(y, parentRect.height - height);\n          \n          updateElementStyle();\n        }\n      };\n      \n      window.addEventListener('resize', handleWindowResize);\n      \n      // Clean up all event listeners\n      return () => {\n        // Remove mousedown listeners\n        node.removeEventListener('mousedown', startDrag);\n        \n        if (resizeHandleElement) {\n          resizeHandleElement.removeEventListener('mousedown', startResize);\n        }\n        \n        // Remove global listeners in case element is destroyed while dragging/resizing\n        window.removeEventListener('mousemove', handleDrag);\n        window.removeEventListener('mouseup', stopDrag);\n        window.removeEventListener('mousemove', handleResize);\n        window.removeEventListener('mouseup', stopResize);\n        window.removeEventListener('resize', handleWindowResize);\n      };\n    });\n  }\n  \n  // Track the dimensions for display\n  let currentDimensions = { x: 0, y: 0, width: 200, height: 150 };\n  \n  function handleUpdate(dimensions) {\n    currentDimensions = dimensions;\n  }\n</script>\n\n<div class=\"container\">\n  <div \n    class=\"draggable-resizable\"\n    use:dragResize={{\n      minWidth: 100,\n      minHeight: 100,\n      constrain: true,\n      onUpdate: handleUpdate\n    }}\n  >\n    <div class=\"drag-handle\">Drag here</div>\n    <div class=\"content\">\n      Position: ({currentDimensions.x}, {currentDimensions.y})<br>\n      Size: {currentDimensions.width} Ã {currentDimensions.height}\n    </div>\n    <div class=\"resize-handle\">â¤¡</div>\n  </div>\n</div>\n\n<style>\n  .container {\n    position: relative;\n    width: 100%;\n    height: 400px;\n    background-color: #f0f0f0;\n    border: 1px solid #ccc;\n    overflow: hidden;\n  }\n  \n  .draggable-resizable {\n    position: absolute;\n    width: 200px;\n    height: 150px;\n    background-color: white;\n    border: 1px solid #ddd;\n    box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n    display: flex;\n    flex-direction: column;\n  }\n  \n  .drag-handle {\n    padding: 8px;\n    background-color: #4285f4;\n    color: white;\n    cursor: move;\n    user-select: none;\n  }\n  \n  .content {\n    flex: 1;\n    padding: 16px;\n    overflow: auto;\n  }\n  \n  .resize-handle {\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    width: 20px;\n    height: 20px;\n    cursor: nwse-resize;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    user-select: none;\n  }\n</style>\n```\n\nThis example demonstrates several important aspects of managing multiple event listeners in a Svelte action:\n\n1. **Event Listener Organization:**\n   - The action sets up different types of event listeners for different purposes (dragging, resizing, window resizing)\n   - Event listeners are organized into logical groups with clear start/handle/stop patterns\n\n2. **Global vs. Local Event Listeners:**\n   - Local event listeners (`mousedown`) are attached directly to the node or its children\n   - Global event listeners (`mousemove`, `mouseup`) are attached to the window only when needed and removed immediately after use\n\n3. **Proper Cleanup:**\n   - All event listeners are properly removed in the cleanup function returned by `$effect`\n   - The action handles the case where the element might be destroyed while an operation is in progress\n\n4. **State Management:**\n   - The action maintains its own internal state (position, dimensions, drag/resize status)\n   - This state is separate from the component's state but can communicate with it via callbacks\n\n5. **Conditional Event Handling:**\n   - Event handlers check conditions before processing (e.g., isDragging, target element checks)\n   - This prevents unnecessary calculations and improves performance\n\n6. **Initialization:**\n   - The action performs initial setup outside of `$effect` since it only needs to happen once\n   - Dynamic elements (handles) are queried and cached for better performance\n\n7. **External Communication:**\n   - The action communicates changes back to the component via the `onUpdate` callback\n   - This allows the component to react to changes without tightly coupling the action to component state\n\n8. **Boundary Constraints:**\n   - The action implements optional constraints to keep the element within its parent\n   - It also handles window resize events to maintain these constraints\n\nThis pattern of organizing event listeners in a Svelte action provides a clean, reusable way to implement complex DOM interactions while ensuring proper cleanup to prevent memory leaks."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"How does Svelte 5's approach to actions differ from previous versions, and what are the implications for migrating existing code?","answer":"Svelte 5 introduces significant changes to how actions work compared to previous versions, primarily due to the introduction of the runes system. Understanding these differences is crucial for migrating existing code. Let's examine the key differences and migration strategies:\n\n### Key Differences Between Svelte 5 and Previous Versions\n\n1. **Reactivity Model**\n\n   **Svelte 4 and earlier:**\n   ```svelte\n   <script>\n     function myAction(node, parameter) {\n       // Initial setup\n       console.log('Initial parameter:', parameter);\n       \n       return {\n         update(newParameter) {\n           // This runs whenever the parameter changes\n           console.log('Updated parameter:', newParameter);\n         },\n         destroy() {\n           // Cleanup when element is unmounted\n           console.log('Action destroyed');\n         }\n       };\n     }\n     \n     let value = 'initial';\n   </script>\n\n   <div use:myAction={value}></div>\n   ```\n\n   **Svelte 5:**\n   ```svelte\n   <script>\n     import { type Action } from 'svelte/action';\n     \n     /** @type {Action} */\n     function myAction(node, parameter) {\n       // Initial setup\n       console.log('Initial parameter:', parameter);\n       \n       $effect(() => {\n         // Setup code\n         console.log('Effect running');\n         \n         // Return cleanup function\n         return () => {\n           console.log('Effect cleanup');\n         };\n       });\n     }\n     \n     let value = 'initial';\n   </script>\n\n   <div use:myAction={value}></div>\n   ```\n\n2. **Parameter Change Handling**\n\n   **Svelte 4:** Actions automatically receive parameter updates via the `update` method\n   \n   **Svelte 5:** The action function is only called once and does not automatically react to parameter changes\n\n3. **Lifecycle Management**\n\n   **Svelte 4:** Uses explicit `update` and `destroy` methods\n   \n   **Svelte 5:** Uses the `$effect` rune with a returned cleanup function\n\n4. **TypeScript Integration**\n\n   **Svelte 4:**\n   ```typescript\n   function myAction(node: HTMLElement, parameter: string): {\n     update: (newParameter: string) => void;\n     destroy: () => void;\n   } {\n     // ...\n   }\n   ```\n   \n   **Svelte 5:**\n   ```typescript\n   import type { Action } from 'svelte/action';\n   \n   const myAction: Action<HTMLElement, string> = (node, parameter) => {\n     // ...\n   };\n   ```\n\n### Implications for Migrating Existing Code\n\n1. **Handling Parameter Changes**\n\n   **Migration Strategy:**\n   If your action needs to react to parameter changes, you have several options:\n\n   a. **Use reactive variables within the component:**\n   ```svelte\n   <script>\n     /** @type {Action} */\n     function myAction(node, initialConfig) {\n       // Store a reference to the node for use in effects\n       const element = node;\n       \n       $effect(() => {\n         // Setup with current config\n         console.log('Setting up with:', config);\n         \n         return () => {\n           // Cleanup\n         };\n       });\n     }\n     \n     let config = { color: 'red' };\n     \n     // Create an effect that updates the DOM when config changes\n     $effect(() => {\n       // This will re-run whenever config changes\n       const element = document.querySelector('#my-element');\n       if (element) {\n         element.style.backgroundColor = config.color;\n       }\n     });\n   </script>\n\n   <div id=\"my-element\" use:myAction={config}></div>\n   <button on:click={() => config.color = 'blue'}>Change Color</button>\n   ```\n\n   b. **Use a store that both the component and action can access:**\n   ```svelte\n   <script>\n     import { writable } from 'svelte/store';\n     \n     const configStore = writable({ color: 'red' });\n     \n     /** @type {Action} */\n     function myAction(node) {\n       $effect(() => {\n         // Subscribe to the store within the effect\n         const unsubscribe = configStore.subscribe(config => {\n           node.style.backgroundColor = config.color;\n         });\n         \n         return () => {\n           unsubscribe();\n         };\n       });\n     }\n   </script>\n\n   <div use:myAction></div>\n   <button on:click={() => configStore.update(c => ({ ...c, color: 'blue' }))}>\n     Change Color\n   </button>\n   ```\n\n2. **Refactoring Lifecycle Methods**\n\n   **Migration Strategy:**\n   Convert `destroy` methods to the cleanup function returned by `$effect`:\n\n   **Svelte 4:**\n   ```svelte\n   <script>\n     function tooltip(node, text) {\n       // Setup\n       const tip = document.createElement('div');\n       tip.textContent = text;\n       document.body.appendChild(tip);\n       \n       return {\n         update(newText) {\n           tip.textContent = newText;\n         },\n         destroy() {\n           document.body.removeChild(tip);\n         }\n       };\n     }\n   </script>\n   ```\n\n   **Svelte 5:**\n   ```svelte\n   <script>\n     /** @type {Action} */\n     function tooltip(node, text) {\n       // Setup\n       const tip = document.createElement('div');\n       tip.textContent = text;\n       document.body.appendChild(tip);\n       \n       $effect(() => {\n         // Any additional reactive setup\n         \n         return () => {\n           document.body.removeChild(tip);\n         };\n       });\n     }\n   </script>\n   ```\n\n3. **Handling Complex Update Logic**\n\n   **Migration Strategy:**\n   For actions with complex update logic, consider refactoring to use function calls or events:\n\n   ```svelte\n   <script>\n     /** @type {Action} */\n     function complexAction(node, initialConfig) {\n       // Create methods that can be called to update the action\n       function updateConfig(newConfig) {\n         // Logic that was previously in the update method\n         console.log('Manually updating with:', newConfig);\n       }\n       \n       // Expose the update method on the node\n       node.updateActionConfig = updateConfig;\n       \n       $effect(() => {\n         return () => {\n           // Clean up\n           delete node.updateActionConfig;\n         };\n       });\n     }\n     \n     let config = { value: 1 };\n     let actionElement;\n     \n     function updateAction() {\n       if (actionElement && actionElement.updateActionConfig) {\n         actionElement.updateActionConfig(config);\n       }\n     }\n     \n     $effect(() => {\n       // Automatically call updateAction when config changes\n       if (actionElement) updateAction();\n     });\n   </script>\n\n   <div \n     bind:this={actionElement} \n     use:complexAction={config}\n   ></div>\n   <button on:click={() => { config = { value: config.value + 1 }; updateAction(); }}>\n     Update\n   </button>\n   ```\n\n4. **TypeScript Adjustments**\n\n   **Migration Strategy:**\n   Update type definitions to use the `Action` type from 'svelte/action':\n\n   ```typescript\n   // Before\n   interface ActionReturn<P> {\n     update?: (newParameters: P) => void;\n     destroy?: () => void;\n   }\n   \n   function myAction<P>(node: HTMLElement, parameters: P): ActionReturn<P> {\n     // ...\n   }\n   \n   // After\n   import type { Action } from 'svelte/action';\n   \n   const myAction: Action<HTMLElement, MyParameterType> = (node, parameters) => {\n     // ...\n   };\n   ```\n\n5. **Server-Side Rendering Considerations**\n\n   **Migration Strategy:**\n   Ensure actions don't run during SSR by checking for browser environment:\n\n   ```svelte\n   <script>\n     /** @type {Action} */\n     function browserOnlyAction(node, params) {\n       // Skip setup during SSR\n       if (typeof window === 'undefined') return;\n       \n       // Browser-only code here\n       \n       $effect(() => {\n         // More browser-only code\n         \n         return () => {\n           // Cleanup\n         };\n       });\n     }\n   </script>\n   ```\n\n### General Migration Approach\n\n1. **Audit Existing Actions**\n   - Identify all actions in your codebase\n   - Categorize them based on complexity and reliance on parameter updates\n\n2. **Prioritize Migration**\n   - Start with simpler actions that don't rely heavily on parameter updates\n   - Leave complex actions for later when you're more comfortable with the new pattern\n\n3. **Refactor in Phases**\n   - Phase 1: Convert to basic `$effect` pattern without handling parameter changes\n   - Phase 2: Implement alternative reactivity strategies for parameter changes\n   - Phase 3: Optimize and clean up\n\n4. **Test Thoroughly**\n   - Actions interact directly with the DOM, so visual testing is important\n   - Ensure all functionality works as expected after migration\n\n5. **Consider Compatibility Layer**\n   - For large codebases, you might want to create a compatibility wrapper that mimics the old behavior\n\n   ```svelte\n   <script>\n     /** \n      * Creates a Svelte 5 compatible action from a Svelte 4 style action\n      */\n     function compatAction(legacyActionFn) {\n       return (node, initialParams) => {\n         let actionObj = legacyActionFn(node, initialParams);\n         \n         $effect(() => {\n           // Return the original destroy method\n           return () => {\n             if (actionObj && typeof actionObj.destroy === 'function') {\n               actionObj.destroy();\n             }\n           };\n         });\n         \n         // Create a special property to handle updates\n         node._updateAction = (newParams) => {\n           if (actionObj && typeof actionObj.update === 'function') {\n             actionObj.update(newParams);\n           }\n         };\n       };\n     }\n     \n     // Original Svelte 4 action\n     function myOldAction(node, params) {\n       console.log('Init with', params);\n       \n       return {\n         update(newParams) {\n           console.log('Update with', newParams);\n         },\n         destroy() {\n           console.log('Cleanup');\n         }\n       };\n     }\n     \n     // Convert to Svelte 5 compatible action\n     const myCompatAction = compatAction(myOldAction);\n     \n     let params = { value: 1 };\n     let actionNode;\n     \n     function updateParams() {\n       params = { value: params.value + 1 };\n       if (actionNode && actionNode._updateAction) {\n         actionNode._updateAction(params);\n       }\n     }\n   </script>\n\n   <div bind:this={actionNode} use:myCompatAction={params}></div>\n   <button on:click={updateParams}>Update</button>\n   ```\n\nThe transition from Svelte 4 to Svelte 5 actions requires a shift in thinking about reactivity and lifecycle management. While the migration process may require some effort, the new approach with `$effect` aligns better with Svelte 5's overall reactivity model and provides a more consistent way to handle setup and cleanup."}
{"source":"docs/svelte/03-template-syntax/12-use.md","question":"How can you create a reusable action library for Svelte 5 with proper TypeScript support?","answer":"Creating a reusable action library for Svelte 5 with proper TypeScript support involves several best practices for organization, typing, and documentation. Let's build a comprehensive example of how to create such a library:\n\n### Creating a Svelte 5 Action Library\n\nHere's a complete approach to building a well-structured action library:\n\n#### 1. Project Structure\n\n```\nsvelte-actions/\nâââ src/\nâ   âââ actions/\nâ   â   âââ clickOutside.ts\nâ   â   âââ longpress.ts\nâ   â   âââ intersectionObserver.ts\nâ   â   âââ tooltip.ts\nâ   â   âââ index.ts\nâ   âââ types/\nâ   â   âââ index.ts\nâ   âââ index.ts\nâââ package.json\nâââ tsconfig.json\nâââ README.md\n```\n\n#### 2. Setting Up Types\n\n```typescript\n// src/types/index.ts\nimport type { Action as SvelteAction } from 'svelte/action';\n\n// Re-export the Svelte Action type\nexport type { SvelteAction };\n\n// Custom event detail types\nexport interface LongpressEventDetail {\n  duration: number;\n}\n\nexport interface IntersectionEventDetail {\n  isIntersecting: boolean;\n  intersectionRatio: number;\n}\n\n// Parameter types for actions\nexport interface TooltipParameters {\n  text: string;\n  position?: 'top' | 'right' | 'bottom' | 'left';\n  delay?: number;\n  theme?: 'light' | 'dark';\n}\n\nexport interface LongpressParameters {\n  duration?: number;\n  threshold?: number;\n}\n\nexport interface IntersectionObserverParameters {\n  root?: Element | null;\n  rootMargin?: string;\n  threshold?: number | number[];\n}\n\n// Utility type for defining actions with custom events\nexport type ActionWithEvents<\n  Node extends Element = Element,\n  Params = void,\n  Events = {}\n> = SvelteAction<Node, Params, Events>;\n```\n\n#### 3. Implementing Individual Actions\n\n```typescript\n// src/actions/clickOutside.ts\nimport type { ActionWithEvents } from '../types';\n\n/**\n * Action that triggers an event when a click occurs outside the element\n * \n * Usage:\n * ```svelte\n * <div use:clickOutside on:outclick={handleClickOutside}>\n *   Click outside me!\n * </div>\n * ```\n */\nexport const clickOutside: ActionWithEvents<\n  Element,\n  void,\n  { outclick: CustomEvent<void> }\n> = (node) => {\n  const handleClick = (event: MouseEvent) => {\n    if (node && !node.contains(event.target as Node) && !event.defaultPrevented) {\n      node.dispatchEvent(new CustomEvent('outclick'));\n    }\n  };\n  \n  $effect(() => {\n    document.addEventListener('click', handleClick, true);\n    \n    return () => {\n      document.removeEventListener('click', handleClick, true);\n    };\n  });\n};\n```\n\n```typescript\n// src/actions/longpress.ts\nimport type { ActionWithEvents, LongpressParameters, LongpressEventDetail } from '../types';\n\n/**\n * Action that triggers an event when an element is pressed for a specified duration\n * \n * Usage:\n * ```svelte\n * <button \n *   use:longpress={{ duration: 1000 }}\n *   on:longpress={handleLongPress}\n * >\n *   Press and hold me\n * </button>\n * ```\n */\nexport const longpress: ActionWithEvents<\n  HTMLElement,\n  LongpressParameters,\n  { longpress: CustomEvent<LongpressEventDetail> }\n> = (node, params = {}) => {\n  const { duration = 500, threshold = 10 } = params;\n  \n  let timer: number;\n  let startTime: number;\n  let startX: number;\n  let startY: number;\n  \n  $effect(() => {\n    const handleMouseDown = (event: MouseEvent | TouchEvent) => {\n      startTime = Date.now();\n      \n      if (event instanceof MouseEvent) {\n        startX = event.clientX;\n        startY = event.clientY;\n      } else {\n        // TouchEvent\n        startX = event.touches[0].clientX;\n        startY = event.touches[0].clientY;\n      }\n      \n      timer = window.setTimeout(() => {\n        const pressedDuration = Date.now() - startTime;\n        node.dispatchEvent(\n          new CustomEvent('longpress', { \n            detail: { duration: pressedDuration } \n          })\n        );\n      }, duration);\n    };\n    \n    const handleMouseUp = () => {\n      clearTimeout(timer);\n    };\n    \n    const handleMouseMove = (event: MouseEvent | TouchEvent) => {\n      let currentX: number;\n      let currentY: number;\n      \n      if (event instanceof MouseEvent) {\n        currentX = event.clientX;\n        currentY = event.clientY;\n      } else {\n        // TouchEvent\n        currentX = event.touches[0].clientX;\n        currentY = event.touches[0].clientY;\n      }\n      \n      // If moved beyond threshold, cancel the longpress\n      if (\n        Math.abs(currentX - startX) > threshold ||\n        Math.abs(currentY - startY) > threshold\n      ) {\n        clearTimeout(timer);\n      }\n    };\n    \n    // Add all event listeners for both mouse and touch\n    node.addEventListener('mousedown', handleMouseDown);\n    node.addEventListener('mouseup', handleMouseUp);\n    node.addEventListener('mouseleave', handleMouseUp);\n    node.addEventListener('mousemove', handleMouseMove);\n    \n    node.addEventListener('touchstart', handleMouseDown);\n    node.addEventListener('touchend', handleMouseUp);\n    node.addEventListener('touchcancel', handleMouseUp);\n    node.addEventListener('touchmove', handleMouseMove);\n    \n    return () => {\n      clearTimeout(timer);\n      \n      // Remove all event listeners\n      node.removeEventListener('mousedown', handleMouseDown);\n      node.removeEventListener('mouseup', handleMouseUp);\n      node.removeEventListener('mouseleave', handleMouseUp);\n      node.removeEventListener('mousemove', handleMouseMove);\n      \n      node.removeEventListener('touchstart', handleMouseDown);\n      node.removeEventListener('touchend', handleMouseUp);\n      node.removeEventListener('touchcancel', handleMouseUp);\n      node.removeEventListener('touchmove', handleMouseMove);\n    };\n  });\n};\n```\n\n```typescript\n// src/actions/tooltip.ts\nimport type { ActionWithEvents, TooltipParameters } from '../types';\n\n/**\n * Action that adds a tooltip to an element\n * \n * Usage:\n * ```svelte\n * <button use:tooltip={{ text: \"Helpful information\", position: \"top\" }}>\n *   Hover me\n * </button>\n * ```\n */\nexport const tooltip: ActionWithEvents<HTMLElement, TooltipParameters> = (node, params) => {\n  const { \n    text, \n    position = 'top', \n    delay = 200,\n    theme = 'dark'\n  } = params;\n  \n  // Create tooltip element\n  const tooltipElement = document.createElement('div');\n  tooltipElement.textContent = text;\n  tooltipElement.className = `svelte-action-tooltip svelte-action-tooltip-${position} svelte-action-tooltip-${theme}`;\n  tooltipElement.style.position = 'absolute';\n  tooltipElement.style.zIndex = '10000';\n  tooltipElement.style.opacity = '0';\n  tooltipElement.style.transition = `opacity 150ms ease-in-out, transform 150ms ease-in-out`;\n  tooltipElement.style.pointerEvents = 'none';\n  tooltipElement.style.padding = '8px 12px';\n  tooltipElement.style.borderRadius = '4px';\n  \n  if (theme === 'dark') {\n    tooltipElement.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n    tooltipElement.style.color = 'white';\n  } else {\n    tooltipElement.style.backgroundColor = 'white';\n    tooltipElement.style.color = 'black';\n    tooltipElement.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';\n  }\n  \n  // Create a reference to setTimeout\n  let showTimeout: number;\n  \n  const positionTooltip = () => {\n    if (!tooltipElement.isConnected) {\n      document.body.appendChild(tooltipElement);\n    }\n    \n    const rect = node.getBoundingClientRect();\n    \n    // Calculate position based on the specified position\n    switch (position) {\n      case 'top':\n        tooltipElement.style.bottom = `${window.innerHeight - rect.top + 10}px`;\n        tooltipElement.style.left = `${rect.left + rect.width / 2}px`;\n        tooltipElement.style.transform = 'translateX(-50%) translateY(0)';\n        break;\n      case 'right':\n        tooltipElement.style.top = `${rect.top + rect.height / 2}px`;\n        tooltipElement.style.left = `${rect.right + 10}px`;\n        tooltipElement.style.transform = 'translateY(-50%) translateX(0)';\n        break;\n      case 'bottom':\n        tooltipElement.style.top = `${rect.bottom + 10}px`;\n        tooltipElement.style.left = `${rect.left + rect.width / 2}px`;\n        tooltipElement.style.transform = 'translateX(-50%) translateY(0)';\n        break;\n      case 'left':\n        tooltipElement.style.top = `${rect.top + rect.height / 2}px`;\n        tooltipElement.style.right = `${window.innerWidth - rect.left + 10}px`;\n        tooltipElement.style.transform = 'translateY(-50%) translateX(0)';\n        break;\n    }\n  };\n  \n  const showTooltip = () => {\n    positionTooltip();\n    tooltipElement.style.opacity = '1';\n    \n    // Add transform based on position for a small animation\n    switch (position) {\n      case 'top':\n        tooltipElement.style.transform = 'translateX(-50%) translateY(-5px)';\n        break;\n      case 'right':\n        tooltipElement.style.transform = 'translateY(-50%) translateX(5px)';\n        break;\n      case 'bottom':\n        tooltipElement.style.transform = 'translateX(-50%) translateY(5px)';\n        break;\n      case 'left':\n        tooltipElement.style.transform = 'translateY(-50%) translateX(-5px)';\n        break;\n    }\n  };\n  \n  const hideTooltip = () => {\n    tooltipElement.style.opacity = '0';\n    \n    // Reset transform\n    switch (position) {\n      case 'top':\n      case 'bottom':\n        tooltipElement.style.transform = 'translateX(-50%) translateY(0)';\n        break;\n      case 'left':\n      case 'right':\n        tooltipElement.style.transform = '"}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"What are transitions in Svelte, and how do you implement a basic fade transition when an element enters or leaves the DOM?","answer":"In Svelte, transitions are animations that occur when elements enter or leave the DOM as a result of state changes. Transitions are applied using the `transition:` directive, which creates a bidirectional transition that can be smoothly reversed while in progress.\n\nTo implement a basic fade transition, you need to:\n1. Import the fade transition from the svelte/transition module\n2. Apply the transition directive to the element you want to animate\n\nHere's a complete example:\n\n```svelte\n<script>\n  import { fade } from 'svelte/transition';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle visibility</button>\n\n{#if visible}\n  <div transition:fade>This element fades in and out</div>\n{/if}\n```\n\nWhen the `visible` state changes to `true`, the div will fade in. When it changes to `false`, the div will fade out. The fade transition is bidirectional, which means if you toggle the state while the transition is in progress, it will smoothly reverse direction.\n\nAll elements inside a transitioning block are kept in the DOM until all transitions in the block have completed, ensuring smooth animations."}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"What's the difference between local and global transitions in Svelte, and when would you use each?","answer":"In Svelte, transitions can be either local or global, which determines when the transition is triggered.\n\n**Local transitions** (the default behavior):\n- Only play when the block they directly belong to is created or destroyed\n- Don't play when parent blocks are created or destroyed\n- Used when you want finer control over when transitions occur\n\n**Global transitions** (using the `|global` modifier):\n- Play when either the block they belong to OR any parent block is created or destroyed\n- Used when you want elements to transition regardless of which containing block caused the change\n\nHere's an example showing the difference:\n\n```svelte\n<script>\n  import { fade } from 'svelte/transition';\n  \n  let x = $state(false);\n  let y = $state(false);\n</script>\n\n<button onclick={() => x = !x}>Toggle x</button>\n<button onclick={() => y = !y}>Toggle y</button>\n\n{#if x}\n  <div class=\"container\">\n    {#if y}\n      <p transition:fade>\n        Local transition - only fades when y changes\n      </p>\n      \n      <p transition:fade|global>\n        Global transition - fades when either x or y changes\n      </p>\n    {/if}\n  </div>\n{/if}\n```\n\nYou would use:\n- **Local transitions** when you want precise control over which state changes trigger animations\n- **Global transitions** when you want elements to animate consistently regardless of which parent block is responsible for adding/removing them from the DOM\n\nThis distinction is particularly useful in complex UIs with nested conditional blocks."}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"How can you customize transition parameters in Svelte, and what are some common parameters available for built-in transitions?","answer":"In Svelte, you can customize transitions by passing parameters as an object to the transition directive. These parameters allow you to control various aspects of the animation such as duration, delay, and easing.\n\nTo pass parameters to a transition, you use an expression with an object literal:\n\n```svelte\n<script>\n  import { fade, fly, slide } from 'svelte/transition';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <div transition:fade={{ duration: 2000, delay: 500 }}>\n    Fades in over 2 seconds, after a 500ms delay\n  </div>\n{/if}\n```\n\nCommon parameters available for most built-in transitions include:\n\n1. **duration** (number, in ms): How long the transition takes (default varies by transition)\n2. **delay** (number, in ms): How long to wait before starting the transition\n3. **easing** (function): The timing function to use (can import from 'svelte/easing')\n\nSpecific transitions have additional parameters:\n\n**fade**:\n- `opacity`: The starting opacity value (default: 0)\n\n**fly**:\n- `x`: The x offset to start/end at (default: 0)\n- `y`: The y offset to start/end at (default: 0)\n- `opacity`: The starting opacity value (default: 0)\n\n**slide**:\n- `axis` (x or y): The axis to slide along (default: y)\n\n**scale**:\n- `start`: The starting scale value (default: 0)\n- `opacity`: The starting opacity value (default: 0)\n\n**draw** (for SVG elements):\n- `speed`: Determines how fast the line is drawn (default: 1)\n\nHere's an example using multiple transitions with different parameters:\n\n```svelte\n<script>\n  import { fade, fly, slide, scale } from 'svelte/transition';\n  import { elasticOut, quintOut } from 'svelte/easing';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <div transition:fade={{ duration: 1500 }}>\n    Basic fade with custom duration\n  </div>\n  \n  <div transition:fly={{ y: 200, duration: 2000, easing: elasticOut }}>\n    Flies in from 200px below with elastic easing\n  </div>\n  \n  <div transition:slide={{ duration: 800, easing: quintOut }}>\n    Slides in and out\n  </div>\n  \n  <div transition:scale={{ start: 0.5, duration: 1000 }}>\n    Scales from 50% to 100%\n  </div>\n{/if}\n```\n\nBy adjusting these parameters, you can create a wide variety of transition effects to enhance your UI's interactivity."}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"How do you create a custom transition function in Svelte, and what are the key properties that a transition object should return?","answer":"Creating a custom transition function in Svelte allows you to build unique animations tailored to your specific needs. A custom transition function receives a node (the DOM element), parameters, and options as arguments, and returns an object with specific properties.\n\nThe basic structure of a custom transition function is:\n\n```js\nfunction myTransition(node, params, options) {\n  // Setup code here\n  \n  return {\n    delay: number,       // Optional: milliseconds before transition starts\n    duration: number,    // Optional: milliseconds the transition lasts\n    easing: function,    // Optional: easing function\n    css: function,       // Optional: returns CSS string\n    tick: function       // Optional: called on each frame\n  };\n}\n```\n\nHere's a complete example of a custom \"whoosh\" transition that scales elements:\n\n```svelte\n<script>\n  import { elasticOut } from 'svelte/easing';\n  \n  let visible = $state(false);\n  \n  /**\n   * @param {HTMLElement} node\n   * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params\n   */\n  function whoosh(node, params) {\n    // Preserve any existing transform\n    const existingTransform = getComputedStyle(node).transform.replace('none', '');\n    \n    return {\n      delay: params.delay || 0,\n      duration: params.duration || 400,\n      easing: params.easing || elasticOut,\n      css: (t, u) => `transform: ${existingTransform} scale(${t})`\n    };\n  }\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <div transition:whoosh={{ duration: 800 }}>\n    Whooshes in and out with custom scaling\n  </div>\n{/if}\n```\n\nThe key properties a transition object can return are:\n\n1. **delay** (number): Milliseconds to wait before starting\n2. **duration** (number): Length of the transition in milliseconds\n3. **easing** (function): Timing function for the transition\n4. **css** (function): A function that returns a CSS string\n   - Receives `t` (value from 0-1) and `u` (equal to 1-t)\n   - `t` is 0â1 for in transitions, 1â0 for out transitions\n   - More efficient as it's compiled to CSS animations\n5. **tick** (function): A function called on each animation frame\n   - Also receives `t` and `u` parameters\n   - Used when CSS can't achieve the desired effect\n\nHere's another example showing a custom typewriter effect using the `tick` function:\n\n```svelte\n<script>\n  let visible = $state(false);\n  \n  /**\n   * @param {HTMLElement} node\n   * @param {{ speed?: number }} params\n   */\n  function typewriter(node, { speed = 1 }) {\n    // Validate that the node has a single text child\n    const valid = node.childNodes.length === 1 && \n                  node.childNodes[0].nodeType === Node.TEXT_NODE;\n    \n    if (!valid) {\n      throw new Error(`This transition only works on elements with a single text node child`);\n    }\n    \n    const text = node.textContent;\n    const duration = text.length / (speed * 0.01);\n    \n    return {\n      duration,\n      tick: (t) => {\n        const i = ~~(text.length * t); // ~~ is a faster Math.floor\n        node.textContent = text.slice(0, i);\n      }\n    };\n  }\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <p in:typewriter={{ speed: 1 }}>\n    The quick brown fox jumps over the lazy dog\n  </p>\n{/if}\n```\n\nCustom transitions also receive a third argument, `options`, which contains information about the transition, including:\n- `direction`: one of `'in'`, `'out'`, or `'both'` depending on the type of transition\n\nThis can be useful when you want your transition to behave differently for intro and outro animations."}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"What transition events are available in Svelte, and how would you use them to coordinate UI updates with animation states?","answer":"Svelte provides four specific transition events that allow you to detect when transitions start and end. These events are useful for coordinating UI updates, triggering additional animations, or updating application state based on animation progress.\n\nThe four transition events are:\n1. `introstart` - Fired when an in transition begins\n2. `introend` - Fired when an in transition completes\n3. `outrostart` - Fired when an out transition begins\n4. `outroend` - Fired when an out transition completes\n\nYou can listen for these events using the standard Svelte event directive syntax (`on:eventname`), or using the shorthand `oneventname` attribute.\n\nHere's an example showing how to use transition events:\n\n```svelte\n<script>\n  import { fly } from 'svelte/transition';\n  \n  let visible = $state(false);\n  let status = $state('idle');\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n<p>Current status: {status}</p>\n\n{#if visible}\n  <div\n    transition:fly={{ y: 200, duration: 2000 }}\n    on:introstart={() => status = 'Element is flying in...'}\n    on:introend={() => status = 'Element has arrived'}\n    on:outrostart={() => status = 'Element is flying away...'}\n    on:outroend={() => status = 'Element has left'}\n  >\n    This element flies in and out\n  </div>\n{/if}\n```\n\nYou can also use the shorthand syntax:\n\n```svelte\n{#if visible}\n  <div\n    transition:fly={{ y: 200, duration: 2000 }}\n    onintrostart={() => status = 'Element is flying in...'}\n    onintroend={() => status = 'Element has arrived'}\n    onoutrostart={() => status = 'Element is flying away...'}\n    onoutroend={() => status = 'Element has left'}\n  >\n    This element flies in and out\n  </div>\n{/if}\n```\n\nThese events can be used for various practical purposes:\n\n1. **Loading indicators**: Show/hide loading states based on transition completion\n```svelte\n{#if loading}\n  <div \n    transition:fade\n    onoutroend={() => showContent = true}\n  >\n    Loading...\n  </div>\n{/if}\n\n{#if showContent}\n  <div transition:fade>Content loaded!</div>\n{/if}\n```\n\n2. **Sequential animations**: Trigger a series of animations one after another\n```svelte\n<script>\n  let step1 = $state(true);\n  let step2 = $state(false);\n  let step3 = $state(false);\n</script>\n\n{#if step1}\n  <div \n    transition:fly={{ x: -100 }}\n    onintroend={() => step2 = true}\n    onoutroend={() => step2 = true}\n  >\n    Step 1\n  </div>\n{/if}\n\n{#if step2}\n  <div \n    transition:fly={{ y: 100 }}\n    onintroend={() => step3 = true}\n  >\n    Step 2\n  </div>\n{/if}\n\n{#if step3}\n  <div transition:scale>\n    Step 3\n  </div>\n{/if}\n```\n\n3. **Accessibility enhancements**: Manage focus or announce changes when transitions complete\n```svelte\n<script>\n  let modalVisible = $state(false);\n  \n  function focusFirstInput() {\n    document.querySelector('.modal input')?.focus();\n  }\n</script>\n\n<button onclick={() => modalVisible = true}>Open Modal</button>\n\n{#if modalVisible}\n  <div \n    class=\"modal\"\n    transition:fade\n    onintroend={focusFirstInput}\n  >\n    <h2>Modal Title</h2>\n    <input type=\"text\" placeholder=\"Focus moves here after intro\">\n    <button onclick={() => modalVisible = false}>Close</button>\n  </div>\n{/if}\n```\n\nBy using transition events, you can create more sophisticated UI interactions that are well-coordinated with the visual animations happening on screen."}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"How do the `in:` and `out:` directives differ from the `transition:` directive, and when would you use each one?","answer":"Svelte provides three different transition directives that control how elements animate when entering or leaving the DOM:\n\n1. **`transition:`** - Creates a bidirectional transition that works both when the element enters and leaves the DOM\n2. **`in:`** - Creates a transition that only applies when the element enters the DOM\n3. **`out:`** - Creates a transition that only applies when the element leaves the DOM\n\nThe main differences are:\n\n**`transition:` directive:**\n- Applies to both entering and leaving transitions\n- The same animation runs in reverse when the element leaves\n- Smoothly reverses if the state changes during the transition\n- Can be thought of as a shorthand for using the same function for both `in:` and `out:`\n\n**`in:` directive:**\n- Only applies when the element enters the DOM\n- No animation plays when the element leaves (it just disappears)\n- Useful when you want different animations for entering vs leaving\n\n**`out:` directive:**\n- Only applies when the element leaves the DOM\n- No animation plays when the element enters (it just appears)\n- Useful when you want different animations for entering vs leaving\n\nHere's an example demonstrating all three:\n\n```svelte\n<script>\n  import { fade, fly, slide } from 'svelte/transition';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <!-- Bidirectional: fades both in and out -->\n  <div transition:fade>\n    This element fades in AND out\n  </div>\n  \n  <!-- Unidirectional: flies in, but disappears instantly -->\n  <div in:fly={{ y: 50 }}>\n    This element flies in but disappears instantly\n  </div>\n  \n  <!-- Unidirectional: appears instantly, but slides out -->\n  <div out:slide>\n    This element appears instantly but slides out\n  </div>\n  \n  <!-- Combined: different transitions for in and out -->\n  <div in:fly={{ y: -20 }} out:fade>\n    This element flies in from above and fades out\n  </div>\n{/if}\n```\n\nWhen to use each:\n\n1. Use **`transition:`** when:\n   - You want the same animation for both entering and leaving\n   - You want smooth reversible transitions\n   - You prefer concise code\n\n```svelte\n<div transition:fade={{ duration: 300 }}>\n  Consistent animation in both directions\n</div>\n```\n\n2. Use **`in:` and `out:`** separately when:\n   - You want different animations for entering vs leaving\n   - You want to animate only in one direction\n\n```svelte\n<div in:fly={{ y: 100 }} out:fade>\n  Flies in from below, fades out\n</div>\n```\n\n3. Use **combined `in:` and `out:`** when:\n   - You need different parameters for the same transition type\n\n```svelte\n<div \n  in:fade={{ duration: 300 }} \n  out:fade={{ duration: 1000 }}\n>\n  Fades in quickly but fades out slowly\n</div>\n```\n\n4. Use **only `in:`** when:\n   - You want elements to animate in but disappear immediately\n\n```svelte\n<div in:slide>\n  Slides in but disappears instantly\n</div>\n```\n\n5. Use **only `out:`** when:\n   - You want elements to appear immediately but animate out\n\n```svelte\n<div out:scale>\n  Appears instantly but scales down when removed\n</div>\n```\n\nBy choosing the appropriate transition directive, you can create more nuanced and effective user interfaces that guide users' attention appropriately."}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"How can you create a custom crossfade transition effect between two elements in Svelte?","answer":"Creating a crossfade effect in Svelte involves coordinating transitions between elements that are entering and leaving the DOM, making it appear as if one element is transforming into another. Svelte allows for this by having transition functions return another function rather than a transition object.\n\nThe key to creating crossfade effects is:\n1. Creating a function that returns two transitions (`send` and `receive`)\n2. Having these transitions communicate with each other\n3. Using deferred transitions to coordinate the animation\n\nHere's a complete example of a custom crossfade implementation:\n\n```svelte\n<script>\n  import { quintOut } from 'svelte/easing';\n  \n  // Track which elements are currently transitioning\n  let activeTransitions = new Map();\n  \n  function crossfade() {\n    // Return an object with send and receive functions\n    return {\n      send: (node, params) => {\n        const { key, duration = 400, easing = quintOut } = params;\n        \n        // Get the element's position and dimensions\n        const rect = node.getBoundingClientRect();\n        \n        // Store the information about this element\n        activeTransitions.set(key, {\n          rect,\n          element: node\n        });\n        \n        return {\n          duration,\n          easing,\n          css: (t, u) => `\n            opacity: ${u};\n            transform: scale(${t});\n          `\n        };\n      },\n      \n      receive: (node, params) => {\n        const { key, duration = 400, easing = quintOut } = params;\n        \n        // If we don't have info about the sending element, use a default transition\n        if (!activeTransitions.has(key)) {\n          return {\n            duration,\n            easing,\n            css: (t) => `\n              opacity: ${t};\n              transform: scale(${t});\n            `\n          };\n        }\n        \n        // Get information about the sending element\n        const { rect: fromRect } = activeTransitions.get(key);\n        const toRect = node.getBoundingClientRect();\n        \n        // Calculate the differences\n        const dx = fromRect.left - toRect.left;\n        const dy = fromRect.top - toRect.top;\n        const dw = fromRect.width / toRect.width;\n        const dh = fromRect.height / toRect.height;\n        \n        // Remove from active transitions\n        activeTransitions.delete(key);\n        \n        return {\n          duration,\n          easing,\n          css: (t, u) => `\n            opacity: ${t};\n            transform: translate(${dx * u}px, ${dy * u}px) \n                       scale(${1 + (dw - 1) * u}, ${1 + (dh - 1) * u});\n          `\n        };\n      }\n    };\n  }\n  \n  // Create the transitions\n  const { send, receive } = crossfade();\n  \n  // Sample data for the example\n  let items = $state([\n    { id: 1, color: 'red' },\n    { id: 2, color: 'blue' },\n    { id: 3, color: 'green' }\n  ]);\n  \n  let selected = $state(null);\n  \n  function select(item) {\n    selected = item;\n  }\n  \n  function deselect() {\n    selected = null;\n  }\n</script>\n\n<div class=\"container\">\n  {#if selected}\n    <!-- Full view of selected item -->\n    <div \n      class=\"selected-item\"\n      style=\"background-color: {selected.color};\"\n      in:receive={{ key: selected.id }}\n      out:send={{ key: selected.id }}\n      onclick={deselect}\n    >\n      Selected: {selected.id}\n    </div>\n  {:else}\n    <!-- List of items -->\n    <div class=\"item-list\">\n      {#each items as item (item.id)}\n        <div \n          class=\"item\"\n          style=\"background-color: {item.color};\"\n          in:receive={{ key: item.id }}\n          out:send={{ key: item.id }}\n          onclick={() => select(item)}\n        >\n          Item {item.id}\n        </div>\n      {/each}\n    </div>\n  {/if}\n</div>\n\n<style>\n  .container {\n    height: 300px;\n  }\n  \n  .item-list {\n    display: flex;\n    gap: 10px;\n  }\n  \n  .item {\n    width: 100px;\n    height: 100px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: white;\n    cursor: pointer;\n  }\n  \n  .selected-item {\n    width: 300px;\n    height: 200px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: white;\n    cursor: pointer;\n  }\n</style>\n```\n\nIn this example:\n\n1. We define a `crossfade` function that returns two transition functions: `send` and `receive`\n2. The `send` transition is applied to elements that are leaving the DOM\n3. The `receive` transition is applied to elements that are entering the DOM\n4. We use a `Map` to track active transitions and share information between them\n5. When an element transitions out with `send`, it stores its dimensions\n6. When an element transitions in with `receive`, it uses those dimensions to create a smooth crossfade effect\n7. The transitions are applied using the `in:` and `out:` directives with a unique `key` parameter\n\nThe key aspects that make crossfade work:\n\n1. **Shared state**: The `activeTransitions` map allows the transitions to share information\n2. **Unique keys**: Each element needs a unique identifier so we know which elements correspond to each other\n3. **Measuring elements**: We use `getBoundingClientRect()` to get the position and size of elements\n4. **Calculating differences**: We compute the transforms needed to make one element appear to morph into another\n5. **CSS transforms**: We use CSS transforms to animate the position, size, and opacity\n\nThis technique is particularly useful for:\n- Photo galleries where thumbnails expand to full-size images\n- List items that expand into detailed views\n- UI elements that transform between different states\n- Creating fluid navigation experiences\n\nSvelte's built-in `svelte/transition` module actually provides a ready-to-use `crossfade` function that works similarly to this example, but this custom implementation shows how the mechanism works under the hood."}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"How do you ensure optimal performance when using transitions in Svelte, and what's the difference between using CSS and JavaScript for animations?","answer":"Optimizing performance with Svelte transitions requires understanding the two main approaches to animations: CSS-based and JavaScript-based. Each has different performance characteristics and use cases.\n\n## CSS vs JavaScript Animations\n\nIn Svelte, transitions can be implemented in two ways:\n\n1. **CSS-based animations** (using the `css` function)\n   ```js\n   return {\n     duration: 300,\n     css: (t, u) => `opacity: ${t}; transform: scale(${t})`\n   }\n   ```\n\n2. **JavaScript-based animations** (using the `tick` function)\n   ```js\n   return {\n     duration: 300,\n     tick: (t, u) => {\n       node.style.opacity = t;\n       node.style.transform = `scale(${t})`;\n     }\n   }\n   ```\n\n### Performance Differences\n\n**CSS-based transitions:**\n- â More performant as they run on the browser's compositor thread\n- â Svelte precomputes the animation and creates CSS keyframes\n- â Animations continue even if the main thread is busy\n- â Better battery life on mobile devices\n- â Limited to properties that can be animated with CSS\n\n**JavaScript-based transitions:**\n- â More flexibility for complex animations\n- â Can animate properties not supported by CSS\n- â Can integrate with other JS-based animation libraries\n- â Run on the main thread, potentially causing jank\n- â Higher CPU usage\n\n## Best Practices for Optimal Performance\n\n### 1. Prefer CSS-based transitions when possible\n\n```svelte\n<script>\n  function scale(node, { duration = 300 }) {\n    return {\n      duration,\n      css: (t) => `\n        transform: scale(${t});\n        opacity: ${t};\n      `\n    };\n  }\n</script>\n\n{#if visible}\n  <div transition:scale>Scales efficiently with CSS</div>\n{/if}\n```\n\n### 2. Animate transform and opacity properties\n\nThese properties are the most performant to animate as they don't trigger layout recalculations:\n\n```js\n// Good - only animates transform and opacity\ncss: (t) => `\n  transform: translate(${t * 100}px, 0) scale(${t});\n  opacity: ${t};\n`\n\n// Avoid - causes layout thrashing\ncss: (t) => `\n  width: ${t * 100}px;\n  height: ${t * 100}px;\n  margin-left: ${t * 20}px;\n`\n```\n\n### 3. Use hardware acceleration for smoother animations\n\n```js\ncss: (t) => `\n  transform: translate3d(0, ${t * 100}px, 0);\n  opacity: ${t};\n  will-change: transform, opacity;\n`\n```\n\n### 4. Only use `tick` when necessary\n\nReserve JavaScript-based animations for cases where CSS cannot achieve the desired effect:\n\n```svelte\n<script>\n  function typewriter(node, { speed = 1 }) {\n    const text = node.textContent;\n    const duration = text.length / (speed * 0.01);\n    \n    // This effect can't be done with CSS, so tick is appropriate\n    return {\n      duration,\n      tick: (t) => {\n        const i = Math.floor(text.length * t);\n        node.textContent = text.slice(0, i);\n      }\n    };\n  }\n</script>\n\n{#if visible}\n  <p in:typewriter={{ speed: 1 }}>\n    This text appears one character at a time\n  </p>\n{/if}\n```\n\n### 5. Limit the number of concurrent animations\n\nToo many simultaneous animations can cause performance issues:\n\n```svelte\n<!-- Instead of animating a long list all at once -->\n{#each longList as item (item.id)}\n  <div transition:fade>...</div>\n{/each}\n\n<!-- Consider animating only visible items or using staggered animations -->\n{#each visibleItems as item, i (item.id)}\n  <div in:fade={{ delay: i * 50 }}>...</div>\n{/each}\n```\n\n### 6. Use appropriate easing functions\n\nDifferent easing functions have different computational costs:\n\n```svelte\n<script>\n  import { linear, cubicOut, elasticOut } from 'svelte/easing';\n  \n  // Linear - most performant\n  // CubicOut - good balance\n  // ElasticOut - more computationally expensive\n</script>\n\n{#if visible}\n  <div transition:fade={{ easing: cubicOut }}>\n    Uses cubic easing for a good balance of quality and performance\n  </div>\n{/if}\n```\n\n### 7. Set reasonable durations\n\nLong animations can feel sluggish and consume more resources:\n\n```js\n// Too long for simple UI transitions\nreturn {\n  duration: 5000,\n  css: (t) => `opacity: ${t}`\n}\n\n// More appropriate for UI transitions\nreturn {\n  duration: 150, // 150-300ms is often ideal for UI transitions\n  css: (t) => `opacity: ${t}`\n}\n```\n\n### 8. Consider reduced motion preferences\n\nRespect user preferences for reduced motion:\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  \n  // Check for reduced motion preference\n  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n  \n  // Adjust transitions based on preference\n  const transitionProps = prefersReducedMotion \n    ? { duration: 0 } // Effectively disable animations\n    : { duration: 300, y: 20 }; // Normal animations\n</script>\n\n{#if visible}\n  <div transition:fly={transitionProps}>\n    Respects user motion preferences\n  </div>\n{/if}\n```\n\n### 9. Debug performance issues\n\nUse the browser's performance tools to identify problematic animations:\n\n```svelte\n<!-- Add debugging info to problematic transitions -->\n<div \n  transition:customTransition\n  onintrostart={() => console.time('transition')}\n  onintroend={() => console.timeEnd('transition')}\n>\n  Measuring transition performance\n</div>\n```\n\nBy following these best practices, you can create smooth, efficient animations in Svelte that enhance the user experience without degrading performance."}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"How can you combine multiple transitions on a single element in Svelte, and what are some creative use cases for this technique?","answer":"In Svelte, you can apply multiple transitions to a single element by combining the `transition:`, `in:`, and `out:` directives. This allows for complex and creative animation effects that can significantly enhance user experience.\n\n## Basic Syntax for Combining Transitions\n\nYou can combine transitions in several ways:\n\n1. **Different transitions for entering and leaving**:\n```svelte\n<div in:fade out:fly={{ y: 200 }}>\n  Fades in, flies out\n</div>\n```\n\n2. **Multiple in transitions**:\n```svelte\n<div in:fade in:scale>\n  Fades and scales in simultaneously\n</div>\n```\n\n3. **Multiple out transitions**:\n```svelte\n<div out:fade out:slide>\n  Fades and slides out simultaneously\n</div>\n```\n\n4. **Complete combination**:\n```svelte\n<div \n  in:fade={{ duration: 300 }}\n  in:fly={{ y: 50, duration: 500 }}\n  out:fade={{ duration: 400 }}\n  out:slide={{ duration: 300 }}\n>\n  Complex multi-transition element\n</div>\n```\n\n## Complete Example\n\nHere's a complete example showing how to combine multiple transitions:\n\n```svelte\n<script>\n  import { fade, fly, slide, scale, blur } from 'svelte/transition';\n  import { elasticOut, cubicInOut } from 'svelte/easing';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <div class=\"card\"\n    in:fade={{ duration: 400 }}\n    in:fly={{ y: 50, duration: 600, easing: elasticOut }}\n    out:fade={{ duration: 300 }}\n    out:slide={{ duration: 400, easing: cubicInOut }}\n  >\n    <h2\n      in:blur={{ delay: 300, duration: 200 }}\n      out:blur={{ duration: 200 }}\n    >\n      Multi-transition Card\n    </h2>\n    <p\n      in:slide={{ delay: 400, duration: 300 }}\n      out:scale={{ duration: 200 }}\n    >\n      This card uses multiple transitions for a rich animation experience.\n    </p>\n  </div>\n{/if}\n\n<style>\n  .card {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n    max-width: 400px;\n  }\n</style>\n```\n\n## Creative Use Cases\n\n### 1. Staggered Entrance of Component Parts\n\nCreate a more engaging entrance by staggering the animation of different parts:\n\n```svelte\n<script>\n  import { fade, fly, slide } from 'svelte/transition';\n  \n  let showModal = $state(false);\n</script>\n\n{#if showModal}\n  <div class=\"modal-backdrop\" \n    in:fade={{ duration: 200 }}\n    out:fade={{ duration: 200 }}\n  >\n    <div class=\"modal\" \n      in:scale={{ duration: 300, start: 0.8 }}\n      in:fade={{ duration: 300 }}\n      out:scale={{ duration: 200, start: 1.1 }}\n      out:fade={{ duration: 200 }}\n    >\n      <h2 in:slide={{ delay: 300, duration: 200 }}>\n        Welcome!\n      </h2>\n      <p in:fade={{ delay: 400, duration: 300 }}>\n        This modal has staggered entrance animations.\n      </p>\n      <button \n        in:fly={{ delay: 500, y: 20, duration: 200 }}\n        onclick={() => showModal = false}\n      >\n        Close\n      </button>\n    </div>\n  </div>\n{/if}\n```\n\n### 2. Attention-Drawing Effects\n\nCombine transitions to draw attention to important elements:\n\n```svelte\n<script>\n  import { scale, fade } from 'svelte/transition';\n  import { elasticOut } from 'svelte/easing';\n  \n  let showNotification = $state(false);\n  \n  function notify() {\n    showNotification = true;\n    setTimeout(() => showNotification = false, 3000);\n  }\n</script>\n\n<button onclick={notify}>Show Notification</button>\n\n{#if showNotification}\n  <div class=\"notification\"\n    in:scale={{ duration: 400, start: 0.5, easing: elasticOut }}\n    in:fade={{ duration: 200 }}\n    out:fade\n  >\n    <span class=\"pulse\"\n      in:scale={{ duration: 1000, start: 0.8, easing: elasticOut }}\n    >\n      ð\n    </span>\n    New message received!\n  </div>\n{/if}\n```\n\n### 3. 3D Card Flip Effect\n\nCombine transitions with CSS 3D transforms:\n\n```svelte\n<script>\n  import { fade } from 'svelte/transition';\n  \n  let flipped = $state(false);\n  \n  function flip() {\n    flipped = !flipped;\n  }\n  \n  // Custom transition for 3D rotation\n  function flipTransition(node, { duration }) {\n    return {\n      duration,\n      css: (t) => {\n        const rotateY = flipped \n          ? `rotateY(${180 * t}deg)` \n          : `rotateY(${180 - 180 * t}deg)`;\n        \n        return `transform: ${rotateY}; backface-visibility: hidden;`;\n      }\n    };\n  }\n</script>\n\n<div class=\"card-container\" onclick={flip}>\n  {#if !flipped}\n    <div class=\"card card-front\"\n      in:flipTransition={{ duration: 500 }}\n      in:fade={{ duration: 250, delay: 250 }}\n    >\n      <h3>Front of Card</h3>\n      <p>Click to flip</p>\n    </div>\n  {:else}\n    <div class=\"card card-back\"\n      in:flipTransition={{ duration: 500 }}\n      in:fade={{ duration: 250, delay: 250 }}\n    >\n      <h3>Back of Card</h3>\n      <p>Click to flip back</p>\n    </div>\n  {/if}\n</div>\n```\n\n### 4. Sequenced Form Field Validation\n\nProvide visual feedback for form validation:\n\n```svelte\n<script>\n  import { fly, scale } from 'svelte/transition';\n  \n  let email = $state('');\n  let password = $state('');\n  let submitted = $state(false);\n  let errors = $state({ email: false, password: false });\n  \n  function validate() {\n    submitted = true;\n    errors = {\n      email: !email.includes('@'),\n      password: password.length < 8\n    };\n  }\n</script>\n\n<form on:submit|preventDefault={validate}>\n  <div class=\"field\">\n    <label for=\"email\">Email</label>\n    <input id=\"email\" type=\"text\" bind:value={email} />\n    \n    {#if submitted && errors.email}\n      <div class=\"error\"\n        in:fly={{ y: -10 }}\n        in:scale={{ start: 0.8, duration: 200 }}\n      >\n        Please enter a valid email\n      </div>\n    {/if}\n  </div>\n  \n  <div class=\"field\">\n    <label for=\"password\">Password</label>\n    <input id=\"password\" type=\"password\" bind:value={password} />\n    \n    {#if submitted && errors.password}\n      <div class=\"error\"\n        in:fly={{ y: -10 }}\n        in:scale={{ start: 0.8, duration: 200 }}\n      >\n        Password must be at least 8 characters\n      </div>\n    {/if}\n  </div>\n  \n  <button type=\"submit\">Submit</button>\n</form>\n```\n\n### 5. Interactive Tutorial Overlay\n\nCreate engaging tutorials with multiple transition effects:\n\n```svelte\n<script>\n  import { fade, fly, scale } from 'svelte/transition';\n  \n  let step = $state(0);\n  \n  function nextStep() {\n    step += 1;\n    if (step > 3) step = 0;\n  }\n</script>\n\n<div class=\"app\">\n  <div class=\"content\">\n    <!-- App content here -->\n  </div>\n  \n  {#if step > 0}\n    <div class=\"tutorial-overlay\"\n      in:fade={{ duration: 200 }}\n      out:fade={{ duration: 200 }}\n    >\n      {#if step === 1}\n        <div class=\"tutorial-tip\"\n          in:fly={{ y: 50 }}\n          in:fade\n          style=\"top: 100px; left: 50px;\"\n        >\n          <div class=\"tip-content\"\n            in:scale={{ delay: 100, duration: 200 }}\n          >\n            Step 1: Click this button to start\n          </div>\n        </div>\n      {/if}\n      \n      {#if step === 2}\n        <div class=\"tutorial-tip\"\n          in:fly={{ y: 50 }}\n          in:fade\n          style=\"top: 200px; left: 150px;\"\n        >\n          <div class=\"tip-content\"\n            in:scale={{ delay: 100, duration: 200 }}\n          >\n            Step 2: Fill out this form\n          </div>\n        </div>\n      {/if}\n      \n      {#if step === 3}\n        <div class=\"tutorial-tip\"\n          in:fly={{ y: 50 }}\n          in:fade\n          style=\"top: 300px; left: 250px;\"\n        >\n          <div class=\"tip-content\"\n            in:scale={{ delay: 100, duration: 200 }}\n          >\n            Step 3: Submit to complete\n          </div>\n        </div>\n      {/if}\n      \n      <button class=\"next-button\"\n        in:scale\n        onclick={nextStep}\n      >\n        {step < 3 ? 'Next' : 'Finish'}\n      </button>\n    </div>\n  {/if}\n  \n  <button onclick={() => step = 1}>Start Tutorial</button>\n</div>\n```\n\nBy combining multiple transitions, you can create rich, engaging animations that guide users through your application, draw attention to important elements, and create a more polished user experience overall."}
{"source":"docs/svelte/03-template-syntax/13-transition.md","question":"What are the built-in transitions available in Svelte, and how do you use them with their specific parameters?","answer":"Svelte provides several built-in transitions in the `svelte/transition` module, each with specific parameters to customize their behavior. These transitions make it easy to add professional animations to your application without writing complex animation code.\n\n## Overview of Built-in Transitions\n\nHere's a comprehensive overview of all the built-in transitions in Svelte:\n\n| Transition | Description | Common Use Cases |\n|------------|-------------|-----------------|\n| `fade` | Simple opacity transition | Modals, tooltips, notifications |\n| `blur` | Combines opacity with a blur effect | Cards, dialogs, emphasis effects |\n| `fly` | Animates position and opacity | Sidebars, menus, dropdowns |\n| `slide` | Expands/collapses along an axis | Accordions, expandable panels |\n| `scale` | Animates size and opacity | Buttons, image galleries, emphasis |\n| `draw` | Animates SVG paths | Icons, illustrations, loaders |\n| `crossfade` | Creates paired transitions | Lists, image galleries, view transitions |\n\nLet's explore each transition in detail with examples:\n\n## 1. fade\n\nThe `fade` transition gradually changes the opacity of an element.\n\n**Parameters:**\n- `delay` (number, default: 0): Milliseconds to wait before starting\n- `duration` (number, default: 400): Milliseconds the transition lasts\n- `easing` (function, default: linear): Easing function to use\n- `opacity` (number, default: 0): Starting opacity (0 = fully transparent)\n\n```svelte\n<script>\n  import { fade } from 'svelte/transition';\n  import { quartOut } from 'svelte/easing';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <!-- Basic fade -->\n  <div transition:fade>\n    Basic fade with default parameters\n  </div>\n  \n  <!-- Customized fade -->\n  <div transition:fade={{ \n    delay: 200, \n    duration: 800, \n    easing: quartOut,\n    opacity: 0.2\n  }}>\n    Customized fade that starts at 20% opacity\n  </div>\n{/if}\n```\n\n## 2. blur\n\nThe `blur` transition combines opacity changes with a blur filter effect.\n\n**Parameters:**\n- `delay` (number, default: 0): Milliseconds to wait before starting\n- `duration` (number, default: 400): Milliseconds the transition lasts\n- `easing` (function, default: cubicInOut): Easing function to use\n- `opacity` (number, default: 0): Starting opacity\n- `amount` (number, default: 5): Blur amount in pixels\n\n```svelte\n<script>\n  import { blur } from 'svelte/transition';\n  import { backOut } from 'svelte/easing';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <!-- Basic blur -->\n  <div transition:blur>\n    Basic blur with default parameters\n  </div>\n  \n  <!-- Heavy blur effect -->\n  <div transition:blur={{ \n    duration: 1000, \n    amount: 20,\n    easing: backOut\n  }}>\n    Heavy blur effect with back-out easing\n  </div>\n{/if}\n```\n\n## 3. fly\n\nThe `fly` transition animates position (x/y coordinates) along with opacity.\n\n**Parameters:**\n- `delay` (number, default: 0): Milliseconds to wait before starting\n- `duration` (number, default: 400): Milliseconds the transition lasts\n- `easing` (function, default: cubicOut): Easing function to use\n- `x` (number, default: 0): Starting x offset in pixels\n- `y` (number, default: 0): Starting y offset in pixels\n- `opacity` (number, default: 0): Starting opacity\n\n```svelte\n<script>\n  import { fly } from 'svelte/transition';\n  import { elasticOut } from 'svelte/easing';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <!-- Fly from below -->\n  <div transition:fly={{ y: 100 }}>\n    Flies in from 100px below\n  </div>\n  \n  <!-- Fly from top-right -->\n  <div transition:fly={{ \n    x: 100, \n    y: -100, \n    duration: 1000,\n    easing: elasticOut\n  }}>\n    Flies in from top-right with elastic easing\n  </div>\n  \n  <!-- Fly with full opacity -->\n  <div transition:fly={{ \n    y: 50, \n    opacity: 1\n  }}>\n    Slides up without fading (maintains full opacity)\n  </div>\n{/if}\n```\n\n## 4. slide\n\nThe `slide` transition expands or collapses an element along its height (default) or width.\n\n**Parameters:**\n- `delay` (number, default: 0): Milliseconds to wait before starting\n- `duration` (number, default: 400): Milliseconds the transition lasts\n- `easing` (function, default: cubicOut): Easing function to use\n- `axis` (string, default: 'y'): Axis to slide along ('x' or 'y')\n\n```svelte\n<script>\n  import { slide } from 'svelte/transition';\n  import { quintOut } from 'svelte/easing';\n  \n  let showVertical = $state(false);\n  let showHorizontal = $state(false);\n</script>\n\n<button onclick={() => showVertical = !showVertical}>Toggle Vertical</button>\n<button onclick={() => showHorizontal = !showHorizontal}>Toggle Horizontal</button>\n\n{#if showVertical}\n  <!-- Vertical slide (default) -->\n  <div class=\"box\" transition:slide>\n    Slides vertically (default behavior)\n  </div>\n  \n  <!-- Slower vertical slide -->\n  <div class=\"box\" transition:slide={{ \n    duration: 1000, \n    easing: quintOut \n  }}>\n    Slower vertical slide with quintOut easing\n  </div>\n{/if}\n\n{#if showHorizontal}\n  <!-- Horizontal slide -->\n  <div class=\"box\" transition:slide={{ \n    axis: 'x' \n  }}>\n    Slides horizontally from left to right\n  </div>\n{/if}\n\n<style>\n  .box {\n    background: #f0f0f0;\n    padding: 20px;\n    margin: 10px 0;\n    border-radius: 4px;\n  }\n</style>\n```\n\n## 5. scale\n\nThe `scale` transition animates the size and opacity of an element.\n\n**Parameters:**\n- `delay` (number, default: 0): Milliseconds to wait before starting\n- `duration` (number, default: 400): Milliseconds the transition lasts\n- `easing` (function, default: cubicOut): Easing function to use\n- `start` (number, default: 0): Starting scale factor (0 to 1)\n- `opacity` (number, default: 0): Starting opacity\n\n```svelte\n<script>\n  import { scale } from 'svelte/transition';\n  import { bounceOut } from 'svelte/easing';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <!-- Basic scale -->\n  <div class=\"card\" transition:scale>\n    Basic scale from 0 to 1\n  </div>\n  \n  <!-- Scale from 50% -->\n  <div class=\"card\" transition:scale={{ \n    start: 0.5,\n    duration: 700\n  }}>\n    Scales from 50% to 100%\n  </div>\n  \n  <!-- Scale with bounce -->\n  <div class=\"card\" transition:scale={{ \n    start: 0.3,\n    duration: 1000,\n    easing: bounceOut,\n    opacity: 1\n  }}>\n    Scales with bounce effect, no opacity change\n  </div>\n{/if}\n\n<style>\n  .card {\n    background: #e0e0e0;\n    padding: 20px;\n    margin: 10px 0;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  }\n</style>\n```\n\n## 6. draw\n\nThe `draw` transition animates the stroke of an SVG element, making it appear to be drawn in.\n\n**Parameters:**\n- `delay` (number, default: 0): Milliseconds to wait before starting\n- `duration` (number, default: 800): Milliseconds the transition lasts\n- `easing` (function, default: cubicInOut): Easing function to use\n- `speed` (number, default: 1): Speed factor (higher = faster)\n\n```svelte\n<script>\n  import { draw } from 'svelte/transition';\n  import { quintOut } from 'svelte/easing';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <svg width=\"200\" height=\"200\" viewBox=\"0 0 200 200\">\n    <!-- Basic draw -->\n    <path \n      transition:draw\n      d=\"M20,80 C20,50 50,20 80,20 C110,20 140,50 140,80 C140,110 110,140 80,140 C50,140 20,110 20,80 Z\"\n      fill=\"none\" \n      stroke=\"black\" \n      stroke-width=\"2\"\n    />\n    \n    <!-- Customized draw -->\n    <path \n      transition:draw={{ \n        duration: 2000, \n        delay: 500,\n        easing: quintOut\n      }}\n      d=\"M40,100 L160,100 M100,40 L100,160\"\n      fill=\"none\" \n      stroke=\"red\" \n      stroke-width=\"4\"\n    />\n  </svg>\n{/if}\n```\n\nNote: The `draw` transition only works with SVG elements that have a `getTotalLength` method, such as `<path>` and `<polyline>`.\n\n## 7. crossfade\n\nThe `crossfade` function creates a pair of transitions called `send` and `receive`. Elements transitioning out with `send` appear to transform into elements transitioning in with `receive` when they share the same key.\n\n**Parameters for crossfade:**\n- `delay` (number, default: 0): Milliseconds to wait before starting\n- `duration` (number, default: 400): Milliseconds the transition lasts\n- `easing` (function, default: cubicOut): Easing function to use\n- `fallback` (transition, optional): Transition to use for elements without counterparts\n\n```svelte\n<script>\n  import { crossfade } from 'svelte/transition';\n  import { quintOut } from 'svelte/easing';\n  \n  // Create the crossfade transitions\n  const [send, receive] = crossfade({\n    duration: 400,\n    easing: quintOut,\n    fallback(node, params) {\n      // Fallback for items without a matching pair\n      const style = getComputedStyle(node);\n      const transform = style.transform === 'none' ? '' : style.transform;\n      \n      return {\n        duration: 600,\n        easing: quintOut,\n        css: (t) => `\n          transform: ${transform} scale(${t});\n          opacity: ${t}\n        `\n      };\n    }\n  });\n  \n  // Sample todos for the example\n  let todos = $state([\n    { id: 1, done: false, text: 'Create a Svelte app' },\n    { id: 2, done: false, text: 'Learn about transitions' },\n    { id: 3, done: true, text: 'Make coffee' }\n  ]);\n  \n  function toggleDone(id) {\n    todos = todos.map(todo => \n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    );\n  }\n</script>\n\n<div class=\"todos\">\n  <h2>To Do</h2>\n  <ul class=\"pending\">\n    {#each todos.filter(t => !t.done) as todo (todo.id)}\n      <li \n        in:receive={{ key: todo.id }}\n        out:send={{ key: todo.id }}\n        onclick={() => toggleDone(todo.id)}\n      >\n        {todo.text}\n      </li>\n    {/each}\n  </ul>\n  \n  <h2>Done</h2>\n  <ul class=\"done\">\n    {#each todos.filter(t => t.done) as todo (todo.id)}\n      <li \n        in:receive={{ key: todo.id }}\n        out:send={{ key: todo.id }}\n        onclick={() => toggleDone(todo.id)}\n      >\n        {todo.text}\n      </li>\n    {/each}\n  </ul>\n</div>\n\n<style>\n  .todos {\n    display: flex;\n    gap: 20px;\n  }\n  \n  ul {\n    list-style: none;\n    padding: 0;\n    min-width: 200px;\n  }\n  \n  li {\n    padding: 10px;\n    margin: 5px 0;\n    background: #f0f0f0;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  \n  .done li {\n    text-decoration: line-through;\n    opacity: 0.7;\n  }\n</style>\n```\n\n## Combining with Easing Functions\n\nAll transitions can be combined with easing functions from the `svelte/easing` module:\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  import { \n    linear, cubicIn, cubicOut, cubicInOut,\n    quartIn, quartOut, quartInOut,\n    quintIn, quintOut, quintInOut,\n    sineIn, sineOut, sineInOut,\n    expoIn, expoOut, expoInOut,\n    circIn, circOut, circInOut,\n    backIn, backOut, backInOut,\n    elasticIn, elasticOut, elasticInOut,\n    bounceIn, bounceOut, bounceInOut\n  } from 'svelte/easing';\n  \n  let visible = $state(false);\n  \n  // Example using elasticOut easing\n  const elasticFly = {\n    y: 100,\n    duration: 1000,\n    easing: elasticOut\n  };\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <div transition:fly={elasticFly}>\n    Flies in with elastic easing\n  </div>\n{/if}\n```\n\n## Direction-Specific Transitions\n\nYou can use `in:` and `out:` to apply different transitions for entering and leaving:\n\n```svelte\n<script>\n  import { fade, fly, scale } from 'svelte/transition';\n  \n  let visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <div \n    in:fly={{ y: 50, duration: 500 }}\n    out:scale={{ duration: 500 }}\n  >\n    Flies in from below, scales out\n  </div>\n{/if}\n```\n\nBy understanding the parameters and capabilities of each built-in transition, you can create sophisticated animation sequences that enhance the user experience of your Svelte applications."}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"What is the key difference between `transition:` directives and the `in:` and `out:` directives in Svelte?","answer":"The key difference is that `transition:` directives are bidirectional, whereas `in:` and `out:` directives are unidirectional. With a bidirectional `transition:`, when a transition is interrupted (for example, if an element is being transitioned out but then transitioned back in before the out transition completes), the transition will reverse direction seamlessly. \n\nIn contrast, with `in:` and `out:` directives, the transitions will play independently of each other. If an element with an `in:` transition is being transitioned in and then needs to transition out before the in transition completes, the `out:` transition will start playing alongside the `in:` transition rather than reversing the `in:` transition. Similarly, if an `out:` transition is aborted, the transitions will restart from scratch rather than reversing.\n\nThis makes `in:` and `out:` useful when you want specific entry and exit animations that should always play completely regardless of interruptions.\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  \n  let visible = $state(false);\n</script>\n\n<!-- Bidirectional transition -->\n<div>\n  <button on:click={() => visible = !visible}>Toggle</button>\n  \n  {#if visible}\n    <div transition:fade>This will fade in and out bidirectionally</div>\n  {/if}\n</div>\n\n<!-- Unidirectional transitions -->\n<div>\n  <button on:click={() => visible = !visible}>Toggle</button>\n  \n  {#if visible}\n    <div in:fly={{ y: 200 }} out:fade>This flies in and fades out independently</div>\n  {/if}\n</div>\n```"}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"How would you implement a UI element that slides in from the left but fades out when removed?","answer":"To create an element that slides in from the left but fades out when removed, you would use the `in:` directive with a sliding animation like `fly` and the `out:` directive with `fade`. Here's how you would implement it:\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  \n  let visible = $state(false);\n</script>\n\n<button on:click={() => visible = !visible}>\n  {visible ? 'Hide' : 'Show'} Element\n</button>\n\n{#if visible}\n  <div \n    in:fly={{ x: -200, duration: 500 }} \n    out:fade={{ duration: 300 }}\n    class=\"notification\"\n  >\n    This element slides in from the left and fades out when removed!\n  </div>\n{/if}\n\n<style>\n  .notification {\n    background-color: #4CAF50;\n    color: white;\n    padding: 16px;\n    margin: 16px 0;\n    border-radius: 4px;\n  }\n</style>\n```\n\nIn this example:\n- The element uses `in:fly={{ x: -200, duration: 500 }}` to slide in from 200 pixels to the left over 500 milliseconds\n- It uses `out:fade={{ duration: 300 }}` to fade out over 300 milliseconds when removed\n- The visibility is toggled with a button that changes the `visible` state\n- Some basic styling is applied to make the element look like a notification\n\nThis approach is particularly useful for notifications, toasts, or any UI elements that should have distinct entrance and exit animations."}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"Can you use multiple `in:` or multiple `out:` directives on the same element in Svelte? If not, how would you combine multiple transition effects?","answer":"No, you cannot use multiple `in:` or multiple `out:` directives on the same element in Svelte. Each element can have at most one `in:` directive and one `out:` directive.\n\nIf you want to combine multiple transition effects, you have a few options:\n\n1. Create a custom transition function that combines the effects you want:\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  \n  let visible = $state(false);\n  \n  // Custom transition that combines fade and fly\n  function fadeAndFly(node, { delay = 0, duration = 400, y = 0, opacity = 0 }) {\n    return {\n      delay,\n      duration,\n      css: (t, u) => `\n        opacity: ${opacity + t * (1 - opacity)};\n        transform: translateY(${y * u}px);\n      `\n    };\n  }\n</script>\n\n<button on:click={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <div in:fadeAndFly={{ y: 100, duration: 500 }} out:fade>\n    This element both fades and flies in!\n  </div>\n{/if}\n```\n\n2. Nest elements to apply different transitions:\n\n```svelte\n<script>\n  import { fade, scale } from 'svelte/transition';\n  \n  let visible = $state(false);\n</script>\n\n<button on:click={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <div in:fade out:fade={{ duration: 300 }}>\n    <div in:scale out:scale={{ duration: 300 }}>\n      This element fades and scales both in and out!\n    </div>\n  </div>\n{/if}\n```\n\n3. Use the `svelte/animate` module for more complex animations, though this is more for lists than transitions.\n\nThe most flexible approach is usually to create a custom transition function that combines exactly the effects you want, giving you full control over the animation behavior."}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"How do you handle the situation when an `out:` transition is aborted in Svelte 5? What happens with the transitions?","answer":"According to the documentation, when an `out:` transition is aborted in Svelte, the transitions will restart from scratch. This means that if an element is transitioning out and you interrupt that process (for example, by toggling the condition that shows the element back to true), the element will start its `in:` transition from the beginning, rather than reversing or continuing from where it was.\n\nThis behavior is different from bidirectional `transition:` directives, which would smoothly reverse the animation.\n\nHere's an example demonstrating this behavior:\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  \n  let visible = $state(true);\n  \n  // Function to briefly hide then show the element again\n  function flashHide() {\n    visible = false;\n    setTimeout(() => {\n      visible = true;\n    }, 200); // Abort the out transition after 200ms\n  }\n</script>\n\n<div>\n  <button on:click={() => visible = !visible}>Toggle</button>\n  <button on:click={flashHide}>Flash Hide (Abort Out Transition)</button>\n  \n  {#if visible}\n    <div \n      in:fly={{ y: 100, duration: 1000 }} \n      out:fade={{ duration: 1000 }}\n      class=\"demo-box\"\n    >\n      This element has separate in/out transitions\n    </div>\n  {/if}\n</div>\n\n<style>\n  .demo-box {\n    background-color: #3498db;\n    color: white;\n    padding: 20px;\n    margin-top: 20px;\n    border-radius: 4px;\n  }\n</style>\n```\n\nIn this example:\n1. Initially, the element is visible\n2. Clicking \"Flash Hide\" will set `visible` to false, starting the fade out transition\n3. After 200ms, `visible` is set back to true, aborting the fade out transition\n4. When this happens, the fly in transition will start from scratch, flying in from 100 pixels below\n\nThis is different from what would happen with a `transition:` directive, where the element would smoothly reverse its fade animation and continue from wherever it was in the transition process.\n\nThis restart-from-scratch behavior makes `in:` and `out:` transitions particularly useful for situations where you want consistent entry and exit animations regardless of interruptions."}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"How would you create a staggered entrance effect for a list of items using `in:` transitions in Svelte?","answer":"To create a staggered entrance effect for a list of items, you can use the `in:` directive with a delay that's calculated based on the item's index. Here's how you can implement this:\n\n```svelte\n<script>\n  import { fly } from 'svelte/transition';\n  \n  let items = $state([\n    { id: 1, text: 'Item 1' },\n    { id: 2, text: 'Item 2' },\n    { id: 3, text: 'Item 3' },\n    { id: 4, text: 'Item 4' },\n    { id: 5, text: 'Item 5' }\n  ]);\n  \n  let visible = $state(false);\n  \n  // Stagger delay calculation\n  function getStaggerDelay(index) {\n    return index * 100; // 100ms delay between each item\n  }\n</script>\n\n<button on:click={() => visible = !visible}>\n  {visible ? 'Hide' : 'Show'} Items\n</button>\n\n{#if visible}\n  <ul class=\"item-list\">\n    {#each items as item, i (item.id)}\n      <li \n        in:fly={{ \n          y: 50, \n          delay: getStaggerDelay(i),\n          duration: 400\n        }}\n        out:fly={{ \n          y: 50, \n          duration: 300 \n        }}\n      >\n        {item.text}\n      </li>\n    {/each}\n  </ul>\n{/if}\n\n<style>\n  .item-list {\n    list-style: none;\n    padding: 0;\n  }\n  \n  li {\n    background-color: #f5f5f5;\n    margin: 8px 0;\n    padding: 12px;\n    border-radius: 4px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  }\n</style>\n```\n\nIn this example:\n\n1. We have an array of items that we want to display with a staggered entrance\n2. The `getStaggerDelay` function calculates a delay based on the item's index (100ms per item)\n3. In the `#each` block, we apply an `in:fly` transition to each item\n4. The delay parameter for the transition is set using `getStaggerDelay(i)`, which means each item will start its transition 100ms after the previous one\n5. We also apply an `out:fly` transition without a staggered delay for when items are removed\n\nYou can adjust the stagger timing by changing the multiplier in the `getStaggerDelay` function. You could also make the stagger effect more complex by using different formulas for the delay, or by varying other parameters like duration or the distance items fly.\n\nThis technique works well for lists, menus, grid layouts, or any UI pattern where you want to draw attention to items appearing in sequence rather than all at once."}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"What happens if you try to use both a `transition:` directive and separate `in:` and `out:` directives on the same element in Svelte?","answer":"In Svelte, you cannot use both a `transition:` directive and separate `in:` and `out:` directives on the same element. If you attempt to do so, Svelte will generate a compile-time error indicating that you can't mix these different transition approaches on a single element.\n\nFor example, the following code would produce an error:\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  \n  let visible = $state(false);\n</script>\n\n<button on:click={() => visible = !visible}>Toggle</button>\n\n{#if visible}\n  <!-- This will cause a compile error -->\n  <div \n    transition:fade\n    in:fly={{ y: 100 }} \n    out:fade\n  >\n    This won't work!\n  </div>\n{/if}\n```\n\nInstead, you must choose either:\n\n1. A bidirectional transition with `transition:`:\n\n```svelte\n<div transition:fade>Bidirectional fade</div>\n```\n\n2. Separate unidirectional transitions with `in:` and/or `out:`:\n\n```svelte\n<div in:fly={{ y: 100 }} out:fade>Flies in, fades out</div>\n```\n\nThe reason for this restriction is that these directives control the same aspect of the element's behavior (its entrance and exit animations), and having both would create ambiguity about which transition should take precedence.\n\nIf you need complex transitions that combine multiple effects, you should either:\n\n1. Create a custom transition function that combines the effects you want\n2. Use nested elements with different transitions applied to each\n3. Choose between bidirectional or unidirectional transitions based on your specific needs\n\nThis separation ensures clarity in how transitions are defined and prevents potential conflicts in animation behavior."}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"How can you customize the timing function of an `in:` or `out:` transition in Svelte to create more dynamic animations?","answer":"You can customize the timing function (easing) of `in:` and `out:` transitions in Svelte by passing an `easing` parameter to the transition function. Svelte provides several built-in easing functions in the `svelte/easing` module, and you can also create custom easing functions.\n\nHere's how to use custom easing with `in:` and `out:` transitions:\n\n```svelte\n<script>\n  import { fly, fade } from 'svelte/transition';\n  import { \n    elasticOut, \n    bounceOut, \n    backIn, \n    cubicInOut \n  } from 'svelte/easing';\n  \n  let visible = $state(false);\n  \n  // Custom easing function example\n  function customEasing(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  }\n</script>\n\n<div class=\"controls\">\n  <button on:click={() => visible = !visible}>\n    {visible ? 'Hide' : 'Show'} Elements\n  </button>\n</div>\n\n<div class=\"container\">\n  {#if visible}\n    <div \n      in:fly={{ y: 100, duration: 800, easing: elasticOut }} \n      out:fade={{ duration: 400, easing: cubicInOut }}\n      class=\"box\"\n    >\n      Elastic in, cubic out\n    </div>\n    \n    <div \n      in:fly={{ y: 100, duration: 800, easing: bounceOut }} \n      out:fade={{ duration: 400, easing: backIn }}\n      class=\"box\"\n    >\n      Bounce in, back out\n    </div>\n    \n    <div \n      in:fly={{ y: 100, duration: 800, easing: customEasing }} \n      out:fade={{ duration: 400 }}\n      class=\"box\"\n    >\n      Custom easing in\n    </div>\n  {/if}\n</div>\n\n<style>\n  .container {\n    display: flex;\n    gap: 20px;\n    margin-top: 20px;\n  }\n  \n  .box {\n    background-color: #9b59b6;\n    color: white;\n    padding: 20px;\n    border-radius: 4px;\n    width: 200px;\n    text-align: center;\n  }\n  \n  .controls {\n    margin-bottom: 20px;\n  }\n</style>\n```\n\nIn this example:\n\n1. We import various easing functions from `svelte/easing`\n2. We define a custom easing function `customEasing`\n3. We apply different easing functions to different elements:\n   - The first element uses `elasticOut` for entry and `cubicInOut` for exit\n   - The second element uses `bounceOut` for entry and `backIn` for exit\n   - The third element uses our custom easing function for entry\n\nHere are some of the built-in easing functions available in Svelte:\n\n- Linear: `linear`\n- Cubic: `cubicIn`, `cubicOut`, `cubicInOut`\n- Sine: `sineIn`, `sineOut`, `sineInOut`\n- Expo: `expoIn`, `expoOut`, `expoInOut`\n- Circ: `circIn`, `circOut`, `circInOut`\n- Quad: `quadIn`, `quadOut`, `quadInOut`\n- Quart: `quartIn`, `quartOut`, `quartInOut`\n- Quint: `quintIn`, `quintOut`, `quintInOut`\n- Elastic: `elasticIn`, `elasticOut`, `elasticInOut`\n- Back: `backIn`, `backOut`, `backInOut`\n- Bounce: `bounceIn`, `bounceOut`, `bounceInOut`\n\nEach of these functions provides a different feel for the animation. The \"In\" variants start slow and end fast, \"Out\" variants start fast and end slow, and \"InOut\" variants start and end slow with a fast middle.\n\nBy combining different transitions, durations, and easing functions, you can create highly customized and dynamic animations for your UI elements."}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"How would you implement a toast notification system in Svelte 5 using `in:` and `out:` transitions?","answer":"A toast notification system is a perfect use case for `in:` and `out:` transitions in Svelte. Here's a comprehensive implementation of a toast notification system that leverages Svelte 5's state management and transition directives:\n\n```svelte\n<script>\n  import { slide, fade } from 'svelte/transition';\n  import { flip } from 'svelte/animate';\n  \n  // Toast state management\n  let toasts = $state([]);\n  let nextId = $state(0);\n  \n  // Toast types with corresponding styles\n  const TOAST_TYPES = {\n    SUCCESS: { bgColor: '#4CAF50', icon: 'â' },\n    ERROR: { bgColor: '#F44336', icon: 'â' },\n    INFO: { bgColor: '#2196F3', icon: 'â¹' },\n    WARNING: { bgColor: '#FF9800', icon: 'â ' }\n  };\n  \n  // Function to add a new toast\n  function addToast(message, type = 'INFO', duration = 3000) {\n    const id = nextId++;\n    const toast = {\n      id,\n      message,\n      type,\n      duration\n    };\n    \n    toasts = [...toasts, toast];\n    \n    // Auto-remove toast after duration\n    if (duration > 0) {\n      setTimeout(() => {\n        removeToast(id);\n      }, duration);\n    }\n    \n    return id;\n  }\n  \n  // Function to remove a toast by id\n  function removeToast(id) {\n    toasts = toasts.filter(toast => toast.id !== id);\n  }\n  \n  // Convenience functions for different toast types\n  function success(message, duration) {\n    return addToast(message, 'SUCCESS', duration);\n  }\n  \n  function error(message, duration) {\n    return addToast(message, 'ERROR', duration);\n  }\n  \n  function info(message, duration) {\n    return addToast(message, 'INFO', duration);\n  }\n  \n  function warning(message, duration) {\n    return addToast(message, 'WARNING', duration);\n  }\n</script>\n\n<!-- Demo buttons to trigger different toast types -->\n<div class=\"controls\">\n  <button on:click={() => success('Operation completed successfully!')}>\n    Show Success Toast\n  </button>\n  \n  <button on:click={() => error('An error occurred. Please try again.')}>\n    Show Error Toast\n  </button>\n  \n  <button on:click={() => info('New updates are available.')}>\n    Show Info Toast\n  </button>\n  \n  <button on:click={() => warning('Your session will expire soon.')}>\n    Show Warning Toast\n  </button>\n</div>\n\n<!-- Toast container -->\n<div class=\"toast-container\">\n  {#each toasts as toast (toast.id)}\n    <div \n      class=\"toast\"\n      style=\"background-color: {TOAST_TYPES[toast.type].bgColor}\"\n      in:slide={{ y: 50, duration: 400 }}\n      out:fade={{ duration: 300 }}\n      animate:flip={{ duration: 300 }}\n      on:click={() => removeToast(toast.id)}\n    >\n      <div class=\"toast-icon\">\n        {TOAST_TYPES[toast.type].icon}\n      </div>\n      <div class=\"toast-message\">\n        {toast.message}\n      </div>\n      <button class=\"toast-close\" on:click|stopPropagation={() => removeToast(toast.id)}>\n        Ã\n      </button>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .toast-container {\n    position: fixed;\n    bottom: 20px;\n    right: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    max-width: 350px;\n    z-index: 1000;\n  }\n  \n  .toast {\n    display: flex;\n    align-items: center;\n    color: white;\n    padding: 12px 16px;\n    border-radius: 4px;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n    cursor: pointer;\n  }\n  \n  .toast-icon {\n    margin-right: 12px;\n    font-size: 1.2em;\n  }\n  \n  .toast-message {\n    flex: 1;\n  }\n  \n  .toast-close {\n    background: none;\n    border: none;\n    color: white;\n    font-size: 1.5em;\n    cursor: pointer;\n    padding: 0;\n    margin-left: 8px;\n  }\n  \n  .controls {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 20px;\n    flex-wrap: wrap;\n  }\n  \n  button {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    background-color: #333;\n    color: white;\n    cursor: pointer;\n  }\n  \n  button:hover {\n    background-color: #555;\n  }\n</style>\n```\n\nKey features of this implementation:\n\n1. **Toast State Management**:\n   - Uses Svelte 5's `$state` for reactive state management\n   - Maintains an array of toast objects with unique IDs\n   - Each toast has a message, type, and duration\n\n2. **Transition Effects**:\n   - Uses `in:slide` to slide toasts in from below\n   - Uses `out:fade` to fade toasts out when removed\n   - Uses `animate:flip` from `svelte/animate` to smoothly rearrange toasts when some are removed\n\n3. **Toast Types**:\n   - Supports multiple toast types (success, error, info, warning)\n   - Each type has its own color and icon\n\n4. **Auto-Removal**:\n   - Toasts automatically remove themselves after the specified duration\n   - Duration can be customized for each toast\n\n5. **User Interaction**:\n   - Toasts can be dismissed by clicking on them\n   - Each toast has a close button\n\n6. **Styling**:\n   - Fixed position at the bottom right of the screen\n   - Stacked vertically with a gap between toasts\n   - Shadow effect for depth\n   - Responsive design\n\nThis implementation demonstrates how `in:` and `out:` transitions in Svelte provide a clean way to handle element entrance and exit animations independently, making it perfect for notification systems where elements are added and removed dynamically."}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"How can you coordinate `in:` and `out:` transitions with global state or events in Svelte 5?","answer":"Coordinating `in:` and `out:` transitions with global state or events in Svelte 5 can create dynamic and responsive UI experiences. Here's how you can implement this coordination using Svelte 5's state management and lifecycle features:\n\n```svelte\n<script>\n  import { fade, fly, scale } from 'svelte/transition';\n  \n  // Global application state\n  let theme = $state('light');\n  let animationSpeed = $state('normal');\n  let notificationCount = $state(0);\n  \n  // Derived values for transition parameters\n  $derived.duration = animationSpeed === 'fast' ? 200 : \n                     animationSpeed === 'slow' ? 1000 : \n                     500;\n  \n  $derived.flyDistance = theme === 'playful' ? 100 : 30;\n  \n  // Function to add a notification\n  function addNotification() {\n    notificationCount++;\n    \n    // Auto-remove after some time\n    setTimeout(() => {\n      if (notificationCount > 0) {\n        notificationCount--;\n      }\n    }, 3000);\n  }\n  \n  // Function to get transition parameters based on global state\n  function getTransitionParams() {\n    // Base parameters\n    const params = { duration: $derived.duration };\n    \n    // Add additional parameters based on theme\n    if (theme === 'playful') {\n      params.easing = (t) => {\n        const bounce = Math.sin(t * 10) * 0.1;\n        return t + (t < 0.5 ? bounce : -bounce);\n      };\n    }\n    \n    return params;\n  }\n</script>\n\n<div class=\"controls\">\n  <div>\n    <label>Theme:</label>\n    <select bind:value={theme}>\n      <option value=\"light\">Light</option>\n      <option value=\"dark\">Dark</option>\n      <option value=\"playful\">Playful</option>\n    </select>\n  </div>\n  \n  <div>\n    <label>Animation Speed:</label>\n    <select bind:value={animationSpeed}>\n      <option value=\"fast\">Fast</option>\n      <option value=\"normal\">Normal</option>\n      <option value=\"slow\">Slow</option>\n    </select>\n  </div>\n  \n  <button on:click={addNotification}>\n    Add Notification\n  </button>\n</div>\n\n<div class=\"theme-container\" class:dark={theme === 'dark'} class:playful={theme === 'playful'}>\n  <h2>Current Theme: {theme}</h2>\n  \n  <div class=\"notification-area\">\n    {#each Array(notificationCount) as _, i (i)}\n      <div \n        class=\"notification\"\n        in:fly={{ \n          y: $derived.flyDistance, \n          x: theme === 'playful' ? (i % 2 === 0 ? 20 : -20) : 0,\n          ...getTransitionParams() \n        }}\n        out:fade={getTransitionParams()}\n      >\n        Notification #{i + 1}\n      </div>\n    {/each}\n  </div>\n  \n  <div class=\"demo-area\">\n    <button on:click={() => theme = theme === 'light' ? 'dark' : 'light'}>\n      Toggle Light/Dark\n    </button>\n    \n    {#if theme === 'dark'}\n      <div \n        class=\"theme-element\"\n        in:scale={getTransitionParams()}\n        out:fade={getTransitionParams()}\n      >\n        Dark theme content\n      </div>\n    {:else if theme === 'light'}\n      <div \n        class=\"theme-element light\"\n        in:scale={getTransitionParams()}\n        out:fade={getTransitionParams()}\n      >\n        Light theme content\n      </div>\n    {:else}\n      <div \n        class=\"theme-element playful\"\n        in:fly={{ \n          y: -50, \n          x: 50, \n          ...getTransitionParams() \n        }}\n        out:scale={getTransitionParams()}\n      >\n        Playful theme content\n      </div>\n    {/if}\n  </div>\n</div>\n\n<style>\n  .theme-container {\n    padding: 20px;\n    background-color: #f5f5f5;\n    border-radius: 8px;\n    margin-top: 20px;\n    transition: all 0.3s ease;\n  }\n  \n  .dark {\n    background-color: #333;\n    color: white;\n  }\n  \n  .playful {\n    background-color: #ffecb3;\n    color: #7b1fa2;\n    border: 3px dashed #7b1fa2;\n  }\n  \n  .controls {\n    display: flex;\n    gap: 20px;\n    margin-bottom: 20px;\n    align-items: center;\n  }\n  \n  .notification-area {\n    position: relative;\n    min-height: 100px;\n    margin: 20px 0;\n  }\n  \n  .notification {\n    background-color: #2196F3;\n    color: white;\n    padding: 10px 16px;\n    border-radius: 4px;\n    margin-bottom: 10px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.2);\n  }\n  \n  .theme-element {\n    padding: 30px;\n    margin-top: 20px;\n    border-radius: 8px;\n    background-color: #424242;\n    color: white;\n    text-align: center;\n  }\n  \n  .theme-element.light {\n    background-color: #e0e0e0;\n    color: #333;\n  }\n  \n  .theme-element.playful {\n    background-color: #ce93d8;\n    color: #4a148c;\n    border-radius: 20px;\n    transform: rotate(2deg);\n  }\n  \n  button, select {\n    padding: 8px 12px;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n  }\n  \n  button {\n    background-color: #4CAF50;\n    color: white;\n    border: none;\n    cursor: pointer;\n  }\n  \n  button:hover {\n    background-color: #45a049;\n  }\n</style>\n```\n\nIn this example, I've demonstrated several ways to coordinate transitions with global state:\n\n1. **Dynamic Transition Parameters**:\n   - The `getTransitionParams()` function returns transition parameters based on the current global state\n   - Transition duration is controlled by the `animationSpeed` state\n   - Custom easing functions are applied based on the theme\n\n2. **Reactive Derived Values**:\n   - Using Svelte 5's `$derived` for calculating transition parameters that depend on global state\n   - The `$derived.duration` and `$derived.flyDistance` are automatically recalculated when their dependencies change\n\n3. **Conditional Transitions**:\n   - Different transition types are applied based on the current theme\n   - For example, the \"playful\" theme uses more dramatic transitions with bouncy easing\n\n4. **Coordinating Multiple Elements**:\n   - The notification system shows how to coordinate transitions across multiple elements\n   - Each notification has transitions that respect the global animation settings\n\n5. **Theme Transitions**:\n   - When switching themes, content transitions out and in with animations that match the theme's character\n   - Dark theme uses scale in and fade out\n   - Playful theme uses fly in and scale out\n\nThis approach provides a consistent user experience where all animations throughout the application respect global preferences like theme and animation speed. It also demonstrates how Svelte 5's reactivity system makes it easy to coordinate complex UI behaviors.\n\nThe key to this coordination is using derived state and functions that can access the global state to generate appropriate transition parameters dynamically."}
{"source":"docs/svelte/03-template-syntax/14-in-and-out.md","question":"What are some advanced techniques for creating custom transition effects with `in:` and `out:` directives in Svelte 5?","answer":"Creating custom transition effects with `in:` and `out:` directives in Svelte 5 allows you to go beyond the built-in transitions and create unique animations tailored to your application. Here are some advanced techniques:\n\n```svelte\n<script>\n  import { cubicOut, elasticOut } from 'svelte/easing';\n  \n  let showElements = $state(false);\n  \n  // 1. Basic custom transition function\n  function typewriter(node, { speed = 1 }) {\n    const text = node.textContent;\n    const duration = text.length / (speed * 0.01);\n    \n    return {\n      duration,\n      tick: t => {\n        const i = Math.trunc(text.length * t);\n        node.textContent = text.slice(0, i);\n      }\n    };\n  }\n  \n  // 2. CSS-based custom transition with multiple properties\n  function glitch(node, { \n    duration = 800, \n    delay = 0,\n    intensity = 1\n  }) {\n    return {\n      delay,\n      duration,\n      css: (t, u) => {\n        const skew = intensity * Math.sin(t * Math.PI * 8) * 4;\n        const scale = 0.8 + t * 0.2;\n        const blur = intensity * u * 8;\n        const opacity = t * 0.8 + 0.2;\n        const rgb = Math.round(u * 255 * intensity);\n        \n        return `\n          transform: skew(${skew}deg) scale(${scale});\n          filter: blur(${blur}px);\n          opacity: ${opacity};\n          text-shadow: ${rgb},0,0 2px, 0,${rgb},0 4px, 0,0,${rgb} 6px;\n        `;\n      }\n    };\n  }\n  \n  // 3. Physics-based transition\n  function bounce(node, { \n    velocity = 1,\n    gravity = 9.8,\n    height = 300,\n    elasticity = 0.6,\n    duration = 1500\n  }) {\n    let startTime;\n    \n    return {\n      duration,\n      tick: (t, u) => {\n        // Simple physics simulation for a bouncing object\n        const time = t * duration / 1000; // time in seconds\n        let position = height;\n        let currentVelocity = -velocity; // initial upward velocity\n        let currentTime = 0;\n        let bounceCount = 0;\n        \n        // Simulate physics up to current time\n        while (currentTime < time) {\n          const dt = 1/60; // 60fps simulation\n          \n          // Update position and velocity\n          position += currentVelocity * dt;\n          currentVelocity += gravity * dt;\n          \n          // Check for bounce\n          if (position <= 0) {\n            position = 0;\n            currentVelocity = -currentVelocity * elasticity;\n            bounceCount++;\n            \n            // Stop bouncing if energy is too low\n            if (Math.abs(currentVelocity) < 0.5) {\n              position = 0;\n              break;\n            }\n          }\n          \n          currentTime += dt;\n          \n          // Prevent infinite loops\n          if (bounceCount > 10) break;\n        }\n        \n        // Apply the calculated position\n        node.style.transform = `translateY(${height - position}px)`;\n      }\n    };\n  }\n  \n  // 4. SVG path transition\n  function followPath(node, { \n    path = \"M0,0 C50,40 50,-40 100,0\", \n    duration = 1000,\n    easing = cubicOut\n  }) {\n    // Create SVG path element to use for calculations\n    const svgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    svgPath.setAttribute('d', path);\n    \n    // Get the total length of the path\n    const pathLength = svgPath.getTotalLength();\n    \n    return {\n      duration,\n      easing,\n      tick: (t) => {\n        // Get point at position t along the path\n        const point = svgPath.getPointAtLength(t * pathLength);\n        \n        // Apply transform to move element along the path\n        node.style.transform = `translate(${point.x}px, ${point.y}px)`;\n      }\n    };\n  }\n  \n  // 5. Canvas-based particle explosion\n  function explode(node, { \n    particleCount = 20,\n    duration = 1000,\n    colors = ['#FF5252', '#FFD740', '#69F0AE', '#40C4FF']\n  }) {\n    // Get the dimensions and position of the node\n    const rect = node.getBoundingClientRect();\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n    \n    // Create a canvas for the particles\n    const canvas = document.createElement('canvas');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    canvas.style.position = 'fixed';\n    canvas.style.top = '0';\n    canvas.style.left = '0';\n    canvas.style.pointerEvents = 'none';\n    canvas.style.zIndex = '9999';\n    document.body.appendChild(canvas);\n    \n    const ctx = canvas.getContext('2d');\n    \n    // Create particles\n    const particles = [];\n    for (let i = 0; i < particleCount; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 2 + Math.random() * 3;\n      particles.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        radius: 3 + Math.random() * 6,\n        color: colors[Math.floor(Math.random() * colors.length)],\n        opacity: 1\n      });\n    }\n    \n    let animationFrame;\n    let startTime;\n    \n    function animate(timestamp) {\n      if (!startTime) startTime = timestamp;\n      const elapsed = timestamp - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      \n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      \n      // Update and draw particles\n      for (const p of particles) {\n        p.x += p.vx;\n        p.y += p.vy;\n        p.opacity = 1 - progress;\n        \n        ctx.beginPath();\n        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);\n        ctx.fillStyle = p.color + Math.round(p.opacity * 255).toString(16).padStart(2, '0');\n        ctx.fill();\n      }\n      \n      if (progress < 1) {\n        animationFrame = requestAnimationFrame(animate);\n      } else {\n        document.body.removeChild(canvas);\n      }\n    }\n    \n    animationFrame = requestAnimationFrame(animate);\n    \n    return {\n      duration,\n      tick: (t) => {\n        node.style.opacity = 1 - t;\n      },\n      destroy() {\n        cancelAnimationFrame(animationFrame);\n        if (document.body.contains(canvas)) {\n          document.body.removeChild(canvas);\n        }\n      }\n    };\n  }\n</script>\n\n<div class=\"controls\">\n  <button on:click={() => showElements = !showElements}>\n    {showElements ? 'Hide' : 'Show'} Elements\n  </button>\n</div>\n\n<div class=\"demo-container\">\n  {#if showElements}\n    <div class=\"demo-item\">\n      <h3 in:typewriter={{ speed: 3 }} out:typewriter={{ speed: 5 }}>\n        Typewriter Effect\n      </h3>\n    </div>\n    \n    <div class=\"demo-item\">\n      <div class=\"box\" in:glitch={{ intensity: 2 }} out:glitch={{ intensity: 3 }}>\n        Glitch Effect\n      </div>\n    </div>\n    \n    <div class=\"demo-item\">\n      <div class=\"box\" in:bounce={{ height: 200 }} out:fade>\n        Physics Bounce\n      </div>\n    </div>\n    \n    <div class=\"demo-item\">\n      <div \n        class=\"circle\" \n        in:followPath={{ \n          path: \"M0,0 C25,-50 75,-50 100,0 C125,50 175,50 200,0\", \n          duration: 1500 \n        }} \n        out:followPath={{ \n          path: \"M0,0 C50,40 50,-40 100,0\", \n          duration: 1000 \n        }}\n      ></div>\n    </div>\n    \n    <div class=\"demo-item\">\n      <div class=\"box\" in:scale out:explode>\n        Particle Explosion\n      </div>\n    </div>\n  {/if}\n</div>\n\n<style>\n  .demo-container {\n    display: flex;\n    flex-direction: column;\n    gap: 40px;\n    margin-top: 30px;\n  }\n  \n  .demo-item {\n    min-height: 100px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  \n  .box {\n    background-color: #3f51b5;\n    color: white;\n    padding: 20px;\n    border-radius: 4px;\n    text-align: center;\n  }\n  \n  .circle {\n    width: 50px;\n    height: 50px;\n    background-color: #ff4081;\n    border-radius: 50%;\n  }\n  \n  .controls {\n    margin-bottom: 20px;\n  }\n  \n  button {\n    padding: 10px 16px;\n    background-color: #4CAF50;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n</style>\n```\n\nThis example demonstrates five advanced custom transition techniques:\n\n1. **Typewriter Effect**:\n   - Animates text as if it's being typed out character by character\n   - Uses the `tick` function to update text content based on progress\n   - Can be used for both `in:` and `out:` transitions\n\n2. **Glitch Effect**:\n   - Creates a digital glitch aesthetic with skew, blur, and color channel offsets\n   - Uses multiple CSS properties in combination\n   - Intensity parameter allows for customization\n\n3. **Physics-Based Bounce**:\n   - Simulates realistic physics with gravity, velocity, and elasticity\n   - Performs a frame-by-frame physics simulation\n   - Parameters allow for customizing the bounce behavior\n\n4. **SVG Path Following**:\n   - Makes elements follow an arbitrary SVG path during transition\n   - Uses SVG path calculations to determine position at each point\n   - Allows for complex motion paths defined as SVG path strings\n\n5. **Canvas Particle Explosion**:\n   - Creates a particle explosion effect using HTML Canvas\n   - Manages its own animation loop with requestAnimationFrame\n   - Properly cleans up resources in the destroy function\n\nKey techniques demonstrated:\n\n1. **Custom CSS Properties**:\n   - Using the `css` callback to generate complex CSS transformations\n   - Combining multiple properties for rich visual effects\n\n2. **Direct DOM Manipulation**:\n   - Using the `tick` callback for frame-by-frame control\n   - Directly setting style properties for effects that can't be achieved with CSS alone\n\n3. **External Elements**:\n   - Creating and managing additional DOM elements (canvas, SVG)\n   - Properly cleaning up with the `destroy` callback\n\n4. **Physics Simulation**:\n   - Implementing basic physics calculations for realistic motion\n   - Using time-based animation for consistent results\n\n5. **Parameter Customization**:\n   - Designing transitions with configurable parameters\n   - Providing sensible defaults while allowing customization\n\nThese advanced techniques can be combined and extended to create unique transition effects that enhance the user experience in your Svelte applications. The key is understanding that Svelte transitions are just functions that return an object with properties like `duration`, `delay`, `css`, `tick`, and optionally `destroy` for cleanup."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"What is the purpose of the `animate:` directive in Svelte, and under what conditions do animations run?","answer":"The `animate:` directive in Svelte is used to create animations when the contents of a keyed each block are re-ordered. Importantly, these animations do not run when elements are added or removed from the DOM, but only when the index of an existing data item within the each block changes.\n\nThe directive must be applied to an element that is an immediate child of a keyed each block. \"Keyed\" means that the each block has a unique identifier for each item, which helps Svelte track which items have moved.\n\nHere's a basic example using Svelte's built-in `flip` animation:\n\n```svelte\n{#each list as item, index (item)}\n\t<li animate:flip>{item}</li>\n{/each}\n```\n\nIn this example, when items in the `list` array are reordered (but not when items are added or removed), the `flip` animation will run, creating a smooth transition between the old and new positions of each element.\n\nThe animation only triggers when the order changes, making it perfect for sortable lists, drag-and-drop interfaces, or any UI where items might change position."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"How can you customize built-in animations with parameters in Svelte?","answer":"Svelte's built-in animations can be customized by passing parameters to the `animate:` directive. These parameters allow you to control aspects of the animation such as duration, delay, and easing function.\n\nParameters are passed as an object inside the directive. The syntax uses curly braces, but note that the double `{{curlies}}` aren't special syntax - they represent an object literal inside an expression tag.\n\nHere's an example customizing the built-in `flip` animation:\n\n```svelte\n{#each list as item, index (item)}\n\t<li animate:flip={{ delay: 500, duration: 1000, easing: quintOut }}>{item}</li>\n{/each}\n```\n\nIn this example:\n- `delay: 500` - The animation will wait 500ms before starting\n- `duration: 1000` - The animation will run for 1000ms (1 second)\n- `easing: quintOut` - The animation will use the quintOut easing function (you would need to import this from 'svelte/easing')\n\nDifferent built-in animations accept different parameters. For the `flip` animation, you can customize:\n- `delay` (default 0) - milliseconds before the animation starts\n- `duration` (default 400) - milliseconds the animation lasts\n- `easing` (default cubicOut) - an easing function from 'svelte/easing'\n\nThis allows you to fine-tune how animations behave to match your application's look and feel."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"What is the signature of a custom animation function in Svelte, and what parameters does it receive?","answer":"A custom animation function in Svelte has the following signature:\n\n```js\nfunction animation(node, { from, to }, params) {\n  // Return animation configuration\n  return {\n    delay?: number,\n    duration?: number,\n    easing?: (t: number) => number,\n    css?: (t: number, u: number) => string,\n    tick?: (t: number, u: number) => void\n  };\n}\n```\n\nThe function receives three parameters:\n\n1. `node`: The HTML element being animated\n2. An animation object containing:\n   - `from`: A DOMRect describing the geometry of the element in its starting position\n   - `to`: A DOMRect describing the geometry of the element in its final position\n3. `params`: Any custom parameters passed to the animation directive\n\nThe DOMRect objects contain properties like `left`, `top`, `width`, `height`, etc., which describe the element's position and size before and after reordering.\n\nThe function should return an object that can include the following properties:\n- `delay` (optional): Time in milliseconds before the animation starts\n- `duration` (optional): Time in milliseconds the animation lasts\n- `easing` (optional): An easing function that transforms `t` (time)\n- `css` (optional): A function that returns a CSS string to be applied\n- `tick` (optional): A function called on each animation frame\n\nHere's a complete example of a custom animation function:\n\n```svelte\n<script>\n  import { cubicOut } from 'svelte/easing';\n\n  function whizz(node, { from, to }, params) {\n    // Calculate the distance the element needs to move\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    const d = Math.sqrt(dx * dx + dy * dy);\n\n    return {\n      delay: 0,\n      duration: Math.sqrt(d) * 120, // Duration based on distance\n      easing: cubicOut,\n      css: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n    };\n  }\n</script>\n\n{#each list as item, index (item)}\n  <div animate:whizz>{item}</div>\n{/each}\n```\n\nThis custom animation will make elements move from their old position to their new position while rotating 360 degrees."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"Explain the difference between the `css` and `tick` methods in a custom animation function. When would you use one over the other?","answer":"In a Svelte custom animation function, both `css` and `tick` methods can be used to control the animation, but they work in fundamentally different ways and have different use cases:\n\n### The `css` Method\n\n```js\ncss: (t, u) => string\n```\n\n- **How it works**: Returns a string of CSS that will be applied to the element during the animation.\n- **Performance**: Svelte optimizes this by creating a CSS animation that runs off the main thread, resulting in better performance.\n- **Parameters**:\n  - `t`: A value from 0 to 1 representing the animation progress after easing is applied\n  - `u`: Equal to `1 - t` (convenient for calculating values that go from 1 to 0)\n- **Called**: Multiple times before the animation starts to build the animation keyframes\n\nExample of a `css` animation:\n\n```svelte\n<script>\n  function slide(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    return {\n      duration: 400,\n      easing: cubicOut,\n      css: (t, u) => `\n        transform: translate(${u * dx}px, ${u * dy}px);\n        opacity: ${t};\n      `\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:slide>{item.text}</div>\n{/each}\n```\n\n### The `tick` Method\n\n```js\ntick: (t, u) => void\n```\n\n- **How it works**: A function called on each animation frame that can manipulate the node directly.\n- **Performance**: Runs on the main thread, so can be less performant for complex animations.\n- **Parameters**: Same `t` and `u` as the `css` method\n- **Called**: During the animation, on each frame\n- **Use case**: For animations that can't be expressed with CSS or that need to manipulate properties not accessible via CSS\n\nExample of a `tick` animation:\n\n```svelte\n<script>\n  function colorChange(node, { from, to }, params) {\n    return {\n      duration: 600,\n      tick: (t, u) => {\n        // Change color based on animation progress\n        if (t < 0.5) {\n          node.style.color = 'blue';\n          node.style.background = 'white';\n        } else {\n          node.style.color = 'white';\n          node.style.background = 'blue';\n        }\n        \n        // Could also manipulate non-CSS properties\n        node.textContent = `Progress: ${Math.round(t * 100)}%`;\n      }\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:colorChange>{item.text}</div>\n{/each}\n```\n\n### When to Use Each\n\n- **Use `css` when**:\n  - The animation can be expressed using CSS properties\n  - Performance is a concern (most cases)\n  - The animation is purely visual\n\n- **Use `tick` when**:\n  - You need to animate properties not accessible via CSS\n  - You need to modify the DOM during the animation\n  - You need to call functions or update other parts of your application during the animation\n  - You need to use browser APIs that can't be controlled via CSS\n\nYou can also use both methods together if needed, though typically you would choose one or the other based on your specific requirements."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"How do the `t` and `u` parameters work in Svelte animations, and how can they be used effectively in custom animations?","answer":"The `t` and `u` parameters are fundamental to creating custom animations in Svelte. They represent the progress of an animation and are passed to both the `css` and `tick` functions.\n\n### Understanding `t` and `u`\n\n- **`t` (time progress)**: \n  - Ranges from 0 to 1\n  - Represents the normalized time progress of the animation after the easing function has been applied\n  - At the start of the animation, `t` = 0\n  - At the end of the animation, `t` = 1\n\n- **`u` (inverted time progress)**:\n  - Equal to `1 - t`\n  - Ranges from 1 to 0\n  - At the start of the animation, `u` = 1\n  - At the end of the animation, `u` = 0\n\n### How Easing Affects `t`\n\nThe `t` value doesn't necessarily increase linearly with time. If you specify an easing function, the `t` value will be transformed by that function. For example:\n\n- With a linear easing, `t` increases linearly from 0 to 1\n- With `cubicOut` easing, `t` might increase slowly at first, then more rapidly\n- With `elasticOut` easing, `t` might temporarily exceed 1 before settling at 1\n\n### Effective Uses of `t` and `u`\n\n1. **Creating motion paths**:\n\n```js\nfunction moveElement(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n  \n  return {\n    duration: 800,\n    easing: cubicOut,\n    css: (t, u) => `\n      transform: translate(${u * dx}px, ${u * dy}px);\n    `\n  };\n}\n```\n\nIn this example, `u` (which goes from 1 to 0) is multiplied by the distance, creating a smooth transition from the original position to the new position.\n\n2. **Fading elements**:\n\n```js\nfunction fadeMove(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n  \n  return {\n    duration: 400,\n    css: (t, u) => `\n      opacity: ${t};\n      transform: translate(${u * dx}px, ${u * dy}px);\n    `\n  };\n}\n```\n\nHere, `t` (which goes from 0 to 1) controls opacity, making the element fade in as it moves.\n\n3. **Rotation with movement**:\n\n```js\nfunction spinMove(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n  \n  return {\n    duration: 600,\n    easing: backOut,\n    css: (t, u) => `\n      transform: \n        translate(${u * dx}px, ${u * dy}px)\n        rotate(${t * 360}deg);\n      scale: ${0.8 + t * 0.2};\n    `\n  };\n}\n```\n\nThis animation combines movement (using `u`), rotation (using `t`), and scaling (using `t`).\n\n4. **Conditional styling based on progress**:\n\n```js\nfunction highlightMove(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n  \n  return {\n    duration: 800,\n    tick: (t, u) => {\n      node.style.transform = `translate(${u * dx}px, ${u * dy}px)`;\n      \n      // Change background color at the midpoint\n      if (t < 0.5) {\n        node.style.backgroundColor = 'yellow';\n      } else {\n        node.style.backgroundColor = 'white';\n      }\n    }\n  };\n}\n```\n\nHere we use `t` to determine when to change the background color during the animation.\n\n5. **Creating complex paths**:\n\n```js\nfunction arcMove(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n  \n  return {\n    duration: 1000,\n    easing: cubicInOut,\n    css: (t, u) => {\n      // Create an arc path by manipulating the y position\n      // based on a sine wave that peaks at t=0.5\n      const arcHeight = Math.sin(t * Math.PI) * Math.min(100, Math.abs(dx));\n      \n      return `\n        transform: translate(\n          ${u * dx}px, \n          ${u * dy - arcHeight}px\n        );\n      `;\n    }\n  };\n}\n```\n\nThis creates an arc motion by combining the linear movement with a sine wave that peaks in the middle of the animation.\n\nUnderstanding and creatively using `t` and `u` allows you to create sophisticated animations that would be difficult to achieve with standard CSS transitions."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"What is the significance of the `from` and `to` parameters in Svelte's custom animation functions, and how can you use them to create responsive animations?","answer":"The `from` and `to` parameters in Svelte's custom animation functions provide crucial information about the element's position before and after reordering, enabling you to create precise and responsive animations.\n\n### Understanding `from` and `to`\n\nBoth `from` and `to` are [DOMRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect) objects, which contain the following properties:\n\n- `x` and `left`: X-coordinate of the rectangle's left edge\n- `y` and `top`: Y-coordinate of the rectangle's top edge\n- `width`: Width of the rectangle\n- `height`: Height of the rectangle\n- `right`: X-coordinate of the rectangle's right edge\n- `bottom`: Y-coordinate of the rectangle's bottom edge\n\nThe `from` DOMRect represents the element's position and size before the list was reordered, while the `to` DOMRect represents its final position and size after reordering.\n\n### Creating Responsive Animations\n\nBy using these DOMRect objects, you can create animations that adapt to:\n1. The actual distance an element needs to move\n2. The element's size\n3. The screen size and layout\n\nHere are several examples of how to use `from` and `to` for responsive animations:\n\n#### 1. Basic Distance-Based Animation\n\n```svelte\n<script>\n  import { cubicOut } from 'svelte/easing';\n  \n  function moveWithDistance(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Calculate the total distance\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    \n    // Make duration proportional to distance (with min/max limits)\n    const duration = Math.min(1000, Math.max(300, distance * 2));\n    \n    return {\n      duration,\n      easing: cubicOut,\n      css: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px);`\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:moveWithDistance>{item.text}</div>\n{/each}\n```\n\nThis animation adapts its duration based on how far the element needs to move - longer distances get longer animations, making the perceived speed consistent.\n\n#### 2. Size-Aware Animation\n\n```svelte\n<script>\n  function sizeAwareAnimation(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Check if size changed\n    const widthChange = to.width / from.width;\n    const heightChange = to.height / from.height;\n    \n    return {\n      duration: 600,\n      css: (t, u) => `\n        transform: \n          translate(${u * dx}px, ${u * dy}px)\n          scale(${1 + (widthChange - 1) * t}, ${1 + (heightChange - 1) * t});\n      `\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:sizeAwareAnimation class=\"item\">{item.text}</div>\n{/each}\n```\n\nThis animation accounts for both position changes and potential size changes of the element.\n\n#### 3. Direction-Aware Animation\n\n```svelte\n<script>\n  function directionAwareMove(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Determine if movement is more horizontal or vertical\n    const isHorizontal = Math.abs(dx) > Math.abs(dy);\n    \n    return {\n      duration: 500,\n      css: (t, u) => {\n        // Apply different effects based on direction\n        if (isHorizontal) {\n          return `\n            transform: translate(${u * dx}px, ${u * dy}px);\n            opacity: ${0.7 + t * 0.3};\n            background-color: rgba(255, ${Math.round(t * 255)}, 100, 0.2);\n          `;\n        } else {\n          return `\n            transform: translate(${u * dx}px, ${u * dy}px);\n            opacity: ${0.7 + t * 0.3};\n            background-color: rgba(100, 255, ${Math.round(t * 255)}, 0.2);\n          `;\n        }\n      }\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:directionAwareMove>{item.text}</div>\n{/each}\n```\n\nThis animation applies different visual effects depending on whether the movement is primarily horizontal or vertical.\n\n#### 4. Path-Based Animation\n\n```svelte\n<script>\n  function pathAnimation(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Calculate center points\n    const fromCenterX = from.left + from.width / 2;\n    const fromCenterY = from.top + from.height / 2;\n    const toCenterX = to.left + to.width / 2;\n    const toCenterY = to.top + to.height / 2;\n    \n    // Create a control point for a quadratic bezier curve\n    // (positioned to the right if moving down, to the left if moving up)\n    const controlX = fromCenterX + (dy > 0 ? 100 : -100);\n    const controlY = (fromCenterY + toCenterY) / 2;\n    \n    return {\n      duration: 800,\n      css: (t, u) => {\n        // Quadratic bezier formula\n        const x = Math.pow(u, 2) * fromCenterX + \n                  2 * u * t * controlX + \n                  Math.pow(t, 2) * toCenterX - \n                  (from.width / 2);\n                  \n        const y = Math.pow(u, 2) * fromCenterY + \n                  2 * u * t * controlY + \n                  Math.pow(t, 2) * toCenterY - \n                  (from.height / 2);\n        \n        return `left: ${x}px; top: ${y}px; position: absolute;`;\n      }\n    };\n  }\n</script>\n\n<div style=\"position: relative; height: 500px;\">\n  {#each items as item (item.id)}\n    <div animate:pathAnimation>{item.text}</div>\n  {/each}\n</div>\n```\n\nThis advanced animation creates a curved path between the start and end positions using a quadratic Bezier curve.\n\n#### 5. Viewport-Aware Animation\n\n```svelte\n<script>\n  function viewportAwareAnimation(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Get viewport dimensions\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n    \n    // Check if element is moving toward or away from viewport center\n    const fromDistanceToCenter = Math.sqrt(\n      Math.pow((from.left + from.width/2) - viewportWidth/2, 2) +\n      Math.pow((from.top + from.height/2) - viewportHeight/2, 2)\n    );\n    \n    const toDistanceToCenter = Math.sqrt(\n      Math.pow((to.left + to.width/2) - viewportWidth/2, 2) +\n      Math.pow((to.top + to.height/2) - viewportHeight/2, 2)\n    );\n    \n    const movingTowardCenter = toDistanceToCenter < fromDistanceToCenter;\n    \n    return {\n      duration: 600,\n      css: (t, u) => `\n        transform: translate(${u * dx}px, ${u * dy}px)\n                   scale(${movingTowardCenter ? 0.8 + t * 0.2 : 1 - t * 0.1});\n        z-index: ${movingTowardCenter ? 10 : 1};\n      `\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:viewportAwareAnimation>{item.text}</div>\n{/each}\n```\n\nThis animation changes its behavior based on whether the element is moving toward or away from the center of the viewport.\n\nBy leveraging the `from` and `to` DOMRect objects, you can create animations that respond intelligently to the actual layout and movement of elements, rather than using fixed animations that might not look right in all contexts."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"What's the difference between transitions and animations in Svelte, and when should you use the `animate:` directive instead of `transition:` directives?","answer":"Svelte offers both transitions and animations, which serve different purposes in creating UI movement. Understanding when to use each is key to creating effective and appropriate motion in your applications.\n\n### Transitions vs. Animations\n\n#### Transitions (`transition:`, `in:`, `out:`)\n\n- **Purpose**: Apply to elements being added to or removed from the DOM\n- **Trigger**: When elements are created or destroyed\n- **Direction**: Can be entering (in), exiting (out), or both (transition)\n- **Context**: Used with conditional rendering (like `{#if}` blocks)\n- **Example use cases**: Fading elements in/out, sliding elements in/out when showing/hiding content\n\n```svelte\n{#if visible}\n  <div transition:fade>This content fades in and out</div>\n{/if}\n```\n\n#### Animations (`animate:`)\n\n- **Purpose**: Apply to elements changing position within the DOM\n- **Trigger**: When the order of elements changes within a keyed each block\n- **Direction**: Always from the old position to the new position\n- **Context**: Must be used with keyed `{#each}` blocks\n- **Example use cases**: Sorting lists, drag-and-drop interfaces, any UI where items reorder\n\n```svelte\n{#each items as item (item.id)}\n  <div animate:flip>{item.text}</div>\n{/each}\n```\n\n### When to Use the `animate:` Directive\n\nYou should use the `animate:` directive when:\n\n1. **Items are reordering within a list**: If you have a sortable list, items changing position based on filters, or any situation where the order of elements changes but the elements themselves remain in the DOM.\n\n2. **You want to show the movement between positions**: When it's important for users to visually track how items move from one position to another.\n\n3. **You're working with a keyed each block**: Animations require a keyed each block to track which items have moved.\n\nHere's an example of a sortable list using animations:\n\n```svelte\n<script>\n  import { flip } from 'svelte/animate';\n  \n  let items = [\n    { id: 1, text: 'Apple' },\n    { id: 2, text: 'Banana' },\n    { id: 3, text: 'Cherry' },\n    { id: 4, text: 'Date' }\n  ];\n  \n  function sortAlphabetically() {\n    items = items.sort((a, b) => a.text.localeCompare(b.text));\n  }\n  \n  function sortReverse() {\n    items = items.sort((a, b) => b.text.localeCompare(a.text));\n  }\n</script>\n\n<button on:click={sortAlphabetically}>Sort A-Z</button>\n<button on:click={sortReverse}>Sort Z-A</button>\n\n<ul>\n  {#each items as item (item.id)}\n    <li animate:flip={{ duration: 500 }}>{item.text}</li>\n  {/each}\n</ul>\n```\n\nIn this example, when users click the sort buttons, the items reorder, and the `flip` animation creates a smooth transition from each item's old position to its new position.\n\n### When to Use Transitions Instead\n\nUse transitions (`transition:`, `in:`, `out:`) when:\n\n1. **Elements are being added or removed**: When content appears or disappears based on conditions.\n\n2. **You want entrance or exit animations**: When you want to control how elements enter or leave the page.\n\n3. **You're working with conditional rendering**: Typically with `{#if}` blocks or dynamic component creation/destruction.\n\nExample of using transitions:\n\n```svelte\n<script>\n  import { fade, fly } from 'svelte/transition';\n  let showDetails = false;\n</script>\n\n<button on:click={() => showDetails = !showDetails}>\n  {showDetails ? 'Hide' : 'Show'} Details\n</button>\n\n{#if showDetails}\n  <div transition:fly={{ y: 20, duration: 300 }}>\n    <h2>Additional Details</h2>\n    <p>This content flies in when shown and flies out when hidden.</p>\n  </div>\n{/if}\n```\n\n### Combining Transitions and Animations\n\nIn some UIs, you might need both:\n\n```svelte\n<script>\n  import { fade } from 'svelte/transition';\n  import { flip } from 'svelte/animate';\n  \n  let items = [/* ... */];\n  let showList = true;\n  \n  function addItem() {\n    const newId = Math.max(0, ...items.map(item => item.id)) + 1;\n    items = [...items, { id: newId, text: `New Item ${newId}` }];\n  }\n  \n  function removeItem(id) {\n    items = items.filter(item => item.id !== id);\n  }\n</script>\n\n<button on:click={() => showList = !showList}>Toggle List</button>\n<button on:click={addItem}>Add Item</button>\n\n{#if showList}\n  <ul transition:fade>\n    {#each items as item (item.id)}\n      <li \n        animate:flip={{ duration: 300 }}\n        transition:fade={{ duration: 200 }}\n      >\n        {item.text}\n        <button on:click={() => removeItem(item.id)}>Remove</button>\n      </li>\n    {/each}\n  </ul>\n{/if}\n```\n\nIn this example:\n- The entire list fades in/out when toggled (transition on the `ul`)\n- Individual items fade in/out when added/removed (transition on the `li`)\n- Items animate between positions when the list order changes (animation on the `li`)\n\n### Key Differences to Remember\n\n1. **Timing**:\n   - Transitions: Run when elements enter or exit the DOM\n   - Animations: Run when elements change position within the DOM\n\n2. **Required Context**:\n   - Transitions: Can be used anywhere elements are conditionally rendered\n   - Animations: Must be used on immediate children of keyed each blocks\n\n3. **Element Lifecycle**:\n   - Transitions: Affect how elements appear or disappear\n   - Animations: Affect how existing elements move between positions\n\nBy understanding these differences, you can choose the right tool for creating motion in your Svelte applications."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"How does Svelte's built-in `flip` animation work, and what are the customization options available for it?","answer":"Svelte's built-in `flip` animation is one of the most commonly used animations in Svelte applications. FLIP stands for \"First, Last, Invert, Play\" - a technique for creating performant animations.\n\n### How the `flip` Animation Works\n\nThe FLIP technique follows these steps:\n\n1. **First**: Record the element's starting position\n2. **Last**: Update the DOM and record the element's final position\n3. **Invert**: Apply a transform to put the element back at its starting position\n4. **Play**: Animate the transform to zero, moving the element to its final position\n\nSvelte's `flip` animation handles all of this automatically when items in a keyed each block are reordered. It creates the illusion that elements physically move from their old position to their new position, providing visual continuity.\n\n### Basic Usage\n\n```svelte\n<script>\n  import { flip } from 'svelte/animate';\n  \n  let items = [\n    { id: 1, name: 'Apple' },\n    { id: 2, name: 'Banana' },\n    { id: 3, name: 'Cherry' }\n  ];\n  \n  function shuffle() {\n    items = items.sort(() => Math.random() - 0.5);\n  }\n</script>\n\n<button on:click={shuffle}>Shuffle</button>\n\n<ul>\n  {#each items as item (item.id)}\n    <li animate:flip>{item.name}</li>\n  {/each}\n</ul>\n```\n\nWhen the \"Shuffle\" button is clicked, the items will smoothly animate to their new positions.\n\n### Customization Options\n\nThe `flip` animation accepts several parameters for customization:\n\n1. **`duration` (number, default: 400)**:\n   - The length of the animation in milliseconds\n\n2. **`delay` (number, default: 0)**:\n   - The time to wait before starting the animation in milliseconds\n\n3. **`easing` (function, default: cubicOut)**:\n   - The easing function to use (from 'svelte/easing')\n\n4. **`css` (function, optional)**:\n   - A custom CSS function for advanced customization\n\nHere's how to use these options:\n\n```svelte\n<script>\n  import { flip } from 'svelte/animate';\n  import { elasticOut } from 'svelte/easing';\n  \n  let items = [/* ... */];\n</script>\n\n{#each items as item (item.id)}\n  <div animate:flip={{ \n    duration: 800,\n    delay: 50,\n    easing: elasticOut\n  }}>\n    {item.text}\n  </div>\n{/each}\n```\n\n### Advanced Customization with the `css` Option\n\nFor more complex animations, you can provide a custom `css` function:\n\n```svelte\n<script>\n  import { flip } from 'svelte/animate';\n  import { cubicOut } from 'svelte/easing';\n  \n  let items = [/* ... */];\n  \n  const customFlip = (node, { from, to }, params) => {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    return {\n      duration: 400,\n      easing: cubicOut,\n      css: (t, u) => `\n        transform: translate(${u * dx}px, ${u * dy}px);\n        background: rgb(255, ${Math.floor(t * 255)}, ${Math.floor(u * 255)});\n        border-radius: ${t * 10}px;\n      `\n    };\n  };\n</script>\n\n{#each items as item (item.id)}\n  <div animate:customFlip>\n    {item.text}\n  </div>\n{/each}\n```\n\nThis custom animation not only moves the elements but also changes their background color and border-radius during the animation.\n\n### Real-World Examples\n\n#### 1. Staggered Animation with Different Durations\n\n```svelte\n<script>\n  import { flip } from 'svelte/animate';\n  import { cubicOut } from 'svelte/easing';\n  \n  let items = [/* ... */];\n  \n  // Longer duration for items further down the list\n  function staggeredFlip(node, { from, to }, params) {\n    const index = parseInt(node.dataset.index);\n    \n    return {\n      delay: index * 50,  // Stagger by index\n      duration: 400 + index * 100,  // Longer duration for higher indexes\n      easing: cubicOut,\n      css: (t, u) => {\n        const dx = from.left - to.left;\n        const dy = from.top - to.top;\n        return `transform: translate(${u * dx}px, ${u * dy}px);`;\n      }\n    };\n  }\n</script>\n\n{#each items as item, i (item.id)}\n  <div animate:staggeredFlip data-index={i}>\n    {item.text}\n  </div>\n{/each}\n```\n\n#### 2. Direction-Aware Animation\n\n```svelte\n<script>\n  import { flip } from 'svelte/animate';\n  import { cubicOut, bounceOut } from 'svelte/easing';\n  \n  let items = [/* ... */];\n  \n  function directionAwareFlip(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Use different easing based on direction\n    const easing = dx > 0 ? cubicOut : bounceOut;\n    \n    return {\n      duration: 600,\n      easing,\n      css: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px);`\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:directionAwareFlip>\n    {item.text}\n  </div>\n{/each}\n```\n\n#### 3. Responsive Duration Based on Distance\n\n```svelte\n<script>\n  import { flip } from 'svelte/animate';\n  import { cubicOut } from 'svelte/easing';\n  \n  let items = [/* ... */];\n  \n  function distanceBasedFlip(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Calculate distance\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    \n    // Duration based on distance (with min/max limits)\n    const duration = Math.min(1000, Math.max(300, distance * 2));\n    \n    return {\n      duration,\n      easing: cubicOut,\n      css: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px);`\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:distanceBasedFlip>\n    {item.text}\n  </div>\n{/each}\n```\n\n### Performance Considerations\n\nThe `flip` animation is generally performant because it uses CSS transforms which are hardware-accelerated in modern browsers. However, for very large lists or complex animations, consider:\n\n1. Limiting the number of animated elements\n2. Using simpler animations for mobile devices\n3. Using the `duration` parameter to make animations shorter when appropriate\n\nBy understanding how `flip` works and its customization options, you can create smooth, intuitive animations that enhance the user experience in your Svelte applications."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"How can you implement a custom animation function that uses both CSS and JavaScript callbacks for complex animation effects?","answer":"Creating custom animations that combine both CSS transformations and JavaScript callbacks allows for powerful and complex animation effects in Svelte. This approach leverages the performance benefits of CSS animations while adding the flexibility of JavaScript for effects that CSS alone can't achieve.\n\n### Implementing a Combined Animation Function\n\nA comprehensive custom animation function can use both the `css` method for performance-critical transformations and the `tick` method for JavaScript-driven effects:\n\n```svelte\n<script>\n  import { cubicOut } from 'svelte/easing';\n  \n  /**\n   * A complex animation that combines CSS transforms with JavaScript callbacks\n   * @param {HTMLElement} node - The DOM node being animated\n   * @param {{ from: DOMRect, to: DOMRect }} states - The start and end positions\n   * @param {Object} params - Custom parameters for the animation\n   */\n  function complexAnimation(node, { from, to }, params = {}) {\n    // Extract parameters with defaults\n    const {\n      duration = 800,\n      delay = 0,\n      easing = cubicOut,\n      intensity = 1,\n      onProgress = null,\n      cssOnly = false\n    } = params;\n    \n    // Calculate movement distances\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    const dw = from.width / to.width;\n    const dh = from.height / to.height;\n    \n    // Store initial state for JavaScript animations\n    const originalTextContent = node.textContent;\n    const originalChildren = Array.from(node.children);\n    const childrenCount = originalChildren.length;\n    \n    // Create wrapper for storing animation state\n    const state = {\n      progress: 0,\n      effectApplied: false\n    };\n    \n    // Return the animation configuration\n    return {\n      delay,\n      duration,\n      easing,\n      // CSS-based animations (hardware accelerated)\n      css: (t, u) => {\n        // Update state for potential use in tick\n        state.progress = t;\n        \n        // Base transformations using CSS\n        return `\n          transform: \n            translate(${u * dx}px, ${u * dy}px)\n            scale(${1 + (dw - 1) * u}, ${1 + (dh - 1) * u})\n            rotate(${t * intensity * 10}deg);\n          opacity: ${0.7 + t * 0.3};\n          background: hsl(${t * 60}, 80%, 70%);\n          box-shadow: 0 ${t * 10}px ${t * 20}px rgba(0, 0, 0, ${u * 0.3});\n        `;\n      },\n      // JavaScript-based effects (more flexible but less performant)\n      tick: (t, u) => {\n        // Skip JS effects if cssOnly is true\n        if (cssOnly) return;\n        \n        // Call the progress callback if provided\n        if (onProgress) onProgress(t, node);\n        \n        // Apply mid-animation effect at 50% progress\n        if (t > 0.4 && t < 0.6 && !state.effectApplied) {\n          // Apply a one-time effect\n          node.style.outline = '3px solid gold';\n          state.effectApplied = true;\n        } else if (t >= 0.6 && state.effectApplied) {\n          // Remove the effect\n          node.style.outline = 'none';\n        }\n        \n        // Manipulate child elements if they exist\n        if (childrenCount > 0) {\n          originalChildren.forEach((child, i) => {\n            // Stagger child animations based on index\n            const childT = Math.max(0, Math.min(1, (t * 2) - (i / childrenCount)));\n            \n            if (child.style) {\n              child.style.opacity = childT;\n              child.style.transform = `scale(${childT})`;\n            }\n          });\n        }\n        \n        // Text scrambling effect during movement\n        if (t > 0.1 && t < 0.9) {\n          const scrambleIntensity = 1 - Math.abs(t - 0.5) * 2; // Peak at t=0.5\n          \n          // Only scramble text if it's short enough to be performant\n          if (originalTextContent.length < 20) {\n            const chars = originalTextContent.split('');\n            const scrambledChars = chars.map(char => {\n              // Randomly decide whether to scramble this character\n              return Math.random() < scrambleIntensity * 0.5 ? \n                String.fromCharCode(char.charCodeAt(0) + Math.floor(Math.random() * 5) - 2) : \n                char;\n            });\n            \n            node.textContent = scrambledChars.join('');\n          }\n        } else if (t >= 0.9) {\n          // Restore original text at the end\n          node.textContent = originalTextContent;\n        }\n      }\n    };\n  }\n</script>\n\n<!-- Usage example -->\n<div>\n  {#each items as item (item.id)}\n    <div \n      animate:complexAnimation={{\n        duration: 1000,\n        intensity: 0.8,\n        onProgress: (t, node) => {\n          // External callback\n          console.log(`Animation progress: ${Math.round(t * 100)}%`);\n        }\n      }}\n    >\n      <h3>{item.title}</h3>\n      <p>{item.description}</p>\n    </div>\n  {/each}\n</div>\n```\n\n### Key Components of a Combined Animation\n\nLet's break down the key techniques used in this complex animation:\n\n#### 1. Parameter Handling with Defaults\n\n```js\nconst {\n  duration = 800,\n  delay = 0,\n  easing = cubicOut,\n  intensity = 1,\n  onProgress = null,\n  cssOnly = false\n} = params;\n```\n\nThis allows users of your animation to customize various aspects, with sensible defaults if they don't specify values.\n\n#### 2. State Management Between CSS and Tick\n\n```js\nconst state = {\n  progress: 0,\n  effectApplied: false\n};\n\n// In css function:\nstate.progress = t;\n\n// In tick function:\nif (t > 0.4 && t < 0.6 && !state.effectApplied) {\n  // ...\n  state.effectApplied = true;\n}\n```\n\nUsing a shared state object allows you to coordinate between the `css` and `tick` functions, which may run at different times.\n\n#### 3. CSS Transformations for Performance\n\n```js\ncss: (t, u) => `\n  transform: \n    translate(${u * dx}px, ${u * dy}px)\n    scale(${1 + (dw - 1) * u}, ${1 + (dh - 1) * u})\n    rotate(${t * intensity * 10}deg);\n  opacity: ${0.7 + t * 0.3};\n  background: hsl(${t * 60}, 80%, 70%);\n  box-shadow: 0 ${t * 10}px ${t * 20}px rgba(0, 0, 0, ${u * 0.3});\n`\n```\n\nUse the `css` function for transformations, colors, and other properties that can be hardware-accelerated.\n\n#### 4. JavaScript for Complex DOM Manipulations\n\n```js\ntick: (t, u) => {\n  // Manipulate child elements\n  if (childrenCount > 0) {\n    originalChildren.forEach((child, i) => {\n      const childT = Math.max(0, Math.min(1, (t * 2) - (i / childrenCount)));\n      \n      if (child.style) {\n        child.style.opacity = childT;\n        child.style.transform = `scale(${childT})`;\n      }\n    });\n  }\n  \n  // Text scrambling effect\n  if (t > 0.1 && t < 0.9) {\n    // ...scramble text logic...\n  }\n}\n```\n\nUse the `tick` function for effects that require DOM manipulation, like animating children independently or modifying text content.\n\n#### 5. Callbacks for External Integration\n\n```js\nif (onProgress) onProgress(t, node);\n```\n\nProviding callback hooks allows users of your animation to integrate it with other parts of their application.\n\n#### 6. Performance Optimization\n\n```js\n// Skip JS effects if cssOnly is true\nif (cssOnly) return;\n\n// Only scramble text if it's short enough to be performant\nif (originalTextContent.length < 20) {\n  // ...text scrambling logic...\n}\n```\n\nInclude options to disable CPU-intensive parts of the animation and add checks to avoid expensive operations when they might impact performance.\n\n### Practical Examples of Combined Animations\n\n#### Example 1: Card Flip with Content Swap\n\n```svelte\n<script>\n  function cardFlip(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Store front/back content\n    const frontContent = node.innerHTML;\n    const backContent = node.dataset.backContent || 'Back side';\n    \n    return {\n      duration: 800,\n      css: (t, u) => {\n        // First half: flip to vertical\n        // Second half: flip from vertical\n        const flipped = t > 0.5;\n        const ft = flipped ? (t - 0.5) * 2 : t * 2;\n        const fu = flipped ? (0.5 - t) * 2 : (1 - t) * 2;\n        \n        return `\n          transform: \n            translate(${u * dx}px, ${u * dy}px)\n            rotateY(${t * 180}deg);\n          backface-visibility: hidden;\n        `;\n      },\n      tick: (t, u) => {\n        // Swap content at the halfway point\n        if (t < 0.5 && t + 0.1 >= 0.5) {\n          node.innerHTML = backContent;\n        } else if (t >= 0.5 && t - 0.1 < 0.5) {\n          node.innerHTML = frontContent;\n        }\n      }\n    };\n  }\n</script>\n\n{#each cards as card (card.id)}\n  <div \n    animate:cardFlip\n    data-back-content={card.backContent}\n    class=\"card\"\n  >\n    {card.frontContent}\n  </div>\n{/each}\n```\n\n#### Example 2: Particle Explosion Effect\n\n```svelte\n<script>\n  function particleExplosion(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Create particles\n    const particles = [];\n    const particleCount = 20;\n    \n    // Return animation config\n    return {\n      duration: 1000,\n      css: (t, u) => `\n        transform: translate(${u * dx}px, ${u * dy}px);\n        opacity: ${t < 0.5 ? 1 : 2 - t * 2};\n      `,\n      tick: (t, u) => {\n        // Create particles at the start\n        if (t < 0.1 && particles.length === 0) {\n          for (let i = 0; i < particleCount; i++) {\n            const particle = document.createElement('div');\n            particle.className = 'particle';\n            particle.style.position = 'absolute';\n            particle.style.width = '5px';\n            particle.style.height = '5px';\n            particle.style.background = 'gold';\n            particle.style.borderRadius = '50%';\n            \n            // Random angle and distance\n            const angle = Math.random() * Math.PI * 2;\n            const distance = 30 + Math.random() * 70;\n            \n            particles.push({\n              element: particle,\n              angle,\n              distance\n            });\n            \n            node.appendChild(particle);\n          }\n        }\n        \n        // Animate particles\n        if (particles.length > 0) {\n          particles.forEach(particle => {\n            // Particle progress (faster than main animation)\n            const pt = Math.min(1, t * 2);\n            \n            // Position based on angle and distance\n            const x = Math.cos(particle.angle) * particle.distance * pt;\n            const y = Math.sin(particle.angle) * particle.distance * pt;\n            \n            // Apply position and fade out at the end\n            particle.element.style.transform = `translate(${x}px, ${y}px)`;\n            particle.element.style.opacity = 1 - pt;\n          });\n        }\n        \n        // Clean up particles at the end\n        if (t === 1) {\n          particles.forEach(p => p.element.remove());\n          particles.length = 0;\n        }\n      }\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:particleExplosion class=\"item\">\n    {item.text}\n  </div>\n{/each}\n```\n\n### Best Practices for Combined Animations\n\n1. **Separate concerns**: Use CSS for transformations and visual effects, JavaScript for DOM manipulations and complex logic.\n\n2. **Consider performance**: Always provide a way to disable CPU-intensive parts of the animation for performance-sensitive contexts.\n\n3. **Handle cleanup**: Make sure to restore original states or clean up added elements when the animation completes.\n\n4. **Provide sensible defaults**: Make your animation work well out of the box, but allow customization.\n\n5. **Add fallbacks**: Consider what happens if the browser doesn't support certain features or if JavaScript is disabled.\n\n6. **Test on different devices**: What works smoothly on a desktop might be sluggish on mobile devices.\n\nBy combining CSS and JavaScript in your custom animations, you can create rich, interactive effects that would be impossible with either approach alone, while still maintaining good performance where it matters most."}
{"source":"docs/svelte/03-template-syntax/15-animate.md","question":"How do animations interact with other Svelte features like transitions and stores, and what are some advanced techniques for orchestrating complex animations?","answer":"Animations in Svelte can be combined with other Svelte features to create sophisticated and coordinated motion effects. Understanding how animations interact with transitions, stores, actions, and other Svelte features opens up powerful possibilities for creating complex, orchestrated animations.\n\n### Animations with Transitions\n\nAnimations and transitions can work together on the same elements, each handling different aspects of element movement:\n\n```svelte\n<script>\n  import { flip } from 'svelte/animate';\n  import { fade, fly } from 'svelte/transition';\n  \n  let items = [/* ... */];\n  \n  function addItem() {\n    const newId = Math.max(0, ...items.map(i => i.id)) + 1;\n    items = [...items, { id: newId, text: `Item ${newId}` }];\n  }\n  \n  function removeItem(id) {\n    items = items.filter(item => item.id !== id);\n  }\n</script>\n\n<button on:click={addItem}>Add Item</button>\n\n<div class=\"list-container\">\n  {#each items as item (item.id)}\n    <div \n      class=\"list-item\"\n      animate:flip={{ duration: 500 }}\n      in:fly={{ y: 20, duration: 300 }}\n      out:fade={{ duration: 200 }}\n    >\n      {item.text}\n      <button on:click={() => removeItem(item.id)}>Ã</button>\n    </div>\n  {/each}\n</div>\n```\n\nIn this example:\n- New items fly in from below (`in:fly`)\n- Removed items fade out (`out:fade`)\n- Existing items smoothly animate to their new positions when the list changes (`animate:flip`)\n\n### Animations with Svelte Stores\n\nSvelte stores can be used to coordinate animations across multiple components or to trigger animations based on application state:\n\n```svelte\n<!-- AnimationController.svelte -->\n<script>\n  import { writable } from 'svelte/store';\n  \n  // Create stores for animation coordination\n  export const animationSpeed = writable(400);\n  export const animationIntensity = writable(1);\n  export const animationPaused = writable(false);\n</script>\n\n<!-- AnimatedList.svelte -->\n<script>\n  import { animationSpeed, animationIntensity, animationPaused } from './AnimationController.svelte';\n  import { flip } from 'svelte/animate';\n  \n  let items = [/* ... */];\n  \n  // Custom animation that respects global settings\n  function controlledFlip(node, { from, to }, params) {\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    \n    // Get current store values\n    let speed, intensity, paused;\n    \n    const unsubscribeSpeed = animationSpeed.subscribe(value => {\n      speed = value;\n    });\n    \n    const unsubscribeIntensity = animationIntensity.subscribe(value => {\n      intensity = value;\n    });\n    \n    const unsubscribePaused = animationPaused.subscribe(value => {\n      paused = value;\n    });\n    \n    // Clean up subscriptions when animation completes\n    node.addEventListener('animationend', () => {\n      unsubscribeSpeed();\n      unsubscribeIntensity();\n      unsubscribePaused();\n    });\n    \n    return {\n      duration: speed,\n      delay: paused ? 9999999 : 0, // \"Pause\" by using a very long delay\n      css: (t, u) => `\n        transform: \n          translate(${u * dx}px, ${u * dy}px)\n          rotate(${t * intensity * 10}deg);\n      `\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div animate:controlledFlip>{item.text}</div>\n{/each}\n\n<!-- App.svelte -->\n<script>\n  import AnimatedList from './AnimatedList.svelte';\n  import { animationSpeed, animationIntensity, animationPaused } from './AnimationController.svelte';\n  \n  let items = [/* ... */];\n  \n  function shuffle() {\n    items = items.sort(() => Math.random() - 0.5);\n  }\n</script>\n\n<div class=\"controls\">\n  <button on:click={shuffle}>Shuffle</button>\n  \n  <label>\n    Speed:\n    <input type=\"range\" min=\"100\" max=\"1000\" bind:value={$animationSpeed} />\n  </label>\n  \n  <label>\n    Intensity:\n    <input type=\"range\" min=\"0\" max=\"3\" step=\"0.1\" bind:value={$animationIntensity} />\n  </label>\n  \n  <label>\n    <input type=\"checkbox\" bind:checked={$animationPaused} />\n    Pause Animations\n  </label>\n</div>\n\n<AnimatedList {items} />\n```\n\nThis example demonstrates a global animation controller using Svelte stores that affects all animations in the application.\n\n### Animations with Actions\n\nSvelte actions can be combined with animations to add interactive behaviors that work with animations:\n\n```svelte\n<script>\n  import { flip } from 'svelte/animate';\n  \n  let items = [/* ... */];\n  \n  // Draggable action for reordering\n  function draggable(node, params) {\n    let y;\n    let originalIndex;\n    \n    function handleMousedown(event) {\n      y = event.clientY;\n      originalIndex = parseInt(node.dataset.index);\n      \n      window.addEventListener('mousemove', handleMousemove);\n      window.addEventListener('mouseup', handleMouseup);\n      \n      node.classList.add('dragging');\n    }\n    \n    function handleMousemove(event) {\n      const dy = event.clientY - y;\n      node.style.transform = `translateY(${dy}px)`;\n      \n      // Calculate new index based on position\n      const newIndex = calculateNewIndex(originalIndex, dy);\n      \n      if (newIndex !== originalIndex && newIndex >= 0 && newIndex < items.length) {\n        // Reorder the items array\n        const itemsCopy = [...items];\n        const [removed] = itemsCopy.splice(originalIndex, 1);\n        itemsCopy.splice(newIndex, 0, removed);\n        items = itemsCopy;\n        \n        // Update originalIndex to track the item as it moves\n        originalIndex = newIndex;\n        y = event.clientY;\n      }\n    }\n    \n    function handleMouseup() {\n      window.removeEventListener('mousemove', handleMousemove);\n      window.removeEventListener('mouseup', handleMouseup);\n      \n      node.style.transform = '';\n      node.classList.remove('dragging');\n    }\n    \n    function calculateNewIndex(startIndex, dy) {\n      // Simple calculation: each item is assumed to be 40px tall\n      return Math.round(startIndex + dy / 40);\n    }\n    \n    node.addEventListener('mousedown', handleMousedown);\n    \n    return {\n      destroy() {\n        node.removeEventListener('mousedown', handleMousedown);\n      }\n    };\n  }\n</script>\n\n<style>\n  .item {\n    padding: 10px;\n    margin: 5px 0;\n    background: #f0f0f0;\n    cursor: grab;\n    user-select: none;\n  }\n  \n  .dragging {\n    opacity: 0.8;\n    z-index: 10;\n  }\n</style>\n\n<div class=\"list\">\n  {#each items as item, i (item.id)}\n    <div \n      class=\"item\"\n      animate:flip={{ duration: 300 }}\n      use:draggable\n      data-index={i}\n    >\n      {item.text}\n    </div>\n  {/each}\n</div>\n```\n\nThis example creates a draggable, sortable list where the `flip` animation smoothly transitions items when their order changes.\n\n### Orchestrating Complex Animations\n\nFor more complex animation sequences, you can create animation orchestrators that coordinate multiple animations:\n\n```svelte\n<script>\n  import { writable, derived } from 'svelte/store';\n  import { cubicOut, elasticOut } from 'svelte/easing';\n  \n  // Timeline for coordinating animations\n  class AnimationTimeline {\n    constructor() {\n      this.progress = writable(0);\n      this.playing = writable(false);\n      this.duration = 3000; // Total timeline duration in ms\n      this.startTime = 0;\n      this.animationFrame = null;\n    }\n    \n    play() {\n      this.playing.set(true);\n      this.startTime = performance.now() - (this.get() * this.duration);\n      this.tick();\n    }\n    \n    pause() {\n      this.playing.set(false);\n      cancelAnimationFrame(this.animationFrame);\n    }\n    \n    reset() {\n      this.progress.set(0);\n      this.pause();\n    }\n    \n    get() {\n      let value;\n      this.progress.subscribe(v => value = v)();\n      return value;\n    }\n    \n    tick() {\n      const now = performance.now();\n      const elapsed = now - this.startTime;\n      const newProgress = Math.min(1, elapsed / this.duration);\n      \n      this.progress.set(newProgress);\n      \n      if (newProgress < 1) {\n        this.animationFrame = requestAnimationFrame(() => this.tick());\n      } else {\n        this.playing.set(false);\n      }\n    }\n    \n    // Create a derived store for a specific segment of the timeline\n    segment(start, end) {\n      return derived(this.progress, $progress => {\n        if ($progress < start) return 0;\n        if ($progress > end) return 1;\n        return ($progress - start) / (end - start);\n      });\n    }\n  }\n  \n  // Create a timeline\n  const timeline = new AnimationTimeline();\n  \n  // Create segments for different animations\n  const firstAnimation = timeline.segment(0, 0.3);\n  const secondAnimation = timeline.segment(0.2, 0.6);\n  const thirdAnimation = timeline.segment(0.5, 1);\n  \n  // Animation functions that use timeline segments\n  function timelineAnimation(node, segment, params = {}) {\n    const {\n      property = 'transform',\n      from = 'translateY(50px)',\n      to = 'translateY(0)',\n      easing = cubicOut\n    } = params;\n    \n    const unsubscribe = segment.subscribe(t => {\n      // Apply easing\n      const easedT = easing(t);\n      \n      if (property === 'transform') {\n        // For transform, interpolate between from and to values\n        node.style.transform = from === 'translateY(50px)' && to === 'translateY(0)' ?\n          `translateY(${(1 - easedT) * 50}px)` :\n          from; // This is simplified - a real implementation would interpolate properly\n      } else {\n        // For other properties, just set the value\n        node.style[property] = easedT < 0.5 ? from : to;\n      }\n    });\n    \n    return {\n      destroy() {\n        unsubscribe();\n      }\n    };\n  }\n</script>\n\n<div class=\"timeline-controls\">\n  <button on:click={() => timeline.play()}>Play</button>\n  <button on:click={() => timeline.pause()}>Pause</button>\n  <button on:click={() => timeline.reset()}>Reset</button>\n  <progress value={$timeline.progress} max=\"1\"></progress>\n</div>\n\n<div class=\"animation-container\">\n  <div class=\"box box1\" use:timelineAnimation={firstAnimation}></div>\n  \n  <div \n    class=\"box box2\" \n    use:timelineAnimation={secondAnimation, {\n      property: 'opacity',\n      from: '0',\n      to: '1'\n    }}\n  ></div>\n  \n  <div \n    class=\"box box3\" \n    use:timelineAnimation={thirdAnimation, {\n      from: 'scale(0.5)',\n      to: 'scale(1)',\n      easing: elasticOut\n    }}\n  ></div>\n</div>\n```\n\nThis example creates a timeline-based animation system that can coordinate multiple animations with precise timing.\n\n### Combining Animations with Spring Physics\n\nFor more natural-feeling animations, you can incorporate spring physics:\n\n```svelte\n<script>\n  import { spring } from 'svelte/motion';\n  \n  let items = [/* ... */];\n  \n  // Create a spring store for each item's position\n  const positions = new Map();\n  \n  function getPosition(id) {\n    if (!positions.has(id)) {\n      positions.set(id, spring({ x: 0, y: 0 }, {\n        stiffness: 0.1,\n        damping: 0.4\n      }));\n    }\n    return positions.get(id);\n  }\n  \n  function springAnimation(node, { from, to }, params) {\n    const id = node.dataset.id;\n    const position = getPosition(id);\n    \n    // Set spring target to the new position (relative to old position)\n    position.set({\n      x: -(to.left - from.left),\n      y: -(to.top - from.top)\n    });\n    \n    // Animate to the target position (which is 0,0)\n    position.stiffness = params?.stiffness || 0.1;\n    position.damping = params?.damping || 0.4;\n    \n    // Gradually animate to the final position\n    setTimeout(() => {\n      position.set({ x: 0, y: 0 });\n    }, 20);\n    \n    // Subscribe to the spring and apply the position\n    const unsubscribe = position.subscribe(({ x, y }) => {\n      node.style.transform = `translate(${x}px, ${y}px)`;\n    });\n    \n    return {\n      // This is needed to satisfy the animate directive API,\n      // but the actual animation happens through the spring subscription\n      duration: 0,\n      css: () => '',\n      tick: (t) => {\n        if (t === 1) {\n          // Clean up when the internal animation finishes\n          unsubscribe();\n        }\n      }\n    };\n  }\n</script>\n\n{#each items as item (item.id)}\n  <div \n    animate:springAnimation={{ stiffness: 0.15, damping: 0.5 }}\n    data-id={item.id}\n  >\n    {item.text}\n  </div>\n{"}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"What is the `style:` directive in Svelte and how does it differ from the standard HTML style attribute?","answer":"The `style:` directive in Svelte is a shorthand for setting CSS styles on an element. While it serves a similar purpose to the standard HTML style attribute, it offers more flexibility and integration with Svelte's reactivity system.\n\nThe basic syntax for the `style:` directive is:\n```svelte\n<div style:property=\"value\">...</div>\n```\n\nThis is equivalent to:\n```svelte\n<div style=\"property: value;\">...</div>\n```\n\nThe key differences are:\n1. The `style:` directive can directly use Svelte variables and expressions\n2. It allows for a shorthand form when the property name matches a variable name\n3. Multiple `style:` directives can be used on a single element for better readability\n4. It can use the `|important` modifier to set styles as important\n5. When both `style` attribute and `style:` directives are used, the directives take precedence\n\nFor example, using a reactive variable with the style directive:\n```svelte\n<script>\n  let textColor = 'red';\n  \n  function changeColor() {\n    textColor = textColor === 'red' ? 'blue' : 'red';\n  }\n</script>\n\n<div style:color={textColor}>This text color will change when the button is clicked</div>\n<button on:click={changeColor}>Change color</button>\n```\n\nThis makes styling more dynamic and integrated with Svelte's reactivity system."}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"How can you use expressions with the `style:` directive in Svelte?","answer":"The `style:` directive in Svelte can accept arbitrary JavaScript expressions as values, making it extremely flexible for dynamic styling. This allows you to compute style values based on component state, props, or other variables.\n\nBasic syntax for using expressions:\n```svelte\n<div style:property={expression}>...</div>\n```\n\nHere are several examples demonstrating different expression types:\n\n1. Using a simple variable:\n```svelte\n<script>\n  let textColor = 'red';\n</script>\n\n<div style:color={textColor}>This text is red</div>\n```\n\n2. Using a conditional (ternary) expression:\n```svelte\n<script>\n  let darkMode = false;\n</script>\n\n<div style:background-color={darkMode ? 'black' : 'white'} \n     style:color={darkMode ? 'white' : 'black'}>\n  This adapts to dark/light mode\n</div>\n<button on:click={() => darkMode = !darkMode}>Toggle mode</button>\n```\n\n3. Using a function return value:\n```svelte\n<script>\n  let progress = 45;\n  \n  function getGradientColor(value) {\n    if (value < 30) return 'red';\n    if (value < 70) return 'orange';\n    return 'green';\n  }\n</script>\n\n<div style:color={getGradientColor(progress)}>\n  Progress indicator\n</div>\n```\n\n4. Using template literals for complex values:\n```svelte\n<script>\n  let x = 10;\n  let y = 20;\n</script>\n\n<div style:transform={`translate(${x}px, ${y}px)`}>\n  This element is positioned dynamically\n</div>\n```\n\n5. Using mathematical expressions:\n```svelte\n<script>\n  let width = 100;\n  let scale = 1.5;\n</script>\n\n<div style:width={`${width * scale}px`}>\n  This element's width is calculated\n</div>\n```\n\nThe ability to use expressions makes the `style:` directive much more powerful than static CSS, especially for building interactive UIs where styles need to change based on application state."}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"What is the shorthand form of the `style:` directive and when would you use it?","answer":"The shorthand form of the `style:` directive in Svelte allows you to set a style property using a variable with the same name as the CSS property. This creates cleaner, more concise code when your variable names match CSS property names.\n\nThe shorthand syntax is:\n```svelte\n<div style:property>...</div>\n```\n\nThis is equivalent to:\n```svelte\n<div style:property={property}>...</div>\n```\n\nHere's a complete example demonstrating when and how to use the shorthand form:\n\n```svelte\n<script>\n  // These variable names match CSS property names\n  let color = 'crimson';\n  let fontSize = '1.5rem';\n  let padding = '10px';\n  let borderRadius = '4px';\n  \n  // This doesn't match a CSS property name directly\n  let primaryBackground = 'lightyellow';\n</script>\n\n<!-- Using shorthand form for matching variable names -->\n<div style:color \n     style:fontSize \n     style:padding \n     style:borderRadius\n     style:background-color={primaryBackground}>\n  This element uses the shorthand style directive\n</div>\n```\n\nThe shorthand form is particularly useful in these scenarios:\n\n1. When building component libraries where you expose style properties as props:\n```svelte\n<script>\n  export let color = 'black';\n  export let fontSize = '1rem';\n</script>\n\n<button style:color style:fontSize>\n  Styled Button\n</button>\n```\n\n2. When working with reactive declarations that compute style values:\n```svelte\n<script>\n  let baseSize = 16;\n  $: fontSize = `${baseSize}px`;\n  $: lineHeight = `${baseSize * 1.5}px`;\n</script>\n\n<p style:fontSize style:lineHeight>\n  This text will update when baseSize changes\n</p>\n<button on:click={() => baseSize += 2}>Increase size</button>\n```\n\n3. When toggling between multiple style configurations:\n```svelte\n<script>\n  let isHighlighted = false;\n  \n  $: color = isHighlighted ? 'yellow' : 'inherit';\n  $: backgroundColor = isHighlighted ? 'black' : 'white';\n</script>\n\n<div style:color style:backgroundColor>\n  Click to highlight\n</div>\n```\n\nThe shorthand form reduces redundancy and makes your code more readable when working with style properties that change based on component state."}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"How can you apply multiple styles using the `style:` directive on a single element?","answer":"In Svelte, you can apply multiple styles to a single element by using multiple `style:` directives. This approach provides better readability and organization compared to combining everything into a single style attribute.\n\nTo apply multiple styles, simply add multiple `style:` directives to the element:\n\n```svelte\n<div \n  style:color=\"red\" \n  style:font-size=\"16px\" \n  style:padding=\"10px\"\n  style:border=\"1px solid black\">\n  This element has multiple styles\n</div>\n```\n\nEach directive can use different forms - some can use direct values, others can use expressions, and some can use the shorthand form:\n\n```svelte\n<script>\n  let textColor = 'blue';\n  let fontSize = '1.2rem';\n  let isActive = false;\n</script>\n\n<div\n  style:color={textColor}\n  style:fontSize\n  style:font-weight=\"bold\"\n  style:background-color={isActive ? 'yellow' : 'transparent'}\n  style:border={isActive ? '2px solid black' : '1px solid gray'}\n  style:padding=\"1rem\">\n  This element combines different style directive forms\n</div>\n```\n\nThis approach is particularly useful for complex styling scenarios:\n\n1. Creating a dynamically styled component:\n```svelte\n<script>\n  // Component props for styling\n  export let width = 'auto';\n  export let height = 'auto';\n  export let color = 'black';\n  export let backgroundColor = 'white';\n  \n  // Computed styles\n  $: opacity = disabled ? 0.5 : 1;\n  $: cursor = disabled ? 'not-allowed' : 'pointer';\n  \n  // Component state\n  let disabled = false;\n</script>\n\n<button\n  style:width\n  style:height\n  style:color\n  style:backgroundColor\n  style:opacity\n  style:cursor\n  style:padding=\"8px 16px\"\n  style:border-radius=\"4px\"\n  style:transition=\"all 0.3s ease\"\n  on:click={() => disabled = !disabled}>\n  Toggle Disabled State\n</button>\n```\n\n2. Creating responsive elements:\n```svelte\n<script>\n  let windowWidth;\n  \n  $: isMobile = windowWidth < 768;\n  $: fontSize = isMobile ? '14px' : '16px';\n  $: padding = isMobile ? '8px' : '16px';\n  $: maxWidth = isMobile ? '100%' : '50%';\n</script>\n\n<svelte:window bind:innerWidth={windowWidth}/>\n\n<div\n  style:font-size={fontSize}\n  style:padding={padding}\n  style:max-width={maxWidth}\n  style:margin=\"0 auto\"\n  style:box-sizing=\"border-box\">\n  This element adapts to screen size\n</div>\n```\n\nUsing multiple `style:` directives makes your code more maintainable as each style property is clearly defined on its own line, and it's easier to add, remove, or modify individual styles without affecting others."}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"How do you mark a style as important using the `style:` directive?","answer":"In Svelte, you can mark a style as important using the `|important` modifier with the `style:` directive. This is equivalent to adding `!important` to a CSS property in regular CSS.\n\nThe syntax for marking a style as important is:\n\n```svelte\n<div style:property|important=\"value\">...</div>\n```\n\nThis will compile to:\n\n```html\n<div style=\"property: value !important;\">...</div>\n```\n\nHere's a complete example demonstrating how to use the important modifier:\n\n```svelte\n<script>\n  let color = 'red';\n</script>\n\n<div style:color|important={color}>\n  This text will be red and override any other color styling\n</div>\n```\n\nThe `|important` modifier is particularly useful in these scenarios:\n\n1. When you need to override styles from a parent component or global CSS:\n\n```svelte\n<div class=\"parent\" style=\"color: blue;\">\n  <p style:color|important=\"red\">\n    This will be red despite the parent's blue color\n  </p>\n</div>\n```\n\n2. When integrating with third-party libraries that might apply their own styles:\n\n```svelte\n<script>\n  let brandColor = '#ff3e00'; // Svelte's orange\n</script>\n\n<div class=\"third-party-component\">\n  <span style:color|important={brandColor}>\n    This will maintain your brand color despite third-party styling\n  </span>\n</div>\n```\n\n3. When you need to ensure specific accessibility styles are maintained:\n\n```svelte\n<script>\n  let highContrastMode = true;\n  $: contrastColor = highContrastMode ? 'white' : 'gray';\n  $: contrastBackground = highContrastMode ? 'black' : 'white';\n</script>\n\n<div \n  style:color|important={contrastColor}\n  style:background-color|important={contrastBackground}>\n  This text will maintain high contrast for accessibility\n</div>\n```\n\n4. When creating a theme system that needs to override default styles:\n\n```svelte\n<script>\n  export let theme = 'light';\n  \n  $: backgroundColor = theme === 'dark' ? '#333' : '#fff';\n  $: textColor = theme === 'dark' ? '#fff' : '#333';\n</script>\n\n<div \n  style:background-color|important={backgroundColor}\n  style:color|important={textColor}>\n  This content will respect the theme settings regardless of other styles\n</div>\n<button on:click={() => theme = theme === 'light' ? 'dark' : 'light'}>\n  Toggle Theme\n</button>\n```\n\nWhile the `|important` modifier is powerful, it should be used judiciously, as overuse of `!important` can lead to CSS specificity issues and make styles harder to maintain, just as in regular CSS."}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"What happens when you combine both the standard `style` attribute and `style:` directives on the same element?","answer":"When you combine both the standard HTML `style` attribute and Svelte's `style:` directives on the same element, the `style:` directives take precedence over the properties set in the `style` attribute. This is an important behavior to understand when mixing these two styling approaches.\n\nFor example:\n\n```svelte\n<div style=\"color: blue;\" style:color=\"red\">This will be red</div>\n```\n\nIn this case, even though the `style` attribute sets the color to blue, the `style:color=\"red\"` directive will override it, making the text red.\n\nThis precedence rule applies to each individual property. Properties that don't conflict will coexist:\n\n```svelte\n<div style=\"background-color: yellow; font-size: 18px;\" style:color=\"red\">\n  This will have red text on a yellow background with 18px font size\n</div>\n```\n\nHere's a more complex example demonstrating this behavior:\n\n```svelte\n<script>\n  let isDanger = true;\n  let customColor = 'purple';\n</script>\n\n<div \n  style=\"\n    color: blue; \n    background-color: lightgray; \n    padding: 10px; \n    border: 1px solid black;\n  \"\n  style:color={isDanger ? 'red' : customColor}\n  style:border={isDanger ? '2px solid red' : '1px dashed gray'}>\n  \n  This element combines both styling approaches.\n  The text will be red (not blue) when isDanger is true,\n  and the border will be a 2px solid red line (not 1px solid black).\n  The background-color and padding from the style attribute will remain.\n</div>\n\n<button on:click={() => isDanger = !isDanger}>\n  Toggle Danger State\n</button>\n```\n\nThis behavior can be useful in several scenarios:\n\n1. When you have base styles in the `style` attribute but need to override specific properties dynamically:\n\n```svelte\n<script>\n  let isHighlighted = false;\n</script>\n\n<div \n  style=\"\n    font-size: 16px;\n    padding: 1rem;\n    border-radius: 4px;\n    color: #333;\n    background-color: #f5f5f5;\n  \"\n  style:background-color={isHighlighted ? 'yellow' : undefined}\n  style:color={isHighlighted ? 'black' : undefined}>\n  \n  This element has base styles but can be highlighted\n</div>\n\n<button on:click={() => isHighlighted = !isHighlighted}>\n  Toggle Highlight\n</button>\n```\n\n2. When working with components that might have internal styling but need external overrides:\n\n```svelte\n<!-- BaseCard.svelte -->\n<script>\n  export let content;\n</script>\n\n<div style=\"padding: 1rem; border: 1px solid #ddd; border-radius: 4px;\">\n  {content}\n</div>\n\n<!-- App.svelte -->\n<script>\n  import BaseCard from './BaseCard.svelte';\n  \n  let cardContent = \"This is a card with custom border\";\n  let borderColor = 'blue';\n</script>\n\n<BaseCard \n  content={cardContent} \n  style:border={`1px solid ${borderColor}`} />\n```\n\nUnderstanding this precedence is important for creating predictable styling behavior in your Svelte applications, especially when migrating existing code or working with third-party components."}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"How can you use the `style:` directive with reactive declarations to create dynamic styles?","answer":"The `style:` directive in Svelte works seamlessly with reactive declarations, allowing you to create dynamic styles that automatically update when their dependencies change. This is one of the most powerful aspects of Svelte's styling system.\n\nHere's how you can combine reactive declarations with the `style:` directive:\n\n```svelte\n<script>\n  let count = 0;\n  \n  // Reactive declaration for a style value\n  $: fontSize = `${16 + count * 0.5}px`;\n  \n  // Reactive declaration for a conditional style\n  $: textColor = count > 5 ? 'red' : 'black';\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n\n<button on:click={increment}>Increment ({count})</button>\n\n<p style:font-size={fontSize} style:color={textColor}>\n  This text grows and changes color as you increment the counter\n</p>\n```\n\nIn this example, both the font size and text color will automatically update whenever the `count` value changes.\n\nHere are more advanced examples of using reactive declarations with the `style:` directive:\n\n1. Creating a progress indicator:\n\n```svelte\n<script>\n  let progress = 0;\n  \n  // Reactive style declarations\n  $: progressWidth = `${progress}%`;\n  $: progressColor = progress < 30 ? 'red' : \n                    progress < 70 ? 'orange' : \n                    'green';\n  \n  function updateProgress() {\n    progress = Math.min(100, progress + 10);\n  }\n</script>\n\n<div style=\"width: 100%; background-color: #eee; height: 20px;\">\n  <div \n    style:width={progressWidth} \n    style:background-color={progressColor}\n    style:height=\"100%\"\n    style:transition=\"all 0.3s ease\">\n  </div>\n</div>\n\n<button on:click={updateProgress}>Increase Progress</button>\n<p>Progress: {progress}%</p>\n```\n\n2. Creating a theme system with reactive styles:\n\n```svelte\n<script>\n  let theme = 'light';\n  \n  // Theme configurations\n  const themes = {\n    light: {\n      background: '#ffffff',\n      text: '#333333',\n      accent: '#0066cc'\n    },\n    dark: {\n      background: '#222222',\n      text: '#f5f5f5',\n      accent: '#4da6ff'\n    },\n    sepia: {\n      background: '#f4ecd8',\n      text: '#5b4636',\n      accent: '#a86518'\n    }\n  };\n  \n  // Reactive style declarations\n  $: backgroundColor = themes[theme].background;\n  $: textColor = themes[theme].text;\n  $: accentColor = themes[theme].accent;\n</script>\n\n<div \n  style:background-color={backgroundColor}\n  style:color={textColor}\n  style:padding=\"2rem\"\n  style:min-height=\"100vh\">\n  \n  <h1 style:color={accentColor}>Themed Content</h1>\n  \n  <p>This content adapts to the selected theme.</p>\n  \n  <div style:margin-top=\"1rem\">\n    <button \n      on:click={() => theme = 'light'}\n      style:background-color={theme === 'light' ? accentColor : 'transparent'}\n      style:color={theme === 'light' ? 'white' : textColor}>\n      Light\n    </button>\n    \n    <button \n      on:click={() => theme = 'dark'}\n      style:background-color={theme === 'dark' ? accentColor : 'transparent'}\n      style:color={theme === 'dark' ? 'white' : textColor}>\n      Dark\n    </button>\n    \n    <button \n      on:click={() => theme = 'sepia'}\n      style:background-color={theme === 'sepia' ? accentColor : 'transparent'}\n      style:color={theme === 'sepia' ? 'white' : textColor}>\n      Sepia\n    </button>\n  </div>\n</div>\n```\n\n3. Creating responsive styles based on window size:\n\n```svelte\n<script>\n  let windowWidth;\n  \n  // Reactive breakpoint calculations\n  $: isMobile = windowWidth < 768;\n  $: isTablet = windowWidth >= 768 && windowWidth < 1024;\n  $: isDesktop = windowWidth >= 1024;\n  \n  // Reactive style declarations\n  $: containerWidth = isMobile ? '100%' : \n                     isTablet ? '80%' : \n                     '60%';\n  $: fontSize = isMobile ? '14px' : \n               isTablet ? '16px' : \n               '18px';\n  $: padding = isMobile ? '1rem' : \n              isTablet ? '2rem' : \n              '3rem';\n</script>\n\n<svelte:window bind:innerWidth={windowWidth}/>\n\n<div \n  style:width={containerWidth}\n  style:font-size={fontSize}\n  style:padding={padding}\n  style:margin=\"0 auto\"\n  style:border=\"1px solid #ccc\">\n  \n  <h2>Responsive Container</h2>\n  <p>Current viewport width: {windowWidth}px</p>\n  <p>Device type: {isMobile ? 'Mobile' : isTablet ? 'Tablet' : 'Desktop'}</p>\n</div>\n```\n\nThe combination of reactive declarations and the `style:` directive creates a powerful system for dynamic styling that's both easy to write and efficient to run, as Svelte's reactivity system only updates the DOM when necessary."}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"How does the `style:` directive handle kebab-case CSS properties versus camelCase in JavaScript?","answer":"The `style:` directive in Svelte accommodates both kebab-case (hyphenated) CSS property names and camelCase JavaScript variable names, giving you flexibility in how you write your styles.\n\nWhen using CSS properties that contain hyphens (kebab-case), you have two options:\n\n1. Use the kebab-case directly with quotes:\n```svelte\n<div style:background-color=\"red\">...</div>\n```\n\n2. Use the camelCase equivalent without quotes when using a variable or expression:\n```svelte\n<script>\n  let backgroundColor = 'red';\n</script>\n\n<div style:backgroundColor={backgroundColor}>...</div>\n```\n\nHere's a comprehensive example showing both approaches:\n\n```svelte\n<script>\n  // Using camelCase for JavaScript variables\n  let fontSize = '18px';\n  let lineHeight = 1.5;\n  let backgroundColor = '#f0f0f0';\n  \n  // These variables will be used with kebab-case properties\n  let border = '1px solid black';\n  let radius = '4px';\n</script>\n\n<!-- Using camelCase property names with variables -->\n<div \n  style:fontSize={fontSize}\n  style:lineHeight={lineHeight}\n  style:backgroundColor={backgroundColor}\n  \n  <!-- Using kebab-case property names with string values -->\n  style:border-width=\"1px\"\n  style:border-style=\"solid\"\n  style:border-color=\"black\"\n  \n  <!-- Using kebab-case property names with variables -->\n  style:border-radius={radius}>\n  \n  This element demonstrates both kebab-case and camelCase styles\n</div>\n```\n\nFor the shorthand form, you must match the variable name to the property name format you're using:\n\n```svelte\n<script>\n  // For camelCase shorthand\n  let backgroundColor = 'yellow';\n  \n  // For kebab-case properties, you can't use direct shorthand\n  // but you can create matching variables\n  let 'border-style' = 'dashed';\n</script>\n\n<!-- This works - camelCase variable with camelCase property -->\n<div style:backgroundColor>...</div>\n\n<!-- This won't work as expected - can't use kebab-case in shorthand -->\n<div style:border-style>...</div>\n```\n\nFor CSS properties with vendor prefixes, you can use them directly:\n\n```svelte\n<div \n  style:-webkit-user-select=\"none\"\n  style:-moz-user-select=\"none\"\n  style:-ms-user-select=\"none\"\n  style:user-select=\"none\">\n  This text cannot be selected\n</div>\n```\n\nWhen working with CSS custom properties (variables), you can use them like this:\n\n```svelte\n<script>\n  let primaryColor = 'blue';\n</script>\n\n<div style:--primary-color={primaryColor}>\n  <p style:color=\"var(--primary-color)\">\n    This text uses a custom property\n  </p>\n</div>\n```\n\nFor the most maintainable code, it's generally recommended to:\n\n1. Use kebab-case for direct CSS property references (as they appear in CSS)\n2. Use camelCase for JavaScript variables that represent CSS properties\n3. Be consistent within your codebase\n\nThis flexibility allows you to write code that feels natural in both the JavaScript and CSS contexts, making your Svelte components more intuitive and maintainable."}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"How can you conditionally apply styles using the `style:` directive in Svelte?","answer":"There are several ways to conditionally apply styles using the `style:` directive in Svelte, each with its own use cases and advantages.\n\n### 1. Using Ternary Expressions\n\nThe most straightforward approach is to use a ternary expression to set different values based on a condition:\n\n```svelte\n<script>\n  let isActive = false;\n</script>\n\n<div \n  style:background-color={isActive ? 'lightblue' : 'white'}\n  style:color={isActive ? 'navy' : 'black'}>\n  This element changes style based on isActive\n</div>\n\n<button on:click={() => isActive = !isActive}>\n  Toggle Active State\n</button>\n```\n\n### 2. Using Nullish or Undefined Values\n\nYou can conditionally apply a style by setting it to `undefined` or `null` when you don't want it applied:\n\n```svelte\n<script>\n  let isHighlighted = false;\n</script>\n\n<div \n  style:border={isHighlighted ? '2px solid gold' : undefined}\n  style:background-color={isHighlighted ? 'lightyellow' : null}>\n  This element is only highlighted conditionally\n</div>\n```\n\nWhen the value is `undefined` or `null`, the style property won't be added to the element.\n\n### 3. Using Logical Operators\n\nYou can use logical operators for more complex conditions:\n\n```svelte\n<script>\n  let status = 'normal'; // can be 'normal', 'warning', or 'error'\n</script>\n\n<div \n  style:color={\n    status === 'error' ? 'red' : \n    status === 'warning' ? 'orange' : \n    'green'\n  }\n  style:font-weight={status !== 'normal' && 'bold'}>\n  Status: {status}\n</div>\n\n<button on:click={() => status = 'normal'}>Normal</button>\n<button on:click={() => status = 'warning'}>Warning</button>\n<button on:click={() => status = 'error'}>Error</button>\n```\n\n### 4. Using Reactive Declarations\n\nYou can use reactive declarations to compute style values based on multiple conditions:\n\n```svelte\n<script>\n  let isActive = false;\n  let isDisabled = false;\n  \n  // Reactive style declarations\n  $: backgroundColor = isDisabled ? 'lightgray' : \n                       isActive ? 'lightblue' : \n                       'white';\n  \n  $: textColor = isDisabled ? 'gray' : \n                isActive ? 'navy' : \n                'black';\n  \n  $: cursor = isDisabled ? 'not-allowed' : 'pointer';\n</script>\n\n<div \n  style:background-color={backgroundColor}\n  style:color={textColor}\n  style:cursor={cursor}\n  style:padding=\"1rem\"\n  style:transition=\"all 0.3s ease\">\n  This element has multiple conditional states\n</div>\n\n<label>\n  <input type=\"checkbox\" bind:checked={isActive} disabled={isDisabled}>\n  Active\n</label>\n\n<label>\n  <input type=\"checkbox\" bind:checked={isDisabled}>\n  Disabled\n</label>\n```\n\n### 5. Using Class Toggling with Inline Styles\n\nSometimes it's better to use classes for major style changes and the `style:` directive for fine-tuning:\n\n```svelte\n<script>\n  let isActive = false;\n  let intensity = 50; // 0-100\n  \n  $: opacity = intensity / 100;\n</script>\n\n<style>\n  .box {\n    padding: 1rem;\n    border: 1px solid #ccc;\n    transition: all 0.3s ease;\n  }\n  \n  .active {\n    background-color: lightblue;\n    color: navy;\n  }\n</style>\n\n<div \n  class=\"box\"\n  class:active={isActive}\n  style:opacity={opacity}>\n  This combines classes and style directives\n</div>\n\n<button on:click={() => isActive = !isActive}>\n  Toggle Active\n</button>\n\n<input type=\"range\" bind:value={intensity} min=\"0\" max=\"100\">\nIntensity: {intensity}%\n```\n\n### 6. Conditional Style Objects\n\nFor more complex scenarios, you can create style objects and apply them conditionally:\n\n```svelte\n<script>\n  let theme = 'light';\n  \n  const themes = {\n    light: {\n      backgroundColor: 'white',\n      color: '#333',\n      borderColor: '#ddd'\n    },\n    dark: {\n      backgroundColor: '#333',\n      color: 'white',\n      borderColor: '#666'\n    },\n    colorful: {\n      backgroundColor: '#f0f8ff',\n      color: '#0066cc',\n      borderColor: '#4da6ff'\n    }\n  };\n  \n  // Get the current theme styles\n  $: currentTheme = themes[theme];\n</script>\n\n<div \n  style:background-color={currentTheme.backgroundColor}\n  style:color={currentTheme.color}\n  style:border={`1px solid ${currentTheme.borderColor}`}\n  style:padding=\"2rem\">\n  This content adapts to the selected theme\n</div>\n\n<div style:margin-top=\"1rem\">\n  <button on:click={() => theme = 'light'}>Light Theme</button>\n  <button on:click={() => theme = 'dark'}>Dark Theme</button>\n  <button on:click={() => theme = 'colorful'}>Colorful Theme</button>\n</div>\n```\n\nThese approaches give you a wide range of options for conditionally styling elements in Svelte, from simple toggles to complex state-dependent styling systems."}
{"source":"docs/svelte/03-template-syntax/17-style.md","question":"How can you use the `style:` directive to implement a CSS animation or transition effect in Svelte?","answer":"While Svelte provides dedicated transition directives for animations, you can also implement CSS animations and transitions using the `style:` directive. This approach gives you fine-grained control over animation properties and can be useful when you need to dynamically adjust animation parameters.\n\nHere are several ways to implement animations using the `style:` directive:\n\n### 1. Basic CSS Transition with Dynamic Properties\n\n```svelte\n<script>\n  let expanded = false;\n  \n  // Dynamic transition properties\n  $: height = expanded ? '200px' : '50px';\n  $: backgroundColor = expanded ? '#f0f0f0' : '#ffffff';\n</script>\n\n<div \n  style:height={height}\n  style:background-color={backgroundColor}\n  style:overflow=\"hidden\"\n  style:transition=\"all 0.3s ease-in-out\"\n  style:padding=\"1rem\"\n  style:border=\"1px solid #ccc\"\n  on:click={() => expanded = !expanded}>\n  \n  <h3>Click to {expanded ? 'collapse' : 'expand'}</h3>\n  \n  {#if expanded}\n    <p>This content appears when expanded.</p>\n    <p>The transition is handled by CSS.</p>\n  {/if}\n</div>\n```\n\n### 2. Dynamic Animation Timing and Easing\n\n```svelte\n<script>\n  let animationSpeed = 0.3; // seconds\n  let easingFunction = 'ease-in-out';\n  \n  let position = 0;\n  \n  function moveBox() {\n    position = position === 0 ? 200 : 0;\n  }\n  \n  // Available easing functions\n  const easingOptions = [\n    'linear', \n    'ease', \n    'ease-in', \n    'ease-out', \n    'ease-in-out',\n    'cubic-bezier(0.6, 0.1, 0.3, 1)'\n  ];\n</script>\n\n<div style:margin-bottom=\"1rem\">\n  <label>\n    Animation Speed:\n    <input \n      type=\"range\" \n      min=\"0.1\" \n      max=\"2\" \n      step=\"0.1\" \n      bind:value={animationSpeed}>\n    {animationSpeed}s\n  </label>\n  \n  <label style:margin-left=\"1rem\">\n    Easing Function:\n    <select bind:value={easingFunction}>\n      {#each easingOptions as option}\n        <option value={option}>{option}</option>\n      {/each}\n    </select>\n  </label>\n</div>\n\n<div \n  style:width=\"50px\"\n  style:height=\"50px\"\n  style:background-color=\"coral\"\n  style:position=\"relative\"\n  style:left=\"{position}px\"\n  style:transition=\"{`left ${animationSpeed}s ${easingFunction}`}\">\n</div>\n\n<button on:click={moveBox} style:margin-top=\"1rem\">\n  Move Box\n</button>\n```\n\n### 3. Implementing CSS Animation with Keyframes\n\n```svelte\n<script>\n  let isAnimating = false;\n  let animationDuration = 2;\n  let animationIterations = 1;\n  \n  function startAnimation() {\n    isAnimating = true;\n    // Reset animation after it completes\n    setTimeout(() => {\n      isAnimating = false;\n    }, animationDuration * animationIterations * 1000);\n  }\n</script>\n\n<style>\n  /* Define keyframes animation */\n  @keyframes pulse {\n    0% { transform: scale(1); }\n    50% { transform: scale(1.2); }\n    100% { transform: scale(1); }\n  }\n</style>\n\n<div style:margin-bottom=\"1rem\">\n  <label>\n    Duration: \n    <input \n      type=\"range\" \n      min=\"0.5\" \n      max=\"5\" \n      step=\"0.5\" \n      bind:value={animationDuration}>\n    {animationDuration}s\n  </label>\n  \n  <label style:margin-left=\"1rem\">\n    Iterations:\n    <input \n      type=\"number\" \n      min=\"1\" \n      max=\"10\" \n      bind:value={animationIterations}>\n  </label>\n</div>\n\n<div \n  style:width=\"100px\"\n  style:height=\"100px\"\n  style:background-color=\"purple\"\n  style:border-radius=\"50%\"\n  style:animation={isAnimating ? \n    `pulse ${animationDuration}s ease-in-out ${animationIterations}` : 'none'}>\n</div>\n\n<button \n  on:click={startAnimation} \n  style:margin-top=\"1rem\"\n  disabled={isAnimating}>\n  {isAnimating ? 'Animating...' : 'Start Animation'}\n</button>\n```\n\n### 4. Creating a Progress Bar with Dynamic Animation\n\n```svelte\n<script>\n  let progress = 0;\n  let animationDuration = 0.5;\n  \n  function increaseProgress() {\n    progress = Math.min(100, progress + 10);\n  }\n  \n  function resetProgress() {\n    progress = 0;\n  }\n</script>\n\n<div \n  style:width=\"100%\"\n  style:height=\"20px\"\n  style:background-color=\"#eee\"\n  style:border-radius=\"10px\"\n  style:overflow=\"hidden\"\n  style:margin-bottom=\"1rem\">\n  \n  <div \n    style:width=\"{progress}%\"\n    style:height=\"100%\"\n    style:background-color={\n      progress < 30 ? 'red' :\n      progress < 70 ? 'orange' :\n      'green'\n    }\n    style:transition=\"{`width ${animationDuration}s ease-out, background-color 0.3s`}\">\n  </div>\n</div>\n\n<div>\n  <button on:click={increaseProgress}>Increase Progress</button>\n  <button on:click={resetProgress}>Reset</button>\n</div>\n\n<div style:margin-top=\"1rem\">\n  <label>\n    Animation Speed:\n    <input \n      type=\"range\" \n      min=\"0.1\" \n      max=\"2\" \n      step=\"0.1\" \n      bind:value={animationDuration}>\n    {animationDuration}s\n  </label>\n</div>\n\n<p>Progress: {progress}%</p>\n```\n\n### 5. Implementing a Loading Spinner\n\n```svelte\n<script>\n  let isLoading = false;\n  let spinSpeed = 1; // seconds\n  \n  function toggleLoading() {\n    isLoading = !isLoading;\n  }\n</script>\n\n<style>\n  @keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n</style>\n\n<div style:margin-bottom=\"1rem\">\n  <label>\n    Spin Speed:\n    <input \n      type=\"range\" \n      min=\"0.5\" \n      max=\"3\" \n      step=\"0.1\" \n      bind:value={spinSpeed}>\n    {spinSpeed}s\n  </label>\n</div>\n\n<div \n  style:width=\"50px\"\n  style:height=\"50px\"\n  style:border=\"5px solid #f3f3f3\"\n  style:border-top=\"5px solid #3498db\"\n  style:border-radius=\"50%\"\n  style:animation={isLoading ? `spin ${spinSpeed}s linear infinite` : 'none'}>\n</div>\n\n<button \n  on:click={toggleLoading} \n  style:margin-top=\"1rem\">\n  {isLoading ? 'Stop Loading' : 'Start Loading'}\n</button>\n```\n\n### 6. Creating a Hover Effect Card with Dynamic Properties\n\n```svelte\n<script>\n  let hoverScale = 1.05;\n  let transitionSpeed = 0.3;\n  let shadowIntensity = 10;\n  \n  // Computed shadow\n  $: boxShadow = `0 ${shadowIntensity}px ${shadowIntensity * 2}px rgba(0,0,0,0.1)`;\n</script>\n\n<div style:margin-bottom=\"1rem\">\n  <label>\n    Hover Scale:\n    <input \n      type=\"range\" \n      min=\"1\" \n      max=\"1.2\" \n      step=\"0.01\" \n      bind:value={hoverScale}>\n    {hoverScale.toFixed(2)}\n  </label>\n  \n  <label style:margin-left=\"1rem\">\n    Transition Speed:\n    <input \n      type=\"range\" \n      min=\"0.1\" \n      max=\"1\" \n      step=\"0.1\" \n      bind:value={transitionSpeed}>\n    {transitionSpeed}s\n  </label>\n  \n  <label style:margin-left=\"1rem\">\n    Shadow Intensity:\n    <input \n      type=\"range\" \n      min=\"0\" \n      max=\"20\" \n      step=\"1\" \n      bind:value={shadowIntensity}>\n  </label>\n</div>\n\n<div \n  style:width=\"200px\"\n  style:height=\"200px\"\n  style:background-color=\"#f0f0f0\"\n  style:border-radius=\"8px\"\n  style:display=\"flex\"\n  style:align-items=\"center\"\n  style:justify-content=\"center\"\n  style:transition=\"{`all ${transitionSpeed}s ease-in-out`}\"\n  style:box-shadow=\"0 2px 4px rgba(0,0,0,0.1)\"\n  style:cursor=\"pointer\"\n  style:user-select=\"none\"\n  on:mouseenter={(e) => {\n    e.currentTarget.style.transform = `scale(${hoverScale})`;\n    e.currentTarget.style.boxShadow = boxShadow;\n  }}\n  on:mouseleave={(e) => {\n    e.currentTarget.style.transform = 'scale(1)';\n    e.currentTarget.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';\n  }}>\n  Hover over me\n</div>\n```\n\nThese examples demonstrate how the `style:` directive can be used to create dynamic animations and transitions in Svelte. While Svelte's built-in transition directives offer a more declarative approach for many animation needs, the `style:` directive provides a way to fine-tune animations and create more complex, interactive effects."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"What are the two primary ways to set classes on elements in Svelte 5, and how do they differ?","answer":"In Svelte 5, there are two main approaches to setting classes on elements:\n\n1. **The `class` attribute**: This is the standard HTML attribute approach, but with Svelte's reactivity capabilities.\n   ```svelte\n   <div class={large ? 'large' : 'small'}>Content</div>\n   ```\n\n2. **The `class:` directive**: This is a Svelte-specific directive that allows for more declarative class toggling.\n   ```svelte\n   <div class:large={isLarge} class:small={!isLarge}>Content</div>\n   ```\n\nThe key differences are:\n- The `class` attribute can accept strings, objects, arrays, or expressions that evaluate to these types\n- The `class:` directive is specifically designed for conditional class toggling and can be more readable when you have many conditional classes\n- With the `class:` directive, you can use shorthand notation when the class name matches the variable name: `<div class:active>` instead of `<div class:active={active}>`\n\nSince Svelte 5.16, the `class` attribute has gained more flexibility with object and array support, making the distinction less pronounced than in earlier versions."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"How does Svelte 5.16+ handle object syntax for the class attribute, and what advantages does this offer?","answer":"Since Svelte 5.16, the `class` attribute can accept objects where the keys represent class names and the values determine whether those classes should be applied. This is processed using the [clsx](https://github.com/lukeed/clsx) library under the hood.\n\nHere's how it works:\n```svelte\n<script>\n  let isActive = $state(true);\n  let isDisabled = $state(false);\n</script>\n\n<button class={{ \n  active: isActive, \n  disabled: isDisabled,\n  'text-bold': isActive && !isDisabled \n}}>\n  Submit\n</button>\n```\n\nIf `isActive` is true and `isDisabled` is false, the resulting HTML would be:\n```html\n<button class=\"active text-bold\">Submit</button>\n```\n\nThe advantages of this approach include:\n1. **Cleaner syntax** for multiple conditional classes compared to ternary expressions\n2. **Better readability**, especially when dealing with many classes\n3. **Easier integration with utility-first CSS frameworks** like Tailwind, where you might need to toggle multiple classes based on a single condition\n4. **Reduced boilerplate** compared to multiple `class:` directives\n\nFor example, with Tailwind you can do:\n```svelte\n<div class={{\n  'bg-blue-500 text-white': isPrimary,\n  'bg-gray-200 text-gray-800': !isPrimary,\n  'p-4 rounded shadow': true\n}}>\n  Button content\n</div>\n```\n\nThis approach is particularly powerful when combined with component props, allowing for flexible class composition."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"How does Svelte 5.16+ handle array syntax for the class attribute, and when would you use it over the object syntax?","answer":"Since Svelte 5.16, the `class` attribute can accept arrays, which are processed using the [clsx](https://github.com/lukeed/clsx) library. With array syntax, each truthy value in the array is included in the final class string.\n\nBasic usage:\n```svelte\n<script>\n  let isLarge = $state(true);\n  let isAnimated = $state(true);\n  let baseClasses = 'btn rounded';\n</script>\n\n<button class={[\n  baseClasses,\n  isLarge && 'btn-lg',\n  isAnimated && 'animate-pulse'\n]}>\n  Click me\n</button>\n```\n\nIf both `isLarge` and `isAnimated` are true, this would render:\n```html\n<button class=\"btn rounded btn-lg animate-pulse\">Click me</button>\n```\n\nYou would use array syntax over object syntax in these scenarios:\n\n1. **When working with predefined class strings** - Arrays are great when you have complete class strings rather than individual class names:\n   ```svelte\n   <div class={[\n     'base-styles',\n     variant === 'primary' && 'bg-blue-500 text-white',\n     variant === 'secondary' && 'bg-gray-200 text-gray-800',\n     size === 'large' && 'text-xl p-4'\n   ]}>Content</div>\n   ```\n\n2. **When combining with component props** - Arrays make it easy to merge local classes with those passed via props:\n   ```svelte\n   <!-- Component.svelte -->\n   <script>\n     let props = $props();\n   </script>\n   <div class={['component-default', props.class]}>\n     {@render props.children?.()}\n   </div>\n   ```\n\n3. **When maintaining order matters** - With arrays, you can ensure classes appear in a specific order, which can be important for CSS specificity\n\n4. **When nesting conditions** - Arrays can contain other arrays or objects, allowing for complex conditional logic:\n   ```svelte\n   <div class={[\n     'base',\n     isActive && ['active', { highlighted: isHighlighted }],\n     theme === 'dark' ? 'dark-mode' : 'light-mode'\n   ]}>Content</div>\n   ```\n\nThe array syntax is particularly useful with utility-first CSS frameworks like Tailwind, where you often need to apply multiple classes based on a single condition."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"How can you combine local component classes with classes passed through props in Svelte 5?","answer":"In Svelte 5, you can combine local component classes with classes passed through props using the array or object syntax for the `class` attribute. This is particularly useful for creating reusable components that can be styled by their parent components.\n\nHere's how to implement this pattern:\n\n```svelte\n<!file: Button.svelte>\n<script>\n  // Use $props() to capture all props including the class\n  let props = $props();\n  \n  // Local classes for the button\n  const baseClasses = 'px-4 py-2 rounded';\n  const variantClasses = props.variant === 'primary' \n    ? 'bg-blue-500 text-white' \n    : 'bg-gray-200 text-black';\n</script>\n\n<button \n  {...props} \n  class={[baseClasses, variantClasses, props.class]}\n>\n  {@render props.children?.()}\n</button>\n```\n\nThen in the parent component:\n\n```svelte\n<!file: App.svelte>\n<script>\n  import Button from './Button.svelte';\n  let isHighlighted = $state(false);\n</script>\n\n<Button \n  variant=\"primary\"\n  onclick={() => isHighlighted = !isHighlighted}\n  class={[\n    'transition-all',\n    isHighlighted && 'ring-2 ring-yellow-400'\n  ]}\n>\n  Click me\n</Button>\n```\n\nYou can also use object syntax:\n\n```svelte\n<!file: Button.svelte>\n<script>\n  let props = $props();\n  \n  // Local classes as an object\n  const localClasses = {\n    'px-4 py-2 rounded': true,\n    'bg-blue-500 text-white': props.variant === 'primary',\n    'bg-gray-200 text-black': props.variant !== 'primary'\n  };\n</script>\n\n<button \n  {...props} \n  class={[localClasses, props.class]}\n>\n  {@render props.children?.()}\n</button>\n```\n\nThis approach offers several benefits:\n1. The component can have its own default styling\n2. Consumers of the component can add or override styles as needed\n3. The pattern works with string, object, or array class values from props\n4. It's compatible with utility-first CSS frameworks like Tailwind\n\nThe Svelte compiler will handle merging all these classes efficiently, removing duplicates and falsy values."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"How does Svelte handle falsy values in the class attribute, and what changes are planned for future versions?","answer":"In Svelte's current implementation, the handling of falsy values in the `class` attribute has some nuances that are important to understand:\n\nCurrent behavior:\n- Most falsy values like `false`, `0`, and `NaN` are stringified and included in the class attribute (e.g., `class=\"false\"`)\n- However, `undefined` and `null` values cause the class to be omitted entirely\n\nFor example:\n```svelte\n<script>\n  let value1 = false;\n  let value2 = 0;\n  let value3 = NaN;\n  let value4 = undefined;\n  let value5 = null;\n</script>\n\n<!-- Renders as: <div class=\"false 0 NaN\"></div> -->\n<div class={value1} class={value2} class={value3} class={value4} class={value5}></div>\n```\n\nThis behavior is considered historical and somewhat inconsistent. According to the documentation, Svelte plans to change this in a future version:\n\n> For historical reasons, falsy values (like `false` and `NaN`) are stringified (`class=\"false\"`), though `class={undefined}` (or `null`) cause the attribute to be omitted altogether. In a future version of Svelte, all falsy values will cause `class` to be omitted.\n\nThis means that in a future version of Svelte, all falsy values (`false`, `0`, `''`, `NaN`, `null`, and `undefined`) will be treated the same way - they will cause the class to be omitted entirely rather than being stringified.\n\nThis planned change will make the behavior more consistent and intuitive. It will align better with how conditional classes are typically used in practice, where falsy values generally indicate that a class should not be applied.\n\nTo future-proof your code, it's best to avoid relying on the current stringification behavior and instead use explicit conditional logic:\n\n```svelte\n<!-- Instead of this -->\n<div class={condition ? 'active' : false}>...</div>\n\n<!-- Do this -->\n<div class={condition ? 'active' : ''}>...</div>\n\n<!-- Or better yet, use object/array syntax -->\n<div class={{ active: condition }}>...</div>\n<div class={[condition && 'active']}>...</div>\n```\n\nWhen using the object or array syntax introduced in Svelte 5.16, falsy values are already handled correctly (they're omitted), so this is the recommended approach going forward."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"How can you use the `class:` directive in Svelte, and in what scenarios might you prefer it over the object syntax for the class attribute?","answer":"The `class:` directive in Svelte provides a declarative way to toggle classes based on boolean conditions. It follows this syntax pattern: `class:name={condition}` where `name` is the class to apply and `condition` is a boolean expression that determines whether the class is applied.\n\nBasic usage:\n```svelte\n<script>\n  let isActive = $state(true);\n  let isDisabled = $state(false);\n</script>\n\n<button \n  class:active={isActive} \n  class:disabled={isDisabled}\n>\n  Toggle\n</button>\n```\n\nIf `isActive` is true and `isDisabled` is false, this renders:\n```html\n<button class=\"active\">Toggle</button>\n```\n\nThe `class:` directive also supports a shorthand syntax when the variable name matches the class name:\n\n```svelte\n<script>\n  let active = $state(true);\n  let disabled = $state(false);\n</script>\n\n<button class:active class:disabled>\n  Toggle\n</button>\n```\n\nYou might prefer the `class:` directive over object syntax in these scenarios:\n\n1. **When working with individual boolean flags** - If you have several independent boolean flags that directly map to class names, the directive can be more readable:\n   ```svelte\n   <!-- Using class: directive -->\n   <div class:active class:highlighted class:selected class:editing>...</div>\n   \n   <!-- Compared to object syntax -->\n   <div class={{ active, highlighted, selected, editing }}>...</div>\n   ```\n\n2. **For better IDE support** - Some IDEs provide better syntax highlighting and autocomplete for the `class:` directive than for dynamic object properties.\n\n3. **For compatibility with older Svelte code** - If you're maintaining code written before Svelte 5.16, the `class:` directive will be more prevalent.\n\n4. **When you prefer more explicit code** - Some developers find the directive syntax more explicit and self-documenting.\n\nHowever, with Svelte 5.16+, the object syntax offers several advantages:\n\n1. It handles multiple classes controlled by a single condition more elegantly:\n   ```svelte\n   <!-- Object syntax -->\n   <div class={{ 'text-bold bg-primary': isPrimary }}>...</div>\n   \n   <!-- Compared to multiple directives -->\n   <div class:text-bold={isPrimary} class:bg-primary={isPrimary}>...</div>\n   ```\n\n2. It's more concise when working with utility-based CSS frameworks like Tailwind.\n\n3. It offers more flexibility with complex expressions and can be combined with arrays for more advanced use cases.\n\nIn practice, many Svelte developers now use a combination of both approaches, with the `class:` directive for simple boolean toggles and object/array syntax for more complex scenarios."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"How can you type-check class values in Svelte components with TypeScript?","answer":"Svelte 5 provides a `ClassValue` type from the 'svelte/elements' module that can be used to type-check class values in TypeScript. This type represents all the possible values that the `class` attribute on elements can accept: strings, objects, arrays, or combinations of these.\n\nHere's how to use the `ClassValue` type for component props:\n\n```svelte\n<script lang=\"ts\">\n  import type { ClassValue } from 'svelte/elements';\n  \n  // Define props with TypeScript typing\n  interface Props {\n    class?: ClassValue;\n    variant?: 'primary' | 'secondary';\n  }\n  \n  const props = $props<Props>();\n  \n  // We can safely use props.class with any class composition method\n  const buttonClass = [\n    'base-button',\n    props.variant === 'primary' ? 'bg-blue-500' : 'bg-gray-300',\n    props.class\n  ];\n</script>\n\n<button class={buttonClass}>\n  <slot />\n</button>\n```\n\nThe `ClassValue` type is a union type that includes:\n- Strings (e.g., `\"btn primary\"`)\n- Objects with boolean values (e.g., `{ active: true, disabled: false }`)\n- Arrays of strings, objects, or nested arrays (e.g., `['btn', { primary: true }]`)\n- `undefined` and `null`\n\nThis type helps catch errors during development, such as:\n- Passing incompatible values to the class attribute\n- Forgetting to handle possible undefined values\n- Ensuring type safety when combining classes\n\nHere's a more complete example showing how to create a type-safe reusable component:\n\n```svelte\n<!file: Button.svelte>\n<script lang=\"ts\">\n  import type { ClassValue } from 'svelte/elements';\n  \n  type ButtonVariant = 'primary' | 'secondary' | 'danger';\n  type ButtonSize = 'sm' | 'md' | 'lg';\n  \n  interface ButtonProps {\n    class?: ClassValue;\n    variant?: ButtonVariant;\n    size?: ButtonSize;\n    disabled?: boolean;\n    type?: 'button' | 'submit' | 'reset';\n  }\n  \n  const props = $props<ButtonProps>({\n    variant: 'primary',\n    size: 'md',\n    disabled: false,\n    type: 'button'\n  });\n  \n  // Map variants to appropriate classes\n  const variantClasses = {\n    primary: 'bg-blue-500 text-white hover:bg-blue-600',\n    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300',\n    danger: 'bg-red-500 text-white hover:bg-red-600'\n  };\n  \n  // Map sizes to appropriate classes\n  const sizeClasses = {\n    sm: 'text-sm px-2 py-1',\n    md: 'text-base px-4 py-2',\n    lg: 'text-lg px-6 py-3'\n  };\n  \n  // Combine all classes\n  const buttonClass = [\n    'rounded transition-colors focus:outline-none focus:ring-2',\n    variantClasses[props.variant],\n    sizeClasses[props.size],\n    props.disabled && 'opacity-50 cursor-not-allowed',\n    props.class\n  ];\n</script>\n\n<button\n  type={props.type}\n  disabled={props.disabled}\n  class={buttonClass}\n  on:click\n>\n  <slot />\n</button>\n```\n\nUsing the component:\n\n```svelte\n<!file: App.svelte>\n<script lang=\"ts\">\n  import Button from './Button.svelte';\n  \n  // This will be type-checked\n  const buttonClass: ClassValue = {\n    'w-full': true,\n    'mt-4': true\n  };\n</script>\n\n<Button variant=\"primary\" class={buttonClass}>\n  Submit\n</Button>\n\n<!-- TypeScript would error on this: -->\n<Button variant=\"invalid\" class={123} />\n```\n\nUsing the `ClassValue` type ensures that your components are more robust and helps prevent runtime errors related to invalid class values."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"How can you combine Tailwind CSS with Svelte 5's class handling features for efficient component styling?","answer":"Svelte 5's enhanced class handling features (particularly the object and array syntax added in 5.16) work exceptionally well with Tailwind CSS. Here's a comprehensive guide on combining these technologies effectively:\n\n### Basic Conditional Tailwind Classes\n\nUsing object syntax for conditional Tailwind classes:\n```svelte\n<script>\n  let isActive = $state(false);\n</script>\n\n<button \n  class={{\n    'bg-blue-500 hover:bg-blue-700 text-white': isActive,\n    'bg-gray-300 hover:bg-gray-400 text-gray-800': !isActive,\n    'font-bold py-2 px-4 rounded transition-colors': true // Always applied\n  }}\n  on:click={() => isActive = !isActive}\n>\n  {isActive ? 'Active' : 'Inactive'}\n</button>\n```\n\nUsing array syntax for the same effect:\n```svelte\n<button \n  class={[\n    'font-bold py-2 px-4 rounded transition-colors',\n    isActive \n      ? 'bg-blue-500 hover:bg-blue-700 text-white' \n      : 'bg-gray-300 hover:bg-gray-400 text-gray-800'\n  ]}\n  on:click={() => isActive = !isActive}\n>\n  {isActive ? 'Active' : 'Inactive'}\n</button>\n```\n\n### Creating Tailwind-Styled Components\n\nBuilding a reusable button component:\n\n```svelte\n<!file: TwButton.svelte>\n<script>\n  // Define props with defaults\n  let props = $props({\n    variant: 'primary',\n    size: 'md',\n    fullWidth: false\n  });\n  \n  // Variant classes\n  const variants = {\n    primary: 'bg-blue-500 hover:bg-blue-700 text-white',\n    secondary: 'bg-gray-300 hover:bg-gray-400 text-gray-800',\n    danger: 'bg-red-500 hover:bg-red-600 text-white',\n    success: 'bg-green-500 hover:bg-green-600 text-white'\n  };\n  \n  // Size classes\n  const sizes = {\n    sm: 'py-1 px-2 text-sm',\n    md: 'py-2 px-4 text-base',\n    lg: 'py-3 px-6 text-lg'\n  };\n  \n  // Combine all classes\n  const buttonClasses = [\n    // Base styles\n    'font-bold rounded transition-colors focus:outline-none focus:ring-2',\n    // Variant styles\n    variants[props.variant],\n    // Size styles\n    sizes[props.size],\n    // Width styles\n    props.fullWidth && 'w-full',\n    // Pass through additional classes from parent\n    props.class\n  ];\n</script>\n\n<button\n  class={buttonClasses}\n  on:click\n  {...props}\n>\n  {@render props.children?.()}\n</button>\n```\n\nUsing the button component:\n\n```svelte\n<!file: App.svelte>\n<script>\n  import TwButton from './TwButton.svelte';\n  let count = $state(0);\n</script>\n\n<div class=\"p-6 space-y-4\">\n  <TwButton \n    variant=\"primary\" \n    on:click={() => count++}\n    class=\"shadow-lg\" // Additional classes\n  >\n    Increment: {count}\n  </TwButton>\n  \n  <TwButton \n    variant=\"danger\" \n    size=\"sm\"\n    on:click={() => count = 0}\n  >\n    Reset\n  </TwButton>\n  \n  <TwButton \n    variant=\"success\" \n    size=\"lg\" \n    fullWidth={true}\n    class={{ 'animate-pulse': count > 10 }}\n  >\n    {count > 10 ? 'High count!' : 'Keep clicking'}\n  </TwButton>\n</div>\n```\n\n### Responsive and State-Based Tailwind Classes\n\nHandling responsive design and different states:\n\n```svelte\n<script>\n  let isHovered = $state(false);\n  let isFocused = $state(false);\n  let screenSize = $state('default'); // 'sm', 'md', 'lg', etc.\n  \n  // Function to update screen size\n  function updateScreenSize() {\n    if (window.innerWidth < 640) screenSize = 'default';\n    else if (window.innerWidth < 768) screenSize = 'sm';\n    else if (window.innerWidth < 1024) screenSize = 'md';\n    else screenSize = 'lg';\n  }\n  \n  // Update on mount and resize\n  $effect(() => {\n    updateScreenSize();\n    window.addEventListener('resize', updateScreenSize);\n    return () => window.removeEventListener('resize', updateScreenSize);\n  });\n</script>\n\n<div\n  class={[\n    // Base classes\n    'p-4 border rounded transition-all duration-300',\n    \n    // Responsive classes\n    {\n      'text-sm': screenSize === 'default',\n      'text-base': screenSize === 'sm',\n      'text-lg': screenSize === 'md',\n      'text-xl': screenSize === 'lg',\n    },\n    \n    // State-based classes\n    isHovered && 'shadow-lg scale-105',\n    isFocused && 'ring-2 ring-blue-500',\n    \n    // Tailwind's responsive classes still work normally\n    'md:flex md:items-center lg:justify-between'\n  ]}\n  on:mouseenter={() => isHovered = true}\n  on:mouseleave={() => isHovered = false}\n  on:focus={() => isFocused = true}\n  on:blur={() => isFocused = false}\n>\n  Dynamic Tailwind styling with Svelte 5\n</div>\n```\n\n### Dark Mode Toggle with Tailwind\n\n```svelte\n<script>\n  let darkMode = $state(false);\n  \n  // Apply dark mode to document\n  $effect(() => {\n    if (darkMode) {\n      document.documentElement.classList.add('dark');\n    } else {\n      document.documentElement.classList.remove('dark');\n    }\n  });\n</script>\n\n<div class=\"p-8 transition-colors duration-300 dark:bg-gray-800 min-h-screen\">\n  <button\n    class={[\n      'px-4 py-2 rounded-full transition-colors',\n      {\n        'bg-gray-800 text-white': !darkMode,\n        'bg-yellow-400 text-gray-900': darkMode\n      }\n    ]}\n    on:click={() => darkMode = !darkMode}\n  >\n    {darkMode ? 'âï¸ Light Mode' : 'ð Dark Mode'}\n  </button>\n  \n  <div class=\"mt-8 p-6 rounded border dark:border-gray-700 transition-colors\">\n    <h1 class=\"text-2xl font-bold dark:text-white\">\n      Tailwind Dark Mode with Svelte 5\n    </h1>\n    <p class=\"mt-2 dark:text-gray-300\">\n      This text will adapt to dark mode automatically.\n    </p>\n  </div>\n</div>\n```\n\nThese examples demonstrate how Svelte 5's class handling features and Tailwind CSS can be combined to create flexible, maintainable, and responsive UI components. The object and array syntax for classes makes it much easier to work with Tailwind's utility classes in a conditional way, while still keeping your code readable and maintainable."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"What are the limitations or edge cases to be aware of when using Svelte 5's class handling features?","answer":"While Svelte 5's class handling features are powerful, there are several limitations, edge cases, and gotchas that developers should be aware of:\n\n### 1. Falsy Value Handling\n\nAs mentioned in the documentation, the current handling of falsy values is inconsistent:\n\n```svelte\n<!-- Currently renders as class=\"false\" -->\n<div class={false}>...</div>\n\n<!-- Currently omits the class attribute entirely -->\n<div class={undefined}>...</div>\n<div class={null}>...</div>\n```\n\nThis behavior is planned to change in a future version of Svelte, where all falsy values will cause the class to be omitted. To future-proof your code, avoid relying on the current stringification behavior.\n\n### 2. Class Name Conflicts\n\nWhen using both the `class` attribute and `class:` directives on the same element, conflicts can occur:\n\n```svelte\n<script>\n  let active = $state(true);\n</script>\n\n<!-- If the string \"active\" appears in someClasses, it could be duplicated -->\n<div class={someClasses} class:active>...</div>\n```\n\nThe compiled output might contain duplicate class names, which isn't harmful but isn't optimal either.\n\n### 3. Dynamic Class Names with `class:` Directive\n\nThe `class:` directive only works with static (known at compile time) class names. You cannot use dynamic class names with this directive:\n\n```svelte\n<script>\n  let status = $state('error');\n  let isActive = $state(true);\n</script>\n\n<!-- This won't work - class name must be a literal -->\n<div class:{status}={isActive}>...</div>\n```\n\nFor dynamic class names, you must use the attribute syntax with objects:\n\n```svelte\n<div class={{ [status]: isActive }}>...</div>\n```\n\n### 4. TypeScript Integration Challenges\n\nWhen using TypeScript with dynamically generated class names, you might encounter type checking issues:\n\n```svelte\n<script lang=\"ts\">\n  import type { ClassValue } from 'svelte/elements';\n  \n  const props = $props<{ class?: ClassValue }>();\n  \n  // This might cause TypeScript errors with strict checking\n  const dynamicClasses = {};\n  for (const [key, value] of Object.entries(someConditions)) {\n    dynamicClasses[`prefix-${key}`] = value;\n  }\n</script>\n\n<div class={[dynamicClasses, props.class]}>...</div>\n```\n\nYou may need to use type assertions in such cases.\n\n### 5. Server-Side Rendering Considerations\n\nWhen using class expressions that depend on browser-specific APIs, you need to ensure they don't cause errors during server-side rendering:\n\n```svelte\n<script>\n  // This could cause SSR errors\n  const isMobile = window.innerWidth < 768;\n</script>\n\n<div class={{ 'mobile-layout': isMobile }}>...</div>\n```\n\nInstead, use lifecycle functions or browser checks:\n\n```svelte\n<script>\n  let isMobile = $state(false);\n  \n  $effect(() => {\n    if (typeof window !== 'undefined') {\n      isMobile = window.innerWidth < 768;\n      window.addEventListener('resize', () => {\n        isMobile = window.innerWidth < 768;\n      });\n    }\n  });\n</script>\n```\n\n### 6. Performance with Very Large Class Objects/Arrays\n\nWhile Svelte is generally efficient, extremely large or deeply nested class objects/arrays could impact performance:\n\n```svelte\n<script>\n  // Creating very large class objects dynamically\n  let complexClasses = {};\n  for (let i = 0; i < 1000; i++) {\n    complexClasses[`class-${i}`] = i % 2 === 0;\n  }\n</script>\n\n<div class={complexClasses}>...</div>\n```\n\nFor better performance with complex class logic, consider memoizing the class object/array or breaking it into smaller components.\n\n### 7. CSS Framework Integration Quirks\n\nSome CSS frameworks might have class names that contain special characters or spaces, which can be tricky to use with object syntax:\n\n```svelte\n<div class={{\n  'p-2 m-2': true,\n  // This won't work as expected\n  'hover:bg-blue-500': isHoverable,\n  // Neither will this\n  'sm:flex md:block': isResponsive\n}}>...</div>\n```\n\nFor these cases, use array syntax or string concatenation:\n\n```svelte\n<div class={[\n  'p-2 m-2',\n  isHoverable && 'hover:bg-blue-500',\n  isResponsive && 'sm:flex md:block'\n]}>...</div>\n```\n\n### 8. Mixing Syntaxes Can Reduce Readability\n\nWhile you can mix different class syntaxes, it can reduce code readability:\n\n```svelte\n<div \n  class={baseClasses} \n  class:active={isActive} \n  class:selected \n  class={[conditionalClasses]}\n>...</div>\n```\n\nFor maintainability, try to stick to one approach consistently within a component.\n\n### 9. Order of Class Application\n\nWhen combining multiple sources of classes, be aware that the order of class application can matter for CSS specificity:\n\n```svelte\n<!-- props.class comes after component classes -->\n<div class={['component-class', props.class]}>...</div>\n\n<!-- vs. props.class comes before component classes -->\n<div class={[props.class, 'component-class']}>...</div>\n```\n\nThe order can affect which styles win in case of conflicts, so be consistent with your approach.\n\n### 10. Reactivity Limitations\n\nClass bindings only react to changes in the referenced values, not to deep changes within objects or arrays:\n\n```svelte\n<script>\n  let classObj = $state({ active: true });\n  \n  function toggleDeep() {\n    // This change won't trigger a class update\n    classObj.active = !classObj.active;\n  }\n  \n  function toggleProperly() {\n    // Create a new object to ensure reactivity\n    classObj = { ...classObj, active: !classObj.active };\n  }\n</script>\n\n<div class={classObj}>...</div>\n```\n\nWith Svelte 5's `$state()`, this is less of an issue, but it's still important to understand how reactivity works with objects and arrays.\n\nBeing aware of these limitations and edge cases will help you use Svelte 5's class handling features more effectively and avoid potential bugs in your applications."}
{"source":"docs/svelte/03-template-syntax/18-class.md","question":"How has Svelte's approach to handling classes evolved from earlier versions to Svelte 5.16+, and what are the best practices for modern Svelte applications?","answer":"Svelte's approach to handling CSS classes has evolved significantly from its earlier versions to the current Svelte 5.16+. Understanding this evolution helps developers make informed decisions about which patterns to use in modern applications.\n\n### Evolution of Class Handling in Svelte\n\n#### Early Svelte (pre-3.0)\n- Limited class binding capabilities\n- Basic conditional class toggling\n- No specialized syntax for class manipulation\n\n#### Svelte 3.0\n- Introduction of the `class:` directive for boolean class toggling\n- String-based class attribute with ternary expressions\n- Shorthand syntax for `class:` directive when variable name matches class name\n\n#### Svelte 4.0\n- Refinements to existing patterns\n- Better TypeScript support\n- No major changes to class handling\n\n#### Svelte 5.0 - 5.15\n- Rethinking reactivity with the introduction of `$state()` and `$props()`\n- Improved performance for class binding\n- Better integration with TypeScript\n\n#### Svelte 5.16+\n- Introduction of object and array syntax for the `class` attribute\n- Integration with [clsx](https://github.com/lukeed/clsx) for class name processing\n- `ClassValue` type exported from 'svelte/elements' for TypeScript\n- Plan to standardize falsy value handling in the future\n\n### Best Practices for Modern Svelte Applications\n\nBased on this evolution, here are the recommended best practices for handling classes in modern Svelte applications:\n\n#### 1. Prefer Object and Array Syntax for Complex Conditions\n\n```svelte\n<!-- Instead of multiple ternary expressions or class: directives -->\n<div \n  class={[\n    'base-class',\n    isActive && 'active',\n    {\n      'highlighted': isHighlighted,\n      'selected disabled': isSelected && isDisabled\n    }\n  ]}\n>...</div>\n```\n\nThis approach is more readable and maintainable, especially with multiple conditions.\n\n#### 2. Use the Appropriate Syntax for Your Use Case\n\n- **For simple boolean toggles**: The `class:` directive is still valid and readable\n  ```svelte\n  <div class:active class:disabled>...</div>\n  ```\n\n- **For utility-first CSS (like Tailwind)**: Object or array syntax works better\n  ```svelte\n  <div class={{\n    'bg-blue-500 text-white': isPrimary,\n    'p-4 rounded': true\n  }}>...</div>\n  ```\n\n- **For component composition**: Array syntax is ideal for combining with props\n  ```svelte\n  <div class={['component-class', props.class]}>...</div>\n  ```\n\n#### 3. Create Consistent Component Patterns\n\nFor reusable components, establish a consistent pattern for class handling:\n\n```svelte\n<!file: Component.svelte>\n<script>\n  import type { ClassValue } from 'svelte/elements';\n  \n  interface Props {\n    class?: ClassValue;\n    variant?: 'default' | 'primary' | 'secondary';\n  }\n  \n  const props = $props<Props>({\n    variant: 'default'\n  });\n  \n  const baseClass = 'component-base';\n  const variantClass = {\n    'default': 'bg-gray-100',\n    'primary': 'bg-blue-500 text-white',\n    'secondary': 'bg-gray-300'\n  }[props.variant];\n</script>\n\n<div class={[baseClass, variantClass, props.class]}>\n  <slot />\n</div>\n```\n\n#### 4. Use TypeScript for Better Type Safety\n\n```svelte\n<script lang=\"ts\">\n  import type { ClassValue } from 'svelte/elements';\n  \n  function createClasses(condition: boolean): ClassValue {\n    return {\n      'active': condition,\n      'inactive': !condition\n    };\n  }\n  \n  let isActive = $state(true);\n</script>\n\n<div class={createClasses(isActive)}>...</div>\n```\n\n#### 5. Be Consistent with Class Order for Specificity\n\nWhen combining local classes with prop classes, decide on a consistent order to control CSS specificity:\n\n```svelte\n<!-- Props override component styles (recommended for component libraries) -->\n<div class={[componentClasses, props.class]}>...</div>\n\n<!-- Component styles override props (for more controlled components) -->\n<div class={[props.class, componentClasses]}>...</div>\n```\n\n#### 6. Avoid Relying on Current Falsy Value Behavior\n\nSince the handling of falsy values is planned to change, use explicit patterns:\n\n```svelte\n<!-- Instead of -->\n<div class={condition ? 'active' : false}>...</div>\n\n<!-- Use -->\n<div class={condition ? 'active' : ''}>...</div>\n<!-- Or better -->\n<div class={[condition && 'active']}>...</div>\n```\n\n#### 7. Use Memoization for Complex Class Logic\n\nFor complex class calculations, consider memoizing to improve performance:\n\n```svelte\n<script>\n  let theme = $state('light');\n  let size = $state('medium');\n  let isActive = $state(false);\n  \n  // Memoize complex class calculations\n  $derived classes = [\n    'base-component',\n    `theme-${theme}`,\n    `size-${size}`,\n    isActive && 'active'\n  ];\n</script>\n\n<div class={classes}>...</div>\n```\n\n#### 8. Handle Dynamic Class Names with Object Computed Properties\n\nFor dynamic class names, use computed property syntax:\n\n```svelte\n<script>\n  let status = $state('error');\n  let isVisible = $state(true);\n</script>\n\n<div class={{ [`status-${status}`]: isVisible }}>...</div>\n```\n\n#### 9. Combine with CSS Custom Properties for Theming\n\n```svelte\n<script>\n  let theme = $state('blue');\n  \n  $derived themeVars = {\n    '--primary-color': theme === 'blue' ? '#3b82f6' : '#10b981',\n    '--text-color': theme === 'blue' ? '#1e3a8a' : '#064e3b'\n  };\n</script>\n\n<div \n  style={themeVars} \n  class={[\n    'themed-component',\n    `theme-${theme}`\n  ]}\n>...</div>\n```\n\n#### 10. Document Your Approach for Team Consistency\n\nFor team projects, document your class handling patterns to ensure consistency:\n\n```svelte\n<!--\n  Component: Button\n  Class handling:\n  1. Base classes are always applied\n  2. Variant classes are determined by props.variant\n  3. Size classes are determined by props.size\n  4. props.class is applied last to allow overrides\n-->\n<button \n  class={[\n    baseClasses,\n    variantClasses[props.variant],\n    sizeClasses[props.size],\n    props.disabled && 'opacity-50 cursor-not-allowed',\n    props.class\n  ]}\n  disabled={props.disabled}\n>\n  <slot />\n</button>\n```\n\nBy following these best practices, you can take full advantage of Svelte 5.16+'s improved class handling capabilities while writing maintainable, type-safe, and performant code. The evolution of Svelte's class handling reflects a trend toward more flexible, declarative patterns that align well with modern CSS approaches like utility-first frameworks."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"How does Svelte 5 handle basic data fetching, and what's the simplest approach according to the documentation?","answer":"According to the Svelte 5 documentation, Svelte is intentionally unopinionated about how you fetch data. The simplest approach is to use the built-in `fetch` method directly in your components. This can be implemented as follows:\n\n```svelte\n<script>\n\tlet response = $state();\n\tfetch('/api/data').then(async (r) => (response = r.json()));\n</script>\n```\n\nIn this example, we create a reactive state variable `response` using the `$state()` syntax introduced in Svelte 5. We then use the standard browser `fetch` API to make a request to '/api/data'. When the promise resolves, we convert the response to JSON and assign it to our state variable. This will trigger reactivity, causing any part of the UI that depends on `response` to update.\n\nWhile this approach works, the documentation notes that it makes working with promises \"somewhat unergonomic\" due to the need for explicit promise handling."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"What feature does Svelte provide to make working with promises and asynchronous data more ergonomic?","answer":"Svelte provides the `#await` block to make working with promises and asynchronous data more ergonomic. The `#await` block allows you to handle different states of a promise (pending, fulfilled, or rejected) directly in your template markup, without having to manage those states manually in your component logic.\n\nWhile the documentation snippet doesn't provide the full syntax for the `#await` block, the standard usage is:\n\n```svelte\n<script>\n\tlet dataPromise = fetch('/api/data').then(r => r.json());\n</script>\n\n{#await dataPromise}\n\t<p>Loading...</p>\n{:then data}\n\t<p>The data is {JSON.stringify(data)}</p>\n{:catch error}\n\t<p>Error: {error.message}</p>\n{/await}\n```\n\nThis declarative approach to handling async data is more readable and maintainable than managing promise states manually. The `#await` block automatically handles the three possible states of a promise:\n1. Pending - showing a loading state\n2. Fulfilled - displaying the resolved data\n3. Rejected - showing an error message\n\nThis pattern reduces boilerplate code and aligns with Svelte's philosophy of declarative UI programming."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"What are the potential issues with fetching data directly inside components, according to the Svelte documentation?","answer":"According to the Svelte documentation, while fetching data directly inside components works for simple use cases, it comes with two significant drawbacks:\n\n1. **Data loading waterfalls**: When components fetch their own data, it can lead to a \"waterfall\" of network requests. This happens because a parent component must first render before its children can render and make their own requests. This sequential loading pattern can significantly impact performance, as each request must wait for the previous one to complete before starting.\n\n2. **Code complexity**: Handling promises directly in components can make the code harder to work with. This includes managing loading states, error handling, and ensuring that the UI correctly reflects the current state of the data fetching process.\n\nThese issues become more pronounced in larger applications with complex data requirements and deeper component hierarchies. The documentation suggests that for more complex scenarios, a more structured approach to data fetching may be beneficial."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"What solution does Svelte recommend for more complex data fetching scenarios, especially to avoid data loading waterfalls?","answer":"For more complex data fetching scenarios, particularly to avoid data loading waterfalls, Svelte recommends using SvelteKit's loader system. The documentation states:\n\n\"SvelteKit solves this problem by providing an opinionated data loading story that is coupled to its router.\"\n\nSvelteKit loaders allow you to:\n- Fetch data at the route level before components render\n- Parallelize data fetching requests\n- Handle loading and error states consistently\n- Make data available to all components within a route\n\nBy moving data fetching logic to route loaders, SvelteKit can optimize the loading process, preventing the sequential \"waterfall\" of requests that can occur when components fetch their own data. This approach also separates data fetching concerns from presentation logic, making components cleaner and more focused on rendering UI.\n\nThe documentation points readers to learn more about this approach in the SvelteKit documentation section, indicating that for production applications with complex data requirements, SvelteKit's structured approach is recommended over ad-hoc fetching within components."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"How would you implement a data fetching solution in Svelte 5 that shows different UI states for loading, success, and error conditions?","answer":"In Svelte 5, you can implement a complete data fetching solution that handles loading, success, and error states using the `#await` block. Here's a comprehensive example:\n\n```svelte\n<script>\n\t// Define the fetch function that returns a promise\n\tfunction fetchUserData(userId) {\n\t\treturn fetch(`/api/users/${userId}`)\n\t\t\t.then(response => {\n\t\t\t\tif (!response.ok) {\n\t\t\t\t\tthrow new Error(`HTTP error! Status: ${response.status}`);\n\t\t\t\t}\n\t\t\t\treturn response.json();\n\t\t\t});\n\t}\n\t\n\t// Create a reactive state variable for the user ID\n\tlet userId = $state(1);\n\t\n\t// Create a derived promise that changes when userId changes\n\t$derived.promise(userDataPromise = fetchUserData(userId));\n\t\n\t// Function to load the next user\n\tfunction loadNextUser() {\n\t\tuserId += 1;\n\t}\n</script>\n\n<div>\n\t<h1>User Details</h1>\n\t\n\t{#await userDataPromise}\n\t\t<div class=\"loading\">\n\t\t\t<p>Loading user data...</p>\n\t\t\t<div class=\"spinner\"></div>\n\t\t</div>\n\t{:then userData}\n\t\t<div class=\"user-card\">\n\t\t\t<h2>{userData.name}</h2>\n\t\t\t<p>Email: {userData.email}</p>\n\t\t\t<p>Role: {userData.role}</p>\n\t\t\t<button on:click={loadNextUser}>Load Next User</button>\n\t\t</div>\n\t{:catch error}\n\t\t<div class=\"error-message\">\n\t\t\t<p>Failed to load user data</p>\n\t\t\t<p class=\"error-details\">{error.message}</p>\n\t\t\t<button on:click={() => userDataPromise = fetchUserData(userId)}>\n\t\t\t\tRetry\n\t\t\t</button>\n\t\t</div>\n\t{/await}\n</div>\n\n<style>\n\t.loading, .error-message, .user-card {\n\t\tpadding: 1rem;\n\t\tborder-radius: 4px;\n\t\tmargin: 1rem 0;\n\t}\n\t\n\t.loading {\n\t\tbackground-color: #f0f0f0;\n\t}\n\t\n\t.error-message {\n\t\tbackground-color: #ffebee;\n\t\tcolor: #c62828;\n\t}\n\t\n\t.user-card {\n\t\tbackground-color: #e8f5e9;\n\t}\n\t\n\t.spinner {\n\t\t/* Spinner styling would go here */\n\t\twidth: 30px;\n\t\theight: 30px;\n\t\tborder: 3px solid #ddd;\n\t\tborder-top-color: #333;\n\t\tborder-radius: 50%;\n\t\tanimation: spin 1s linear infinite;\n\t}\n\t\n\t@keyframes spin {\n\t\tto { transform: rotate(360deg); }\n\t}\n</style>\n```\n\nThis implementation:\n1. Creates a function `fetchUserData` that handles the actual API request and error checking\n2. Uses Svelte 5's `$state` for the userId and `$derived.promise` for the data fetching promise\n3. Uses the `#await` block to declaratively handle all three states of the promise:\n   - Loading state with a spinner\n   - Success state showing the user data\n   - Error state with a retry button\n4. Includes a button to load the next user, demonstrating how to trigger new data fetches\n5. Adds styling to visually distinguish between the different states\n\nThis approach provides a complete, reactive data fetching solution that automatically updates the UI based on the current state of the data loading process."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"How does Svelte 5's approach to data fetching differ from other frameworks like React or Angular?","answer":"Svelte 5's approach to data fetching differs from other frameworks like React and Angular in several key ways:\n\n1. **Unopinionated Core Framework**: Unlike some frameworks that come with built-in data fetching solutions, Svelte's core is intentionally unopinionated about data fetching. As the documentation states, \"Svelte is unopinionated with how you fetch your data.\" This gives developers the freedom to use whatever approach best fits their needs.\n\n2. **Declarative Promise Handling**: Svelte's `#await` block provides a uniquely declarative way to handle promises directly in the template. Compare this to React, which requires using hooks like `useState` and `useEffect` along with conditional rendering to achieve the same result:\n\n   **Svelte 5:**\n   ```svelte\n   {#await dataPromise}\n     <p>Loading...</p>\n   {:then data}\n     <p>Data: {data}</p>\n   {:catch error}\n     <p>Error: {error.message}</p>\n   {/await}\n   ```\n\n   **React:**\n   ```jsx\n   const [data, setData] = useState(null);\n   const [loading, setLoading] = useState(true);\n   const [error, setError] = useState(null);\n   \n   useEffect(() => {\n     setLoading(true);\n     fetch('/api/data')\n       .then(res => res.json())\n       .then(data => {\n         setData(data);\n         setLoading(false);\n       })\n       .catch(err => {\n         setError(err);\n         setLoading(false);\n       });\n   }, []);\n   \n   if (loading) return <p>Loading...</p>;\n   if (error) return <p>Error: {error.message}</p>;\n   return <p>Data: {JSON.stringify(data)}</p>;\n   ```\n\n3. **Framework vs. Meta-Framework Split**: Svelte makes a clearer distinction between the core framework (Svelte) and its meta-framework (SvelteKit). For simple cases, vanilla Svelte is sufficient. For more complex data fetching needs, SvelteKit provides an opinionated solution. This is different from frameworks like Angular, which includes HTTP services in its core package, or Next.js which is more tightly coupled with React.\n\n4. **Reactivity System**: Svelte 5's fine-grained reactivity system (with the new `$state()` and `$derived` syntax) makes it easier to work with async data without excessive re-renders. When data changes, only the affected DOM nodes update, rather than re-evaluating entire component trees.\n\n5. **SvelteKit's Approach**: For more complex applications, SvelteKit's loader system offers a route-based data fetching approach that's deeply integrated with the routing system. This is conceptually similar to React Router or Next.js data fetching, but with Svelte's more efficient update mechanism.\n\nIn summary, Svelte provides a simpler, more declarative approach to handling async data in the core framework, while deferring more complex data fetching patterns to SvelteKit. This separation allows developers to choose the right level of complexity for their specific needs."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"What are the benefits of using SvelteKit loaders for data fetching compared to component-level fetching in Svelte?","answer":"SvelteKit loaders offer several significant benefits over component-level fetching in Svelte:\n\n1. **Preventing Data Loading Waterfalls**: As explicitly mentioned in the documentation, SvelteKit loaders help prevent \"data loading waterfalls.\" In component-level fetching, each component must wait for its parent to render before it can start fetching data, creating a sequential chain of requests. SvelteKit loaders can initiate data fetching for routes in parallel, significantly improving load times.\n\n2. **Server-Side Rendering (SSR) Integration**: SvelteKit loaders are designed to work seamlessly with SSR. Data can be fetched on the server before sending HTML to the client, improving both performance and SEO.\n\n3. **Code Organization**: Loaders separate data fetching concerns from presentation logic. This makes components cleaner and more focused on their primary responsibility: rendering UI.\n\n4. **Caching and Deduplication**: SvelteKit can automatically deduplicate identical requests and implement caching strategies, reducing unnecessary network traffic.\n\n5. **Improved Error Handling**: SvelteKit provides standardized error handling for data fetching operations, including the ability to show error pages or fallback content.\n\n6. **Progressive Enhancement**: SvelteKit loaders support progressive enhancement, allowing your app to work even without JavaScript enabled.\n\n7. **Type Safety**: When using TypeScript, SvelteKit loaders can provide type safety between your data fetching layer and your components.\n\n8. **Prefetching**: SvelteKit can prefetch data for routes that users are likely to navigate to next, making subsequent page navigations feel instantaneous.\n\nHere's a simplified example comparing the two approaches:\n\n**Component-level fetching:**\n```svelte\n<!-- UserProfile.svelte -->\n<script>\n\texport let userId;\n\t\n\tlet userPromise = $state(null);\n\tlet postsPromise = $state(null);\n\t\n\t$effect(() => {\n\t\tuserPromise = fetch(`/api/users/${userId}`).then(r => r.json());\n\t\t// Posts fetch can only start after component renders\n\t});\n\t\n\t$effect(() => {\n\t\tif (userData) {\n\t\t\tpostsPromise = fetch(`/api/users/${userId}/posts`).then(r => r.json());\n\t\t}\n\t});\n</script>\n\n{#await userPromise}\n\t<p>Loading user...</p>\n{:then userData}\n\t<h1>{userData.name}</h1>\n\t\n\t{#await postsPromise}\n\t\t<p>Loading posts...</p>\n\t{:then posts}\n\t\t<ul>\n\t\t\t{#each posts as post}\n\t\t\t\t<li>{post.title}</li>\n\t\t\t{/each}\n\t\t</ul>\n\t{/await}\n{/await}\n```\n\n**SvelteKit loader approach:**\n```typescript\n// +page.server.js\nexport async function load({ params, fetch }) {\n\t// These requests run in parallel\n\tconst [userData, posts] = await Promise.all([\n\t\tfetch(`/api/users/${params.userId}`).then(r => r.json()),\n\t\tfetch(`/api/users/${params.userId}/posts`).then(r => r.json())\n\t]);\n\t\n\treturn {\n\t\tuser: userData,\n\t\tposts\n\t};\n}\n```\n\n```svelte\n<!-- +page.svelte -->\n<script>\n\texport let data;\n\tconst { user, posts } = data;\n</script>\n\n<h1>{user.name}</h1>\n<ul>\n\t{#each posts as post}\n\t\t<li>{post.title}</li>\n\t{/each}\n</ul>\n```\n\nThe SvelteKit approach is not only more concise but also more efficient, as it fetches the user data and posts in parallel rather than sequentially, eliminating the waterfall effect."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"How can you handle more complex data fetching scenarios in Svelte 5, such as dependent requests or polling for updates?","answer":"Handling complex data fetching scenarios in Svelte 5 can be accomplished using a combination of reactive declarations, effects, and the `#await` block. Here are implementations for two common complex scenarios:\n\n### Dependent Requests\n\nDependent requests occur when one fetch operation depends on the result of another. Here's how to handle this in Svelte 5:\n\n```svelte\n<script>\n\tlet userId = $state(1);\n\t\n\t// First request\n\tfunction fetchUser(id) {\n\t\treturn fetch(`/api/users/${id}`)\n\t\t\t.then(r => r.json());\n\t}\n\t\n\t// Second request that depends on the first\n\tfunction fetchUserPosts(user) {\n\t\treturn fetch(`/api/users/${user.id}/posts?category=${user.preferredCategory}`)\n\t\t\t.then(r => r.json());\n\t}\n\t\n\t// Create a chain of dependent promises\n\t$derived.promise(userPromise = fetchUser(userId));\n\t$derived.promise(postsPromise = userPromise.then(user => fetchUserPosts(user)));\n\t\n\tfunction changeUser(newId) {\n\t\tuserId = newId;\n\t}\n</script>\n\n<div>\n\t<div class=\"user-selector\">\n\t\t<button on:click={() => changeUser(1)}>User 1</button>\n\t\t<button on:click={() => changeUser(2)}>User 2</button>\n\t\t<button on:click={() => changeUser(3)}>User 3</button>\n\t</div>\n\t\n\t<div class=\"user-data\">\n\t\t{#await userPromise}\n\t\t\t<p>Loading user...</p>\n\t\t{:then user}\n\t\t\t<h2>{user.name}</h2>\n\t\t\t<p>Preferred category: {user.preferredCategory}</p>\n\t\t\t\n\t\t\t{#await postsPromise}\n\t\t\t\t<p>Loading posts...</p>\n\t\t\t{:then posts}\n\t\t\t\t<h3>Posts</h3>\n\t\t\t\t{#if posts.length > 0}\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t{#each posts as post}\n\t\t\t\t\t\t\t<li>{post.title}</li>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</ul>\n\t\t\t\t{:else}\n\t\t\t\t\t<p>No posts found in {user.preferredCategory} category</p>\n\t\t\t\t{/if}\n\t\t\t{:catch error}\n\t\t\t\t<p class=\"error\">Error loading posts: {error.message}</p>\n\t\t\t{/await}\n\t\t{:catch error}\n\t\t\t<p class=\"error\">Error loading user: {error.message}</p>\n\t\t{/await}\n\t</div>\n</div>\n```\n\n### Polling for Updates\n\nPolling involves fetching data at regular intervals to check for updates:\n\n```svelte\n<script>\n\tlet pollingInterval = $state(5000); // 5 seconds\n\tlet isPolling = $state(true);\n\tlet lastUpdated = $state(new Date());\n\tlet pollTimer = $state(null);\n\t\n\t// Function to fetch latest data\n\tfunction fetchLatestData() {\n\t\treturn fetch('/api/live-data')\n\t\t\t.then(r => {\n\t\t\t\tif (!r.ok) throw new Error(`HTTP error! Status: ${r.status}`);\n\t\t\t\treturn r.json();\n\t\t\t});\n\t}\n\t\n\t// Initial data fetch\n\tlet dataPromise = $state(fetchLatestData());\n\t\n\t// Set up polling\n\t$effect(() => {\n\t\tif (isPolling) {\n\t\t\tstartPolling();\n\t\t} else {\n\t\t\tstopPolling();\n\t\t}\n\t\t\n\t\t// Cleanup when component is destroyed\n\t\treturn () => stopPolling();\n\t});\n\t\n\tfunction startPolling() {\n\t\t// Clear any existing timer\n\t\tif (pollTimer) clearInterval(pollTimer);\n\t\t\n\t\t// Set up new polling interval\n\t\tpollTimer = setInterval(() => {\n\t\t\tdataPromise = fetchLatestData();\n\t\t\tlastUpdated = new Date();\n\t\t}, pollingInterval);\n\t}\n\t\n\tfunction stopPolling() {\n\t\tif (pollTimer) {\n\t\t\tclearInterval(pollTimer);\n\t\t\tpollTimer = null;\n\t\t}\n\t}\n\t\n\tfunction manualRefresh() {\n\t\tdataPromise = fetchLatestData();\n\t\tlastUpdated = new Date();\n\t}\n</script>\n\n<div class=\"live-data-container\">\n\t<div class=\"controls\">\n\t\t<button on:click={() => isPolling = !isPolling}>\n\t\t\t{isPolling ? 'Stop' : 'Start'} Auto-Refresh\n\t\t</button>\n\t\t<button on:click={manualRefresh} disabled={isPolling}>\n\t\t\tRefresh Now\n\t\t</button>\n\t\t<select bind:value={pollingInterval}>\n\t\t\t<option value={1000}>Every 1 second</option>\n\t\t\t<option value={5000}>Every 5 seconds</option>\n\t\t\t<option value={10000}>Every 10 seconds</option>\n\t\t\t<option value={30000}>Every 30 seconds</option>\n\t\t</select>\n\t\t<p>Last updated: {lastUpdated.toLocaleTimeString()}</p>\n\t</div>\n\t\n\t<div class=\"data-display\">\n\t\t{#await dataPromise}\n\t\t\t<div class=\"loading\">\n\t\t\t\t<p>Updating data...</p>\n\t\t\t\t<div class=\"spinner\"></div>\n\t\t\t</div>\n\t\t{:then data}\n\t\t\t<h2>Live Data</h2>\n\t\t\t<div class=\"data-grid\">\n\t\t\t\t{#each Object.entries(data) as [key, value]}\n\t\t\t\t\t<div class=\"data-item\">\n\t\t\t\t\t\t<strong>{key}:</strong> {JSON.stringify(value)}\n\t\t\t\t\t</div>\n\t\t\t\t{/each}\n\t\t\t</div>\n\t\t{:catch error}\n\t\t\t<div class=\"error\">\n\t\t\t\t<p>Failed to load data: {error.message}</p>\n\t\t\t\t<button on:click={manualRefresh}>Try Again</button>\n\t\t\t</div>\n\t\t{/await}\n\t</div>\n</div>\n\n<style>\n\t.live-data-container {\n\t\tborder: 1px solid #ddd;\n\t\tborder-radius: 4px;\n\t\tpadding: 1rem;\n\t}\n\t\n\t.controls {\n\t\tmargin-bottom: 1rem;\n\t\tpadding-bottom: 1rem;\n\t\tborder-bottom: 1px solid #eee;\n\t}\n\t\n\t.data-grid {\n\t\tdisplay: grid;\n\t\tgrid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n\t\tgap: 1rem;\n\t}\n\t\n\t.data-item {\n\t\tpadding: 0.5rem;\n\t\tbackground-color: #f5f5f5;\n\t\tborder-radius: 4px;\n\t}\n\t\n\t.loading {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tgap: 1rem;\n\t}\n\t\n\t.spinner {\n\t\twidth: 20px;\n\t\theight: 20px;\n\t\tborder: 2px solid #ddd;\n\t\tborder-top-color: #333;\n\t\tborder-radius: 50%;\n\t\tanimation: spin 1s linear infinite;\n\t}\n\t\n\t@keyframes spin {\n\t\tto { transform: rotate(360deg); }\n\t}\n\t\n\t.error {\n\t\tcolor: #c62828;\n\t\tbackground-color: #ffebee;\n\t\tpadding: 1rem;\n\t\tborder-radius: 4px;\n\t}\n</style>\n```\n\n### Combining with SvelteKit\n\nFor the most complex scenarios, you might want to combine these techniques with SvelteKit's loaders:\n\n```typescript\n// +page.server.js\nexport const load = async ({ fetch, depends }) => {\n\t// Tell SvelteKit this data depends on 'stock-prices'\n\tdepends('stock-prices');\n\t\n\tconst stockData = await fetch('/api/stocks').then(r => r.json());\n\treturn { stockData };\n};\n```\n\n```svelte\n<!-- +page.svelte -->\n<script>\n\timport { invalidate } from '$app/navigation';\n\t\n\texport let data;\n\tlet { stockData } = data;\n\tlet pollingInterval = $state(null);\n\t\n\t// Set up polling\n\tfunction startPolling() {\n\t\tpollingInterval = setInterval(() => {\n\t\t\t// This will re-run the load function in +page.server.js\n\t\t\tinvalidate('stock-prices');\n\t\t}, 5000);\n\t}\n\t\n\tonMount(() => {\n\t\tstartPolling();\n\t\treturn () => clearInterval(pollingInterval);\n\t});\n</script>\n\n<div>\n\t<h1>Stock Prices</h1>\n\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>Symbol</th>\n\t\t\t\t<th>Price</th>\n\t\t\t\t<th>Change</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t{#each stockData as stock}\n\t\t\t\t<tr class={stock.change > 0 ? 'positive' : stock.change < 0 ? 'negative' : ''}>\n\t\t\t\t\t<td>{stock.symbol}</td>\n\t\t\t\t\t<td>${stock.price.toFixed(2)}</td>\n\t\t\t\t\t<td>{stock.change > 0 ? '+' : ''}{stock.change.toFixed(2)}%</td>\n\t\t\t\t</tr>\n\t\t\t{/each}\n\t\t</tbody>\n\t</table>\n</div>\n```\n\nThese examples demonstrate how Svelte 5 can handle complex data fetching scenarios by leveraging its reactivity system and template syntax, with the option to integrate with SvelteKit for more advanced use cases."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"What are the potential drawbacks or limitations of using the basic fetch approach described in the Svelte documentation, and how might you address them?","answer":"The basic fetch approach described in the Svelte documentation has several potential drawbacks and limitations. Here's an analysis of these issues and how to address them:\n\n### 1. No Built-in Request Cancellation\n\n**Problem**: The basic fetch approach doesn't handle request cancellation. If a component is unmounted while a fetch is in progress, or if multiple fetches are triggered in quick succession, you might encounter race conditions or memory leaks.\n\n**Solution**:\n```svelte\n<script>\n\tlet controller = $state(new AbortController());\n\tlet data = $state(null);\n\tlet error = $state(null);\n\tlet loading = $state(false);\n\t\n\tasync function fetchData(id) {\n\t\t// Cancel any in-flight request\n\t\tcontroller.abort();\n\t\t// Create a new controller for this request\n\t\tcontroller = new AbortController();\n\t\t\n\t\tloading = true;\n\t\terror = null;\n\t\t\n\t\ttry {\n\t\t\tconst response = await fetch(`/api/data/${id}`, {\n\t\t\t\tsignal: controller.signal\n\t\t\t});\n\t\t\t\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(`HTTP error! Status: ${response.status}`);\n\t\t\t}\n\t\t\t\n\t\t\tdata = await response.json();\n\t\t} catch (e) {\n\t\t\tif (e.name !== 'AbortError') {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t} finally {\n\t\t\tloading = false;\n\t\t}\n\t}\n\t\n\t// Cleanup on component destruction\n\tonDestroy(() => {\n\t\tcontroller.abort();\n\t});\n</script>\n```\n\n### 2. No Caching Strategy\n\n**Problem**: The basic fetch approach doesn't implement any caching, potentially causing redundant network requests.\n\n**Solution**:\n```svelte\n<script>\n\t// Simple in-memory cache\n\tconst cache = $state(new Map());\n\tconst CACHE_TTL = 60000; // 1 minute\n\t\n\tasync function fetchWithCache(url) {\n\t\tconst now = Date.now();\n\t\t\n\t\t// Check if we have a fresh cached version\n\t\tif (cache.has(url)) {\n\t\t\tconst { data, timestamp } = cache.get(url);\n\t\t\tif (now - timestamp < CACHE_TTL) {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Fetch fresh data\n\t\tconst response = await fetch(url);\n\t\tconst data = await response.json();\n\t\t\n\t\t// Update cache\n\t\tcache.set(url, { data, timestamp: now });\n\t\t\n\t\treturn data;\n\t}\n\t\n\t// Example usage\n\tlet userData = $state(null);\n\t\n\tasync function loadUser(id) {\n\t\tuserData = await fetchWithCache(`/api/users/${id}`);\n\t}\n</script>\n```\n\n### 3. No Retry Mechanism\n\n**Problem**: The basic approach doesn't handle retries for failed requests.\n\n**Solution**:\n```svelte\n<script>\n\tasync function fetchWithRetry(url, options = {}, retries = 3, backoff = 300) {\n\t\ttry {\n\t\t\tconst response = await fetch(url, options);\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(`HTTP error! Status: ${response.status}`);\n\t\t\t}\n\t\t\treturn await response.json();\n\t\t} catch (error) {\n\t\t\tif (retries <= 0) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\t\n\t\t\t// Wait before retrying (with exponential backoff)\n\t\t\tawait new Promise(resolve => setTimeout(resolve, backoff));\n\t\t\t\n\t\t\t// Retry with increased backoff\n\t\t\treturn fetchWithRetry(url, options, retries - 1, backoff * 2);\n\t\t}\n\t}\n\t\n\tlet data = $state(null);\n\tlet error = $state(null);\n\t\n\tasync function loadData() {\n\t\ttry {\n\t\t\tdata = await fetchWithRetry('/api/unreliable-endpoint');\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\t}\n</script>\n```\n\n### 4. No Loading or Error State Management\n\n**Problem**: The basic example doesn't handle loading or error states explicitly.\n\n**Solution**: While the `#await` block helps with this, you might want more control:\n\n```svelte\n<script>\n\tlet data = $state(null);\n\tlet error = $state(null);\n\tlet loading = $state(false);\n\t\n\tasync function fetchData() {\n\t\tloading = true;\n\t\terror = null;\n\t\t\n\t\ttry {\n\t\t\tconst response = await fetch('/api/data');\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(`HTTP error! Status: ${response.status}`);\n\t\t\t}\n\t\t\tdata = await response.json();\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tdata = null;\n\t\t} finally {\n\t\t\tloading = false;\n\t\t}\n\t}\n</script>\n\n<div>\n\t<button on:click={fetchData} disabled={loading}>\n\t\t{loading ? 'Loading...' : 'Fetch Data'}\n\t</button>\n\t\n\t{#if loading}\n\t\t<div class=\"loader\">Loading...</div>\n\t{:else if error}\n\t\t<div class=\"error\">\n\t\t\t<p>Error: {error.message}</p>\n\t\t\t<button on:click={fetchData}>Retry</button>\n\t\t</div>\n\t{:else if data}\n\t\t<div class=\"data\">\n\t\t\t<pre>{JSON.stringify(data, null, 2)}</pre>\n\t\t</div>\n\t{:else}\n\t\t<p>No data loaded yet.</p>\n\t{/if}\n</div>\n```\n\n### 5. No Request Deduplication\n\n**Problem**: Multiple components might trigger the same fetch, causing duplicate requests.\n\n**Solution**:\n```svelte\n<script context=\"module\">\n\t// Shared pending promises for deduplication\n\tconst pendingRequests = new Map();\n\t\n\texport async function fetchDeduplicated(url) {\n\t\t// If we already have this request in flight, reuse the promise\n\t\tif (pendingRequests.has(url)) {\n\t\t\treturn pendingRequests.get(url);\n\t\t}\n\t\t\n\t\t// Create a new promise for this request\n\t\tconst promise = fetch(url)\n\t\t\t.then(r => r.json())\n\t\t\t.finally(() => {\n\t\t\t\t// Remove from pending requests when done\n\t\t\t\tpendingRequests.delete(url);\n\t\t\t});\n\t\t\n\t\t// Store the promise\n\t\tpendingRequests.set(url, promise);\n\t\t\n\t\treturn promise;\n\t}\n</script>\n\n<script>\n\tlet data = $state(null);\n\t\n\tasync function loadData() {\n\t\tdata = await fetchDeduplicated('/api/expensive-operation');\n\t}\n</script>\n```\n\n### 6. No Progress Tracking\n\n**Problem**: For large file uploads or downloads, there's no progress indication.\n\n**Solution**:\n```svelte\n<script>\n\tlet progress = $state(0);\n\tlet file = $state(null);\n\tlet uploadComplete = $state(false);\n\t\n\tasync function uploadFile() {\n\t\tif (!file) return;\n\t\t\n\t\tconst formData = new FormData();\n\t\tformData.append('file', file);\n\t\t\n\t\tuploadComplete = false;\n\t\tprogress = 0;\n\t\t\n\t\tconst xhr = new XMLHttpRequest();\n\t\t\n\t\txhr.upload.addEventListener('progress', (event) => {\n\t\t\tif (event.lengthComputable) {\n\t\t\t\tprogress = Math.round((event.loaded / event.total) * 100);\n\t\t\t}\n\t\t});\n\t\t\n\t\txhr.addEventListener('load', () => {\n\t\t\tif (xhr.status >= 200 && xhr.status < 300) {\n\t\t\t\tuploadComplete = true;\n\t\t\t}\n\t\t});\n\t\t\n\t\txhr.open('POST', '/api/upload');\n\t\txhr.send(formData);\n\t}\n</script>\n\n<div>\n\t<input type=\"file\" on:change={(e) => file = e.target.files[0]} />\n\t<button on:click={uploadFile} disabled={!file || progress > 0 && progress < 100}>\n\t\tUpload\n\t</button>\n\t\n\t{#if progress > 0}\n\t\t<div class=\"progress-bar\">\n\t\t\t<div class=\"progress\" style=\"width: {progress}%\"></div>\n\t\t</div>\n\t\t<p>{progress}% complete</p>\n\t{/if}\n\t\n\t{#if uploadComplete}\n\t\t<p class=\"success\">Upload complete!</p>\n\t{/if}\n</div>\n```\n\n### 7. No Data Transformation\n\n**Problem**: The basic approach doesn't handle data transformation or normalization.\n\n**Solution**:\n```svelte\n<script>\n\t// Define a schema for the expected data\n\tclass User {\n\t\tconstructor(data) {\n\t\t\tthis.id = data.id;\n\t\t\tthis.name = data.name || 'Unknown';\n\t\t\tthis.email = data.email || '';\n\t\t\t// Convert string date to Date object\n\t\t\tthis.joinDate = data.join_date ? new Date(data.join_date) : new Date();\n\t\t\t// Ensure roles is always an array\n\t\t\tthis.roles = Array.isArray(data.roles) ? data.roles : [];\n\t\t}\n\t\t\n\t\tget isAdmin() {\n\t\t\treturn this.roles.includes('admin');\n\t\t}\n\t\t\n\t\tget formattedJoinDate() {\n\t\t\treturn this.joinDate.toLocaleDateString();\n\t\t}\n\t}\n\t\n\tasync function fetchUser(id) {\n\t\tconst response = await fetch(`/api/users/${id}`);\n\t\tconst data = await response.json();\n\t\t// Transform raw data into structured object\n\t\treturn new User(data);\n\t}\n\t\n\tlet user = $state(null);\n\t\n\tasync function loadUser(id) {\n\t\tuser = await fetchUser(id);\n\t}\n</script>\n\n<div>\n\t{#if user}\n\t\t<h2>{user.name}</h2>\n\t\t<p>Email: {user.email}</p>\n\t\t<p>Joined: {user.formattedJoinDate}</p>\n\t\t<p>Admin access: {user.isAdmin ? 'Yes' : 'No'}</p>\n\t{/if}\n</div>\n```\n\nBy addressing these limitations, you can build a more robust data fetching solution in Svelte that handles edge cases and provides a better user experience. For production applications with complex requirements, the documentation suggests using SvelteKit's data loading system, which addresses many of these concerns out of the box."}
{"source":"docs/svelte/03-template-syntax/xx-data-fetching.md","question":"How can Svelte 5's reactivity system be leveraged to create a reusable data fetching abstraction that handles common patterns like loading states, error handling, and caching?","answer":"Svelte 5's reactivity system can be leveraged to create a powerful, reusable data fetching abstraction. Below, I'll demonstrate how to build a comprehensive `useFetch` custom store that handles loading states, error handling, caching, retries, and more.\n\n```svelte\n<!-- useFetch.js -->\n<script context=\"module\">\n\timport { writable, derived } from 'svelte/store';\n\t\n\t// Cache storage\n\tconst cache = new Map();\n\t\n\t// Configure default options\n\tconst defaultOptions = {\n\t\tcacheTime: 5 * 60 * 1000, // 5 minutes\n\t\tstaleTime: 30 * 1000,     // 30 seconds\n\t\tretries: 3,\n\t\tretryDelay: 1000,\n\t\tdedupingInterval: 200,\n\t\trefetchOnFocus: false,\n\t\trefetchOnReconnect: true,\n\t\tonSuccess: null,\n\t\tonError: null\n\t};\n\t\n\t// Keep track of in-flight requests for deduplication\n\tconst pendingRequests = new Map();\n\t\n\t// Create a reusable fetch hook\n\texport function useFetch(url, options = {}) {\n\t\t// Merge options with defaults\n\t\tconst config = { ...defaultOptions, ...options };\n\t\t\n\t\t// Create stores for state management\n\t\tconst state = writable({\n\t\t\tdata: null,\n\t\t\terror: null,\n\t\t\tstatus: 'idle', // idle, loading, success, error\n\t\t\ttimestamp: 0,\n\t\t\tretryCount: 0\n\t\t});\n\t\t\n\t\t// Create a controller for this instance\n\t\tlet controller = new AbortController();\n\t\t\n\t\t// Derived stores for convenience\n\t\tconst isLoading = derived(state, $state => $state.status === 'loading');\n\t\tconst isError = derived(state, $state => $state.status === 'error');\n\t\tconst isSuccess = derived(state, $state => $state.status === 'success');\n\t\tconst data = derived(state, $state => $state.data);\n\t\tconst error = derived(state, $state => $state.error);\n\t\t\n\t\t// Function to execute the fetch\n\t\tasync function executeFetch(fetchUrl, fetchOptions = {}) {\n\t\t\t// Check if we have a valid cached response\n\t\t\tconst cacheKey = fetchUrl + JSON.stringify(fetchOptions);\n\t\t\tconst now = Date.now();\n\t\t\t\n\t\t\tif (cache.has(cacheKey)) {\n\t\t\t\tconst cachedData = cache.get(cacheKey);\n\t\t\t\t// If data is fresh enough, use it immediately\n\t\t\t\tif (now - cachedData.timestamp < config.staleTime) {\n\t\t\t\t\tstate.update(s => ({ \n\t\t\t\t\t\t...s, \n\t\t\t\t\t\tdata: cachedData.data, \n\t\t\t\t\t\tstatus: 'success', \n\t\t\t\t\t\ttimestamp: cachedData.timestamp \n\t\t\t\t\t}));\n\t\t\t\t\treturn cachedData.data;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If data is stale but still valid, use it but refetch\n\t\t\t\tif (now - cachedData.timestamp < config.cacheTime) {\n\t\t\t\t\t// Use stale data immediately\n\t\t\t\t\tstate.update(s => ({ \n\t\t\t\t\t\t...s, \n\t\t\t\t\t\tdata: cachedData.data, \n\t\t\t\t\t\tstatus: 'success', \n\t\t\t\t\t\ttimestamp: cachedData.timestamp \n\t\t\t\t\t}));\n\t\t\t\t\t\n\t\t\t\t\t// Then trigger a background refresh\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\trefresh();\n\t\t\t\t\t}, 0);\n\t\t\t\t\t\n\t\t\t\t\treturn cachedData.data;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Check for deduplication of in-flight requests\n\t\t\tif (pendingRequests.has(cacheKey)) {\n\t\t\t\tconst request = pendingRequests.get(cacheKey);\n\t\t\t\treturn request;\n\t\t\t}\n\t\t\t\n\t\t\t// Set loading state\n\t\t\tstate.update(s => ({ ...s, status: 'loading' }));\n\t\t\t\n\t\t\t// Create promise for this request\n\t\t\tconst fetchPromise = (async () => {\n\t\t\t\ttry {\n\t\t\t\t\t// Abort any previous request\n\t\t\t\t\tcontroller.abort();\n\t\t\t\t\tcontroller = new AbortController();\n\t\t\t\t\t\n\t\t\t\t\t// Merge fetch options\n\t\t\t\t\tconst mergedOptions = {\n\t\t\t\t\t\t...fetchOptions,\n\t\t\t\t\t\tsignal: controller.signal\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// Execute fetch\n\t\t\t\t\tconst response = await fetch(fetchUrl, mergedOptions);\n\t\t\t\t\t\n\t\t\t\t\t// Handle HTTP errors\n\t\t\t\t\tif (!response.ok) {\n\t\t\t\t\t\tthrow new Error(`HTTP error! Status: ${response.status}`);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Parse response\n\t\t\t\t\tconst result = await response.json();\n\t\t\t\t\t\n\t\t\t\t\t// Update state with success\n\t\t\t\t\tstate.update(s => ({ \n\t\t\t\t\t\t...s, \n\t\t\t\t\t\tdata: result, \n\t\t\t\t\t\terror: null, \n\t\t\t\t\t\tstatus: 'success', \n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t\tretryCount: 0\n\t\t\t\t\t}));\n\t\t\t\t\t\n\t\t\t\t\t// Update cache\n\t\t\t\t\tcache.set(cacheKey, {\n\t\t\t\t\t\tdata: result,\n\t\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t// Call success callback if provided\n\t\t\t\t\tif (config.onSuccess) {\n\t\t\t\t\t\tconfig.onSuccess(result);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn result;\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Don't handle aborted requests as errors\n\t\t\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Update state with error\n\t\t\t\t\tstate.update(s => ({ \n\t\t\t\t\t\t...s, \n\t\t\t\t\t\terror: err, \n\t\t\t\t\t\tstatus: 'error' \n\t\t\t\t\t}));\n\t\t\t\t\t\n\t\t\t\t\t// Handle retries\n\t\t\t\t\tif (config.retries > 0) {\n\t\t\t\t\t\tstate.update(s => {\n\t\t\t\t\t\t\t// Check if we've reached max retries\n\t\t\t\t\t\t\tif (s.retryCount < config.retries) {\n\t\t\t\t\t\t\t\t// Schedule retry with exponential backoff\n\t\t\t\t\t\t\t\tconst delay = config.retryDelay * Math.pow(2, s.retryCount);\n\t\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\t\trefresh();\n\t\t\t\t\t\t\t\t}, delay);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn { ...s, retryCount: s.retryCount + 1 };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn s;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Call error callback if provided\n\t\t\t\t\tif (config.onError) {\n\t\t\t\t\t\tconfig.onError(err);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthrow err;\n\t\t\t\t} finally {\n\t\t\t\t\t// Remove from pending requests\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tpendingRequests.delete(cacheKey);\n\t\t\t\t\t}, config.dedupingInterval);\n\t\t\t\t}\n\t\t\t})();\n\t\t\t\n\t\t\t// Store the promise for deduplication\n\t\t\tpendingRequests.set(cacheKey, fetchPromise);\n\t\t\t\n\t\t\treturn fetchPromise;\n\t\t}\n\t\t\n\t\t// Function to manually trigger a refresh\n\t\tfunction refresh() {\n\t\t\treturn executeFetch(url, options.fetchOptions);\n\t\t}\n\t\t\n\t\t// Function to clear cache for this URL\n\t\tfunction clearCache() {\n\t\t\tconst cacheKey = url + JSON.stringify(options.fetchOptions || {});\n\t\t\tcache.delete(cacheKey);\n\t\t}\n\t\t\n\t\t// Function to manually set data (useful for optimistic updates)\n\t\tfunction setData(newData) {\n\t\t\tstate.update(s => ({ ...s, data: newData }));\n\t\t\t\n\t\t\t// Update cache if using cache\n\t\t\tif (config.cacheTime > 0) {\n\t\t\t\tconst cacheKey = url + JSON.stringify(options.fetchOptions || {});\n\t\t\t\tcache.set(cacheKey, {\n\t\t\t\t\tdata: newData,\n\t\t\t\t\ttimestamp: Date.now()\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Function to abort current request\n\t\tfunction abort() {\n\t\t\tcontroller.abort();\n\t\t\tstate.update(s => ({ ...s, status: 'idle' }));\n\t\t}\n\t\t\n\t\t// Set up window focus listener for refetching\n\t\tif (typeof window !== 'undefined' && config.refetchOnFocus) {\n\t\t\twindow.addEventListener('focus', refresh);\n\t\t}\n\t\t\n\t\t// Set up reconnection listener\n\t\tif (typeof window !== 'undefined' && config.refetchOnReconnect) {\n\t\t\twindow.addEventListener('online', refresh);\n\t\t}\n\t\t\n\t\t// Initial fetch if not lazy\n\t\tif (!options.lazy) {\n\t\t\trefresh();\n\t\t}\n\t\t\n\t\t// Cleanup function\n\t\tfunction destroy() {\n\t\t\tcontroller.abort();\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tif (config.refetchOnFocus) {\n\t\t\t\t\twindow.removeEventListener('focus', refresh);\n\t\t\t\t}\n\t\t\t\tif (config.refetchOnReconnect) {\n\t\t\t\t\twindow.removeEventListener('online', refresh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Return the store and utility functions\n\t\treturn {\n\t\t\tsubscribe: state.subscribe,\n\t\t\tdata,\n\t\t\terror,\n\t\t\tisLoading,\n\t\t\tisError,\n\t\t\tisSuccess,\n\t\t\trefresh,\n\t\t\tabort,\n\t\t\tclearCache,\n\t\t\tsetData,\n\t\t\tdestroy\n\t\t};\n\t}\n\t\n\t// Helper function to clear entire cache\n\texport function clearFetchCache() {\n\t\tcache.clear();\n\t}\n</script>\n```\n\nNow let's see how to use this abstraction in a component:\n\n```svelte\n<!-- UserProfile.svelte -->\n<script>\n\timport { onDestroy } from 'svelte';\n\timport { useFetch } from './useFetch.js';\n\t\n\texport let userId;\n\t\n\t// Create a fetch store for the user data\n\tconst userFetch = useFetch(`/api/users/${userId}`, {\n\t\tcacheTime: 10 * 60 * 1000, // Cache for 10 minutes\n\t\tretries: 2,\n\t\tonSuccess: (data) => console.log('User data loaded:', data),\n\t\tonError: (err) => console.error('Failed to load user:', err)\n\t});\n\t\n\t// Create a dependent fetch for user posts\n\t$derived.promise(userPosts = userFetch.data ? \n\t\tuseFetch(`/api/users/${userId}/posts`, {\n\t\t\tcacheTime: 5 * 60 * 1000\n\t\t}) : null\n\t);\n\t\n\t// Cleanup on component destruction\n\tonDestroy(() => {\n\t\tuserFetch.destroy();\n\t\tif (userPosts) userPosts.destroy();\n\t});\n\t\n\t// Function to refresh both user and posts data\n\tfunction refreshAll() {\n\t\tuserFetch.refresh();\n\t\tif (userPosts) userPosts.refresh();\n\t}\n</script>\n\n<div class=\"user-profile\">\n\t<div class=\"header\">\n\t\t<h1>User Profile</h1>\n\t\t<button on:click={refreshAll}>Refresh</button>\n\t</div>\n\t\n\t<!-- User data section -->\n\t{#if $userFetch.isLoading && !$userFetch.data}\n\t\t<div class=\"loading-skeleton\">\n\t\t\t<div class=\"skeleton-avatar\"></div>\n\t\t\t<div class=\"skeleton-name\"></div>\n\t\t\t<div class=\"skeleton-email\"></div>\n\t\t</div>\n\t{:else if $userFetch.isError}\n\t\t<div class=\"error-container\">\n\t\t\t<p>Error loading user: {$userFetch.error.message}</p>\n\t\t\t<button on:click={() => userFetch.refresh()}>Try Again</button>\n\t\t</div>\n\t{:else if $userFetch.data}\n\t\t<div class=\"user-card\">\n\t\t\t<img src={$userFetch.data.avatar} alt=\"User avatar\" />\n\t\t\t<h2>{$userFetch.data.name}</h2>\n\t\t\t<p>{$userFetch.data.email}</p>\n\t\t\t<p>Member since: {new Date($userFetch.data.joinDate).toLocaleDateString()}</p>\n\t\t</div>\n\t\t\n\t\t<!-- Background refresh indicator -->\n\t\t{#if $userFetch.isLoading}\n\t\t\t<div class=\"refresh-indicator\">Refreshing user data...</div>\n\t\t{/if}\n\t{/if}\n\t\n\t<!-- Posts section (only show if we have user data) -->\n\t{#if $userFetch.data}\n\t\t<h2>User Posts</h2>\n\t\t\n\t\t{#if userPosts && $userPosts.isLoading && !$userPosts.data}\n\t\t\t<div class=\"loading-posts\">\n\t\t\t\t<div class=\"skeleton-post\"></div>\n\t\t\t\t<div class=\"skeleton-post\"></div>\n\t\t\t\t<div class=\"skeleton-post\"></div>\n\t\t\t</div>\n\t\t{:else if userPosts && $userPosts.isError}\n\t\t\t<div class=\"error-container\">\n\t\t\t\t<p>Error loading posts: {$userPosts.error.message}</p>\n\t\t\t\t<button on:click={() => userPosts.refresh()}>Try Again</button>\n\t\t\t</div>\n\t\t{:else if userPosts && $userPosts.data}\n\t\t\t{#if $userPosts.data.length === 0}\n\t\t\t\t<p>This user hasn't posted anything yet.</p>\n\t\t\t{:else}\n\t\t\t\t<ul class=\"posts-list\">\n\t\t\t\t\t{#each $userPosts.data as post}\n\t\t\t\t\t\t<li class=\"post-item\">\n\t\t\t\t\t\t\t<h3>{post.title}</h3>\n\t\t\t\t\t\t\t<p>{post.excerpt}</p>\n\t\t\t\t\t\t\t<span class=\"post-date\">{new Date(post.date).toLocaleDateString()}</span>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t{/each}\n\t\t\t\t</ul>\n\t\t\t\t\n\t\t\t\t<!-- Background refresh indicator -->\n\t\t\t\t{#if $userPosts.isLoading}\n\t\t\t\t\t<div class=\"refresh-indicator\">Refreshing posts...</div>\n\t\t\t\t{/if}\n\t\t\t{/if}\n\t\t{/if}\n\t{/if}\n</div>\n\n<style>\n\t/* Styling for the component */\n\t.user-profile {\n\t\tmax-width: 800px;\n\t\tmargin: 0 auto;\n\t\tpadding: 1rem;\n\t}\n\t\n\t.header {\n\t\tdisplay: flex;\n\t\tjustify-content: space-between;\n\t\talign-items: center;\n\t\tmargin-bottom: 2rem;\n\t}\n\t\n\t.loading-skeleton {\n\t\tpadding: 1rem;\n\t\tborder-radius: 8px;\n\t\tbackground: #f0f0f0;\n\t}\n\t\n\t.skeleton-avatar, .skeleton-name, .skeleton-email {\n\t\tbackground: #e0e0e0;\n\t\tmargin-bottom: 0.5rem;\n\t\tborder-radius: 4px;\n\t\tanimation: pulse 1.5s infinite;\n\t}\n\t\n\t.skeleton-avatar {\n\t\twidth: 80px;\n\t\theight: 80px;\n\t\tborder-radius: 50%;\n\t}\n\t\n\t.skeleton-name {\n\t\twidth: 60%;\n\t\theight: 24px;\n\t}\n\t\n\t.skeleton-email {\n\t\twidth: 40%;\n\t\theight: 16px;\n\t}\n\t\n\t.refresh-indicator {\n\t\tfont-size: 0.8rem;\n\t\tcolor: #666;\n\t\tmargin-top: 0.5rem;\n\t\tfont-style: italic;\n\t}\n\t\n\t.error-container {\n\t\tpadding: 1rem;\n\t\tbackground: #ffebee;\n\t\tcolor: #c62828;\n\t\tborder-radius: 4px;\n\t\tmargin-bottom: 1rem;\n\t}\n\t\n\t.user-card {\n\t\tpadding: 1rem;\n\t\tborder-radius: 8px;\n\t\tbackground: #f5f5f5;\n\t\tmargin-bottom: 2rem;\n\t}\n\t\n\t.posts-list {\n\t\tlist-style: none;\n\t\tpadding: 0;\n\t}\n\t\n\t.post-item {\n\t\tpadding: 1rem;\n\t\tborder-bottom: 1px solid #eee;\n\t\tmargin-bottom: 1rem;\n\t}\n\t\n\t.post-date {\n\t\tfont-size: 0.8rem;\n\t\tcolor: #666;\n\t}\n\t\n\t@keyframes pulse {\n\t\t0% { opacity: 0.6; }\n\t\t50% { opacity: 1; }\n\t\t100% { opacity: 0.6; }\n\t}\n</style>\n```\n\nThis implementation leverages Svelte 5's reactivity system to create a powerful data fetching abstraction that:\n\n1. **Handles all data fetching states**: Loading, success, error, and idle states are tracked and exposed via derived stores.\n\n2. **Implements smart caching**: Uses a time-based caching strategy with separate stale time and cache time concepts. Stale data is shown immediately while a background refresh happens.\n\n3. **Deduplicates requests**: Prevents duplicate network requests for the same data by tracking in-flight requests.\n\n4. **Supports retry logic**: Automatically retries failed requests with exponential backoff.\n\n5. **Manages cleanup**: Provides destroy functions to clean up event listeners and abort in-flight requests when components unmount.\n\n6. **Enables optimistic updates**: The `setData` method allows for optimistic UI updates during mutations.\n\n7. **Supports dependent fetches**: The example shows how to create dependent fetch operations where one request depends on the data from another.\n\n8. **Implements background refreshing**: Supports refreshing data when the window regains focus or when the network reconnects.\n\n9. **Provides skeleton loading states**: The UI example shows how to implement skeleton screens for better perceived performance.\n\n10. **Exposes a clean API**: The abstraction provides a simple, store-based API that works well with Svelte's reactivity system.\n\nThis pattern demonstrates how Svelte 5's reactivity system can be leveraged to create sophisticated data fetching abstractions that handle common challenges in web applications. It provides a reusable solution that can be used throughout an application to maintain consistent data fetching behavior.\n\nFor even more complex applications, this approach could be combined with SvelteKit's loaders, using this client-side abstraction for dynamic data fetching that happens after the initial page load."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"What is the default scoping behavior of styles in Svelte components, and how does Svelte implement this scoping under the hood?","answer":"In Svelte, styles defined within a `<style>` element of a component are scoped by default. This means that the CSS rules only apply to elements within that specific component and won't affect elements outside of it.\n\nUnder the hood, Svelte implements this scoping by adding a unique class to all affected elements. This class is based on a hash of the component styles (e.g., `svelte-123xyz`). This approach ensures style isolation without requiring Shadow DOM.\n\nHere's an example of how this works:\n\n```svelte\n<script>\n  // Component logic\n</script>\n\n<p>This paragraph will be styled</p>\n\n<style>\n  p {\n    /* This will only affect <p> elements in this component */\n    color: burlywood;\n    font-size: 16px;\n  }\n</style>\n```\n\nWhen Svelte compiles this component, it transforms the CSS and HTML. The compiled output would conceptually look something like:\n\n```html\n<p class=\"svelte-123xyz\">This paragraph will be styled</p>\n\n<style>\n  p.svelte-123xyz {\n    color: burlywood;\n    font-size: 16px;\n  }\n</style>\n```\n\nThis ensures that the styles only apply to elements within this specific component instance, preventing unintended style leakage to the rest of the application."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"How does Svelte handle CSS specificity when applying scoped styles, and what implications does this have for style precedence?","answer":"Svelte increases the specificity of each scoped selector by adding a scoping class (e.g., `.svelte-123xyz`) to the selector. This results in a specificity increase of 0-1-0 (according to the [specificity calculation](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity)) for each scoped selector.\n\nThis specificity increase has important implications for style precedence. It means that component-scoped styles will typically take precedence over global styles, even if the global styles are loaded later in the document. This behavior differs from standard CSS cascade rules where later styles generally override earlier ones of equal specificity.\n\nFor example:\n\n```svelte\n<!-- Component.svelte -->\n<p>This text will be burlywood, not blue</p>\n\n<style>\n  p {\n    color: burlywood;\n  }\n</style>\n```\n\n```css\n/* global.css (loaded after the component) */\np {\n  color: blue;\n}\n```\n\nIn this case, the paragraph text will be burlywood, not blue, because Svelte's scoped selector has higher specificity (`p.svelte-123xyz` vs just `p`).\n\nIt's worth noting that Svelte is careful not to increase specificity unnecessarily. After the first occurrence of the scoping class, Svelte adds subsequent instances using `:where(.svelte-xyz123)` syntax, which doesn't increase specificity further. This is a thoughtful approach to avoid creating overly specific selectors that would be difficult to override when needed.\n\nUnderstanding this specificity behavior is crucial when mixing global and component styles in Svelte applications, especially when you need to determine which styles will take precedence."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"How are keyframe animations scoped in Svelte components, and what happens to animation rules that reference these keyframes?","answer":"In Svelte, when a component defines `@keyframes` animations, the keyframe names are automatically scoped to that component using the same hashing approach used for selectors. This ensures that keyframe animations defined in one component don't conflict with similarly named keyframes in other components.\n\nAdditionally, any `animation` rules within the component that reference these keyframes are automatically adjusted to use the scoped keyframe name. This means developers can use simple, descriptive names for their animations without worrying about global namespace collisions.\n\nHere's an example:\n\n```svelte\n<script>\n  // Component logic\n</script>\n\n<div class=\"bouncy\">This element will bounce</div>\n\n<style>\n  .bouncy {\n    animation: bounce 2s infinite ease-in-out;\n  }\n\n  /* These keyframes are only accessible inside this component */\n  @keyframes bounce {\n    0% {\n      transform: translateY(0);\n    }\n    50% {\n      transform: translateY(-20px);\n    }\n    100% {\n      transform: translateY(0);\n    }\n  }\n</style>\n```\n\nWhen Svelte compiles this component, it transforms the keyframe name and references to it. Conceptually, the output might look like:\n\n```css\n.bouncy.svelte-123xyz {\n  animation: bounce-svelte-123xyz 2s infinite ease-in-out;\n}\n\n@keyframes bounce-svelte-123xyz {\n  0% {\n    transform: translateY(0);\n  }\n  50% {\n    transform: translateY(-20px);\n  }\n  100% {\n    transform: translateY(0);\n  }\n}\n```\n\nThis scoping of keyframes provides several benefits:\n1. Prevents animation conflicts between components\n2. Allows developers to use simple, semantic names for animations\n3. Maintains the component encapsulation principle for all aspects of styling\n4. Enables multiple instances of the same component to animate independently\n\nThis feature is particularly valuable in larger applications where many components might define animations with common names like \"fade\", \"slide\", or \"bounce\"."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"If you want to override the default scoped styling behavior in Svelte, what options do you have, and in what scenarios might you want to do this?","answer":"While Svelte scopes styles by default, there are scenarios where you might want different styling behaviors. Here are the options available:\n\n1. **Global styles**: You can apply styles globally by using the `:global()` modifier:\n\n```svelte\n<style>\n  /* Scoped to this component */\n  p {\n    color: burlywood;\n  }\n\n  /* Applied globally */\n  :global(body) {\n    background-color: #f4f4f4;\n  }\n  \n  /* You can also combine scoped and global selectors */\n  div :global(p) {\n    font-style: italic; /* All <p> inside <div> elements in this component will be italic */\n  }\n</style>\n```\n\n2. **External CSS files**: You can import external CSS files in your Svelte components. These styles will be global:\n\n```svelte\n<script>\n  import './styles.css';\n</script>\n```\n\n3. **Global style tags**: You can add a `<style>` tag without the `scoped` attribute to your main app layout or entry point:\n\n```html\n<style>\n  /* These styles will be global */\n  body {\n    margin: 0;\n    font-family: 'Roboto', sans-serif;\n  }\n</style>\n```\n\nCommon scenarios where you might want to override scoped styling:\n\n1. **Theme implementation**: When implementing app-wide theming, you need global CSS variables or base styles.\n\n```svelte\n<style>\n  :global(:root) {\n    --primary-color: #3498db;\n    --secondary-color: #2ecc71;\n    --text-color: #333;\n  }\n</style>\n```\n\n2. **Third-party component styling**: When you need to style third-party components that you can't modify directly.\n\n```svelte\n<style>\n  :global(.third-party-component .button) {\n    background-color: var(--primary-color);\n  }\n</style>\n```\n\n3. **Reset or normalize CSS**: When applying CSS resets or normalization.\n\n```svelte\n<style>\n  :global(*) {\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n  }\n</style>\n```\n\n4. **Styling markdown or HTML content**: When you have dynamically generated HTML (e.g., from markdown) and need to style its elements.\n\n```svelte\n<style>\n  .content :global(h1) {\n    color: var(--heading-color);\n  }\n  \n  .content :global(p) {\n    line-height: 1.6;\n  }\n</style>\n\n<div class=\"content\">\n  {@html markdownContent}\n</div>\n```\n\nRemember that using global styles should be done judiciously, as it breaks the component encapsulation that is one of Svelte's key benefits. When possible, it's better to use component composition and props to manage styling in a more controlled way."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"How would you style elements from a third-party library or elements generated from HTML strings in Svelte while maintaining the benefits of scoped styles?","answer":"Styling third-party components or dynamically generated HTML content in Svelte requires special techniques because these elements won't automatically receive the scoped class that Svelte adds to your component's elements. Here's how to approach this challenge:\n\n### Styling Third-Party Components\n\nThe most effective approach is to use the `:global()` selector within a scoped context:\n\n```svelte\n<script>\n  import ThirdPartyComponent from 'some-library';\n</script>\n\n<div class=\"wrapper\">\n  <ThirdPartyComponent />\n</div>\n\n<style>\n  /* Create a scoped container */\n  .wrapper :global(.third-party-button) {\n    background-color: burlywood;\n    border-radius: 4px;\n  }\n  \n  /* You can target nested elements too */\n  .wrapper :global(.third-party-dropdown .item) {\n    color: #333;\n    padding: 8px;\n  }\n</style>\n```\n\nBy placing the `:global()` selector inside a scoped class (`.wrapper`), you:\n1. Limit the global style's reach to only elements within your component\n2. Maintain style encapsulation\n3. Avoid polluting the global namespace\n\n### Styling Dynamically Generated HTML\n\nFor content generated from HTML strings (like markdown renderers or WYSIWYG editors), use a similar approach:\n\n```svelte\n<script>\n  let htmlContent = '<h2>Dynamic Title</h2><p>Some paragraph text</p>';\n</script>\n\n<div class=\"content-container\">\n  {@html htmlContent}\n</div>\n\n<style>\n  .content-container {\n    padding: 16px;\n    border: 1px solid #eee;\n  }\n  \n  /* Style dynamic headings */\n  .content-container :global(h2) {\n    color: #2a5885;\n    font-size: 1.5rem;\n  }\n  \n  /* Style dynamic paragraphs */\n  .content-container :global(p) {\n    line-height: 1.6;\n    margin-bottom: 1rem;\n  }\n  \n  /* Style links in the dynamic content */\n  .content-container :global(a) {\n    color: #0066cc;\n    text-decoration: none;\n  }\n  \n  .content-container :global(a:hover) {\n    text-decoration: underline;\n  }\n</style>\n```\n\n### Using CSS Custom Properties for More Flexibility\n\nYou can also use CSS custom properties (variables) to influence third-party components while keeping your styles scoped:\n\n```svelte\n<script>\n  import ThirdPartyComponent from 'some-library';\n</script>\n\n<div class=\"theme-provider\">\n  <ThirdPartyComponent />\n</div>\n\n<style>\n  .theme-provider {\n    /* Define variables that the third-party component might use */\n    --third-party-primary-color: burlywood;\n    --third-party-font-size: 16px;\n    --third-party-border-radius: 4px;\n  }\n  \n  /* Additional scoped global styles if needed */\n  .theme-provider :global(.some-class) {\n    margin: 10px;\n  }\n</style>\n```\n\n### Practical Example: Styling a Markdown Renderer\n\nHere's a more complete example with a markdown renderer:\n\n```svelte\n<script>\n  import { marked } from 'marked';\n  \n  let markdown = `\n# My Markdown Title\n  \nThis is a paragraph with **bold** and *italic* text.\n\n- List item 1\n- List item 2\n\n[Visit Svelte](https://svelte.dev)\n  `;\n  \n  $: htmlContent = marked(markdown);\n</script>\n\n<div class=\"markdown-content\">\n  {@html htmlContent}\n</div>\n\n<style>\n  .markdown-content {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    line-height: 1.6;\n    color: #333;\n    max-width: 800px;\n    margin: 0 auto;\n  }\n  \n  .markdown-content :global(h1) {\n    color: #2c3e50;\n    border-bottom: 1px solid #eee;\n    padding-bottom: 10px;\n  }\n  \n  .markdown-content :global(p) {\n    margin: 16px 0;\n  }\n  \n  .markdown-content :global(strong) {\n    color: #e74c3c;\n  }\n  \n  .markdown-content :global(em) {\n    color: #3498db;\n  }\n  \n  .markdown-content :global(ul) {\n    padding-left: 20px;\n  }\n  \n  .markdown-content :global(li) {\n    margin: 8px 0;\n  }\n  \n  .markdown-content :global(a) {\n    color: #9b59b6;\n    text-decoration: none;\n    border-bottom: 1px dotted #9b59b6;\n  }\n  \n  .markdown-content :global(a:hover) {\n    border-bottom-style: solid;\n  }\n</style>\n```\n\nBy using these techniques, you can style third-party components and dynamic content while still maintaining the benefits of Svelte's scoped styles, keeping your application's styling modular and predictable."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"How does Svelte handle multiple instances of the same scoped selector in a component's style block, and what is the purpose of using `:where()` in this context?","answer":"When Svelte encounters multiple instances of the same selector in a component's style block, it handles the scoping class addition in a special way to manage CSS specificity appropriately. This is an important detail in Svelte's styling system.\n\n### Multiple Instances of Selectors\n\nFor the first occurrence of a selector, Svelte adds the scoping class directly, which increases the selector's specificity by 0-1-0 (adding one class to the specificity calculation). However, for subsequent occurrences of the same selector, Svelte uses the `:where()` pseudo-class function to add the scoping class without further increasing specificity.\n\nHere's how this works:\n\n```svelte\n<style>\n  /* First instance - scoping class added directly */\n  p {\n    color: burlywood;\n  }\n  \n  /* Subsequent instances - scoping class added with :where() */\n  p {\n    font-size: 16px;\n  }\n</style>\n```\n\nWhen compiled, Svelte might transform this to something conceptually like:\n\n```css\n/* First instance - increases specificity */\np.svelte-123xyz {\n  color: burlywood;\n}\n\n/* Subsequent instance - doesn't further increase specificity */\np:where(.svelte-123xyz) {\n  font-size: 16px;\n}\n```\n\n### Purpose of Using `:where()`\n\nThe `:where()` pseudo-class function has a special property in CSS: it has zero specificity contribution. This means that any selectors inside `:where()` don't add to the overall specificity of the selector.\n\nSvelte uses this feature for several important reasons:\n\n1. **Preventing Excessive Specificity Inflation**: If every occurrence of a selector in a component added another scoping class directly, the specificity would increase with each occurrence. This would make styles increasingly difficult to override when needed.\n\n2. **Maintaining Predictable Specificity**: By only increasing specificity once per unique selector, Svelte ensures that the specificity remains predictable and manageable.\n\n3. **Preserving Original Selector Relationships**: This approach helps maintain the relative specificity relationships between different selectors as they were written in the component.\n\n### Practical Example\n\nLet's see a more complex example to illustrate how this works:\n\n```svelte\n<style>\n  /* Base styles */\n  p {\n    color: #333;\n    font-size: 16px;\n  }\n  \n  /* More specific selectors still work as expected */\n  p.important {\n    color: red;\n    font-weight: bold;\n  }\n  \n  /* Another instance of p selector */\n  p {\n    line-height: 1.5;\n    margin-bottom: 1rem;\n  }\n</style>\n\n<p>Regular paragraph</p>\n<p class=\"important\">Important paragraph</p>\n```\n\nSvelte would handle the scoping of these selectors in a way that maintains their relative specificity. Conceptually, the compiled CSS might look like:\n\n```css\n/* First p selector - gets direct class addition */\np.svelte-123xyz {\n  color: #333;\n  font-size: 16px;\n}\n\n/* p.important selector - gets direct class addition */\np.important.svelte-123xyz {\n  color: red;\n  font-weight: bold;\n}\n\n/* Second p selector - gets :where() to avoid further specificity increase */\np:where(.svelte-123xyz) {\n  line-height: 1.5;\n  margin-bottom: 1rem;\n}\n```\n\nThis approach ensures that:\n- All styles remain scoped to the component\n- The specificity hierarchy is preserved (p.important still overrides p)\n- Specificity doesn't unnecessarily accumulate for repeated selectors\n\nThis careful handling of specificity is one of the subtle but important ways Svelte makes CSS more manageable in component-based applications."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"What are the implications of Svelte's scoped styling for CSS performance, and how does it compare to other component styling approaches like CSS-in-JS or CSS Modules?","answer":"Svelte's approach to scoped styling has significant implications for CSS performance and developer experience. Let's examine how it compares to other popular component styling approaches:\n\n### Performance Implications of Svelte's Scoped Styles\n\nSvelte's approach to styling has several performance advantages:\n\n1. **Compile-time Processing**: Svelte processes styles at build time rather than runtime, eliminating the performance overhead that runtime CSS-in-JS solutions often introduce.\n\n```svelte\n<!-- This style block is processed at build time -->\n<style>\n  p {\n    color: burlywood;\n  }\n</style>\n```\n\n2. **Static CSS Output**: Svelte generates static CSS that's included in the bundle, avoiding the dynamic style injection that can cause layout thrashing in some CSS-in-JS libraries.\n\n3. **Minimal Runtime Overhead**: There's no JavaScript required to apply the styles at runtime, unlike many CSS-in-JS solutions that need to execute code to generate and inject styles.\n\n4. **Efficient Class-based Scoping**: Svelte uses simple class selectors for scoping, which browsers can process very efficiently.\n\n### Comparison with Other Styling Approaches\n\n#### Svelte vs. CSS-in-JS (styled-components, emotion, etc.)\n\n**Svelte:**\n- â No runtime style generation or injection\n- â No style props parsing at runtime\n- â Smaller JavaScript bundle (styles aren't in JS)\n- â No style duplication across component instances\n- â Native CSS syntax with full language features\n\n**CSS-in-JS:**\n- â Runtime overhead for style processing\n- â Additional JavaScript bundle size\n- â Dynamic styles based on props (more flexible)\n- â No build step required for some implementations\n- â Automatic critical CSS extraction in some libraries\n\nExample of CSS-in-JS (styled-components):\n```jsx\nconst Button = styled.button`\n  background-color: ${props => props.primary ? 'blue' : 'gray'};\n  color: white;\n  padding: 8px 16px;\n`;\n```\n\nEquivalent in Svelte:\n```svelte\n<script>\n  export let primary = false;\n</script>\n\n<button class:primary>Click me</button>\n\n<style>\n  button {\n    background-color: gray;\n    color: white;\n    padding: 8px 16px;\n  }\n  \n  .primary {\n    background-color: blue;\n  }\n</style>\n```\n\n#### Svelte vs. CSS Modules\n\n**Svelte:**\n- â No need for import statements for styles\n- â More concise syntax\n- â Component and styles are co-located in the same file\n- â Automatic scoping without naming conventions\n\n**CSS Modules:**\n- â Separate style files can be easier to manage in large projects\n- â Potentially better for teams with dedicated CSS developers\n- â Works with any framework\n- â Requires import statements and class application\n\nExample of CSS Modules (React):\n```css\n/* Button.module.css */\n.button {\n  background-color: gray;\n  color: white;\n  padding: 8px 16px;\n}\n\n.primary {\n  background-color: blue;\n}\n```\n\n```jsx\nimport styles from './Button.module.css';\n\nfunction Button({ primary, children }) {\n  return (\n    <button className={`${styles.button} ${primary ? styles.primary : ''}`}>\n      {children}\n    </button>\n  );\n}\n```\n\nEquivalent in Svelte:\n```svelte\n<script>\n  export let primary = false;\n</script>\n\n<button class:primary>\n  <slot></slot>\n</button>\n\n<style>\n  button {\n    background-color: gray;\n    color: white;\n    padding: 8px 16px;\n  }\n  \n  .primary {\n    background-color: blue;\n  }\n</style>\n```\n\n#### Svelte vs. Utility-First CSS (Tailwind, etc.)\n\n**Svelte:**\n- â Separation of concerns (HTML structure vs. styling)\n- â More readable component templates\n- â True style encapsulation\n\n**Utility CSS:**\n- â No context switching between files\n- â Consistent design constraints\n- â Less CSS overall in the project\n- â Verbose class lists in templates\n\nExample with Tailwind:\n```html\n<button class=\"bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded\">\n  Click me\n</button>\n```\n\nIn Svelte:\n```svelte\n<button>Click me</button>\n\n<style>\n  button {\n    background-color: rgb(107, 114, 128);\n    color: white;\n    font-weight: bold;\n    padding: 0.5rem 1rem;\n    border-radius: 0.25rem;\n  }\n  \n  button:hover {\n    background-color: rgb(55, 65, 81);\n  }\n</style>\n```\n\n### Real-world Performance Considerations\n\nIn real-world applications, Svelte's approach offers several practical advantages:\n\n1. **Faster Initial Render**: With no runtime style calculation, components render faster.\n\n2. **Smaller Bundle Size**: Styles aren't duplicated in the JavaScript bundle.\n\n3. **Better Mobile Performance**: Less JavaScript processing means better performance on lower-powered devices.\n\n4. **Efficient Updates**: When component state changes, there's no need to recalculate styles.\n\nHere's a performance-focused example:\n\n```svelte\n<script>\n  // Even with many items and frequent updates,\n  // the styling system adds no performance overhead\n  export let items = [];\n</script>\n\n{#each items as item (item.id)}\n  <div class=\"item\" class:completed={item.completed}>\n    {item.text}\n  </div>\n{/each}\n\n<style>\n  .item {\n    padding: 10px;\n    border-bottom: 1px solid #eee;\n    transition: background-color 0.2s;\n  }\n  \n  .completed {\n    background-color: #f8f8f8;\n    text-decoration: line-through;\n    color: #888;\n  }\n</style>\n```\n\nIn summary, Svelte's approach to scoped styling offers an excellent balance of developer experience and runtime performance. It provides true style encapsulation with no runtime overhead, making it particularly well-suited for performance-critical applications and devices with limited resources."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"How can you use Svelte's scoped styles to implement a component with multiple visual states, and what are the best practices for managing complex styling variations?","answer":"Implementing components with multiple visual states in Svelte can be done efficiently using its scoped styling system combined with reactive class bindings. Here's a comprehensive approach to managing complex styling variations:\n\n### Basic State-Based Styling\n\nThe simplest approach is to use class bindings to apply different styles based on component state:\n\n```svelte\n<script>\n  export let variant = 'default'; // 'default', 'primary', 'danger'\n  export let size = 'medium';     // 'small', 'medium', 'large'\n  export let disabled = false;\n  export let loading = false;\n</script>\n\n<button \n  class=\"button\"\n  class:primary={variant === 'primary'} \n  class:danger={variant === 'danger'}\n  class:small={size === 'small'}\n  class:large={size === 'large'}\n  class:disabled\n  class:loading\n  disabled={disabled || loading}\n>\n  {#if loading}\n    <span class=\"spinner\"></span>\n  {/if}\n  <slot></slot>\n</button>\n\n<style>\n  .button {\n    font-family: inherit;\n    border: none;\n    border-radius: 4px;\n    padding: 0.5rem 1rem;\n    cursor: pointer;\n    background-color: #e0e0e0;\n    color: #333;\n    transition: all 0.2s;\n  }\n  \n  /* Variants */\n  .primary {\n    background-color: #3498db;\n    color: white;\n  }\n  \n  .danger {\n    background-color: #e74c3c;\n    color: white;\n  }\n  \n  /* Sizes */\n  .small {\n    font-size: 0.8rem;\n    padding: 0.3rem 0.7rem;\n  }\n  \n  .large {\n    font-size: 1.2rem;\n    padding: 0.7rem 1.5rem;\n  }\n  \n  /* States */\n  .disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n  \n  .loading {\n    position: relative;\n    color: transparent;\n  }\n  \n  .spinner {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    width: 1rem;\n    height: 1rem;\n    border: 2px solid rgba(255, 255, 255, 0.3);\n    border-radius: 50%;\n    border-top-color: white;\n    animation: spin 1s linear infinite;\n  }\n  \n  @keyframes spin {\n    to { transform: translate(-50%, -50%) rotate(360deg); }\n  }\n  \n  /* Hover states (excluding disabled) */\n  .button:not(.disabled):hover {\n    filter: brightness(1.1);\n  }\n  \n  /* Active states (excluding disabled) */\n  .button:not(.disabled):active {\n    transform: translateY(1px);\n  }\n</style>\n```\n\n### Advanced Techniques for Complex Components\n\nFor more complex components, you can use these additional techniques:\n\n#### 1. CSS Custom Properties for Theme Variations\n\n```svelte\n<script>\n  export let theme = 'light'; // 'light', 'dark', 'custom'\n  export let accentColor = '#3498db';\n</script>\n\n<div class=\"card\" class:dark={theme === 'dark'} style=\"--accent-color: {accentColor}\">\n  <slot></slot>\n</div>\n\n<style>\n  .card {\n    --bg-color: white;\n    --text-color: #333;\n    --border-color: #eee;\n    \n    background-color: var(--bg-color);\n    color: var(--text-color);\n    border: 1px solid var(--border-color);\n    border-left: 3px solid var(--accent-color);\n    padding: 1rem;\n    border-radius: 4px;\n  }\n  \n  .dark {\n    --bg-color: #2c3e50;\n    --text-color: #ecf0f1;\n    --border-color: #34495e;\n  }\n</style>\n```\n\n#### 2. Compound Selectors for Component States\n\n```svelte\n<script>\n  export let expanded = false;\n  export let hasError = false;\n</script>\n\n<div class=\"accordion\" class:expanded class:error={hasError}>\n  <div class=\"header\" on:click={() => expanded = !expanded}>\n    <slot name=\"header\"></slot>\n    <span class=\"icon\"></span>\n  </div>\n  \n  <div class=\"content\">\n    <slot></slot>\n  </div>\n</div>\n\n<style>\n  .accordion {\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    overflow: hidden;\n  }\n  \n  .header {\n    padding: 1rem;\n    background-color: #f5f5f5;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    cursor: pointer;\n  }\n  \n  .icon {\n    width: 10px;\n    height: 10px;\n    border-right: 2px solid #666;\n    border-bottom: 2px solid #666;\n    transform: rotate(45deg);\n    transition: transform 0.3s;\n  }\n  \n  .content {\n    max-height: 0;\n    padding: 0 1rem;\n    overflow: hidden;\n    transition: all 0.3s;\n  }\n  \n  /* Compound selectors for different states */\n  .expanded .icon {\n    transform: rotate(-135deg);\n  }\n  \n  .expanded .content {\n    max-height: 500px; /* Arbitrary large value */\n    padding: 1rem;\n  }\n  \n  .error {\n    border-color: #e74c3c;\n  }\n  \n  .error .header {\n    background-color: #fde2e2;\n    color: #c0392b;\n  }\n</style>\n```\n\n#### 3. Using Parent Selectors for Context-Aware Styling\n\n```svelte\n<script>\n  export let compact = false;\n  export let items = [];\n</script>\n\n<ul class=\"list\" class:compact>\n  {#each items as item}\n    <li class=\"item\">\n      <div class=\"title\">{item.title}</div>\n      <div class=\"description\">{item.description}</div>\n    </li>\n  {/each}\n</ul>\n\n<style>\n  .list {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n  }\n  \n  .item {\n    padding: 1rem;\n    border-bottom: 1px solid #eee;\n  }\n  \n  .title {\n    font-weight: bold;\n    margin-bottom: 0.5rem;\n  }\n  \n  .description {\n    color: #666;\n  }\n  \n  /* Parent selector modifies children */\n  .compact .item {\n    padding: 0.5rem;\n  }\n  \n  .compact .title {\n    margin-bottom: 0.2rem;\n    font-size: 0.9rem;\n  }\n  \n  .compact .description {\n    font-size: 0.8rem;\n  }\n</style>\n```\n\n### Best Practices for Managing Complex Styling Variations\n\n1. **Organize Styles Logically**: Group styles by feature or state rather than by CSS property.\n\n```svelte\n<style>\n  /* Base styles */\n  .button { /* ... */ }\n  \n  /* Variants section */\n  .primary { /* ... */ }\n  .secondary { /* ... */ }\n  \n  /* Size variations section */\n  .small { /* ... */ }\n  .large { /* ... */ }\n  \n  /* State variations section */\n  .disabled { /* ... */ }\n  .loading { /* ... */ }\n</style>\n```\n\n2. **Use CSS Custom Properties for Themeable Values**:\n\n```svelte\n<script>\n  export let theme = 'default';\n</script>\n\n<div class=\"component\" class:dark={theme === 'dark'}>\n  <slot></slot>\n</div>\n\n<style>\n  .component {\n    /* Base theme values */\n    --primary-color: #3498db;\n    --text-color: #333;\n    --background: white;\n    \n    color: var(--text-color);\n    background: var(--background);\n  }\n  \n  .dark {\n    /* Override theme values */\n    --primary-color: #5dade2;\n    --text-color: #ecf0f1;\n    --background: #2c3e50;\n  }\n</style>\n```\n\n3. **Create Component Composition Systems**:\n\nInstead of one complex component with many variations, consider creating a family of components:\n\n```svelte\n<!-- Button.svelte - Base button component -->\n<script>\n  export let type = 'button';\n  export let disabled = false;\n</script>\n\n<button {type} {disabled} class=\"btn\" on:click>\n  <slot></slot>\n</button>\n\n<style>\n  .btn {\n    /* Base button styles */\n  }\n</style>\n\n<!-- PrimaryButton.svelte -->\n<script>\n  import Button from './Button.svelte';\n  export let disabled = false;\n</script>\n\n<Button disabled={disabled} class=\"primary\" on:click>\n  <slot></slot>\n</Button>\n\n<style>\n  :global(.primary) {\n    background-color: #3498db;\n    color: white;\n  }\n</style>\n```\n\n4. **Use SCSS with Svelte for More Complex Projects**:\n\nFor very complex styling needs, you can use SCSS with Svelte:\n\n```svelte\n<style lang=\"scss\">\n  $primary-color: #3498db;\n  $danger-color: #e74c3c;\n  \n  .button {\n    padding: 0.5rem 1rem;\n    border-radius: 4px;\n    \n    &.primary {\n      background-color: $primary-color;\n      color: white;\n      \n      &:hover {\n        background-color: darken($primary-color, 10%);\n      }\n    }\n    \n    &.danger {\n      background-color: $danger-color;\n      color: white;\n      \n      &:hover {\n        background-color: darken($danger-color, 10%);\n      }\n    }\n    \n    &.disabled {\n      opacity: 0.6;\n      pointer-events: none;\n    }\n  }\n</style>\n```\n\n5. **Create a Design System with Component Props**:\n\n```svelte\n<script>\n  // Define a consistent API for styling variations\n  export let variant = 'default'; // 'default', 'primary', 'danger'\n  export let size = 'md';         // 'sm', 'md', 'lg'\n  export let outlined = false;\n  export let rounded = false;\n  export let disabled = false;\n  \n  // Map props to class names\n  $: classes = [\n    'component',\n    `variant-${variant}`,\n    `size-${size}`,\n    outlined && 'outlined',\n    rounded && 'rounded',\n    disabled && 'disabled'\n  ].filter(Boolean).join(' ');\n</script>\n\n<div class={classes}>\n  <slot></slot>\n</div>\n\n<style>\n  /* Base styles */\n  .component { /* ... */ }\n  \n  /* Variants */\n  .variant-default { /* ... */ }\n  .variant-primary { /* ... */ }\n  .variant-danger { /* ... */ }\n  \n  /* Sizes */\n  .size-sm { /* ... */ }\n  .size-md { /* ... */ }\n  .size-lg { /* ... */ }\n  \n  /* Modifiers */\n  .outlined { /* ... */ }\n  .rounded { /* ... */ }\n  .disabled { /* ... */ }\n</style>\n```\n\nBy combining these techniques, you can create highly flexible components with multiple visual states while maintaining the benefits of Svelte's scoped styling system. This approach keeps your components maintainable and your CSS organized, even as styling complexity increases."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"Can you explain how Svelte's scoped styles work with nested components, and what happens when parent and child components have styles targeting the same elements?","answer":"Svelte's scoped styling system has specific behaviors when dealing with nested components and when parent and child components target the same elements. Understanding these behaviors is crucial for creating predictable and maintainable component hierarchies.\n\n### How Scoped Styles Work with Nested Components\n\nIn Svelte, when components are nested, each component's styles remain isolated to that specific component. The scoping mechanism (adding unique classes like `svelte-xyz123`) ensures that styles from a parent component don't leak into child components and vice versa.\n\nHere's a basic example of nested components:\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n</script>\n\n<div class=\"parent\">\n  <h2>Parent Component</h2>\n  <p>This is styled by the parent's styles</p>\n  <ChildComponent />\n</div>\n\n<style>\n  .parent {\n    border: 2px solid blue;\n    padding: 20px;\n  }\n  \n  h2 {\n    color: blue;\n  }\n  \n  p {\n    color: navy;\n  }\n</style>\n```\n\n```svelte\n<!-- ChildComponent.svelte -->\n<div class=\"child\">\n  <h2>Child Component</h2>\n  <p>This is styled by the child's styles</p>\n</div>\n\n<style>\n  .child {\n    border: 2px solid red;\n    padding: 10px;\n    margin-top: 10px;\n  }\n  \n  h2 {\n    color: red;\n  }\n  \n  p {\n    color: maroon;\n  }\n</style>\n```\n\nIn this example:\n- The parent's `h2` and `p` styles only affect elements in the parent component\n- The child's `h2` and `p` styles only affect elements in the child component\n- There's no style collision, even though both components target the same element types\n\nBehind the scenes, Svelte adds unique class names to each component's elements:\n\n```html\n<!-- Conceptual rendered output -->\n<div class=\"parent svelte-parent123\">\n  <h2 class=\"svelte-parent123\">Parent Component</h2>\n  <p class=\"svelte-parent123\">This is styled by the parent's styles</p>\n  \n  <div class=\"child svelte-child456\">\n    <h2 class=\"svelte-child456\">Child Component</h2>\n    <p class=\"svelte-child456\">This is styled by the child's styles</p>\n  </div>\n</div>\n```\n\n### What Happens When Parent and Child Target the Same Elements\n\nWhen it comes to styling the same elements across parent and child components, there are several important behaviors to understand:\n\n#### 1. Styles Don't Cascade Down to Child Components\n\nA parent component's styles do not affect elements inside child components, even if the selectors would match. Each component's scope is completely isolated.\n\n#### 2. Slots Content is Styled by the Parent\n\nContent passed through slots is styled by the parent component that owns the content, not by the component that renders the slot:\n\n```svelte\n<!-- ParentWithSlot.svelte -->\n<script>\n  import ChildWithSlot from './ChildWithSlot.svelte';\n</script>\n\n<ChildWithSlot>\n  <p>This content is styled by the parent</p>\n</ChildWithSlot>\n\n<style>\n  p {\n    color: purple;\n    font-weight: bold;\n  }\n</style>\n```\n\n```svelte\n<!-- ChildWithSlot.svelte -->\n<div class=\"child\">\n  <h2>Child Component</h2>\n  <slot></slot>\n</div>\n\n<style>\n  .child {\n    border: 2px solid orange;\n    padding: 10px;\n  }\n  \n  p {\n    color: orange; /* This won't affect slotted content */\n  }\n</style>\n```\n\nIn this example, the paragraph inside the slot will be purple (styled by the parent), not orange, because the content belongs to the parent component even though it's rendered inside the child.\n\n#### 3. Using Global Styles to Target Child Components\n\nIf you do need a parent component to style elements within child components, you can use the `:global()` selector, but this should be used sparingly:\n\n```svelte\n<!-- ParentStylingChild.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n</script>\n\n<div class=\"parent\">\n  <ChildComponent />\n</div>\n\n<style>\n  .parent :global(.child) {\n    /* This will affect the child component */\n    margin: 20px;\n    box-shadow: 0 0 10px rgba(0,0,0,0.1);\n  }\n  \n  /* This approach should be used carefully */\n  .parent :global(.child h2) {\n    text-decoration: underline;\n  }\n</style>\n```\n\n### Practical Examples and Best Practices\n\n#### Example 1: Creating a Theme Provider\n\nA common use case is creating a theme that affects nested components:\n\n```svelte\n<!-- ThemeProvider.svelte -->\n<script>\n  export let theme = 'light'; // 'light' or 'dark'\n</script>\n\n<div class=\"theme-provider\" class:dark={theme === 'dark'}>\n  <slot></slot>\n</div>\n\n<style>\n  .theme-provider {\n    /* Light theme variables */\n    --background: white;\n    --text-color: #333;\n    --border-color: #ddd;\n    --accent-color: #3498db;\n  }\n  \n  .dark {\n    /* Dark theme variables */\n    --background: #2c3e50;\n    --text-color: #ecf0f1;\n    --border-color: #34495e;\n    --accent-color: #5dade2;\n  }\n</style>\n```\n\n```svelte\n<!-- ThemedButton.svelte -->\n<button class=\"button\">\n  <slot></slot>\n</button>\n\n<style>\n  .button {\n    background-color: var(--accent-color, #3498db);\n    color: var(--text-color, #333);\n    border: 1px solid var(--border-color, #ddd);\n    padding: 0.5rem 1rem;\n    border-radius: 4px;\n  }\n</style>\n```\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import ThemeProvider from './ThemeProvider.svelte';\n  import ThemedButton from './ThemedButton.svelte';\n  \n  let darkMode = false;\n</script>\n\n<ThemeProvider theme={darkMode ? 'dark' : 'light'}>\n  <div class=\"app\">\n    <h1>Themed App</h1>\n    <ThemedButton>Click Me</ThemedButton>\n    <label>\n      <input type=\"checkbox\" bind:checked={darkMode}>\n      Dark Mode\n    </label>\n  </div>\n</ThemeProvider>\n\n<style>\n  .app {\n    padding: 20px;\n    background-color: var(--background, white);\n    color: var(--text-color, #333);\n    min-height: 100vh;\n  }\n  \n  h1 {\n    color: var(--accent-color, #3498db);\n  }\n</style>\n```\n\nIn this example, the theme variables cascade down to child components through CSS variables, not through Svelte's scoping mechanism.\n\n#### Example 2: Layout Components with Slotted Content\n\n```svelte\n<!-- Card.svelte -->\n<div class=\"card\">\n  <div class=\"card-header\">\n    <slot name=\"header\">Default Header</slot>\n  </div>\n  <div class=\"card-body\">\n    <slot></slot>\n  </div>\n  <div class=\"card-footer\">\n    <slot name=\"footer\"></slot>\n  </div>\n</div>\n\n<style>\n  .card {\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    overflow: hidden;\n  }\n  \n  .card-header {\n    padding: 1rem;\n    background-color: #f5f5f5;\n    border-bottom: 1px solid #ddd;\n    font-weight: bold;\n  }\n  \n  .card-body {\n    padding: 1rem;\n  }\n  \n  .card-footer {\n    padding: 1rem;\n    background-color: #f5f5f5;\n    border-top: 1px solid #ddd;\n  }\n</style>\n```\n\n```svelte\n<!-- Usage -->\n<Card>\n  <svelte:fragment slot=\"header\">\n    <h2>Custom Header</h2>\n  </svelte:fragment>\n  \n  <p>This is the card content.</p>\n  <p>It can have multiple paragraphs.</p>\n  \n  <svelte:fragment slot=\"footer\">\n    <button>Action</button>\n  </svelte:fragment>\n</Card>\n\n<style>\n  h2 {\n    margin: 0;\n    color: #3498db;\n  }\n  \n  p {\n    margin: 0 0 1rem 0;\n  }\n  \n  button {\n    background-color: #3498db;\n    color: white;\n    border: none;\n    padding: 0.5rem 1rem;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n</style>\n```\n\nIn this example:\n- The Card component provides the structure and basic styling\n- The parent component styles its own content (h2, p, button)\n- Each component's styles remain isolated to their own elements\n\n### Best Practices for Nested Component Styling\n\n1. **Prefer Component Composition**: Build UI by composing smaller, well-styled components rather than trying to style child components from parents.\n\n2. **Use CSS Variables for Theming**: Pass design tokens and theme values through CSS variables rather than trying to directly style child components.\n\n3. **Respect Component Boundaries**: Avoid using `:global()` to reach into child components when possible.\n\n4. **Document Style Dependencies**: If a component expects certain CSS variables to be defined, document this in comments or props.\n\n5. **Style Slot Content in the Parent**: Remember that slotted content should be styled where it's defined, not where it's rendered.\n\nBy understanding these principles, you can create maintainable component hierarchies with predictable styling behavior, leveraging Svelte's scoped styling system to its full potential."}
{"source":"docs/svelte/04-styling/01-scoped-styles.md","question":"What are the limitations of Svelte's scoped styling approach, and how can you work around them when necessary?","answer":"While Svelte's scoped styling system offers many benefits, it does have some limitations that developers should be aware of. Understanding these limitations and knowing the appropriate workarounds is essential for building complex applications effectively.\n\n### Limitations of Svelte's Scoped Styling\n\n#### 1. No Direct Styling of Child Components\n\n**Limitation**: A parent component cannot directly style elements inside a child component using scoped styles.\n\n**Example of what doesn't work**:\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n</script>\n\n<div class=\"parent\">\n  <ChildComponent />\n</div>\n\n<style>\n  /* This won't affect elements inside ChildComponent */\n  .parent h2 {\n    color: blue;\n  }\n</style>\n```\n\n#### 2. Limited Dynamic Styling Based on Props\n\n**Limitation**: Svelte's scoped CSS doesn't have a built-in way to create truly dynamic styles based on prop values (unlike CSS-in-JS libraries).\n\n**Example of limitation**:\n```svelte\n<script>\n  export let buttonColor = '#3498db'; // We can't directly use this in CSS\n</script>\n\n<button class=\"button\">Click me</button>\n\n<style>\n  .button {\n    /* Can't use buttonColor prop directly here */\n    background-color: #3498db; /* Hardcoded value */\n  }\n</style>\n```\n\n#### 3. No Automatic Vendor Prefixing\n\n**Limitation**: Svelte doesn't automatically add vendor prefixes to CSS properties that might need them for cross-browser compatibility.\n\n#### 4. No Built-in Support for CSS Preprocessors\n\n**Limitation**: Svelte doesn't have built-in support for CSS preprocessors like SASS or LESS (though they can be added with plugins).\n\n#### 5. Specificity Challenges with Global Styles\n\n**Limitation**: When mixing scoped and global styles, specificity conflicts can arise that are sometimes difficult to manage.\n\n#### 6. Limited Access to Parent Context in CSS\n\n**Limitation**: CSS in a component doesn't have awareness of the component's context (like its position in the DOM hierarchy).\n\n### Workarounds and Solutions\n\n#### 1. For Styling Child Components\n\n**Solution A: Use CSS Variables**\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n</script>\n\n<div class=\"parent\">\n  <ChildComponent --header-color=\"blue\" --header-font-size=\"24px\" />\n</div>\n\n<style>\n  .parent {\n    /* Define variables that child components can use */\n    --header-color: red; /* Default value */\n    --header-font-size: 18px; /* Default value */\n  }\n</style>\n```\n\n```svelte\n<!-- ChildComponent.svelte -->\n<div class=\"child\">\n  <h2>Child Component</h2>\n</div>\n\n<style>\n  h2 {\n    /* Use variables passed from parent */\n    color: var(--header-color, black); /* fallback to black */\n    font-size: var(--header-font-size, 16px); /* fallback to 16px */\n  }\n</style>\n```\n\n**Solution B: Use Global Selectors Carefully**\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n</script>\n\n<div class=\"parent\">\n  <ChildComponent />\n</div>\n\n<style>\n  /* Use :global() to target specific child elements */\n  .parent :global(.child-heading) {\n    color: blue;\n  }\n</style>\n```\n\n```svelte\n<!-- ChildComponent.svelte -->\n<div class=\"child\">\n  <!-- Use a consistent class name that parent can target -->\n  <h2 class=\"child-heading\">Child Component</h2>\n</div>\n```\n\n#### 2. For Dynamic Styling Based on Props\n\n**Solution A: Use inline styles for truly dynamic values**\n\n```svelte\n<script>\n  export let buttonColor = '#3498db';\n  export let textColor = 'white';\n</script>\n\n<button \n  class=\"button\" \n  style=\"--button-color: {buttonColor}; --text-color: {textColor};\"\n>\n  Click me\n</button>\n\n<style>\n  .button {\n    background-color: var(--button-color);\n    color: var(--text-color);\n    padding: 0.5rem 1rem;\n    border: none;\n    border-radius: 4px;\n  }\n</style>\n```\n\n**Solution B: Use class bindings for predefined variants**\n\n```svelte\n<script>\n  export let variant = 'default'; // 'default', 'primary', 'danger'\n  export let size = 'medium'; // 'small', 'medium', 'large'\n</script>\n\n<button \n  class=\"button\"\n  class:primary={variant === 'primary'} \n  class:danger={variant === 'danger'}\n  class:small={size === 'small'}\n  class:large={size === 'large'}\n>\n  Click me\n</button>\n\n<style>\n  .button {\n    /* Base styles */\n    background-color: #e0e0e0;\n    color: #333;\n  }\n  \n  .primary {\n    background-color: #3498db;\n    color: white;\n  }\n  \n  .danger {\n    background-color: #e74c3c;\n    color: white;\n  }\n  \n  .small { font-size: 0.8rem; }\n  .large { font-size: 1.2rem; }\n</style>\n```\n\n#### 3. For Vendor Prefixing\n\n**Solution: Use PostCSS with autoprefixer**\n\nConfigure your Svelte project with PostCSS and autoprefixer:\n\n```js\n// svelte.config.js\nimport autoprefixer from 'autoprefixer';\n\nconst config = {\n  preprocess: {\n    style: {\n      postcss: {\n        plugins: [\n          autoprefixer\n        ]\n      }\n    }\n  }\n};\n\nexport default config;\n```\n\n#### 4. For CSS Preprocessors\n\n**Solution: Use svelte-preprocess**\n\n```js\n// svelte.config.js\nimport preprocess from 'svelte-preprocess';\n\nconst config = {\n  preprocess: preprocess({\n    scss: {\n      // scss options\n    },\n    postcss: true\n  })\n};\n\nexport default config;\n```\n\nThen in your component:\n\n```svelte\n<style lang=\"scss\">\n  $primary-color: #3498db;\n  \n  .button {\n    background-color: $primary-color;\n    \n    &:hover {\n      background-color: darken($primary-color, 10%);\n    }\n    \n    &.large {\n      font-size: 1.2rem;\n    }\n  }\n</style>\n```\n\n#### 5. For Specificity Challenges\n\n**Solution A: Use more specific selectors in your global CSS**\n\n```css\n/* global.css */\n/* Instead of this */\np {\n  color: black;\n}\n\n/* Use this */\nbody p {\n  color: black;\n}\n```\n\n**Solution B: Use `!important` sparingly in global styles**\n\n```css\n/* global.css - use sparingly! */\n.global-important-text {\n  color: red !important;\n}\n```\n\n**Solution C: Structure your CSS to minimize conflicts**\n\n```svelte\n<!-- App.svelte -->\n<style>\n  /* Put global styles in a top-level component */\n  :global(html, body) {\n    margin: 0;\n    padding: 0;\n  }\n  \n  :global(body) {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    line-height: 1.6;\n  }\n  \n  /* Use namespacing for global utilities */\n  :global(.util-center) {\n    text-align: center;\n  }\n</style>\n```\n\n#### 6. For Parent Context Awareness\n\n**Solution: Pass context information via props or CSS variables**\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import ChildComponent from './ChildComponent.svelte';\n  let isInSidebar = true;\n</script>\n\n<div class=\"container\" class:sidebar={isInSidebar}>\n  <ChildComponent inSidebar={isInSidebar} />\n</div>\n\n<style>\n  .container {\n    --is-in-sidebar: 0;\n    padding: 20px;\n  }\n  \n  .sidebar {\n    --is-in-sidebar: 1;\n    background-color: #f5f5f5;\n  }\n</style>\n```\n\n```svelte\n<!-- ChildComponent.svelte -->\n<script>\n  export let inSidebar = false;\n</script>\n\n<div class=\"child\" class:sidebar-child={inSidebar}>\n  Content\n</div>\n\n<style>\n  .child {\n    padding: 10px;\n    /* Can use CSS variable approach too */\n    margin: calc(var(--is-in-sidebar, 0) * 10px);\n  }\n  \n  .sidebar-child {\n    font-size: 0.9rem;\n  }\n</style>\n```\n\n### Real-World Example: Building a Flexible Component System\n\nHere's a comprehensive example that addresses multiple limitations by creating a flexible card component system:\n\n```svelte\n<!-- Theme.svelte - Global theme provider -->\n<script>\n  export let theme = 'light'; // 'light', 'dark', 'custom'\n  export let customColors = {};\n  \n  // Derive theme variables\n  $: themeVars = {\n    light: {\n      backgroundColor: '#ffffff',\n      textColor: '#333333',\n      primaryColor: '#3498db',\n      secondaryColor: '#2ecc71',\n      borderColor: '#e0e0e0'\n    },\n    dark: {\n      backgroundColor: '#2c3e50',\n      textColor: '#ecf0f1',\n      primaryColor: '#3498db',\n      secondaryColor: '#2ecc71',\n      borderColor: '#34495e'\n    },\n    custom: customColors\n  }[theme];\n</script>\n\n<div \n  class=\"theme-provider\"\n  style=\"\n    --background: {themeVars.backgroundColor};\n    --text-color: {themeVars.textColor};\n    --primary: {themeVars.primaryColor};\n    --secondary: {themeVars.secondaryColor};\n    --border-color: {themeVars.borderColor};\n  \"\n>\n  <slot></slot>\n</div>\n\n<style>\n  .theme-provider {\n    /* Fallback values if not set */\n    --background: #ffffff;\n    --text-color: #333333;\n    --primary: #3498db;\n    --secondary: #2ecc71;\n    --border-color: #e0e0e0;\n  }\n</style>\n```\n\n```svelte\n<!-- Card.svelte - Flexible card component -->\n<script>\n  export let variant = 'default'; // 'default', 'primary', 'outlined'\n  export let size = 'medium'; // 'small', 'medium', 'large'\n  export let elevation = 1; // 0-5\n  export let fullWidth = false;\n  \n  // Calculate dynamic styles\n  $: shadowStyle = elevation > 0 \n    ? `0 ${elevation * 2}px ${elevation * 3}px rgba(0,0,0,${0.1 + elevation * 0.05})` \n    : 'none';\n</script>\n\n<div \n  class=\"card\"\n  class:primary={variant === 'primary'}\n  class:outlined={variant === 'outlined'}\n  class:small={size === 'small'}\n  class:large={size === 'large'}\n  class:full-width={fullWidth}\n  style=\"--card-shadow: {shadowStyle};\"\n>\n  <slot></slot>\n</div>\n\n<style>\n  .card {\n    background-color: var(--background, white);\n    color: var(--text-color, #333);\n    border-radius: 4px;\n    padding: 1rem;\n    box-shadow: var(--card-shadow, none);\n    border: 1px solid transparent;\n    transition: all 0.2s ease;\n  }\n  \n  .primary {\n    background-color: var(--primary, #3498db);\n    color: white;\n  }\n  \n  .outlined {\n    border-color: var(--border-color, #e0e0e0);\n    box-shadow: none;\n  }\n  \n  .small {\n    padding: 0.5rem;\n    font-size: 0.9rem;\n  }\n  \n  .large {\n    padding: 1.5rem;\n    font-size: 1.1rem;\n  }\n  \n  .full-width {\n    width: 100%;\n  }\n</style>\n```\n\n```svelte\n<!-- CardContent.svelte - Example of a child component -->\n<script>\n  export let padded = true;\n</script>\n\n<div class=\"card-content\" class:padded>\n  <slot></slot>\n</div>\n\n<style>\n  .card-content {\n    /* Uses variables from parent context */\n    color: var(--text-color, inherit);\n  }\n  \n  .padded {\n    padding: 0.5rem 0;\n  }\n</style>\n```\n\n```svelte\n<!-- App.svelte - Usage example -->\n<script>\n  import Theme from './Theme.svelte';\n  import Card from './Card.svelte';\n  import CardContent from './CardContent.svelte';\n  \n  let currentTheme = 'light';\n  let customColors = {\n    backgroundColor: '#f9f7f7',\n    textColor: '#112d4e',\n    primaryColor: '#3f72af',\n    secondaryColor: '#dbe2ef',\n    borderColor: '#dbe2ef'\n  };\n</script>\n\n<Theme theme={currentTheme} customColors={customColors}>\n  <div class=\"app\">\n    <h1>Card Examples</h1>\n    \n    <div class=\"card-grid\">\n      <Card>\n        <CardContent>\n          <h2>Default Card</h2>\n          <p>This is a default card with medium size.</p>\n        </CardContent>\n      </Card>\n      \n      <Card variant=\"primary\" size=\"large\" elevation={3}>\n        <CardContent>\n          <h2>Primary Card</h2>\n          <p>This is a primary card with large size and elevation.</p>\n        </CardContent>\n      </Card>\n      \n      <Card variant=\"outlined\" size=\"small\">\n        <CardContent>\n          <h2>Outlined Card</h2>\n          <p>This is an outlined card with small size.</p>\n        </CardContent>\n      </Card>\n    </div>\n    \n    <div class=\"theme-controls\">\n      <button on:click={() => currentTheme = 'light'}>Light Theme</button>\n      <button on:click={() => currentTheme = 'dark'}>Dark Theme</button>\n      <button on:click={() => currentTheme = 'custom'}>Custom Theme</button>\n    </div>\n  </div>\n</Theme>\n\n<style>\n  .app {\n    padding: 2rem;\n    background-color: var(--background);\n    color: var(--text-color);\n    min-height: 100vh;\n  }\n  \n  h1 {\n    color: var(--primary);\n    margin-bottom: 2rem;\n  }\n  \n  .card-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 1rem;\n    margin-bottom: 2rem;\n  }\n  \n  .theme-controls {\n    display: flex;\n    gap: 1rem;\n  }\n  \n  button {\n    background-color: var(--primary);\n    color: white;\n    border: none;\n    padding: 0.5rem 1rem;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  \n  /* Global styles for content inside cards */\n  :global(.card-content h2) {\n    margin-top: 0;\n    font-size: 1.2rem;\n  }\n  \n  :global(.card-content p) {\n    margin-bottom: 0;\n  }\n</style>\n```\n\n### Summary of Workarounds for Svelte's Styling Limitations\n\n1. **For styling across component boundaries**:\n   - Use CSS variables to pass styling information\n   - Create well-documented class hooks with `:global()`\n   - Build component composition systems\n\n2. **For dynamic styling**:\n   - Use inline style bindings with CSS variables\n   - Use class bindings for predefined variations\n   - Combine both approaches for maximum flexibility\n\n3. **For advanced CSS features**:\n   - Configure preprocessors with svelte-preprocess\n   - Use PostCSS for autoprefixing and other transformations\n   - Consider extracting complex styles to external files\n\n4. **For global styling needs**:\n   - Create a dedicated theme provider component\n   - Use namespaced global classes\n   - Structure global styles to minimize specificity conflicts\n\nBy understanding these limitations and implementing the appropriate workarounds, you can build sophisticated, maintainable UIs with Svelte's scoped styling system while avoiding common pitfalls."}
{"source":"docs/svelte/04-styling/02-global-styles.md","question":"How do you apply a style to a single element globally in Svelte, and what's the difference from regular component-scoped styles?","answer":"In Svelte, you can apply a style to a single element globally using the `:global(...)` modifier. This is different from regular component-scoped styles, which only apply to elements within the component.\n\nRegular component styles in Svelte are scoped by default, meaning they only apply to elements within the component. This is one of Svelte's key features for style encapsulation. However, sometimes you need styles to affect elements outside your component or elements that might be added dynamically.\n\nHere's how to use the `:global(...)` modifier:\n\n```svelte\n<style>\n  /* Regular scoped style - only affects h1 elements in this component */\n  h1 {\n    color: blue;\n  }\n  \n  /* Global style - affects all body elements in the application */\n  :global(body) {\n    margin: 0;\n    padding: 0;\n    font-family: 'Arial', sans-serif;\n  }\n  \n  /* Global style within context - affects all strong elements inside \n     div elements that belong to this component */\n  div :global(strong) {\n    color: goldenrod;\n    font-weight: 700;\n  }\n</style>\n\n<div>\n  <h1>This heading is blue (scoped)</h1>\n  <strong>This text is goldenrod (global within div context)</strong>\n  <p>Regular text with <strong>goldenrod strong text</strong></p>\n</div>\n```\n\nThe `:global(...)` modifier is particularly useful when:\n1. You need to style elements that aren't part of your component's template\n2. You're working with third-party libraries that inject HTML\n3. You want to override styles in child components\n4. You need to style elements that are added dynamically\n\nRemember that using global styles should be done judiciously, as they can lead to style conflicts and make your application harder to maintain if overused."}
{"source":"docs/svelte/04-styling/02-global-styles.md","question":"How would you create global keyframe animations in Svelte, and why is the syntax different from regular global styles?","answer":"In Svelte, to create global keyframe animations, you need to prepend your keyframe names with `-global-`. This special syntax is different from the regular `:global()` modifier used for selectors because keyframes operate differently in CSS.\n\nThe `-global-` prefix is a Svelte-specific convention that tells the compiler to make these keyframes accessible throughout your application. When compiled, Svelte removes the `-global-` part, so the keyframe will be referenced using just the name you defined after the prefix.\n\nHere's how to define and use global keyframes in Svelte:\n\n```svelte\n<script>\n  let isAnimating = true;\n</script>\n\n<style>\n  /* Define a global keyframe animation */\n  @keyframes -global-bounce {\n    0% { transform: translateY(0); }\n    50% { transform: translateY(-20px); }\n    100% { transform: translateY(0); }\n  }\n  \n  /* Using the global keyframe in a component-scoped style */\n  .bouncing-element {\n    animation: bounce 1s infinite ease-in-out;\n  }\n  \n  /* Define a component-scoped keyframe animation (for comparison) */\n  @keyframes fade {\n    from { opacity: 0; }\n    to { opacity: 1; }\n  }\n  \n  .fading-element {\n    animation: fade 2s;\n  }\n</style>\n\n<div class=\"bouncing-element\">\n  This element uses the global bounce animation\n</div>\n\n<div class=\"fading-element\">\n  This element uses the component-scoped fade animation\n</div>\n```\n\nThe syntax is different because of how CSS processes and scopes animations:\n\n1. Regular CSS selectors can be modified with the `:global()` syntax to escape Svelte's scoping\n2. Keyframes are referenced by name in animation properties, so they need a different mechanism to be made global\n3. The `-global-` prefix allows Svelte to recognize which keyframes should be accessible application-wide\n\nThis approach ensures that you can create animations that can be used across multiple components without having to redefine them in each component, while still maintaining Svelte's component-based style encapsulation system for regular CSS rules."}
{"source":"docs/svelte/04-styling/02-global-styles.md","question":"What is the difference between using `:global(...)` for a single selector and using a `:global {...}` block in Svelte?","answer":"In Svelte, there are two different ways to create global styles, each with different use cases and scopes:\n\n1. **`:global(...)`** - The modifier approach for single selectors\n2. **`:global {...}`** - The block approach for groups of selectors\n\nLet's examine the differences:\n\n**`:global(...)` Modifier**:\n- Applies to a single selector\n- Can be combined with component-scoped selectors\n- Useful for targeting specific elements globally within a context\n\n```svelte\n<style>\n  /* Makes all <h1> elements in the entire application red */\n  :global(h1) {\n    color: red;\n  }\n  \n  /* Makes strong elements within this component's divs bold and blue */\n  div :global(strong) {\n    font-weight: bold;\n    color: blue;\n  }\n  \n  /* Targets p elements in this component that have class=\"important\" */\n  /* The class might be added programmatically or by a library */\n  p:global(.important) {\n    font-size: 1.2em;\n    border-left: 3px solid red;\n    padding-left: 10px;\n  }\n</style>\n```\n\n**`:global {...}` Block**:\n- Applies to multiple selectors grouped together\n- All selectors inside the block are treated as global\n- Useful for defining a set of related global styles\n- Can be nested inside component-scoped selectors to create context-specific global styles\n\n```svelte\n<style>\n  /* All selectors in this block apply globally */\n  :global {\n    h1 {\n      margin-top: 0;\n      color: #333;\n    }\n    \n    p {\n      line-height: 1.6;\n    }\n    \n    .card {\n      border-radius: 4px;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n    }\n  }\n  \n  /* Context-specific global styles */\n  .theme-dark :global {\n    /* These apply to any elements within .theme-dark, \n       regardless of which component they belong to */\n    h1 { color: white; }\n    p { color: #ddd; }\n    .card { background-color: #333; }\n  }\n</style>\n```\n\n**Key differences**:\n\n1. **Scope**: \n   - `:global(...)` applies to a single selector\n   - `:global {...}` applies to multiple selectors\n\n2. **Syntax**: \n   - `:global(...)` wraps a single selector\n   - `:global {...}` creates a block containing multiple selectors\n\n3. **Context**: \n   - Both can be combined with component-scoped selectors to create contextual global styles\n   - `:global {...}` is more efficient when you need to make many selectors global\n\n4. **Use case**:\n   - `:global(...)` is better for targeted global styling\n   - `:global {...}` is better for comprehensive global styling\n\nChoose the approach that best fits your specific styling needs and organization preferences."}
{"source":"docs/svelte/04-styling/02-global-styles.md","question":"How can you style elements that are dynamically added by a third-party library in Svelte?","answer":"Styling elements dynamically added by third-party libraries in Svelte requires using global styles, as these elements aren't part of your component's template and therefore won't be affected by Svelte's default scoped styles. Here's how to handle this common scenario:\n\n### Using `:global(...)` for Third-Party Elements\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let container;\n  \n  onMount(() => {\n    // Simulate a third-party library adding elements\n    // This could be a chart library, rich text editor, etc.\n    const thirdPartyElement = document.createElement('div');\n    thirdPartyElement.className = 'third-party-widget';\n    \n    const header = document.createElement('h3');\n    header.textContent = 'Third-Party Widget Header';\n    header.className = 'widget-header';\n    \n    const content = document.createElement('div');\n    content.innerHTML = '<p>Widget content</p><button class=\"widget-button\">Click me</button>';\n    content.className = 'widget-content';\n    \n    thirdPartyElement.appendChild(header);\n    thirdPartyElement.appendChild(content);\n    container.appendChild(thirdPartyElement);\n  });\n</script>\n\n<style>\n  /* These styles won't affect the dynamically added elements */\n  .container {\n    border: 1px solid #ccc;\n    padding: 20px;\n    margin: 20px 0;\n  }\n  \n  /* These global styles will affect the dynamically added elements */\n  :global(.third-party-widget) {\n    background-color: #f5f5f5;\n    border-radius: 4px;\n    padding: 15px;\n    font-family: sans-serif;\n  }\n  \n  :global(.widget-header) {\n    color: #2c3e50;\n    border-bottom: 1px solid #ddd;\n    padding-bottom: 10px;\n    margin-top: 0;\n  }\n  \n  :global(.widget-content p) {\n    color: #34495e;\n    line-height: 1.5;\n  }\n  \n  :global(.widget-button) {\n    background-color: #3498db;\n    color: white;\n    border: none;\n    padding: 8px 16px;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  \n  :global(.widget-button:hover) {\n    background-color: #2980b9;\n  }\n  \n  /* You can also scope global styles to your container */\n  .container :global(.widget-button) {\n    margin-top: 10px;\n    font-weight: bold;\n  }\n</style>\n\n<div class=\"container\" bind:this={container}>\n  <!-- Third-party content will be inserted here -->\n</div>\n```\n\n### Using `:global {...}` Block for Multiple Third-Party Elements\n\nIf you need to style many elements from a third-party library, the block syntax can be more concise:\n\n```svelte\n<style>\n  /* Container for the third-party widget */\n  .rich-text-container {\n    border: 1px solid #ddd;\n    border-radius: 4px;\n  }\n  \n  /* Apply styles to all elements created by the rich text editor */\n  .rich-text-container :global {\n    /* Editor toolbar */\n    .editor-toolbar {\n      background: #f7f7f7;\n      border-bottom: 1px solid #ddd;\n      padding: 8px;\n    }\n    \n    /* Editor buttons */\n    .editor-button {\n      background: transparent;\n      border: 1px solid #ccc;\n      border-radius: 3px;\n      margin-right: 5px;\n      padding: 4px 8px;\n    }\n    \n    .editor-button:hover {\n      background: #e7e7e7;\n    }\n    \n    /* Content area */\n    .editor-content {\n      padding: 15px;\n      min-height: 200px;\n    }\n    \n    /* Different text elements the editor might create */\n    h1, h2, h3 {\n      margin-top: 0.5em;\n      margin-bottom: 0.5em;\n    }\n    \n    p {\n      margin-bottom: 1em;\n      line-height: 1.5;\n    }\n    \n    blockquote {\n      border-left: 3px solid #ccc;\n      margin-left: 0;\n      padding-left: 1em;\n      color: #777;\n    }\n    \n    code {\n      background: #f0f0f0;\n      padding: 2px 4px;\n      border-radius: 3px;\n      font-family: monospace;\n    }\n  }\n</style>\n\n<div class=\"rich-text-container\">\n  <!-- Third-party rich text editor will be initialized here -->\n</div>\n```\n\n### Best Practices When Styling Third-Party Components:\n\n1. **Be specific with selectors**: Use class names or data attributes specific to the third-party library to avoid affecting other elements.\n\n2. **Contain global styles**: Whenever possible, prefix global styles with a container selector to limit their scope.\n\n3. **Use !important judiciously**: Sometimes third-party libraries have inline styles or high-specificity selectors. You might need to use !important to override them, but use it sparingly.\n\n4. **Consider using Shadow DOM**: For complete isolation, you might want to place third-party components in a custom element with Shadow DOM.\n\n5. **Check for styling APIs**: Many libraries provide their own theming or styling APIs that might be more maintainable than CSS overrides.\n\nBy using Svelte's global styling capabilities, you can effectively style dynamically added content while maintaining a clean component structure."}
{"source":"docs/svelte/04-styling/02-global-styles.md","question":"How can you combine component-scoped styles with global styles to create context-specific styling in Svelte?","answer":"Svelte offers powerful ways to combine component-scoped styles with global styles, allowing you to create context-specific styling. This approach gives you the best of both worlds: the encapsulation benefits of component-scoped styles and the flexibility of global styles when needed.\n\n### Combining Component-Scoped and Global Styles\n\nHere are the main techniques for creating context-specific styling:\n\n#### 1. Using Component Selectors with `:global()` Modifiers\n\n```svelte\n<style>\n  /* Component-scoped container */\n  .themed-section {\n    background-color: #f9f9f9;\n    padding: 20px;\n    border-radius: 8px;\n  }\n  \n  /* Global styles that only apply within this component's .themed-section */\n  .themed-section :global(h2) {\n    color: #3498db;\n    border-bottom: 2px solid #e0e0e0;\n    padding-bottom: 8px;\n  }\n  \n  .themed-section :global(p) {\n    line-height: 1.6;\n    color: #555;\n  }\n  \n  /* Different theme variant */\n  .themed-section.dark {\n    background-color: #2c3e50;\n  }\n  \n  .themed-section.dark :global(h2) {\n    color: #ecf0f1;\n    border-bottom-color: #34495e;\n  }\n  \n  .themed-section.dark :global(p) {\n    color: #bdc3c7;\n  }\n  \n  /* Apply styles to specific element types that might be added dynamically */\n  .content-area :global(ul) {\n    padding-left: 20px;\n  }\n  \n  .content-area :global(li) {\n    margin-bottom: 8px;\n  }\n  \n  /* Target elements with specific classes, even if added programmatically */\n  .content-area :global(.note) {\n    background-color: #fffde7;\n    padding: 10px;\n    border-left: 4px solid #ffd600;\n    margin: 15px 0;\n  }\n</style>\n\n<div class=\"themed-section\" class:dark={isDarkTheme}>\n  <h2>This heading will be styled by the global style</h2>\n  <div class=\"content-area\">\n    <p>This paragraph will be styled by the global style.</p>\n    <!-- Content could be dynamically generated -->\n    <div class=\"note\">This note will be styled even if added programmatically</div>\n  </div>\n</div>\n```\n\n#### 2. Using `:global {}` Blocks with Component Context\n\n```svelte\n<script>\n  export let theme = 'light';\n</script>\n\n<style>\n  .card {\n    border-radius: 8px;\n    overflow: hidden;\n    box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n  }\n  \n  /* Light theme styles (default) */\n  .card.theme-light :global {\n    h3 {\n      color: #333;\n      background-color: #f0f0f0;\n      margin: 0;\n      padding: 15px;\n    }\n    \n    p {\n      color: #555;\n    }\n    \n    .card-body {\n      padding: 15px;\n    }\n    \n    .card-footer {\n      background-color: #f9f9f9;\n      padding: 10px 15px;\n      border-top: 1px solid #eee;\n    }\n    \n    button {\n      background-color: #4CAF50;\n      color: white;\n      border: none;\n      padding: 8px 16px;\n      border-radius: 4px;\n      cursor: pointer;\n    }\n  }\n  \n  /* Dark theme styles */\n  .card.theme-dark :global {\n    h3 {\n      color: #fff;\n      background-color: #2c3e50;\n      padding: 15px;\n      margin: 0;\n    }\n    \n    p {\n      color: #ecf0f1;\n    }\n    \n    .card-body {\n      background-color: #34495e;\n      padding: 15px;\n    }\n    \n    .card-footer {\n      background-color: #2c3e50;\n      padding: 10px 15px;\n      border-top: 1px solid #4a6785;\n    }\n    \n    button {\n      background-color: #e74c3c;\n      color: white;\n      border: none;\n      padding: 8px 16px;\n      border-radius: 4px;\n      cursor: pointer;\n    }\n  }\n</style>\n\n<div class=\"card\" class:theme-light={theme === 'light'} class:theme-dark={theme === 'dark'}>\n  <h3>Card Title</h3>\n  <div class=\"card-body\">\n    <p>This is the card content. It could be dynamically generated or include other components.</p>\n  </div>\n  <div class=\"card-footer\">\n    <button>Action Button</button>\n  </div>\n</div>\n```\n\n#### 3. Creating a Theme Provider Component\n\nFor more complex applications, you might want to create a dedicated theme provider component:\n\n```svelte\n<!-- ThemeProvider.svelte -->\n<script>\n  export let theme = 'light';\n</script>\n\n<style>\n  .theme-provider.light :global {\n    /* Light theme global variables */\n    :root {\n      --bg-color: #ffffff;\n      --text-color: #333333;\n      --primary-color: #4CAF50;\n      --secondary-color: #2196F3;\n      --border-color: #e0e0e0;\n    }\n  }\n  \n  .theme-provider.dark :global {\n    /* Dark theme global variables */\n    :root {\n      --bg-color: #121212;\n      --text-color: #f0f0f0;\n      --primary-color: #8bc34a;\n      --secondary-color: #03a9f4;\n      --border-color: #333333;\n    }\n  }\n  \n  /* Global styles that apply to both themes */\n  .theme-provider :global {\n    body {\n      background-color: var(--bg-color);\n      color: var(--text-color);\n      transition: background-color 0.3s, color 0.3s;\n    }\n    \n    .btn-primary {\n      background-color: var(--primary-color);\n      color: white;\n      border: none;\n      padding: 8px 16px;\n      border-radius: 4px;\n    }\n    \n    .btn-secondary {\n      background-color: var(--secondary-color);\n      color: white;\n      border: none;\n      padding: 8px 16px;\n      border-radius: 4px;\n    }\n    \n    .card {\n      border: 1px solid var(--border-color);\n      border-radius: 8px;\n      padding: 16px;\n      background-color: var(--bg-color);\n    }\n  }\n</style>\n\n<div class=\"theme-provider {theme}\">\n  <slot></slot>\n</div>\n```\n\nUsage of the theme provider:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import ThemeProvider from './ThemeProvider.svelte';\n  import { writable } from 'svelte/store';\n  \n  const theme = writable('light');\n  \n  function toggleTheme() {\n    theme.update(t => t === 'light' ? 'dark' : 'light');\n  }\n</script>\n\n<ThemeProvider theme={$theme}>\n  <header>\n    <h1>My Application</h1>\n    <button on:click={toggleTheme}>Toggle Theme</button>\n  </header>\n  \n  <main>\n    <div class=\"card\">\n      <h2>Welcome</h2>\n      <p>This content will be styled according to the current theme.</p>\n      <button class=\"btn-primary\">Primary Action</button>\n      <button class=\"btn-secondary\">Secondary Action</button>\n    </div>\n  </main>\n</ThemeProvider>\n```\n\n### Best Practices for Combining Scoped and Global Styles:\n\n1. **Be intentional about scope**: Only make styles global when they need to be. Keep as much as possible scoped to components.\n\n2. **Use CSS variables for themes**: They make it easier to maintain consistent styling across components.\n\n3. **Create context with parent selectors**: Use component-scoped parent selectors with global modifiers to create context-specific styling.\n\n4. **Organize by component hierarchy**: Match your styling structure to your component hierarchy for better maintainability.\n\n5. **Document global styles**: Since global styles can affect the entire application, make sure to document them well.\n\nBy thoughtfully combining component-scoped and global styles, you can create flexible, maintainable styling systems in Svelte that provide consistent user experiences while preserving the benefits of component encapsulation."}
{"source":"docs/svelte/04-styling/02-global-styles.md","question":"What are the potential pitfalls of using global styles in Svelte, and how can you avoid them?","answer":"While global styles in Svelte provide flexibility, they can introduce several challenges if not used carefully. Understanding these pitfalls and how to avoid them is crucial for maintaining a clean, maintainable codebase.\n\n### Potential Pitfalls of Global Styles\n\n#### 1. Style Conflicts and Specificity Wars\n\n**Problem**: Global styles can clash with each other, especially in larger applications with multiple developers.\n\n```svelte\n<!-- ComponentA.svelte -->\n<style>\n  :global(.button) {\n    background-color: blue;\n    color: white;\n  }\n</style>\n\n<!-- ComponentB.svelte -->\n<style>\n  :global(.button) {\n    background-color: green;\n    color: black;\n  }\n</style>\n```\n\n**Solution**: \n- Use more specific selectors or namespacing\n- Adopt a CSS methodology like BEM, SMACSS, or OOCSS\n- Use component context to limit the scope of global styles\n\n```svelte\n<!-- Better approach -->\n<style>\n  .component-a :global(.button) {\n    background-color: blue;\n    color: white;\n  }\n</style>\n\n<div class=\"component-a\">\n  <button class=\"button\">Scoped Global Button</button>\n</div>\n```\n\n#### 2. Unintended Side Effects\n\n**Problem**: Global styles might affect elements you didn't intend to style.\n\n```svelte\n<style>\n  :global(p) {\n    font-size: 18px;\n    line-height: 1.5;\n  }\n</style>\n```\n\nThis will affect ALL paragraphs in your application, which might not be what you want.\n\n**Solution**:\n- Be more specific with selectors\n- Use classes instead of element selectors\n- Scope global styles to specific containers\n\n```svelte\n<style>\n  .article-content :global(p) {\n    font-size: 18px;\n    line-height: 1.5;\n  }\n</style>\n\n<div class=\"article-content\">\n  <!-- Only paragraphs inside this div will be affected -->\n</div>\n```\n\n#### 3. Maintenance Challenges\n\n**Problem**: As your application grows, tracking where global styles are defined becomes difficult.\n\n**Solution**:\n- Centralize global styles in dedicated files or components\n- Document global styles with comments\n- Create a style guide for your application\n\n```svelte\n<!-- GlobalStyles.svelte -->\n<style>\n  :global {\n    /* Typography */\n    .heading-1 {\n      font-size: 2.5rem;\n      font-weight: 700;\n      margin-bottom: 1rem;\n    }\n    \n    /* Buttons */\n    .btn {\n      padding: 0.5rem 1rem;\n      border-radius: 4px;\n      border: none;\n      cursor: pointer;\n    }\n    \n    .btn-primary {\n      background-color: #3498db;\n      color: white;\n    }\n    \n    /* ... other global styles ... */\n  }\n</style>\n\n<!-- Import in your root component -->\n<script>\n  import GlobalStyles from './GlobalStyles.svelte';\n</script>\n\n<GlobalStyles />\n<!-- Rest of your app -->\n```\n\n#### 4. Performance Concerns\n\n**Problem**: Excessive global styles can bloat your CSS and negatively impact performance.\n\n**Solution**:\n- Only use global styles when necessary\n- Consider using CSS-in-JS libraries that support tree-shaking\n- Split global styles into smaller, more focused components\n\n#### 5. Overriding Third-Party Styles\n\n**Problem**: Using `:global()` to override third-party library styles can lead to specificity issues.\n\n**Solution**:\n- Use more specific selectors\n- Use `!important` judiciously (as a last resort)\n- Consider using CSS custom properties if the library supports them\n\n```svelte\n<style>\n  /* Overriding styles from a chart library */\n  :global(.chart-container .axis text) {\n    font-family: 'Roboto', sans-serif !important;\n    font-size: 12px !important;\n  }\n  \n  /* Better approach if the library supports CSS variables */\n  :global {\n    --chart-font-family: 'Roboto', sans-serif;\n    --chart-font-size: 12px;\n  }\n</style>\n```\n\n### Best Practices to Avoid Global Style Pitfalls\n\n#### 1. Create a Structured CSS Architecture\n\nImplement a consistent approach to styling:\n\n```svelte\n<!-- app.css or GlobalStyles.svelte -->\n<style>\n  :global {\n    /* Base styles */\n    html, body {\n      margin: 0;\n      padding: 0;\n      font-family: 'Helvetica Neue', Arial, sans-serif;\n      line-height: 1.6;\n    }\n    \n    /* Typography system */\n    .text-xs { font-size: 0.75rem; }\n    .text-sm { font-size: 0.875rem; }\n    .text-md { font-size: 1rem; }\n    .text-lg { font-size: 1.125rem; }\n    .text-xl { font-size: 1.25rem; }\n    \n    /* Color system */\n    .text-primary { color: #3498db; }\n    .text-secondary { color: #2ecc71; }\n    .text-danger { color: #e74c3c; }\n    .bg-primary { background-color: #3498db; }\n    .bg-secondary { background-color: #2ecc71; }\n    .bg-danger { background-color: #e74c3c; }\n    \n    /* ... other utility classes ... */\n  }\n</style>\n```\n\n#### 2. Use CSS Custom Properties for Theming\n\n```svelte\n<style>\n  :global {\n    :root {\n      /* Base colors */\n      --color-primary: #3498db;\n      --color-secondary: #2ecc71;\n      --color-danger: #e74c3c;\n      --color-warning: #f39c12;\n      --color-info: #1abc9c;\n      \n      /* Typography */\n      --font-family-base: 'Helvetica Neue', Arial, sans-serif;\n      --font-size-base: 16px;\n      --line-height-base: 1.6;\n      \n      /* Spacing */\n      --spacing-unit: 8px;\n      --spacing-xs: calc(var(--spacing-unit) * 0.5);\n      --spacing-sm: var(--spacing-unit);\n      --spacing-md: calc(var(--spacing-unit) * 2);\n      --spacing-lg: calc(var(--spacing-unit) * 3);\n      --spacing-xl: calc(var(--spacing-unit) * 4);\n    }\n    \n    /* Dark theme */\n    .theme-dark {\n      --color-primary: #5dade2;\n      --color-secondary: #58d68d;\n      --color-text: #ecf0f1;\n      --color-background: #2c3e50;\n    }\n  }\n</style>\n```\n\n#### 3. Scope Global Styles to Specific Contexts\n\n```svelte\n<style>\n  /* Styles for a rich text content area */\n  .rich-text-content :global {\n    h1 {\n      font-size: 2rem;\n      margin-top: 2rem;\n      margin-bottom: 1rem;\n    }\n    \n    h2 {\n      font-size: 1.5rem;\n      margin-top: 1.5rem;\n      margin-bottom: 0.75rem;\n    }\n    \n    p {\n      margin-bottom: 1rem;\n    }\n    \n    ul, ol {\n      margin-bottom: 1rem;\n      padding-left: 2rem;\n    }\n    \n    li {\n      margin-bottom: 0.5rem;\n    }\n    \n    blockquote {\n      border-left: 4px solid #e0e0e0;\n      padding-left: 1rem;\n      font-style: italic;\n      margin-left: 0;\n    }\n    \n    pre {\n      background-color: #f5f5f5;\n      padding: 1rem;\n      border-radius: 4px;\n      overflow-x: auto;\n    }\n    \n    code {\n      font-family: monospace;\n      background-color: #f0f0f0;\n      padding: 0.2rem 0.4rem;\n      border-radius: 3px;\n    }\n  }\n</style>\n\n<div class=\"rich-text-content\">\n  <!-- Content from a rich text editor or markdown will be rendered here -->\n</div>\n```\n\n#### 4. Create Component Libraries with Consistent Styling\n\n```svelte\n<!-- Button.svelte -->\n<script>\n  export let variant = 'primary';\n  export let size = 'medium';\n  export let disabled = false;\n</script>\n\n<style>\n  .btn {\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-weight: 500;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n  }\n  \n  .btn:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n  \n  .btn-primary {\n    background-color: var(--color-primary, #3498db);\n    color: white;\n  }\n  \n  .btn-secondary {\n    background-color: var(--color-secondary, #2ecc71);\n    color: white;\n  }\n  \n  .btn-danger {\n    background-color: var(--color-danger, #e74c3c);\n    color: white;\n  }\n  \n  .btn-small {\n    padding: 0.25rem 0.5rem;\n    font-size: 0.875rem;\n  }\n  \n  .btn-medium {\n    padding: 0.5rem 1rem;\n    font-size: 1rem;\n  }\n  \n  .btn-large {\n    padding: 0.75rem 1.5rem;\n    font-size: 1.125rem;\n  }\n</style>\n\n<button \n  class=\"btn btn-{variant} btn-{size}\" \n  disabled={disabled}\n  on:click\n>\n  <slot></slot>\n</button>\n```\n\n#### 5. Document Your Global Styles\n\nCreate a style guide component or documentation:\n\n```svelte\n<!-- StyleGuide.svelte -->\n<script>\n  import Button from './components/Button.svelte';\n</script>\n\n<style>\n  .style-guide {\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 2rem;\n  }\n  \n  .section {\n    margin-bottom: 3rem;\n  }\n  \n  .color-swatch {\n    width: 100px;\n    height: 100px;\n    display: inline-block;\n    margin-right: 1rem;\n    margin-bottom: 1rem;\n    border-radius: 4px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  }\n  \n  .swatch-label {\n    text-align: center;\n    margin-top: 0.5rem;\n    font-size: 0.875rem;\n  }\n</style>\n\n<div class=\"style-guide\">\n  <h1>Style Guide</h1>\n  \n  <div class=\"section\">\n    <h2>Colors</h2>\n    <div>\n      <div class=\"color-swatch bg-primary\">\n        <div class=\"swatch-label\">Primary</div>\n      </div>\n      <div class=\"color-swatch bg-secondary\">\n        <div class=\"swatch-label\">Secondary</div>\n      </div>\n      <div class=\"color-swatch bg-danger\">\n        <div class=\"swatch-label\">Danger</div>\n      </div>\n      <!-- More color swatches -->\n    </div>\n  </div>\n  \n  <div class=\"section\">\n    <h2>Typography</h2>\n    <h1>Heading 1</h1>\n    <h2>Heading 2</h2>\n    <h3>Heading 3</h3>\n    <p class=\"text-lg\">Large paragraph text</p>\n    <p>Regular paragraph text</p>\n    <p class=\"text-sm\">Small paragraph text</p>\n  </div>\n  \n  <div class=\"section\">\n    <h2>Buttons</h2>\n    <div>\n      <Button variant=\"primary\">Primary Button</Button>\n      <Button variant=\"secondary\">Secondary Button</Button>\n      <Button variant=\"danger\">Danger Button</Button>\n    </div>\n    <div style=\"margin-top: 1rem;\">\n      <Button size=\"small\">Small Button</Button>\n      <Button>Medium Button</Button>\n      <Button size=\"large\">Large Button</Button>\n    </div>\n  </div>\n  \n  <!-- More component examples -->\n</div>\n```\n\nBy following these best practices, you can effectively use global styles in Svelte while avoiding common pitfalls, resulting in a more maintainable and scalable styling architecture."}
{"source":"docs/svelte/04-styling/02-global-styles.md","question":"How would you create a theme system in Svelte using global styles and CSS variables?","answer":"Creating a theme system in Svelte using global styles and CSS variables is a powerful approach for building flexible, customizable applications. This method leverages Svelte's global styling capabilities along with CSS custom properties (variables) to create a cohesive theming solution.\n\nHere's a comprehensive guide to implementing a theme system in Svelte:\n\n### 1. Setting Up the Theme Foundation\n\nFirst, create a base theme component that defines your CSS variables:\n\n```svelte\n<!-- Theme.svelte -->\n<script>\n  export let theme = 'light'; // default theme\n</script>\n\n<style>\n  :global {\n    /* Base theme (light) */\n    :root {\n      /* Colors */\n      --color-primary: #3498db;\n      --color-secondary: #2ecc71;\n      --color-accent: #9b59b6;\n      --color-success: #2ecc71;\n      --color-warning: #f39c12;\n      --color-danger: #e74c3c;\n      --color-info: #1abc9c;\n      \n      /* Neutral colors */\n      --color-text: #333333;\n      --color-text-secondary: #666666;\n      --color-background: #ffffff;\n      --color-background-secondary: #f5f5f5;\n      --color-border: #e0e0e0;\n      \n      /* Typography */\n      --font-family-base: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n      --font-family-heading: var(--font-family-base);\n      --font-size-base: 16px;\n      --font-weight-normal: 400;\n      --font-weight-bold: 700;\n      --line-height-base: 1.5;\n      \n      /* Spacing */\n      --spacing-unit: 8px;\n      --spacing-xs: calc(var(--spacing-unit) * 0.5);  /* 4px */\n      --spacing-sm: var(--spacing-unit);              /* 8px */\n      --spacing-md: calc(var(--spacing-unit) * 2);    /* 16px */\n      --spacing-lg: calc(var(--spacing-unit) * 3);    /* 24px */\n      --spacing-xl: calc(var(--spacing-unit) * 4);    /* 32px */\n      --spacing-xxl: calc(var(--spacing-unit) * 6);   /* 48px */\n      \n      /* Layout */\n      --border-radius-sm: 4px;\n      --border-radius-md: 8px;\n      --border-radius-lg: 16px;\n      --border-radius-full: 9999px;\n      \n      /* Effects */\n      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);\n      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);\n      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);\n      \n      /* Transitions */\n      --transition-fast: 150ms ease;\n      --transition-normal: 300ms ease;\n      --transition-slow: 500ms ease;\n    }\n  }\n  \n  /* Dark theme overrides */\n  :global(.theme-dark) {\n    --color-primary: #5dade2;\n    --color-secondary: #58d68d;\n    --color-accent: #bb8fce;\n    --color-success: #58d68d;\n    --color-warning: #f5b041;\n    --color-danger: #ec7063;\n    --color-info: #48c9b0;\n    \n    --color-text: #f0f0f0;\n    --color-text-secondary: #cccccc;\n    --color-background: #121212;\n    --color-background-secondary: #1e1e1e;\n    --color-border: #333333;\n    \n    --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);\n    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.3);\n    --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.3);\n  }\n  \n  /* High contrast theme overrides */\n  :global(.theme-high-contrast) {\n    --color-primary: #0066cc;\n    --color-secondary: #008000;\n    --color-accent: #800080;\n    --color-success: #008000;\n    --color-warning: #cc6600;\n    --color-danger: #cc0000;\n    --color-info: #008080;\n    \n    --color-text: #000000;\n    --color-text-secondary: #333333;\n    --color-background: #ffffff;\n    --color-background-secondary: #eeeeee;\n    --color-border: #000000;\n    \n    --border-radius-sm: 0;\n    --border-radius-md: 0;\n    --border-radius-lg: 0;\n    \n    --shadow-sm: none;\n    --shadow-md: none;\n    --shadow-lg: none;\n  }\n}\n</style>\n\n<div class={`theme-container ${theme !== 'light' ? `theme-${theme}` : ''}`}>\n  <slot></slot>\n</div>\n```\n\n### 2. Creating a Theme Store\n\nNext, create a Svelte store to manage the active theme:\n\n```javascript\n// stores/theme.js\nimport { writable } from 'svelte/store';\n\n// Check for saved theme in localStorage or use default\nconst storedTheme = typeof localStorage !== 'undefined' ? \n                    localStorage.getItem('theme') : null;\nconst initialTheme = storedTheme || 'light';\n\n// Create the store\nexport const theme = writable(initialTheme);\n\n// Save theme changes to localStorage\ntheme.subscribe(value => {\n  if (typeof localStorage !== 'undefined') {\n    localStorage.setItem('theme', value);\n  }\n});\n\n// Helper function to toggle between themes\nexport function toggleTheme() {\n  theme.update(current => {\n    if (current === 'light') return 'dark';\n    if (current === 'dark') return 'light';\n    return 'light';\n  });\n}\n\n// Set a specific theme\nexport function setTheme(newTheme) {\n  theme.set(newTheme);\n}\n```\n\n### 3. Implementing Base Component Styles\n\nCreate a set of base component styles that use your theme variables:\n\n```svelte\n<!-- GlobalStyles.svelte -->\n<style>\n  :global {\n    /* Reset and base styles */\n    * {\n      box-sizing: border-box;\n      margin: 0;\n      padding: 0;\n    }\n    \n    html, body {\n      font-family: var(--font-family-base);\n      font-size: var(--font-size-base);\n      line-height: var(--line-height-base);\n      color: var(--color-text);\n      background-color: var(--color-background);\n      transition: background-color var(--transition-normal), color var(--transition-normal);\n    }\n    \n    /* Typography */\n    h1, h2, h3, h4, h5, h6 {\n      font-family: var(--font-family-heading);\n      margin-bottom: var(--spacing-md);\n      font-weight: var(--font-weight-bold);\n      line-height: 1.2;\n      color: var(--color-text);\n    }\n    \n    h1 { font-size: 2.5rem; }\n    h2 { font-size: 2rem; }\n    h3 { font-size: 1.75rem; }\n    h4 { font-size: 1.5rem; }\n    h5 { font-size: 1.25rem; }\n    h6 { font-size: 1rem; }\n    \n    p {\n      margin-bottom: var(--spacing-md);\n    }\n    \n    a {\n      color: var(--color-primary);\n      text-decoration: none;\n      transition: color var(--transition-fast);\n    }\n    \n    a:hover {\n      color: color-mix(in srgb, var(--color-primary) 80%, black);\n    }\n    \n    /* Form elements */\n    input, select, textarea, button {\n      font-family: inherit;\n      font-size: inherit;\n    }\n    \n    input, select, textarea {\n      padding: var(--spacing-sm) var(--spacing-md);\n      border: 1px solid var(--color-border);\n      border-radius: var(--border-radius-sm);\n      background-color: var(--color-background);\n      color: var(--color-text);\n      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);\n    }\n    \n    input:focus, select:focus, textarea:focus {\n      outline: none;\n      border-color: var(--color-primary);\n      box-shadow: 0 0 0 3px color-mix(in srgb, var(--color-primary) 30%, transparent);\n    }\n    \n    /* Buttons */\n    .btn {\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      padding: var(--spacing-sm) var(--spacing-md);\n      border: none;\n      border-radius: var(--border-radius-sm);\n      font-weight: var(--font-weight-bold);\n      cursor: pointer;\n      transition: background-color var(--transition-fast), color var(--transition-fast), box-shadow var(--transition-fast);\n    }\n    \n    .btn-primary {\n      background-color: var(--color-primary);\n      color: white;\n    }\n    \n    .btn-primary:hover {\n      background-color: color-mix(in srgb, var(--color-primary) 80%, black);\n    }\n    \n    .btn-secondary {\n      background-color: var(--color-secondary);\n      color: white;\n    }\n    \n    .btn-secondary:hover {\n      background-color: color-mix(in srgb, var(--color-secondary) 80%, black);\n    }\n    \n    .btn-outline {\n      background-color: transparent;\n      color: var(--color-primary);\n      border: 1px solid var(--color-primary);\n    }\n    \n    .btn-outline:hover {\n      background-color: var(--color-primary);\n      color: white;\n    }\n    \n    /* Cards */\n    .card {\n      background-color: var(--color-background);\n      border-radius: var(--border-radius-md);\n      box-shadow: var(--shadow-md);\n      padding: var(--spacing-lg);\n      margin-bottom: var(--spacing-lg);\n      transition: box-shadow var(--transition-normal), transform var(--transition-normal);\n    }\n    \n    .card:hover {\n      box-shadow: var(--shadow-lg);\n      transform: translateY(-2px);\n    }\n    \n    /* Utility classes */\n    .text-primary { color: var(--color-primary); }\n    .text-secondary { color: var(--color-secondary); }\n    .text-accent { color: var(--color-accent); }\n    .text-success { color: var(--color-success); }\n    .text-warning { color: var(--color-warning); }\n    .text-danger { color: var(--color-danger); }\n    .text-info { color: var(--color-info); }\n    \n    .bg-primary { background-color: var(--color-primary); }\n    .bg-secondary { background-color: var(--color-secondary); }\n    .bg-accent { background-color: var(--color-accent); }\n    .bg-success { background-color: var(--color-success); }\n    .bg-warning { background-color: var(--color-warning); }\n    .bg-danger { background-color: var(--color-danger); }\n    .bg-info { background-color: var(--color-info); }\n  }\n</style>\n```\n\n### 4. Setting Up the Theme Provider in Your App\n\nNow, wire everything together in your root component:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  import { theme, toggleTheme } from './stores/theme';\n  import Theme from './Theme.svelte';\n  import GlobalStyles from './GlobalStyles.svelte';\n  \n  // Check for system preference on mount\n  onMount(() => {\n    if (typeof window !== 'undefined' && !localStorage.getItem('theme')) {\n      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n      if (prefersDark) {\n        theme.set('dark');\n      }\n    }\n  });\n</script>\n\n<GlobalStyles />\n\n<Theme theme={$theme}>\n  <header>\n    <nav>\n      <h1>My Themed App</h1>\n      <button class=\"btn btn-outline\" on:click={toggleTheme}>\n        Toggle Theme ({$theme === 'light' ? 'ð' : 'âï¸'})\n      </button>\n    </nav>\n  </header>\n  \n  <main>\n    <section class=\"card\">\n      <h2>Welcome to my themed application</h2>\n      <p>This content adapts to the current theme using CSS variables.</p>\n      <button class=\"btn btn-primary\">Primary Action</button>\n      <button class=\"btn btn-secondary\">Secondary Action</button>\n    </section>\n    \n    <!-- More content... -->\n  </main>\n  \n  <footer>\n    <p>Â© 2023 My Themed App</p>\n  </footer>\n</Theme>\n```\n\n### 5. Creating Theme-Aware Components\n\nBuild components that use your theme variables:\n\n```svelte\n<!-- components/Alert.svelte -->\n<script>\n  export let type = 'info'; // info, success, warning, danger\n  export let dismissible = false;\n  \n  let visible = true;\n  \n  function dismiss() {\n    visible = false;\n  }\n</script>\n\n<style>\n  .alert {\n    padding: var(--spacing-md);\n    border-radius: var(--border-radius-sm);\n    margin-bottom: var(--spacing-md);\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n  }\n  \n  .alert-content {\n    flex: 1;\n  }\n  \n  .alert-info {\n    background-color: color-mix(in srgb, var(--color-info) 15%, transparent);\n    border-left: 4px solid var(--color-info);\n  }\n  \n  .alert-success {\n    background-color: color-mix(in srgb, var(--color-success) 15%, transparent);\n    border-left: 4px solid var(--color-success);\n  }\n  \n  .alert-warning {\n    background-color: color-mix(in srgb, var(--color-warning) 15%, transparent);\n    border-left: 4px solid var(--color-warning);\n  }\n  \n  .alert-danger {\n    background-color: color-mix(in srgb, var(--color-danger) 15%, transparent);\n    border-left: 4px solid var(--color-danger);\n  }\n  \n  .dismiss-btn {\n    background: transparent;\n    border: none;\n    cursor: pointer;\n    font-size: 1.25rem;\n    line-height: 1;\n    padding: var(--spacing-xs);\n    color: var(--color-text-secondary);\n    transition: color var(--transition-fast);\n  }\n  \n  .dismiss-btn:hover {\n    color: var(--color-text);\n  }\n</style>\n\n{#if visible}\n  <div class=\"alert alert-{type}\">\n    <div class=\"alert-content\">\n      <slot></slot>\n    </div>\n    \n    {#if dismissible}\n      <button class=\"dismiss-btn\" on:click={dismiss} aria-label=\"Dismiss\">\n        Ã\n      </button>\n    {/if}\n  </div>\n{/if}\n```\n\n### 6. Implementing Custom Theme Selector\n\nAdd a component to let users choose from multiple themes:\n\n```svelte\n<!-- components/ThemeSelector.svelte -->\n<script>\n  import { theme, setTheme } from '../stores/theme';\n  \n  const themes = [\n    { id: 'light', name: 'Light', icon: 'âï¸' },\n    { id: 'dark', name: 'Dark', icon: 'ð' },\n    { id: 'high-contrast', name: 'High Contrast', icon: 'ð' }\n  ];\n</script>\n\n<style>\n  .theme-selector {\n    display: flex;\n    gap: var(--spacing-sm);\n    margin-bottom: var(--spacing-md);\n  }\n  \n  .theme-option {\n    padding: var(--spacing-sm) var(--spacing-md);\n    border-radius: var(--border-radius-sm);\n    border: 2px solid var(--color-border);\n    background-color: var(--color-background-secondary);\n    cursor: pointer;\n    transition: all var(--transition-fast);\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n  }\n  \n  .theme-option:hover {\n    border-color: var(--color-primary);\n  }\n  \n  .theme-option.active {\n    border-color: var(--color-primary);\n    background-color: color-mix(in srgb, var(--color-primary) 10%, transparent);\n  }\n  \n  .theme-icon {\n    font-size: 1.25rem;\n  }\n</style>\n\n<div class=\"theme-selector\">\n  {#each themes as themeOption}\n    <button \n      class=\"theme-option {$theme === themeOption.id ? 'active' : ''}\"\n      on:click={() => setTheme(themeOption.id)}\n      aria-label={`Switch to ${themeOption.name} theme`}\n    >\n      <span class=\"theme-icon\">{themeOption.icon}</span>\n      <span>{themeOption.name}</span>\n    </button>\n  {/each}\n</div>\n```\n\n### 7. Supporting User Customization\n\nAllow users to customize theme colors:\n\n```svelte\n<!-- components/ThemeCustomizer.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  \n  let primaryColor;\n  let secondaryColor;\n  let backgroundColor;\n  let textColor;\n  \n  onMount(() => {\n    // Get the computed styles to show current values\n    const styles = getComputedStyle(document.documentElement);\n    primaryColor = styles.getPropertyValue('--color-primary').trim();\n    secondaryColor = styles.getPropertyValue('--color-secondary').trim();\n    backgroundColor = styles.getPropertyValue('--color-background').trim();\n    textColor = styles.getPropertyValue('--color-text').trim();\n  });\n  \n  function updateThemeColor(variable, value) {\n    document.documentElement.style.setProperty(variable, value);\n    \n    // Save customizations to localStorage\n    const customizations = JSON.parse(localStorage.getItem('themeCustomizations') || '{}');\n    customizations[variable] = value;\n    localStorage.setItem('themeCustomizations', JSON.stringify(customizations));\n  }\n  \n  function resetCustomizations() {\n    document.documentElement.style.removeProperty('--color-primary');\n    document.documentElement.style.removeProperty('--color-secondary');\n    document.documentElement.style.removeProperty('--color-background');\n    document.documentElement.style.removeProperty('--color-text');\n    \n    localStorage.removeItem('themeCustomizations');\n    \n    // Reset the input values\n    const styles = getComputedStyle(document.documentElement);\n    primaryColor = styles.getPropertyValue('--color-primary').trim();\n    secondaryColor = styles.getPropertyValue('--color-secondary').trim();\n    backgroundColor = styles.getPropertyValue('--color-background').trim();\n    textColor = styles.getPropertyValue('--color-text').trim();\n  }\n</script>\n\n<style>\n  .customizer {\n    background-color: var(--color-background-secondary);\n    padding: var(--spacing-lg);\n    border-radius: var(--border-radius-md);\n    margin-bottom: var(--spacing-lg);\n  }\n  \n  .color-option {\n    display: flex;\n    align-items: center;\n    margin-bottom: var(--spacing-md);\n  }\n  \n  .color-label {\n    width: 120px;\n    margin-right: var(--spacing-md);\n  }\n  \n  .color-preview {\n    width: 24px;\n    height: 24px;\n    border-radius: var(--border-radius-sm);\n    border: 1px solid var(--color-border);\n    margin-right: var(--spacing-md);\n  }\n  \n  .reset-button {\n    margin-top: var(--spacing-md);\n  }\n</style>\n\n<div class=\"customizer\">\n  <h3>Customize Theme</h3>\n  \n  <div class=\"color-option\">\n    <span class=\"color-label\">Primary Color</span>\n    <div class=\"color-preview\" style=\"background-color: {primaryColor};\"></div>\n    <input \n      type=\"color\" \n      bind:value={primaryColor} \n      on:change={() => updateThemeColor('--color-primary', primaryColor)}\n    />\n  </div>\n  \n  <div class=\"color-option\">\n    <span class=\"color-label\">Secondary Color</span>\n    <div class=\"color-preview\" style=\"background-color: {secondaryColor};\"></div>\n    <input \n      type=\"color\" \n      bind:value={secondaryColor} \n      on:change={() => updateThemeColor('--color-secondary', secondaryColor)}\n    />\n  </div>\n  \n  <div class=\"color-option\">\n    <span class=\"color-label\">Background</span>\n    <div class=\"color-preview\" style=\"background-color: {backgroundColor};\"></div>\n    <input \n      type=\"color\" \n      bind:value={backgroundColor} \n      on:change={() => updateThemeColor('--color-background', backgroundColor)}\n    />\n  </div>\n  \n  <div class=\"color-option\">\n    <span class=\"color-label\">Text Color</span>\n    <div class=\"color-preview\" style=\"background-color: {textColor};\"></div>\n    <input \n      type=\"color\" \n      bind:value={textColor} \n      on:change={() => updateThemeColor('--color-text', textColor)}\n    />\n  </div>\n  \n  <button class=\"btn btn-outline reset-button\" on:click={resetCustomizations}>\n    Reset to Defaults\n  </button>\n</div>\n```\n\n### 8. Loading Saved Customizations\n\nAdd code to load user customizations when the app starts:\n\n```svelte\n<!-- App.svelte (additional code) -->\n<script>\n  // ... existing imports and code\n\n  // Load theme customizations\n  onMount(() => {\n    // ... existing onMount code\n    \n    // Load any saved customizations\n    const customizations = JSON.parse(localStorage.getItem('themeCustomizations') || '{}');\n    \n    // Apply saved customizations\n    Object.entries(customizations).forEach(([variable, value]) => {\n      document.documentElement.style.setProperty(variable, value);\n    });\n  });\n</script>\n```\n\n### 9. Supporting System Preference Changes\n\nAdd a listener for system preference changes:\n\n```svelte\n<!-- App.svelte (additional code) -->\n<script>\n  // ... existing imports and code\n  \n  let systemThemeMediaQuery;\n  \n  onMount(() => {\n    // ... existing onMount code\n    \n    // Listen for system preference changes\n    systemThemeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    \n    const handleSystemThemeChange = (e) => {\n      // Only change theme if user hasn't explicitly set one\n      if (!localStorage.getItem('theme')) {\n        theme.set(e.matches ? 'dark' : 'light');\n      }\n    };\n    \n    systemThemeMediaQuery.addEventListener('change', handleSystemThemeChange);\n    \n    return () => {\n      systemThemeMediaQuery.removeEventListener('change', handleSystemThemeChange);\n    };\n  });\n</script>\n```\n\n### 10. Creating a Complete Theme Demo Page\n\n```svelte\n<!-- ThemeDemo.svelte -->\n<script>\n  import { theme } from './stores/theme';\n  import ThemeSelector from './components/ThemeSelector.svelte';\n  import ThemeCustomizer from './components/ThemeCustomizer.svelte';\n  import Alert from './components/Alert.svelte';\n  \n  let showCustomizer = false;\n</script>\n\n<style>\n  .demo-container {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: var(--spacing-lg);\n  }\n  \n  .demo-section {\n    margin-bottom: var(--spacing-xl);\n  }\n  \n  .color-palette {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));\n    gap: var(--spacing-md);\n    margin-bottom: var(--spacing-lg);\n  }\n  \n  .color-item {\n    height: 80px;\n    border-radius: var(--border-radius-sm);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: white;\n    font-weight: bold;\n    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n  }\n  \n  .button-demo {\n    display: flex;\n    gap: var(--spacing-md);\n    flex-wrap: wrap;\n    margin-bottom: var(--spacing-lg);\n  }\n  \n  .customizer-toggle {\n    margin-bottom: var(--spacing-md);\n  }\n</style>\n\n<div class=\"demo-container\">\n  <div class=\"demo-section\">\n    <h1>Theme System Demo</h1>\n    <p>Current theme: <strong class=\"text-primary\">{$theme}</strong></p>\n    \n    <ThemeSelector />\n    \n    <button \n      class=\"btn btn-outline customizer-toggle\" \n      on:click={() => showCustomizer = !showCustomizer}\n    >\n      {showCustomizer ? 'Hide' : 'Show'} Theme Customizer\n    </button>\n    \n    {#if showCustomizer}\n      <ThemeCustomizer />\n    {/if}\n  </div>\n  \n  <div class=\"demo-section\">\n    <h2>Color Palette</h2>\n    <div class=\"color-palette\">\n      <div class=\"color-item bg-primary\">Primary</div>\n      <div class=\"color-item bg-secondary\">Secondary</div>\n      <div class=\"color-item bg-accent\">Accent</div>\n      <div class=\"color-item bg-success\">Success</div>\n      <div class=\"color-item bg-warning\">Warning</div>\n      <div class=\"color-item bg-danger\">Danger</div>\n      <div class=\"color-item bg-info\">Info</div>\n    </div>\n  </div>\n  \n  <div class=\"demo-section\">\n    <h2>Typography</h2>\n    <h1>Heading 1</h1>\n    <h2>Heading 2</h2>\n    <h3>Heading 3</h3>\n    <h4>Heading 4</h4>\n    <p>This is a paragraph with <a href=\"#\">a link</a> inside it.</p>\n    <p><strong>Bold text</strong> and <em>italic text</em> examples.</p>\n  </div>\n  \n  <div class=\"demo-section\">\n    <h2>Buttons</h2>\n    <div class=\"button-demo\">\n      <button class=\"btn btn-primary\">Primary</button>\n      <button class=\"btn btn-secondary\">Secondary</button>\n      <button class=\"btn btn-outline\">Outline</button>\n    </div>\n  </div>\n  \n  <div class=\"demo-section\">\n    <h2>Form Elements</h2>\n    <div>\n      <label for=\"demo-input\">Text Input</label>\n      <input type=\"text\" id=\"demo-input\" placeholder=\"Enter some text\">\n    </div>\n    \n    <div style=\"margin-top: var(--spacing-md);\">\n      <label for=\"demo-select\">Select</label>\n      <select id=\"demo-select\">\n        <option>Option 1</option>\n        <option>Option 2</option>\n        <option>Option 3</option>\n      </select>\n    </div>\n    \n    <div style=\"margin-top: var(--spacing-md);\">\n      <label for=\"demo-textarea\">Textarea</label>\n      <textarea id=\"demo-textarea\" rows=\"3\" placeholder=\"Enter multiple lines of text\"></textarea>"}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"How do you pass CSS custom properties to components in Svelte, and what's happening behind the scenes when you do this?","answer":"In Svelte, you can pass CSS custom properties directly to components using the `--property-name` syntax in the component tag. These can be either static values or dynamic expressions.\n\nFor example, you can pass both static and dynamic custom properties like this:\n```svelte\n<Slider\n  bind:value\n  min={0}\n  max={100}\n  --track-color=\"black\"\n  --thumb-color=\"rgb({r} {g} {b})\"\n/>\n```\n\nBehind the scenes, Svelte transforms this code by wrapping your component with a special container that applies these styles. For regular HTML elements, it uses a `<svelte-css-wrapper>` with a `display: contents` style:\n\n```svelte\n<svelte-css-wrapper style=\"display: contents; --track-color: black; --thumb-color: rgb({r} {g} {b})\">\n  <Slider\n    bind:value\n    min={0}\n    max={100}\n  />\n</svelte-css-wrapper>\n```\n\nFor SVG elements, Svelte uses a `<g>` element instead:\n\n```svelte\n<g style=\"--track-color: black; --thumb-color: rgb({r} {g} {b})\">\n  <Slider\n    bind:value\n    min={0}\n    max={100}\n  />\n</g>\n```\n\nThis approach maintains proper scoping of the custom properties while allowing them to cascade down to the component's children."}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"How can a Svelte component consume custom properties passed to it, and how do you provide fallback values?","answer":"Inside a Svelte component, you can access custom properties passed to it using the standard CSS `var()` function in your component's `<style>` block. The `var()` function also allows you to specify fallback values that will be used if the custom property isn't defined.\n\nHere's how you would use custom properties with fallbacks in a component:\n\n```svelte\n<script>\n  // Component logic here\n</script>\n\n<div class=\"track\">\n  <div class=\"thumb\"></div>\n</div>\n\n<style>\n  .track {\n    /* Use --track-color if provided, otherwise fall back to #aaa */\n    background: var(--track-color, #aaa);\n    height: 10px;\n    border-radius: 5px;\n    position: relative;\n  }\n\n  .thumb {\n    /* Use --thumb-color if provided, otherwise fall back to blue */\n    background: var(--thumb-color, blue);\n    height: 20px;\n    width: 20px;\n    border-radius: 50%;\n    position: absolute;\n  }\n</style>\n```\n\nIn this example, if the component is used without specifying `--track-color` or `--thumb-color`, the fallback values `#aaa` and `blue` will be used respectively. If the properties are provided when using the component, those values will override the defaults."}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"Can you use dynamic expressions in custom properties passed to components? If so, provide an example of a practical use case.","answer":"Yes, you can use dynamic expressions in custom properties passed to Svelte components. This is a powerful feature that allows for reactive styling based on component state or props.\n\nHere's a practical example of a color picker component that uses dynamic custom properties to visualize the selected color:\n\n```svelte\n<script>\n  // Parent component\n  import ColorSlider from './ColorSlider.svelte';\n  \n  let r = 100;\n  let g = 150;\n  let b = 200;\n  \n  $: rgbValue = `rgb(${r}, ${g}, ${b})`;\n  $: hexValue = rgbToHex(r, g, b);\n  \n  function rgbToHex(r, g, b) {\n    return '#' + [r, g, b]\n      .map(x => x.toString(16).padStart(2, '0'))\n      .join('');\n  }\n</script>\n\n<div class=\"color-picker\">\n  <div class=\"preview\" style=\"background-color: {rgbValue}\"></div>\n  \n  <div class=\"sliders\">\n    <ColorSlider \n      label=\"R\" \n      bind:value={r} \n      min={0} \n      max={255} \n      --track-color=\"rgba(255, 0, 0, 0.3)\"\n      --thumb-color=\"rgb({r}, 0, 0)\"\n    />\n    \n    <ColorSlider \n      label=\"G\" \n      bind:value={g} \n      min={0} \n      max={255} \n      --track-color=\"rgba(0, 255, 0, 0.3)\"\n      --thumb-color=\"rgb(0, {g}, 0)\"\n    />\n    \n    <ColorSlider \n      label=\"B\" \n      bind:value={b} \n      min={0} \n      max={255} \n      --track-color=\"rgba(0, 0, 255, 0.3)\"\n      --thumb-color=\"rgb(0, 0, {b})\"\n    />\n  </div>\n  \n  <div class=\"values\">\n    <div>RGB: {rgbValue}</div>\n    <div>HEX: {hexValue}</div>\n  </div>\n</div>\n\n<style>\n  .color-picker {\n    padding: 1rem;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n  \n  .preview {\n    height: 100px;\n    border-radius: 4px;\n    margin-bottom: 1rem;\n  }\n  \n  .sliders {\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n  }\n  \n  .values {\n    margin-top: 1rem;\n    font-family: monospace;\n  }\n</style>\n```\n\nAnd here's the `ColorSlider.svelte` component that consumes these dynamic custom properties:\n\n```svelte\n<script>\n  export let label = '';\n  export let value = 0;\n  export let min = 0;\n  export let max = 100;\n</script>\n\n<div class=\"slider-container\">\n  <span class=\"label\">{label}</span>\n  <div class=\"track\">\n    <div class=\"fill\" style=\"width: {(value - min) / (max - min) * 100}%\"></div>\n    <div class=\"thumb\" style=\"left: {(value - min) / (max - min) * 100}%\"></div>\n  </div>\n  <input type=\"range\" bind:value {min} {max} />\n</div>\n\n<style>\n  .slider-container {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n  \n  .label {\n    width: 1.5rem;\n    font-weight: bold;\n  }\n  \n  .track {\n    position: relative;\n    height: 8px;\n    flex-grow: 1;\n    background: var(--track-color, #ddd);\n    border-radius: 4px;\n  }\n  \n  .fill {\n    position: absolute;\n    height: 100%;\n    background: var(--track-color, #ddd);\n    border-radius: 4px;\n    opacity: 0.8;\n  }\n  \n  .thumb {\n    position: absolute;\n    height: 20px;\n    width: 20px;\n    background: var(--thumb-color, #666);\n    border-radius: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  \n  input[type=\"range\"] {\n    position: absolute;\n    width: 100%;\n    opacity: 0;\n    cursor: pointer;\n  }\n</style>\n```\n\nIn this example, as the user adjusts the R, G, and B sliders, the custom properties update dynamically, changing the colors of the track and thumb elements to visually represent the selected color values."}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"Is it necessary to explicitly pass custom properties to a component for them to be available within that component? Explain how CSS custom properties cascade in Svelte applications.","answer":"No, it's not strictly necessary to explicitly pass custom properties directly to a component for them to be available within that component. CSS custom properties follow the standard CSS cascading rules, which means they cascade down through the DOM tree.\n\nIn Svelte applications, there are several ways custom properties can be made available to components:\n\n1. **Direct passing to components** (as shown in previous examples):\n```svelte\n<MyComponent --text-color=\"blue\" />\n```\n\n2. **Defined on a parent element**:\n```svelte\n<div style=\"--text-color: blue;\">\n  <MyComponent />\n</div>\n```\n\n3. **Defined in a global stylesheet**:\n```css\n/* global.css */\n:root {\n  --text-color: blue;\n}\n```\n\nThe documentation specifically mentions this cascading behavior:\n\n> You don't _have_ to specify the values directly on the component; as long as the custom properties are defined on a parent element, the component can use them. It's common to define custom properties on the `:root` element in a global stylesheet so that they apply to your entire application.\n\nThis is a powerful aspect of CSS custom properties - they can be defined at a high level in your application and then consumed by any component that needs them.\n\nHere's an example of how this might work in practice:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import ThemeProvider from './ThemeProvider.svelte';\n  import Card from './Card.svelte';\n  \n  let darkMode = false;\n</script>\n\n<ThemeProvider {darkMode}>\n  <div class=\"app\">\n    <h1>My Application</h1>\n    <Card title=\"First Card\" content=\"This is some content\" />\n    <Card title=\"Second Card\" content=\"This is more content\" />\n    <button on:click={() => darkMode = !darkMode}>\n      Toggle {darkMode ? 'Light' : 'Dark'} Mode\n    </button>\n  </div>\n</ThemeProvider>\n```\n\n```svelte\n<!-- ThemeProvider.svelte -->\n<script>\n  export let darkMode = false;\n  \n  $: theme = {\n    '--background-color': darkMode ? '#222' : '#fff',\n    '--text-color': darkMode ? '#eee' : '#222',\n    '--card-background': darkMode ? '#333' : '#f5f5f5',\n    '--card-border': darkMode ? '1px solid #444' : '1px solid #ddd'\n  };\n</script>\n\n<div style={Object.entries(theme).map(([prop, value]) => `${prop}: ${value}`).join(';')}>\n  <slot></slot>\n</div>\n```\n\n```svelte\n<!-- Card.svelte -->\n<script>\n  export let title;\n  export let content;\n</script>\n\n<div class=\"card\">\n  <h2>{title}</h2>\n  <p>{content}</p>\n</div>\n\n<style>\n  .card {\n    background-color: var(--card-background, white);\n    color: var(--text-color, black);\n    border: var(--card-border, 1px solid #ccc);\n    padding: 1rem;\n    margin: 1rem 0;\n    border-radius: 4px;\n  }\n  \n  h2 {\n    margin-top: 0;\n    color: var(--text-color, black);\n  }\n</style>\n```\n\nIn this example, the `ThemeProvider` component sets custom properties based on the `darkMode` state. These properties cascade down to the `Card` components, which use them for styling without the custom properties being explicitly passed to the `Card` components themselves."}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"How do custom properties in Svelte work with SVG elements compared to regular HTML elements?","answer":"When using custom properties with SVG elements in Svelte, there's a key difference in how Svelte handles the wrapping of these elements compared to regular HTML elements.\n\nFor regular HTML elements, Svelte wraps the component with a `<svelte-css-wrapper>` element that has `display: contents` to ensure the wrapper doesn't affect the layout:\n\n```svelte\n<svelte-css-wrapper style=\"display: contents; --track-color: black; --thumb-color: red\">\n  <MyComponent />\n</svelte-css-wrapper>\n```\n\nHowever, for SVG elements, Svelte uses an SVG `<g>` (group) element instead:\n\n```svelte\n<g style=\"--track-color: black; --thumb-color: red\">\n  <MySvgComponent />\n</g>\n```\n\nThis difference is important because SVG has a different DOM structure and styling context than HTML. The `<g>` element is a natural grouping element in SVG that doesn't disrupt the SVG rendering context, while a `<svelte-css-wrapper>` would not be a valid SVG element.\n\nHere's an example of using custom properties with an SVG component:\n\n```svelte\n<!-- CircleGraph.svelte -->\n<script>\n  export let percentage = 75;\n  export let size = 100;\n  \n  $: radius = size / 2;\n  $: circumference = 2 * Math.PI * (radius - 10);\n  $: dashOffset = circumference * (1 - percentage / 100);\n</script>\n\n<svg width={size} height={size} viewBox=\"0 0 {size} {size}\">\n  <circle \n    class=\"background\"\n    cx={radius}\n    cy={radius}\n    r={radius - 10}\n    fill=\"none\"\n    stroke-width=\"5\"\n  />\n  <circle \n    class=\"progress\"\n    cx={radius}\n    cy={radius}\n    r={radius - 10}\n    fill=\"none\"\n    stroke-width=\"5\"\n    stroke-dasharray={circumference}\n    stroke-dashoffset={dashOffset}\n    transform=\"rotate(-90 {radius} {radius})\"\n  />\n  <text \n    class=\"percentage\"\n    x=\"50%\"\n    y=\"50%\"\n    text-anchor=\"middle\"\n    dominant-baseline=\"middle\"\n  >\n    {percentage}%\n  </text>\n</svg>\n\n<style>\n  .background {\n    stroke: var(--background-color, #eee);\n  }\n  \n  .progress {\n    stroke: var(--progress-color, #4caf50);\n    transition: stroke-dashoffset 0.5s ease;\n  }\n  \n  .percentage {\n    font-size: var(--font-size, 1.5rem);\n    font-weight: bold;\n    fill: var(--text-color, #333);\n  }\n</style>\n```\n\nAnd here's how you would use this SVG component with custom properties:\n\n```svelte\n<script>\n  import CircleGraph from './CircleGraph.svelte';\n  \n  let value = 75;\n</script>\n\n<div>\n  <CircleGraph \n    percentage={value}\n    size={200}\n    --background-color=\"#ddd\"\n    --progress-color=\"purple\"\n    --text-color=\"darkblue\"\n    --font-size=\"2rem\"\n  />\n  \n  <input type=\"range\" bind:value min=\"0\" max=\"100\" />\n</div>\n```\n\nBehind the scenes, Svelte would wrap the `CircleGraph` component with a `<g>` element when rendering it inside the SVG context:\n\n```svelte\n<svg width=\"200\" height=\"200\" viewBox=\"0 0 200 200\">\n  <g style=\"--background-color: #ddd; --progress-color: purple; --text-color: darkblue; --font-size: 2rem\">\n    <!-- CircleGraph component content -->\n  </g>\n</svg>\n```\n\nThis ensures that the custom properties are properly applied to the SVG elements while maintaining valid SVG structure."}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"How can you create a theming system for a Svelte application using CSS custom properties?","answer":"CSS custom properties are ideal for creating flexible theming systems in Svelte applications. You can define theme variables globally and then switch between themes by changing these variables. Here's a comprehensive approach to building a theming system in Svelte:\n\n1. First, define your themes as sets of custom properties:\n\n```svelte\n<!-- stores/theme.js -->\n<script context=\"module\">\n  import { writable } from 'svelte/store';\n\n  export const themes = {\n    light: {\n      '--primary-color': '#3498db',\n      '--secondary-color': '#2ecc71',\n      '--background-color': '#ffffff',\n      '--text-color': '#333333',\n      '--card-background': '#f8f9fa',\n      '--card-border': '1px solid #dee2e6',\n      '--shadow': '0 2px 4px rgba(0,0,0,0.1)',\n      '--input-background': '#ffffff',\n      '--input-border': '1px solid #ced4da',\n      '--input-text': '#495057'\n    },\n    dark: {\n      '--primary-color': '#2980b9',\n      '--secondary-color': '#27ae60',\n      '--background-color': '#121212',\n      '--text-color': '#e0e0e0',\n      '--card-background': '#1e1e1e',\n      '--card-border': '1px solid #333333',\n      '--shadow': '0 2px 4px rgba(255,255,255,0.05)',\n      '--input-background': '#2d2d2d',\n      '--input-border': '1px solid #444444',\n      '--input-text': '#e0e0e0'\n    },\n    highContrast: {\n      '--primary-color': '#ffff00',\n      '--secondary-color': '#00ffff',\n      '--background-color': '#000000',\n      '--text-color': '#ffffff',\n      '--card-background': '#000000',\n      '--card-border': '3px solid #ffffff',\n      '--shadow': 'none',\n      '--input-background': '#000000',\n      '--input-border': '3px solid #ffffff',\n      '--input-text': '#ffffff'\n    }\n  };\n\n  // Create a store for the current theme\n  export const currentTheme = writable('light');\n</script>\n```\n\n2. Create a ThemeProvider component that applies the theme to your application:\n\n```svelte\n<!-- ThemeProvider.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  import { currentTheme, themes } from './stores/theme.js';\n  \n  // Function to apply theme to document\n  function applyTheme(themeName) {\n    const theme = themes[themeName];\n    if (!theme) return;\n    \n    // Apply each custom property to the document root\n    Object.entries(theme).forEach(([property, value]) => {\n      document.documentElement.style.setProperty(property, value);\n    });\n    \n    // Optionally store the user's preference\n    localStorage.setItem('preferred-theme', themeName);\n  }\n  \n  // Apply theme whenever it changes\n  $: if (typeof document !== 'undefined') applyTheme($currentTheme);\n  \n  onMount(() => {\n    // Check for saved theme preference\n    const savedTheme = localStorage.getItem('preferred-theme');\n    if (savedTheme && themes[savedTheme]) {\n      currentTheme.set(savedTheme);\n    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {\n      // Use dark theme if user prefers dark color scheme\n      currentTheme.set('dark');\n    }\n    \n    // Listen for system theme changes\n    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {\n      if (!localStorage.getItem('preferred-theme')) {\n        currentTheme.set(e.matches ? 'dark' : 'light');\n      }\n    });\n  });\n</script>\n\n<slot></slot>\n```\n\n3. Create a ThemeSwitcher component:\n\n```svelte\n<!-- ThemeSwitcher.svelte -->\n<script>\n  import { currentTheme, themes } from './stores/theme.js';\n  \n  const themeOptions = Object.keys(themes);\n</script>\n\n<div class=\"theme-switcher\">\n  <label for=\"theme-select\">Theme:</label>\n  <select id=\"theme-select\" bind:value={$currentTheme}>\n    {#each themeOptions as theme}\n      <option value={theme}>{theme.charAt(0).toUpperCase() + theme.slice(1)}</option>\n    {/each}\n  </select>\n</div>\n\n<style>\n  .theme-switcher {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    padding: 0.5rem;\n    background-color: var(--card-background);\n    border: var(--card-border);\n    border-radius: 4px;\n  }\n  \n  select {\n    background-color: var(--input-background);\n    color: var(--input-text);\n    border: var(--input-border);\n    padding: 0.25rem 0.5rem;\n    border-radius: 4px;\n  }\n</style>\n```\n\n4. Use components that consume these theme variables:\n\n```svelte\n<!-- Button.svelte -->\n<script>\n  export let variant = 'primary'; // 'primary' or 'secondary'\n  export let size = 'medium'; // 'small', 'medium', or 'large'\n  export let type = 'button';\n</script>\n\n<button \n  class=\"btn {variant} {size}\" \n  {type} \n  on:click\n>\n  <slot></slot>\n</button>\n\n<style>\n  .btn {\n    font-family: inherit;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    transition: background-color 0.2s, transform 0.1s;\n  }\n  \n  .btn:active {\n    transform: translateY(1px);\n  }\n  \n  .primary {\n    background-color: var(--primary-color);\n    color: white;\n  }\n  \n  .secondary {\n    background-color: var(--secondary-color);\n    color: white;\n  }\n  \n  .small {\n    padding: 0.25rem 0.5rem;\n    font-size: 0.875rem;\n  }\n  \n  .medium {\n    padding: 0.5rem 1rem;\n    font-size: 1rem;\n  }\n  \n  .large {\n    padding: 0.75rem 1.5rem;\n    font-size: 1.125rem;\n  }\n</style>\n```\n\n```svelte\n<!-- Card.svelte -->\n<script>\n  export let title = '';\n</script>\n\n<div class=\"card\">\n  {#if title}\n    <div class=\"card-header\">\n      <h3>{title}</h3>\n    </div>\n  {/if}\n  <div class=\"card-body\">\n    <slot></slot>\n  </div>\n</div>\n\n<style>\n  .card {\n    background-color: var(--card-background);\n    color: var(--text-color);\n    border: var(--card-border);\n    border-radius: 8px;\n    box-shadow: var(--shadow);\n    overflow: hidden;\n    margin-bottom: 1rem;\n  }\n  \n  .card-header {\n    padding: 1rem;\n    border-bottom: var(--card-border);\n  }\n  \n  .card-header h3 {\n    margin: 0;\n    color: var(--primary-color);\n  }\n  \n  .card-body {\n    padding: 1rem;\n  }\n</style>\n```\n\n5. Finally, use these components in your app:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import ThemeProvider from './ThemeProvider.svelte';\n  import ThemeSwitcher from './ThemeSwitcher.svelte';\n  import Button from './Button.svelte';\n  import Card from './Card.svelte';\n</script>\n\n<ThemeProvider>\n  <div class=\"app\">\n    <header>\n      <h1>Themed Svelte App</h1>\n      <ThemeSwitcher />\n    </header>\n    \n    <main>\n      <Card title=\"Welcome\">\n        <p>This app demonstrates a theming system using CSS custom properties in Svelte.</p>\n        <div class=\"button-group\">\n          <Button variant=\"primary\">Primary Action</Button>\n          <Button variant=\"secondary\">Secondary Action</Button>\n        </div>\n      </Card>\n      \n      <Card title=\"Features\">\n        <ul>\n          <li>Multiple theme support</li>\n          <li>Respects user's system preferences</li>\n          <li>Persists theme selection</li>\n          <li>Easy to extend with new themes</li>\n        </ul>\n      </Card>\n    </main>\n  </div>\n</ThemeProvider>\n\n<style>\n  .app {\n    font-family: system-ui, sans-serif;\n    background-color: var(--background-color);\n    color: var(--text-color);\n    min-height: 100vh;\n    padding: 2rem;\n    transition: background-color 0.3s, color 0.3s;\n  }\n  \n  header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 2rem;\n  }\n  \n  h1 {\n    margin: 0;\n    color: var(--primary-color);\n  }\n  \n  main {\n    max-width: 800px;\n    margin: 0 auto;\n  }\n  \n  .button-group {\n    display: flex;\n    gap: 1rem;\n    margin-top: 1rem;\n  }\n  \n  ul {\n    margin: 0;\n    padding-left: 1.5rem;\n  }\n  \n  li {\n    margin-bottom: 0.5rem;\n  }\n  \n  /* Global styles */\n  :global(body) {\n    margin: 0;\n    padding: 0;\n  }\n</style>\n```\n\nThis comprehensive theming system demonstrates several key aspects of using CSS custom properties in Svelte:\n\n1. Global theme definitions with multiple theme options\n2. Dynamic theme switching with reactive updates\n3. System preference detection\n4. Theme persistence with localStorage\n5. Components that consume theme variables\n6. Smooth transitions between themes\n\nThe beauty of this approach is that you can add new themes or modify existing ones by simply updating the theme definitions in the store, without changing any component code. Components automatically adapt to the current theme through the CSS custom properties."}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"How do CSS custom properties in Svelte interact with component encapsulation? Are there any limitations or gotchas to be aware of?","answer":"CSS custom properties in Svelte have a unique relationship with component encapsulation that differs from regular CSS properties. Understanding this interaction is important for effective component design.\n\n### How CSS Custom Properties Work with Svelte's Encapsulation\n\nSvelte encapsulates component styles by default, adding unique class identifiers to elements and scoping CSS rules to only affect elements within the component. However, CSS custom properties have special behavior:\n\n1. **Custom properties cascade downward**: Unlike regular CSS properties that are scoped to the component, custom properties defined in a parent component (or at the `:root` level) cascade down to child components.\n\n2. **They can be consumed but not leaked**: Child components can consume custom properties defined by parents, but a child component cannot define custom properties that affect its parent.\n\n3. **They work across component boundaries**: This makes them ideal for theming and design systems in Svelte applications.\n\n### Example Demonstrating the Interaction\n\n```svelte\n<!-- Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n  let color = 'blue';\n</script>\n\n<div class=\"parent\">\n  <h2>Parent Component</h2>\n  <div class=\"box\"></div>\n  \n  <Child --child-text-color={color} />\n  <button on:click={() => color = color === 'blue' ? 'red' : 'blue'}>\n    Toggle Color\n  </button>\n</div>\n\n<style>\n  .parent {\n    --parent-background: #f0f0f0;\n    padding: 20px;\n    background-color: var(--parent-background);\n  }\n  \n  .box {\n    width: 100px;\n    height: 100px;\n    background-color: var(--parent-background);\n    border: 2px solid black;\n  }\n</style>\n```\n\n```svelte\n<!-- Child.svelte -->\n<div class=\"child\">\n  <h3>Child Component</h3>\n  <p>This text uses a custom property from the parent.</p>\n  <div class=\"inner-box\"></div>\n</div>\n\n<style>\n  .child {\n    padding: 15px;\n    border: 1px solid #ccc;\n    margin-top: 20px;\n    /* Can access parent's custom property */\n    background-color: var(--parent-background, white);\n  }\n  \n  p {\n    /* Uses the custom property passed directly to the component */\n    color: var(--child-text-color, black);\n  }\n  \n  .inner-box {\n    width: 50px;\n    height: 50px;\n    /* Defines a custom property only for elements within this component */\n    --local-color: green;\n    background-color: var(--local-color);\n    margin: 10px 0;\n  }\n</style>\n```\n\n### Limitations and Gotchas\n\n1. **Fallback Values Are Important**: Always provide fallback values when using `var()` to ensure your component works even if the custom property isn't defined:\n\n```css\ncolor: var(--text-color, #333);\n```\n\n2. **No Type Checking**: Unlike component props, there's no type checking or validation for custom properties. A component expecting a color might receive an invalid value without warning.\n\n3. **Performance Considerations**: Overusing dynamic custom properties (those that change frequently) can impact performance, as each change requires recalculating styles.\n\n4. **No Direct Access in JavaScript**: You can't directly access custom property values in your component's JavaScript code without using `getComputedStyle()`:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let element;\n  let textColor;\n  \n  onMount(() => {\n    // Need to use getComputedStyle to access custom property values\n    textColor = getComputedStyle(element).getPropertyValue('--text-color').trim();\n  });\n</script>\n\n<div bind:this={element}>\n  Current text color is: {textColor}\n</div>\n```\n\n5. **SVG Handling Differences**: As mentioned in the documentation, Svelte handles custom properties differently for SVG elements (using a `<g>` wrapper instead of `<svelte-css-wrapper>`).\n\n6. **Specificity Challenges**: When using both inline custom properties and global ones, you might encounter specificity issues. The cascade still applies, so more specific selectors can override properties:\n\n```svelte\n<!-- GlobalStyles.svelte -->\n<style>\n  :global(:root) {\n    --button-color: blue;\n  }\n  \n  :global(.theme-red) {\n    --button-color: red !important; /* Using !important to override inline styles */\n  }\n</style>\n\n<!-- App.svelte -->\n<script>\n  import Button from './Button.svelte';\n  import GlobalStyles from './GlobalStyles.svelte';\n</script>\n\n<GlobalStyles />\n<div class=\"theme-red\">\n  <!-- This would still be green due to inline style having higher specificity -->\n  <Button --button-color=\"green\" />\n</div>\n```\n\n7. **Browser Support**: While custom properties are well-supported in modern browsers, you might need fallbacks for older browsers.\n\n### Best Practices\n\n1. **Define a Clear Contract**: Document which custom properties your component accepts and their expected values/formats.\n\n2. **Use Meaningful Names**: Use descriptive names that indicate the purpose rather than the value (e.g., `--primary-color` instead of `--blue`).\n\n3. **Namespace Component-Specific Properties**: To avoid collisions, consider namespacing custom properties for components:\n\n```svelte\n<!-- Button.svelte -->\n<style>\n  button {\n    background-color: var(--btn-background-color, #0077cc);\n    color: var(--btn-text-color, white);\n    border: var(--btn-border, none);\n  }\n</style>\n```\n\n4. **Create a Design System**: Define a consistent set of custom properties that form your design system's foundation:\n\n```css\n:root {\n  /* Color palette */\n  --color-primary: #3498db;\n  --color-secondary: #2ecc71;\n  --color-danger: #e74c3c;\n  --color-warning: #f39c12;\n  --color-info: #1abc9c;\n  \n  /* Typography */\n  --font-family-base: 'Inter', system-ui, sans-serif;\n  --font-size-base: 16px;\n  --line-height-base: 1.5;\n  \n  /* Spacing */\n  --spacing-unit: 8px;\n  --spacing-small: calc(var(--spacing-unit) * 1);\n  --spacing-medium: calc(var(--spacing-unit) * 2);\n  --spacing-large: calc(var(--spacing-unit) * 3);\n  \n  /* Borders & Shadows */\n  --border-radius: 4px;\n  --shadow-small: 0 1px 3px rgba(0,0,0,0.12);\n  --shadow-medium: 0 4px 6px rgba(0,0,0,0.12);\n}\n```\n\nBy understanding these interactions, limitations, and best practices, you can effectively leverage CSS custom properties in Svelte to create flexible, maintainable component systems."}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"How can you use CSS custom properties to create variant styles for a reusable component in Svelte?","answer":"CSS custom properties are excellent for creating variant styles in reusable components. This approach allows for flexible customization without the need for multiple component versions or complex conditional class logic. Let's explore how to implement a versatile Button component with variants using CSS custom properties.\n\n### Creating a Button Component with Variants\n\nHere's a comprehensive Button component that uses CSS custom properties for variants:\n\n```svelte\n<!-- Button.svelte -->\n<script>\n  // Props for basic configuration\n  export let type = 'button';\n  export let variant = 'primary'; // primary, secondary, danger, success, etc.\n  export let size = 'medium'; // small, medium, large\n  export let disabled = false;\n  export let fullWidth = false;\n  \n  // Generate classes based on props\n  $: classes = [\n    'btn',\n    `btn-${variant}`,\n    `btn-${size}`,\n    fullWidth ? 'btn-full' : '',\n  ].filter(Boolean).join(' ');\n</script>\n\n<button \n  {type} \n  class={classes} \n  {disabled} \n  on:click\n>\n  <slot></slot>\n</button>\n\n<style>\n  .btn {\n    font-family: inherit;\n    font-weight: 500;\n    border-radius: var(--btn-border-radius, 4px);\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: all 0.2s ease;\n    border: none;\n    outline: none;\n  }\n  \n  .btn:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n  \n  /* Size variants */\n  .btn-small {\n    font-size: var(--btn-small-font-size, 0.875rem);\n    padding: var(--btn-small-padding, 0.375rem 0.75rem);\n  }\n  \n  .btn-medium {\n    font-size: var(--btn-medium-font-size, 1rem);\n    padding: var(--btn-medium-padding, 0.5rem 1rem);\n  }\n  \n  .btn-large {\n    font-size: var(--btn-large-font-size, 1.125rem);\n    padding: var(--btn-large-padding, 0.75rem 1.5rem);\n  }\n  \n  /* Style variants */\n  .btn-primary {\n    background-color: var(--btn-primary-bg, #3498db);\n    color: var(--btn-primary-text, white);\n  }\n  \n  .btn-primary:hover:not(:disabled) {\n    background-color: var(--btn-primary-bg-hover, #2980b9);\n  }\n  \n  .btn-secondary {\n    background-color: var(--btn-secondary-bg, #95a5a6);\n    color: var(--btn-secondary-text, white);\n  }\n  \n  .btn-secondary:hover:not(:disabled) {\n    background-color: var(--btn-secondary-bg-hover, #7f8c8d);\n  }\n  \n  .btn-danger {\n    background-color: var(--btn-danger-bg, #e74c3c);\n    color: var(--btn-danger-text, white);\n  }\n  \n  .btn-danger:hover:not(:disabled) {\n    background-color: var(--btn-danger-bg-hover, #c0392b);\n  }\n  \n  .btn-success {\n    background-color: var(--btn-success-bg, #2ecc71);\n    color: var(--btn-success-text, white);\n  }\n  \n  .btn-success:hover:not(:disabled) {\n    background-color: var(--btn-success-bg-hover, #27ae60);\n  }\n  \n  .btn-outline {\n    background-color: transparent;\n    border: 2px solid var(--btn-outline-border, #3498db);\n    color: var(--btn-outline-text, #3498db);\n  }\n  \n  .btn-outline:hover:not(:disabled) {\n    background-color: var(--btn-outline-bg-hover, rgba(52, 152, 219, 0.1));\n  }\n  \n  /* Full width variant */\n  .btn-full {\n    width: 100%;\n  }\n</style>\n```\n\n### Using the Button Component with Default Variants\n\n```svelte\n<script>\n  import Button from './Button.svelte';\n</script>\n\n<div class=\"button-showcase\">\n  <h2>Button Variants</h2>\n  \n  <div class=\"section\">\n    <h3>Styles</h3>\n    <div class=\"button-row\">\n      <Button variant=\"primary\">Primary</Button>\n      <Button variant=\"secondary\">Secondary</Button>\n      <Button variant=\"danger\">Danger</Button>\n      <Button variant=\"success\">Success</Button>\n      <Button variant=\"outline\">Outline</Button>\n    </div>\n  </div>\n  \n  <div class=\"section\">\n    <h3>Sizes</h3>\n    <div class=\"button-row\">\n      <Button size=\"small\">Small</Button>\n      <Button>Medium (Default)</Button>\n      <Button size=\"large\">Large</Button>\n    </div>\n  </div>\n  \n  <div class=\"section\">\n    <h3>States</h3>\n    <div class=\"button-row\">\n      <Button>Normal</Button>\n      <Button disabled>Disabled</Button>\n    </div>\n  </div>\n  \n  <div class=\"section\">\n    <h3>Full Width</h3>\n    <Button fullWidth>Full Width Button</Button>\n  </div>\n</div>\n\n<style>\n  .button-showcase {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 2rem;\n  }\n  \n  .section {\n    margin-bottom: 2rem;\n  }\n  \n  .button-row {\n    display: flex;\n    gap: 1rem;\n    flex-wrap: wrap;\n  }\n</style>\n```\n\n### Customizing Button Variants with CSS Custom Properties\n\nNow, let's create a custom theme for our buttons using CSS custom properties. We can do this at the application level:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import Button from './Button.svelte';\n</script>\n\n<div class=\"app\">\n  <h1>Custom Button Themes</h1>\n  \n  <div class=\"default-theme\">\n    <h2>Default Theme</h2>\n    <div class=\"button-row\">\n      <Button variant=\"primary\">Primary</Button>\n      <Button variant=\"secondary\">Secondary</Button>\n      <Button variant=\"danger\">Danger</Button>\n    </div>\n  </div>\n  \n  <div class=\"custom-theme\">\n    <h2>Custom Theme</h2>\n    <div class=\"button-row\">\n      <Button variant=\"primary\">Primary</Button>\n      <Button variant=\"secondary\">Secondary</Button>\n      <Button variant=\"danger\">Danger</Button>\n    </div>\n  </div>\n  \n  <div class=\"rounded-theme\">\n    <h2>Rounded Theme</h2>\n    <div class=\"button-row\">\n      <Button variant=\"primary\">Primary</Button>\n      <Button variant=\"secondary\">Secondary</Button>\n      <Button variant=\"danger\">Danger</Button>\n    </div>\n  </div>\n  \n  <div class=\"specific-button\">\n    <h2>Individual Button Customization</h2>\n    <Button \n      variant=\"primary\"\n      --btn-primary-bg=\"purple\"\n      --btn-primary-bg-hover=\"darkpurple\"\n      --btn-border-radius=\"12px\"\n    >\n      Custom Purple Button\n    </Button>\n  </div>\n</div>\n\n<style>\n  .app {\n    font-family: system-ui, sans-serif;\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 2rem;\n  }\n  \n  .button-row {\n    display: flex;\n    gap: 1rem;\n    margin-bottom: 2rem;\n  }\n  \n  /* Custom theme with earthy colors */\n  .custom-theme {\n    --btn-primary-bg: #8e44ad;\n    --btn-primary-bg-hover: #703688;\n    --btn-primary-text: white;\n    \n    --btn-secondary-bg: #f39c12;\n    --btn-secondary-bg-hover: #d35400;\n    --btn-secondary-text: white;\n    \n    --btn-danger-bg: #c0392b;\n    --btn-danger-bg-hover: #922b21;\n    --btn-danger-text: white;\n    \n    padding: 1rem;\n    background-color: #f5f5f5;\n    border-radius: 8px;\n  }\n  \n  /* Rounded theme with soft colors */\n  .rounded-theme {\n    --btn-border-radius: 24px;\n    --btn-medium-padding: 0.5rem 1.5rem;\n    \n    --btn-primary-bg: #3498db;\n    --btn-primary-bg-hover: #2980b9;\n    \n    --btn-secondary-bg: #1abc9c;\n    --btn-secondary-bg-hover: #16a085;\n    \n    --btn-danger-bg: #e74c3c;\n    --btn-danger-bg-hover: #c0392b;\n    \n    padding: 1rem;\n    background-color: #f5f5f5;\n    border-radius: 8px;\n  }\n</style>\n```\n\n### Creating a Button Group Component\n\nWe can extend this pattern to create a ButtonGroup component that uses CSS custom properties to ensure consistent styling:\n\n```svelte\n<!-- ButtonGroup.svelte -->\n<script>\n  export let variant = 'primary';\n  export let size = 'medium';\n  export let vertical = false;\n  \n  // Pass these props down to child buttons\n  import { setContext } from 'svelte';\n  \n  setContext('buttonGroup', {\n    variant,\n    size\n  });\n</script>\n\n<div class=\"button-group {vertical ? 'vertical' : 'horizontal'}\">\n  <slot></slot>\n</div>\n\n<style>\n  .button-group {\n    display: inline-flex;\n    overflow: hidden;\n  }\n  \n  .horizontal {\n    flex-direction: row;\n  }\n  \n  .vertical {\n    flex-direction: column;\n  }\n  \n  /* Remove border radius between buttons */\n  :global(.button-group > :not(:first-child):not(:last-child)) {\n    border-radius: 0;\n  }\n  \n  :global(.button-group.horizontal > :first-child) {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n  \n  :global(.button-group.horizontal > :last-child) {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n  \n  :global(.button-group.vertical > :first-child) {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n  \n  :global(.button-group.vertical > :last-child) {\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n  }\n</style>\n```\n\nAnd the GroupButton component that works within the ButtonGroup:\n\n```svelte\n<!-- GroupButton.svelte -->\n<script>\n  import { getContext } from 'svelte';\n  \n  export let type = 'button';\n  export let variant = undefined;\n  export let size = undefined;\n  export let disabled = false;\n  \n  // Get values from ButtonGroup if available\n  const buttonGroup = getContext('buttonGroup');\n  \n  // Use ButtonGroup values as fallbacks\n  $: actualVariant = variant || (buttonGroup && buttonGroup.variant) || 'primary';\n  $: actualSize = size || (buttonGroup && buttonGroup.size) || 'medium';\n  \n  $: classes = [\n    'btn',\n    `btn-${actualVariant}`,\n    `btn-${actualSize}`,\n  ].join(' ');\n</script>\n\n<button \n  {type} \n  class={classes} \n  {disabled} \n  on:click\n>\n  <slot></slot>\n</button>\n\n<style>\n  /* Same styles as Button.svelte */\n  .btn {\n    font-family: inherit;\n    font-weight: 500;\n    border-radius: var(--btn-border-radius, 4px);\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    transition: all 0.2s ease;\n    border: none;\n    outline: none;\n  }\n  \n  /* ... rest of the styles from Button.svelte ... */\n</style>\n```\n\nUsing the ButtonGroup:\n\n```svelte\n<script>\n  import ButtonGroup from './ButtonGroup.svelte';\n  import GroupButton from './GroupButton.svelte';\n</script>\n\n<div class=\"button-groups\">\n  <h2>Button Groups</h2>\n  \n  <div class=\"section\">\n    <h3>Horizontal Group (Default)</h3>\n    <ButtonGroup variant=\"primary\">\n      <GroupButton>Left</GroupButton>\n      <GroupButton>Middle</GroupButton>\n      <GroupButton>Right</GroupButton>\n    </ButtonGroup>\n  </div>\n  \n  <div class=\"section\">\n    <h3>Vertical Group</h3>\n    <ButtonGroup variant=\"secondary\" vertical>\n      <GroupButton>Top</GroupButton>\n      <GroupButton>Middle</GroupButton>\n      <GroupButton>Bottom</GroupButton>\n    </ButtonGroup>\n  </div>\n  \n  <div class=\"section\">\n    <h3>Mixed Variants</h3>\n    <ButtonGroup>\n      <GroupButton variant=\"primary\">Primary</GroupButton>\n      <GroupButton variant=\"secondary\">Secondary</GroupButton>\n      <GroupButton variant=\"danger\">Danger</GroupButton>\n    </ButtonGroup>\n  </div>\n  \n  <div class=\"custom-group\">\n    <h3>Custom Styled Group</h3>\n    <ButtonGroup>\n      <GroupButton>One</GroupButton>\n      <GroupButton>Two</GroupButton>\n      <GroupButton>Three</GroupButton>\n    </ButtonGroup>\n  </div>\n</div>\n\n<style>\n  .button-groups {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 2rem;\n  }\n  \n  .section {\n    margin-bottom: 2rem;\n  }\n  \n  .custom-group {\n    --btn-primary-bg: #9b59b6;\n    --btn-primary-bg-hover: #8e44ad;\n    --btn-border-radius: 0px;\n    --btn-medium-padding: 1rem 2rem;\n    margin-bottom: 2rem;\n  }\n</style>\n```\n\n### Benefits of Using CSS Custom Properties for Component Variants\n\n1. **Separation of Concerns**: The component defines its structure and base styles, while the custom properties allow for theming without modifying the component.\n\n2. **Contextual Styling**: You can style components differently based on their context (e.g., buttons in a sidebar vs. buttons in a form).\n\n3. **Reduced Prop Explosion**: Instead of adding numerous props for every styling option, custom properties provide a more flexible approach.\n\n4. **Cascading Inheritance**: Custom properties defined at higher levels cascade down, allowing for theme-wide changes.\n\n5. **Runtime Customization**: Styles can be changed dynamically at runtime without recompiling components.\n\nThis approach creates a powerful and flexible component system that can adapt to various design requirements while maintaining a consistent API and behavior."}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"What are the performance implications of using dynamic CSS custom properties in Svelte components?","answer":"Using dynamic CSS custom properties in Svelte components can impact performance in various ways. Understanding these implications helps in making informed decisions about when and how to use them effectively.\n\n### Performance Considerations for Dynamic CSS Custom Properties\n\n#### 1. Style Recalculation Costs\n\nWhen a CSS custom property value changes, the browser needs to recalculate styles for all elements that use that property. This can be more expensive than traditional class-based styling approaches.\n\n**Example of potentially expensive dynamic custom properties:**\n\n```svelte\n<script>\n  let count = 0;\n  \n  // This will update the custom property on every tick\n  setInterval(() => {\n    count++;\n  }, 16); // ~60fps\n</script>\n\n<div \n  class=\"animated-element\"\n  style=\"--rotation-angle: {count}deg\"\n>\n  Spinning element\n</div>\n\n<style>\n  .animated-element {\n    width: 100px;\n    height: 100px;\n    background: red;\n    transform: rotate(var(--rotation-angle, 0deg));\n  }\n</style>\n```\n\nIn this example, the custom property changes 60 times per second, causing frequent style recalculations.\n\n#### 2. Comparison with Class-Based Approaches\n\nFor many use cases, toggling classes can be more performant than changing custom properties:\n\n```svelte\n<!-- Using custom properties (potentially less performant) -->\n<div class=\"box\" style=\"--box-color: {isActive ? 'blue' : 'gray'}\"></div>\n\n<!-- Using classes (potentially more performant) -->\n<div class=\"box {isActive ? 'active' : 'inactive'}\"></div>\n\n<style>\n  .box {\n    width: 100px;\n    height: 100px;\n  }\n  \n  /* Custom property approach */\n  .box {\n    background-color: var(--box-color, gray);\n  }\n  \n  /* Class-based approach */\n  .box.active {\n    background-color: blue;\n  }\n  \n  .box.inactive {\n    background-color: gray;\n  }\n</style>\n```\n\n#### 3. DOM Size Impact\n\nThe way Svelte handles custom properties by adding wrapper elements can increase DOM size:\n\n```svelte\n<!-- What you write -->\n<MyComponent --text-color=\"red\" />\n\n<!-- What Svelte produces -->\n<svelte-css-wrapper style=\"display: contents; --text-color: red;\">\n  <MyComponent />\n</svelte-css-wrapper>\n```\n\nThis additional wrapper can have a small performance cost in terms of memory and rendering time, especially if you have many components with custom properties.\n\n#### 4. Inline Style Performance\n\nWhen using dynamic expressions in custom properties, Svelte generates inline styles. Inline styles have higher specificity and can be less efficient for the browser to process compared to stylesheet rules:\n\n```svelte\n<script>\n  export let theme = 'light';\n  \n  $: themeColors = theme === 'light' \n    ? { '--bg-color': 'white', '--text-color': 'black' }\n    : { '--bg-color': '#222', '--text-color': 'white' };\n</script>\n\n<div style={Object.entries(themeColors).map(([prop, val]) => `${prop}:${val}`).join(';')}>\n  Content with dynamic theme\n</div>\n```\n\n### Performance Benchmarks and Measurements\n\nHere's a comparison of different styling approaches in Svelte, from most to least performant (generally):\n\n1. **Static CSS Classes**: Predefined classes in stylesheets\n2. **Toggling CSS Classes**: Adding/removing classes based on state\n3. **Static CSS Custom Properties**: Defined once and not changed\n4. **Dynamic CSS Custom Properties**: Changed in response to state\n\n### Optimization Strategies\n\n#### 1. Limit the Scope of Dynamic Properties\n\nOnly use dynamic custom properties for elements that actually need to change:\n\n```svelte\n<!-- Bad: Setting custom property at a high level -->\n<div style=\"--highlight-color: {isHighlighted ? 'yellow' : 'transparent'}\">\n  <DeepNestedComponent />\n</div>\n\n<!-- Better: Setting custom property closer to where it's used -->\n<div>\n  <DeepNestedComponent --highlight-color={isHighlighted ? 'yellow' : 'transparent'} />\n</div>\n```\n\n#### 2. Batch Custom Property Updates\n\nInstead of updating custom properties individually, batch them together:\n\n```svelte\n<script>\n  let x = 0;\n  let y = 0;\n  \n  // Bad: Individual updates\n  function updatePosition(newX, newY) {\n    x = newX;\n    y = newY;\n  }\n  \n  // Better: Batched updates\n  $: position = `--x: ${x}px; --y: ${y}px`;\n</script>\n\n<!-- Bad: Separate custom properties -->\n<div style=\"--x: {x}px; --y: {y}px\">Element</div>\n\n<!-- Better: Single style binding -->\n<div style={position}>Element</div>\n```\n\n#### 3. Use CSS Transitions Instead of Custom Property Animations\n\nFor animations, CSS transitions are often more performant than continuously updating custom properties:\n\n```svelte\n<!-- Less performant: Animating with custom properties -->\n<script>\n  let progress = 0;\n  \n  // This might run many times per second\n  function updateProgress(value) {\n    progress = value;\n  }\n</script>\n\n<div class=\"progress-bar\" style=\"--progress: {progress}%\"></div>\n\n<style>\n  .progress-bar {\n    width: var(--progress, 0%);\n    height: 20px;\n    background: blue;\n  }\n</style>\n\n<!-- More performant: Using CSS transitions -->\n<script>\n  let progress = 0;\n  \n  function updateProgress(value) {\n    progress = value;\n  }\n</script>\n\n<div class=\"progress-bar\" style=\"width: {progress}%\"></div>\n\n<style>\n  .progress-bar {\n    height: 20px;\n    background: blue;\n    transition: width 0.3s ease-out;\n  }\n</style>\n```\n\n#### 4. Consider Using CSS Variables for Theming, Classes for State\n\nA hybrid approach often works best:\n\n```svelte\n<script>\n  export let theme = 'light';\n  export let isActive = false;\n  \n  // Theme variables (change infrequently)\n  $: themeVars = theme === 'light'\n    ? { '--theme-bg': 'white', '--theme-text': 'black' }\n    : { '--theme-bg': '#222', '--theme-text': 'white' };\n  \n  $: themeStyle = Object.entries(themeVars)\n    .map(([prop, val]) => `${prop}:${val}`)\n    .join(';');\n</script>\n\n<!-- Theme via custom properties, state via classes -->\n<div \n  class=\"card {isActive ? 'active' : ''}\" \n  style={themeStyle}\n>\n  Card content\n</div>\n\n<style>\n  .card {\n    background: var(--theme-bg, white);\n    color: var(--theme-text, black);\n    padding: 1rem;\n    border-radius: 4px;\n    transition: transform 0.2s;\n  }\n  \n  .card.active {\n    transform: scale(1.05);\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n  }\n</style>\n```\n\n#### 5. Use Hardware Acceleration Where Appropriate\n\nTransform and opacity are GPU-accelerated properties. When animating, prefer these over properties that trigger layout recalculations:\n\n```svelte\n<script>\n  let progress = 0;\n</script>\n\n<!-- Better performance: Using transform -->\n<div class=\"progress\" style=\"--progress: {progress}\">\n  Progress: {progress}%\n</div>\n\n<style>\n  .progress {\n    transform: scaleX(calc(var(--progress, 0) / 100));\n    transform-origin: left;\n    background: blue;\n    height: 20px;\n  }\n</style>\n```\n\n### Real-World Performance Testing Example\n\nHere's how you might benchmark different styling approaches:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let items = Array(1000).fill().map((_, i) => ({ id: i, value: Math.random() }));\n  let approach = 'classes'; // 'classes', 'customProps', or 'inlineStyles'\n  let renderTime = 0;\n  \n  function benchmark() {\n    const start = performance.now();\n    approach = approach; // Force re-render\n    setTimeout(() => {\n      renderTime = (performance.now() - start).toFixed(2);\n    }, 0);\n  }\n  \n  onMount(benchmark);\n</script>\n\n<div>\n  <div class=\"controls\">\n    <button on:click={() => { approach = 'classes'; benchmark(); }}>\n      Use Classes\n    </button>\n    <button on:click={() => { approach = 'customProps'; benchmark(); }}>\n      Use Custom Properties\n    </button>\n    <button on:click={() => { approach = 'inlineStyles'; benchmark(); }}>\n      Use Inline Styles\n    </button>\n    <p>Render time: {renderTime}ms</p>\n  </div>\n  \n  <div class=\"list\">\n    {#if approach === 'classes'}\n      {#each items as item}\n        <div class=\"item {item.value > 0.5 ? 'high' : 'low'}\">\n          Item {item.id}: {item.value.toFixed(2)}\n        </div>\n      {/each}\n    {:else if approach === 'customProps'}\n      {#each items as item}\n        <div class=\"item-custom-prop\" style=\"--item-opacity: {item.value}\">\n          Item {item.id}: {item.value.toFixed(2)}\n        </div>\n      {/each}\n    {:else}\n      {#each items as item}\n        <div class=\"item-inline\" style=\"opacity: {item.value}\">\n          Item {item.id}: {item.value.toFixed(2)}\n        </div>\n      {/each}\n    {/if}\n  </div>\n</div>\n\n<style>\n  .list {\n    height: 400px;\n    overflow-y: auto;\n    border: 1px solid #ccc;\n  }\n  \n  .item, .item-custom-prop, .item-inline {\n    padding: 8px;\n    border-bottom: 1px solid #eee;\n  }\n  \n  .high {\n    opacity: 1;\n  }\n  \n  .low {\n    opacity: 0.5;\n  }\n  \n  .item-custom-prop {\n    opacity: var(--item-opacity);\n  }\n</style>\n```\n\n### Conclusion on Performance\n\nCSS custom properties in Svelte are powerful but come with performance considerations:\n\n1. **For Infrequently Changing Styles (Themes, Design Systems)**: Custom properties are excellent and have minimal performance impact.\n\n2. **For Frequently Changing Values (Animations, Real-time Updates)**: Consider alternatives like class toggling or CSS transitions.\n\n3. **For Large Lists or Performance-Critical Components**: Benchmark different approaches and choose based on measured results.\n\n4. **For Complex Applications**: Consider a hybrid approach - use custom properties for theming and design system variables, and use classes for state changes.\n\nBy understanding these performance implications, you can make informed decisions about when and how to use CSS custom properties in your Svelte applications."}
{"source":"docs/svelte/04-styling/03-custom-properties.md","question":"How can you effectively use CSS custom properties to create adaptive components that respond to both parent context and direct customization?","answer":"Creating adaptive components that respond to both parent context and direct customization is a powerful pattern in Svelte. CSS custom properties are ideal for this approach as they respect the CSS cascade while allowing for specific overrides. Let's explore comprehensive strategies for building such components.\n\n### Creating Context-Aware Adaptive Components\n\nThe key to building adaptive components is to leverage the cascading nature of CSS custom properties while providing clear points for customization. Here's a comprehensive approach:\n\n#### 1. Design a Component with Layered Customization Points\n\nLet's create a Card component that adapts to:\n- Global theme variables\n- Parent container context\n- Direct customization\n\n```svelte\n<!-- Card.svelte -->\n<script>\n  export let elevation = 'medium'; // 'low', 'medium', 'high'\n  export let interactive = false;\n  export let padding = undefined; // Allow override of padding\n</script>\n\n<div \n  class=\"card {elevation} {interactive ? 'interactive' : ''}\"\n  style={padding ? `--card-padding: ${padding}` : ''}\n>\n  <div class=\"card-content\">\n    <slot></slot>\n  </div>\n</div>\n\n<style>\n  .card {\n    /* Layer 1: Default styles as fallbacks */\n    background-color: var(--card-bg, white);\n    color: var(--card-text, #333);\n    border-radius: var(--card-radius, 8px);\n    padding: var(--card-padding, 1rem);\n    border: var(--card-border, none);\n    transition: var(--card-transition, all 0.2s ease);\n    \n    /* Use box-shadow for elevation */\n    box-shadow: var(--card-shadow, 0 2px 4px rgba(0,0,0,0.1));\n  }\n  \n  /* Layer 2: Elevation variants */\n  .card.low {\n    --card-shadow: var(--shadow-low, 0 1px 2px rgba(0,0,0,0.08));\n  }\n  \n  .card.medium {\n    --card-shadow: var(--shadow-medium, 0 2px 4px rgba(0,0,0,0.1));\n  }\n  \n  .card.high {\n    --card-shadow: var(--shadow-high, 0 4px 8px rgba(0,0,0,0.12));\n  }\n  \n  /* Layer 3: Interactive state */\n  .card.interactive {\n    cursor: pointer;\n  }\n  \n  .card.interactive:hover {\n    transform: translateY(var(--card-hover-lift, -2px));\n    box-shadow: var(--card-hover-shadow, var(--shadow-high, 0 4px 8px rgba(0,0,0,0.12)));\n  }\n  \n  .card-content {\n    /* Additional customization point for inner content */\n    color: var(--card-content-color, inherit);\n  }\n</style>\n```\n\n#### 2. Create a Theme Provider for Global Context\n\n```svelte\n<!-- ThemeProvider.svelte -->\n<script>\n  export let theme = 'light'; // 'light', 'dark', 'colorful'\n  \n  $: themeVars = {\n    // Light theme (default)\n    light: {\n      // Base colors\n      '--color-primary': '#3498db',\n      '--color-secondary': '#2ecc71',\n      '--color-background': '#ffffff',\n      '--color-surface': '#f8f9fa',\n      '--color-text': '#333333',\n      \n      // Component-specific variables\n      '--card-bg': 'var(--color-surface)',\n      '--card-text': 'var(--color-text)',\n      '--card-radius': '8px',"}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"What is the purpose of the `svelte/legacy` module in Svelte 5, and when should developers use it?","answer":"The `svelte/legacy` module in Svelte 5 provides functions to help with migration from Svelte 4 to Svelte 5. It contains utilities that allow developers to gradually migrate their code since some features from Svelte 4 can't be replaced directly with new Svelte 5 features.\n\nThe module is explicitly marked as deprecated, indicating that these functions should be used only temporarily during the migration process and should be phased out over time as code is fully updated to Svelte 5 patterns.\n\nDevelopers should use the `svelte/legacy` module when:\n1. They're in the process of migrating a Svelte 4 application to Svelte 5\n2. They need to maintain compatibility with older code patterns while gradually updating\n3. They have imperative component code that needs to be adapted to the new reactive paradigm\n4. They're dealing with event modifiers that worked differently in Svelte 4\n\nExample of importing from the legacy module:\n```js\nimport {\n  asClassComponent,\n  createBubbler,\n  preventDefault,\n  stopPropagation\n} from 'svelte/legacy';\n```\n\nIt's important to understand that these imports should be considered temporary solutions, and developers should plan to migrate away from them as they fully adopt Svelte 5 patterns."}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"How can you convert a Svelte 5 component function into a Svelte 4 compatible component constructor using the legacy module?","answer":"The `svelte/legacy` module provides two main functions for converting Svelte 5 component functions to Svelte 4 compatible component constructors: `asClassComponent` and `createClassComponent`.\n\n1. `asClassComponent` - Takes a component function and returns a Svelte 4 compatible component constructor:\n\n```js\nimport { asClassComponent } from 'svelte/legacy';\n\n// Modern Svelte 5 component function\nfunction MyComponent(props) {\n  let { name = 'world' } = props;\n  \n  return {\n    // Component implementation\n    h: () => {\n      return `<h1>Hello ${name}!</h1>`;\n    }\n  };\n}\n\n// Convert to a Svelte 4 compatible class component\nconst MyClassComponent = asClassComponent(MyComponent);\n\n// Now you can use it like a Svelte 4 component\nnew MyClassComponent({\n  target: document.body,\n  props: {\n    name: 'Svelte'\n  }\n});\n```\n\n2. `createClassComponent` - Takes the same options as a Svelte 4 component along with the component function:\n\n```js\nimport { createClassComponent } from 'svelte/legacy';\n\nfunction MyComponent(props) {\n  let { count = 0 } = props;\n  \n  function increment() {\n    count += 1;\n  }\n  \n  return {\n    h: () => {\n      return `\n        <div>\n          <p>Count: ${count}</p>\n          <button onclick=${increment}>Increment</button>\n        </div>\n      `;\n    }\n  };\n}\n\n// Create a Svelte 4 compatible component with additional options\nconst MyClassComponent = createClassComponent({\n  component: MyComponent,\n  props: {\n    count: { default: 0 }\n  },\n  immutable: true\n});\n\n// Use as a Svelte 4 component\nconst instance = new MyClassComponent({\n  target: document.body\n});\n```\n\nBoth of these functions are marked as deprecated and should only be used as temporary solutions during migration. The long-term goal should be to fully adopt the Svelte 5 component model."}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"How can you replicate Svelte 4's event modifiers in Svelte 5 using the legacy module?","answer":"In Svelte 4, event modifiers like `preventDefault`, `stopPropagation`, `once`, etc. were available as directive modifiers (e.g., `on:click|preventDefault`). In Svelte 5, these have changed, but the `svelte/legacy` module provides functions to replicate this behavior during migration.\n\nHere's how to use each event modifier function from the legacy module:\n\n1. `preventDefault` - Prevents the default action of the event:\n\n```svelte\n<script>\n  import { preventDefault } from 'svelte/legacy';\n  \n  function handleClick(event) {\n    console.log('Link clicked, but navigation prevented');\n  }\n  \n  // Wrap your handler with preventDefault\n  const handleClickWithPreventDefault = preventDefault(handleClick);\n</script>\n\n<a href=\"https://example.com\" on:click={handleClickWithPreventDefault}>Click me</a>\n```\n\n2. `stopPropagation` - Stops the event from propagating up the DOM tree:\n\n```svelte\n<script>\n  import { stopPropagation } from 'svelte/legacy';\n  \n  function handleClick() {\n    console.log('Inner div clicked');\n  }\n  \n  function outerClick() {\n    console.log('Outer div clicked');\n  }\n  \n  const handleClickWithStopPropagation = stopPropagation(handleClick);\n</script>\n\n<div on:click={outerClick}>\n  Outer div\n  <div on:click={handleClickWithStopPropagation}>\n    Inner div (click won't propagate)\n  </div>\n</div>\n```\n\n3. `self` - Only triggers if the event target is the element itself:\n\n```svelte\n<script>\n  import { self } from 'svelte/legacy';\n  \n  function handleClick() {\n    console.log('Div itself was clicked');\n  }\n  \n  const handleClickSelf = self(handleClick);\n</script>\n\n<div on:click={handleClickSelf}>\n  Click me directly (not my children)\n  <span>Clicking this won't trigger the parent handler</span>\n</div>\n```\n\n4. `once` - Ensures the handler runs only once:\n\n```svelte\n<script>\n  import { once } from 'svelte/legacy';\n  \n  function handleClick() {\n    console.log('This will only log once');\n  }\n  \n  const handleClickOnce = once(handleClick);\n</script>\n\n<button on:click={handleClickOnce}>Click me (only works once)</button>\n```\n\n5. `trusted` - Only runs if the event is a trusted (browser-generated) event:\n\n```svelte\n<script>\n  import { trusted } from 'svelte/legacy';\n  \n  function handleClick() {\n    console.log('Trusted click detected');\n  }\n  \n  const handleTrustedClick = trusted(handleClick);\n</script>\n\n<button on:click={handleTrustedClick}>Only responds to real user clicks</button>\n```\n\n6. `stopImmediatePropagation` - Prevents other listeners of the same event from being called:\n\n```svelte\n<script>\n  import { stopImmediatePropagation } from 'svelte/legacy';\n  \n  function handleClick1() {\n    console.log('Handler 1');\n  }\n  \n  function handleClick2() {\n    console.log('Handler 2 - won\\'t run if stopImmediatePropagation is used');\n  }\n  \n  const handleWithStop = stopImmediatePropagation(handleClick1);\n</script>\n\n<button on:click={handleWithStop} on:click={handleClick2}>\n  Only the first handler will run\n</button>\n```\n\n7. `passive` and `nonpassive` - These are implemented as actions for touch events:\n\n```svelte\n<script>\n  import { passive, nonpassive } from 'svelte/legacy';\n  \n  function handleTouchMove(event) {\n    console.log('Touch move detected');\n  }\n</script>\n\n<!-- Passive event listener (better performance for scrolling) -->\n<div use:passive={['touchmove', () => handleTouchMove]}>\n  Passive touch area\n</div>\n\n<!-- Non-passive event listener (allows preventDefault) -->\n<div use:nonpassive={['touchmove', () => handleTouchMove]}>\n  Non-passive touch area\n</div>\n```\n\nThese functions should be used only temporarily during migration, with the goal of eventually updating your code to use Svelte 5's native patterns for handling events."}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"What is the `createBubbler` function in the `svelte/legacy` module, and how can it be used to mimic Svelte 4's event bubbling behavior?","answer":"The `createBubbler` function in the `svelte/legacy` module is designed to mimic Svelte 4's automatic event delegation behavior where components could forward events using the `on:event` syntax without explicitly defining a handler.\n\nIn Svelte 4, you could do:\n\n```svelte\n<!-- ParentComponent.svelte -->\n<ChildComponent on:click />\n```\n\nThis would automatically bubble up any `click` events from the child component to the parent without needing to define a handler.\n\nIn Svelte 5, this automatic bubbling behavior changed, and the `createBubbler` function provides a way to replicate this during migration:\n\n```svelte\n<!-- ChildComponent.svelte (Svelte 5) -->\n<script>\n  import { createBubbler } from 'svelte/legacy';\n  \n  // Create a bubble function\n  const bubble = createBubbler();\n  \n  // Use it to forward specific events\n  const forwardClick = bubble('click');\n</script>\n\n<button on:click={forwardClick}>\n  Click me (event will bubble to parent)\n</button>\n```\n\nThen in the parent component:\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  function handleClick(event) {\n    console.log('Click event bubbled from child component');\n  }\n</script>\n\n<ChildComponent on:click={handleClick} />\n```\n\nHere's a more complex example showing how to handle multiple events:\n\n```svelte\n<!-- ComplexComponent.svelte -->\n<script>\n  import { createBubbler } from 'svelte/legacy';\n  \n  // Create the bubbler once\n  const bubble = createBubbler();\n  \n  // Create event forwarders for different event types\n  const forwardClick = bubble('click');\n  const forwardMouseover = bubble('mouseover');\n  const forwardSubmit = bubble('submit');\n  \n  // You can also combine with other event modifiers\n  import { stopPropagation } from 'svelte/legacy';\n  const forwardKeydown = stopPropagation(bubble('keydown'));\n</script>\n\n<div>\n  <button on:click={forwardClick}>Click bubbles</button>\n  <div on:mouseover={forwardMouseover}>Hover bubbles</div>\n  <form on:submit={forwardSubmit}>\n    <input type=\"text\" on:keydown={forwardKeydown} />\n    <button type=\"submit\">Submit bubbles</button>\n  </form>\n</div>\n```\n\nThe `createBubbler` function is marked as deprecated and should be used only as a temporary solution during migration to Svelte 5. The long-term approach should be to explicitly handle and forward events in the component structure."}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"How can you handle multiple event listeners for the same event using the `svelte/legacy` module?","answer":"In Svelte 4, you could attach multiple event listeners to the same event directly in the markup. In Svelte 5, this behavior has changed, but the `svelte/legacy` module provides the `handlers` function to mimic this functionality during migration.\n\nThe `handlers` function takes multiple event listener functions and returns a single event listener that will execute all of them in sequence.\n\nHere's how to use it:\n\n```svelte\n<script>\n  import { handlers } from 'svelte/legacy';\n  \n  function firstHandler(event) {\n    console.log('First handler called');\n  }\n  \n  function secondHandler(event) {\n    console.log('Second handler called');\n  }\n  \n  function thirdHandler(event) {\n    console.log('Third handler called');\n  }\n  \n  // Combine multiple handlers into one\n  const combinedHandlers = handlers(\n    firstHandler,\n    secondHandler,\n    thirdHandler\n  );\n</script>\n\n<!-- Attach the combined handler to an event -->\n<button on:click={combinedHandlers}>\n  Click me to trigger all handlers\n</button>\n```\n\nYou can also combine it with other event modifiers from the legacy module:\n\n```svelte\n<script>\n  import { handlers, preventDefault, stopPropagation } from 'svelte/legacy';\n  \n  function logClick(event) {\n    console.log('Button clicked');\n  }\n  \n  function updateCounter(event) {\n    counter += 1;\n  }\n  \n  let counter = 0;\n  \n  // Combine handlers with modifiers\n  const clickHandlers = handlers(\n    preventDefault(logClick),\n    stopPropagation(updateCounter)\n  );\n</script>\n\n<div on:click={() => console.log('Outer div clicked')}>\n  <a href=\"https://example.com\" on:click={clickHandlers}>\n    Click me ({counter})\n  </a>\n</div>\n```\n\nIn a more complex scenario, you might use it with component events:\n\n```svelte\n<!-- ParentComponent.svelte -->\n<script>\n  import { handlers, createBubbler } from 'svelte/legacy';\n  import ChildComponent from './ChildComponent.svelte';\n  \n  function parentHandler1(event) {\n    console.log('Parent handler 1');\n  }\n  \n  function parentHandler2(event) {\n    console.log('Parent handler 2');\n  }\n  \n  const combinedHandlers = handlers(parentHandler1, parentHandler2);\n</script>\n\n<ChildComponent on:customEvent={combinedHandlers} />\n```\n\n```svelte\n<!-- ChildComponent.svelte -->\n<script>\n  import { createBubbler } from 'svelte/legacy';\n  \n  const bubble = createBubbler();\n  const forwardCustomEvent = bubble('customEvent');\n  \n  function triggerEvent() {\n    const event = new CustomEvent('customEvent', {\n      detail: { message: 'Hello from child' }\n    });\n    forwardCustomEvent(event);\n  }\n</script>\n\n<button on:click={triggerEvent}>\n  Trigger custom event\n</button>\n```\n\nThe `handlers` function is part of the legacy module and should be used as a temporary solution during migration. In a fully migrated Svelte 5 application, you would typically handle multiple listeners differently."}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"What is the purpose of the `run` function in the `svelte/legacy` module, and how does it differ between server and client environments?","answer":"The `run` function in the `svelte/legacy` module is designed to help migrate component code that needs to run initialization logic. It has different behaviors on the server and client:\n\n1. On the server: It runs the given function once immediately\n2. On the client: It works like `$effect.pre` (runs before the DOM is updated)\n\nThis makes it useful for initialization code that needs to execute in both environments but with slightly different timing requirements.\n\nHere's how to use the `run` function:\n\n```svelte\n<script>\n  import { run } from 'svelte/legacy';\n  \n  let data = null;\n  let loading = true;\n  let error = null;\n  \n  // Use run for initialization code\n  run(() => {\n    console.log('This runs immediately on the server, and as $effect.pre on the client');\n    \n    // Fetch data during initialization\n    fetchData()\n      .then(result => {\n        data = result;\n        loading = false;\n      })\n      .catch(err => {\n        error = err;\n        loading = false;\n      });\n    \n    // Optionally return a cleanup function\n    return () => {\n      console.log('Cleanup function - runs when dependencies change or component is destroyed');\n      // Perform any cleanup like cancelling requests, etc.\n    };\n  });\n  \n  async function fetchData() {\n    // Fetch implementation\n    return new Promise(resolve => {\n      setTimeout(() => resolve({ message: 'Data loaded' }), 1000);\n    });\n  }\n</script>\n\n{#if loading}\n  <p>Loading...</p>\n{:else if error}\n  <p>Error: {error.message}</p>\n{:else}\n  <p>{data.message}</p>\n{/if}\n```\n\nThe `run` function is particularly useful when migrating components that had initialization code in their `onMount` lifecycle methods or in the component's constructor in Svelte 4.\n\nAnother example showing dependency tracking:\n\n```svelte\n<script>\n  import { run } from 'svelte/legacy';\n  \n  let userId = 1;\n  let userProfile = null;\n  \n  // This will re-run when userId changes\n  run(() => {\n    console.log(`Fetching profile for user ${userId}`);\n    fetchUserProfile(userId).then(profile => {\n      userProfile = profile;\n    });\n    \n    return () => {\n      console.log(`Cleaning up for user ${userId}`);\n      // Cancel any in-flight requests\n    };\n  });\n  \n  function nextUser() {\n    userId += 1;\n  }\n  \n  async function fetchUserProfile(id) {\n    // Simulate API call\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve({ id, name: `User ${id}`, email: `user${id}@example.com` });\n      }, 500);\n    });\n  }\n</script>\n\n<div>\n  {#if userProfile}\n    <h2>{userProfile.name}</h2>\n    <p>Email: {userProfile.email}</p>\n  {:else}\n    <p>Loading profile...</p>\n  {/if}\n  \n  <button on:click={nextUser}>Next User</button>\n</div>\n```\n\nIt's important to note that the `run` function is marked as deprecated with a note to use it only as a temporary solution during migration to Svelte 5. The long-term approach would be to use Svelte 5's native reactivity system with `$effect` and other reactive primitives."}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"How do the `passive` and `nonpassive` functions work in the `svelte/legacy` module, and why are they implemented as actions rather than event wrappers?","answer":"The `passive` and `nonpassive` functions in the `svelte/legacy` module are designed to replicate Svelte 4's `passive` and `nonpassive` event modifiers. Unlike other event modifiers in the legacy module (like `preventDefault` or `stopPropagation`), these are implemented as actions rather than event wrapper functions.\n\nThe reason they're implemented as actions is because the passive/nonpassive nature of an event listener needs to be specified when the listener is attached to the DOM element, not when the event is handled. Actions in Svelte allow direct manipulation of DOM elements when they're created.\n\nHere's how these functions work:\n\n1. `passive` - Creates a passive event listener, which improves scrolling performance by telling the browser that the handler will never call `preventDefault()`:\n\n```svelte\n<script>\n  import { passive } from 'svelte/legacy';\n  \n  function handleTouchMove(event) {\n    console.log('Touch move detected');\n    // Cannot call preventDefault() in a passive listener\n  }\n</script>\n\n<!-- Use the passive action to create a passive event listener -->\n<div use:passive={['touchmove', () => handleTouchMove]}>\n  Scroll this area (passive listener)\n</div>\n```\n\n2. `nonpassive` - Creates a non-passive event listener, which allows calling `preventDefault()` but may impact scrolling performance:\n\n```svelte\n<script>\n  import { nonpassive } from 'svelte/legacy';\n  \n  function handleTouchMove(event) {\n    // Can call preventDefault() to prevent scrolling\n    event.preventDefault();\n    console.log('Touch move detected and default prevented');\n  }\n</script>\n\n<!-- Use the nonpassive action to create a non-passive event listener -->\n<div use:nonpassive={['touchmove', () => handleTouchMove]}>\n  Try to scroll this area (will be prevented)\n</div>\n```\n\nThese are particularly useful for touch events on mobile devices, where the browser's default behavior (like scrolling) can interfere with custom touch interactions.\n\nHere's a more complex example showing both in use:\n\n```svelte\n<script>\n  import { passive, nonpassive } from 'svelte/legacy';\n  \n  let startY = 0;\n  let currentY = 0;\n  let dragging = false;\n  \n  function handleTouchStart(event) {\n    startY = event.touches[0].clientY;\n    dragging = true;\n  }\n  \n  function handleTouchMove(event) {\n    if (dragging) {\n      currentY = event.touches[0].clientY - startY;\n    }\n  }\n  \n  function handleTouchEnd() {\n    dragging = false;\n  }\n  \n  // Prevent default only for the draggable element\n  function handleDraggableTouchMove(event) {\n    event.preventDefault(); // Prevent scrolling while dragging\n    if (dragging) {\n      currentY = event.touches[0].clientY - startY;\n    }\n  }\n</script>\n\n<style>\n  .container {\n    height: 200px;\n    overflow-y: scroll;\n    border: 1px solid #ccc;\n  }\n  \n  .draggable {\n    background: #f0f0f0;\n    padding: 20px;\n    cursor: grab;\n  }\n  \n  .content {\n    height: 500px;\n  }\n</style>\n\n<!-- Container with passive touch handler (allows normal scrolling) -->\n<div \n  class=\"container\" \n  use:passive={['touchmove', () => handleTouchMove]}\n  on:touchstart={handleTouchStart}\n  on:touchend={handleTouchEnd}\n>\n  <div class=\"content\">\n    <p>Scroll me normally (passive listener)</p>\n    \n    <!-- Draggable element with non-passive touch handler -->\n    <div \n      class=\"draggable\" \n      use:nonpassive={['touchmove', () => handleDraggableTouchMove]}\n      style=\"transform: translateY({currentY}px)\"\n    >\n      Drag me (prevents scrolling)\n    </div>\n    \n    <p>More scrollable content...</p>\n  </div>\n</div>\n```\n\nBoth `passive` and `nonpassive` are marked as deprecated and should be used only as temporary solutions during migration to Svelte 5. In a fully migrated application, you would typically use other approaches to handle these cases, such as the browser's native `{ passive: true }` option in event listeners."}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"What is the `LegacyComponentType` in the `svelte/legacy` module, and how does it help with component migration?","answer":"The `LegacyComponentType` is a TypeScript type definition in the `svelte/legacy` module that helps support using components as both class-based components (Svelte 4 style) and function components (Svelte 5 style) during the transition period.\n\nThis type is particularly useful when you're gradually migrating a codebase from Svelte 4 to Svelte 5 and need to maintain compatibility with both component paradigms.\n\nHere's the type definition:\n\n```typescript\ntype LegacyComponentType = {\n  new (o: ComponentConstructorOptions): SvelteComponent;\n  (\n    ...args: Parameters<Component<Record<string, any>>>\n  ): ReturnType<\n    Component<Record<string, any>, Record<string, any>>\n  >;\n};\n```\n\nThis type defines a component that can be:\n1. Instantiated with `new` like a Svelte 4 class component\n2. Called as a function like a Svelte 5 function component\n\nHere's how you might use it in practice:\n\n```typescript\n// Component.ts\nimport { asClassComponent } from 'svelte/legacy';\nimport type { LegacyComponentType } from 'svelte/legacy';\n\n// Modern Svelte 5 function component\nfunction MyComponent(props: { name: string }) {\n  let { name = 'world' } = props;\n  \n  return {\n    h: () => {\n      return `<h1>Hello ${name}!</h1>`;\n    }\n  };\n}\n\n// Convert to a dual-use component\nconst Component: LegacyComponentType = asClassComponent(MyComponent) as any;\n\nexport default Component;\n```\n\nThen you can use this component in both Svelte 4 and Svelte 5 styles:\n\n```javascript\n// Svelte 4 style (class-based)\nimport Component from './Component';\n\nconst instance = new Component({\n  target: document.body,\n  props: {\n    name: 'Svelte 4'\n  }\n});\n\n// Svelte 5 style (function-based)\nimport Component from './Component';\n\nconst { h } = Component({ name: 'Svelte 5' });\n// Use h() to render\n```\n\nThis dual-mode capability is particularly useful in large applications where you're migrating components gradually, or when you're creating a library that needs to support both Svelte 4 and Svelte 5 consumers.\n\nHere's a more complex example with TypeScript that shows how to create a component that works in both paradigms:\n\n```typescript\n// DualModeComponent.ts\nimport { asClassComponent } from 'svelte/legacy';\nimport type { LegacyComponentType } from 'svelte/legacy';\n\ninterface Props {\n  count: number;\n  name: string;\n}\n\ninterface Events {\n  increment: CustomEvent<number>;\n  reset: CustomEvent<void>;\n}\n\n// Modern Svelte 5 function component\nfunction Counter(props: Props) {\n  let { count = 0, name = 'Counter' } = props;\n  \n  function increment() {\n    count += 1;\n    const event = new CustomEvent('increment', { detail: count });\n    dispatchEvent(event);\n  }\n  \n  function reset() {\n    count = 0;\n    const event = new CustomEvent('reset');\n    dispatchEvent(event);\n  }\n  \n  return {\n    h: () => {\n      return `\n        <div>\n          <h2>${name}</h2>\n          <p>Count: ${count}</p>\n          <button onclick=${increment}>Increment</button>\n          <button onclick=${reset}>Reset</button>\n        </div>\n      `;\n    }\n  };\n}\n\n// Create the dual-mode component\nconst DualModeCounter = asClassComponent(Counter) as LegacyComponentType;\n\nexport default DualModeCounter;\n```\n\nUsing the `LegacyComponentType` and the helpers from `svelte/legacy` allows for a smoother transition between Svelte versions, but it's important to remember that these are temporary solutions. The end goal should be to fully migrate to Svelte 5's component model."}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"How can you combine multiple event modifiers from the `svelte/legacy` module to create complex event handling behaviors?","answer":"The event modifier functions in the `svelte/legacy` module can be combined (composed) to create complex event handling behaviors, similar to how you could chain event modifiers in Svelte 4 (e.g., `on:click|preventDefault|stopPropagation`).\n\nThe key to combining these modifiers is function composition - applying one modifier function to the result of another. Here are examples of how to combine multiple event modifiers:\n\n1. Basic combination of `preventDefault` and `stopPropagation`:\n\n```svelte\n<script>\n  import { preventDefault, stopPropagation } from 'svelte/legacy';\n  \n  function handleClick(event) {\n    console.log('Link clicked, but navigation prevented and propagation stopped');\n  }\n  \n  // Compose multiple modifiers by applying them in sequence\n  // Order matters! Apply from inside to outside\n  const modifiedHandler = stopPropagation(preventDefault(handleClick));\n</script>\n\n<div on:click={() => console.log('This won\\'t run when link is clicked')}>\n  <a href=\"https://example.com\" on:click={modifiedHandler}>\n    Click me\n  </a>\n</div>\n```\n\n2. Combining `once`, `self`, and `trusted`:\n\n```svelte\n<script>\n  import { once, self, trusted } from 'svelte/legacy';\n  \n  function handleClick(event) {\n    console.log('Button clicked - this will only run once, only if clicked directly, and only for trusted events');\n  }\n  \n  // Compose multiple modifiers\n  const modifiedHandler = once(self(trusted(handleClick)));\n</script>\n\n<div>\n  <button on:click={modifiedHandler}>\n    Click me directly (only works once)\n    <span>Clicking this span won't trigger the handler</span>\n  </button>\n</div>\n```\n\n3. Using `handlers` with other modifiers:\n\n```svelte\n<script>\n  import { handlers, preventDefault, stopPropagation } from 'svelte/legacy';\n  \n  function log(event) {\n    console.log('Action logged');\n  }\n  \n  function updateCounter(event) {\n    counter += 1;\n  }\n  \n  function saveData(event) {\n    console.log('Data saved');\n  }\n  \n  let counter = 0;\n  \n  // Combine multiple handlers with different modifiers\n  const clickHandler = handlers(\n    preventDefault(log),\n    stopPropagation(updateCounter),\n    saveData // No modifier for this one\n  );\n</script>\n\n<div on:click={() => console.log('Outer div - this won\\'t run')}>\n  <form on:submit={clickHandler}>\n    <input type=\"text\" placeholder=\"Enter data\">\n    <button type=\"submit\">Submit ({counter})</button>\n  </form>\n</div>\n```\n\n4. Complex example with actions and event modifiers:\n\n```svelte\n<script>\n  import { \n    preventDefault, \n    stopPropagation, \n    once, \n    self, \n    handlers,\n    passive,\n    nonpassive\n  } from 'svelte/legacy';\n  \n  let dragState = { x: 0, y: 0, isDragging: false };\n  let clickCount = 0;\n  \n  function startDrag(event) {\n    dragState.isDragging = true;\n    dragState.x = event.clientX;\n    dragState.y = event.clientY;\n  }\n  \n  function handleDrag(event) {\n    if (dragState.isDragging) {\n      console.log(`Dragging: dx=${event.clientX - dragState.x}, dy=${event.clientY - dragState.y}`);\n    }\n  }\n  \n  function endDrag() {\n    dragState.isDragging = false;\n  }\n  \n  function logOnce() {\n    console.log('This will only log once');\n  }\n  \n  function incrementCounter() {\n    clickCount += 1;\n  }\n  \n  // Compose complex handlers\n  const dragStartHandler = preventDefault(startDrag);\n  const dragHandler = preventDefault(handleDrag);\n  const clickHandler = handlers(\n    once(logOnce),\n    self(incrementCounter)\n  );\n</script>\n\n<div class=\"container\">\n  <!-- Draggable element with non-passive touch handling -->\n  <div \n    class=\"draggable\"\n    on:mousedown={dragStartHandler}\n    use:nonpassive={['touchmove', () => dragHandler]}\n    on:mouseup={endDrag}\n    on:mouseleave={endDrag}\n  >\n    Drag me\n  </div>\n  \n  <!-- Scrollable area with passive touch handling -->\n  <div \n    class=\"scrollable\"\n    use:passive={['touchmove', () => console.log('Scrolling...')]}\n  >\n    <div class=\"content\">\n      <button on:click={clickHandler}>\n        Click me directly ({clickCount})\n        <span>Clicking this span won't count</span>\n      </button>\n    </div>\n  </div>\n</div>\n\n<style>\n  .container {\n    display: flex;\n    height: 300px;\n  }\n  \n  .draggable {\n    width: 100px;\n    height: 100px;\n    background: #f0f0f0;\n    cursor: move;\n    user-select: none;\n  }\n  \n  .scrollable {\n    flex: 1;\n    overflow-y: auto;\n    border: 1px solid #ccc;\n  }\n  \n  .content {\n    height: 600px;\n    padding: 20px;\n  }\n</style>\n```\n\nWhen combining these modifiers, it's important to apply them in the correct order, typically from the innermost function (the actual handler) outward. The execution happens in reverse order: the outermost modifier runs first, then the next one in, and so on, until finally the original handler runs (if all modifiers allow it to).\n\nRemember that these event modifier functions from the `svelte/legacy` module are meant to be temporary solutions during migration. In a fully migrated Svelte 5 application, you would typically handle these behaviors differently using the new reactivity system and event handling patterns."}
{"source":"docs/svelte/98-reference/21-svelte-legacy.md","question":"What migration strategy should developers adopt when using the `svelte/legacy` module, and how should they plan to move away from it over time?","answer":"When using the `svelte/legacy` module for migration to Svelte 5, developers should adopt a strategic approach that allows for incremental updates while maintaining application functionality. Here's a comprehensive migration strategy:\n\n### Phase 1: Initial Migration with Legacy Helpers\n\n1. **Identify Svelte 4 Patterns**: Audit your codebase to identify Svelte 4-specific patterns that need migration:\n   - Class components\n   - Event modifiers\n   - Automatic event bubbling\n   - Lifecycle methods\n\n2. **Introduce Legacy Helpers**: Use the appropriate functions from `svelte/legacy`:\n   ```js\n   import {\n     asClassComponent,\n     createBubbler,\n     preventDefault,\n     stopPropagation,\n     run\n     // other helpers as needed\n   } from 'svelte/legacy';\n   ```\n\n3. **Mark Legacy Code**: Add comments to clearly identify legacy code that needs future refactoring:\n   ```js\n   // TODO: Migrate away from legacy helpers\n   const clickHandler = preventDefault(handleClick);\n   ```\n\n### Phase 2: Component-by-Component Migration\n\n4. **Create a Migration Schedule**: Prioritize components for full migration based on:\n   - Complexity\n   - Frequency of updates\n   - Dependencies\n\n5. **Migrate Component Structure**: Start with the simplest components:\n   ```svelte\n   <!-- Before (using legacy helpers) -->\n   <script>\n     import { preventDefault } from 'svelte/legacy';\n     \n     function handleSubmit(event) {\n       // handle submission\n     }\n     \n     const submitHandler = preventDefault(handleSubmit);\n   </script>\n   \n   <form on:submit={submitHandler}>\n     <!-- form content -->\n   </form>\n   \n   <!-- After (native Svelte 5) -->\n   <script>\n     function handleSubmit(event) {\n       event.preventDefault();\n       // handle submission\n     }\n   </script>\n   \n   <form on:submit={handleSubmit}>\n     <!-- form content -->\n   </form>\n   ```\n\n6. **Replace Event Modifiers**: Migrate away from legacy event modifiers:\n   - Replace `preventDefault(handler)` with inline `event.preventDefault()`\n   - Replace `stopPropagation(handler)` with inline `event.stopPropagation()`\n   - Replace `once(handler)` with manual tracking or DOM `{ once: true }` option\n\n7. **Update Event Bubbling**: Replace `createBubbler()` with explicit event forwarding:\n   ```svelte\n   <!-- Before (Child.svelte) -->\n   <script>\n     import { createBubbler } from 'svelte/legacy';\n     const bubble = createBubbler();\n     const forwardClick = bubble('click');\n   </script>\n   \n   <button on:click={forwardClick}>Click</button>\n   \n   <!-- After (Child.svelte) -->\n   <script>\n     import { createEventDispatcher } from 'svelte';\n     const dispatch = createEventDispatcher();\n     \n     function handleClick(event) {\n       dispatch('click', event);\n     }\n   </script>\n   \n   <button on:click={handleClick}>Click</button>\n   ```\n\n8. **Migrate Class Components**: Convert from legacy class components to function components:\n   ```js\n   // Before\n   import { asClassComponent } from 'svelte/legacy';\n   \n   function MyComponent(props) {\n     // component logic\n   }\n   \n   export default asClassComponent(MyComponent);\n   \n   // After\n   function MyComponent(props) {\n     // component logic\n   }\n   \n   export default MyComponent;\n   ```\n\n### Phase 3: Reactivity System Migration\n\n9. **Replace `run` with Native Reactivity**: Migrate from `run` to Svelte 5's reactivity primitives:\n   ```svelte\n   <!-- Before -->\n   <script>\n     import { run } from 'svelte/legacy';\n     \n     let data;\n     \n     run(() => {\n       fetchData().then(result => {\n         data = result;\n       });\n       \n       return () => {\n         // cleanup\n       };\n     });\n   </script>\n   \n   <!-- After -->\n   <script>\n     import { onMount } from 'svelte';\n     \n     let data;\n     \n     $effect(() => {\n       fetchData().then(result => {\n         data = result;\n       });\n       \n       return () => {\n         // cleanup\n       };\n     });\n   </script>\n   ```\n\n10. **Migrate Passive/Nonpassive Actions**: Replace with native event options:\n    ```svelte\n    <!-- Before -->\n    <script>\n      import { passive } from 'svelte/legacy';\n    </script>\n    \n    <div use:passive={['touchmove', () => handleTouchMove]}>\n      Content\n    </div>\n    \n    <!-- After -->\n    <script>\n      function setupPassive(node) {\n        const handleTouchMove = (e) => {\n          // handler code\n        };\n        \n        node.addEventListener('touchmove', handleTouchMove, { passive: true });\n        \n        return {\n          destroy() {\n            node.removeEventListener('touchmove', handleTouchMove);\n          }\n        };\n      }\n    </script>\n    \n    <div use:setupPassive>\n      Content\n    </div>\n    ```\n\n### Phase 4: Testing and Cleanup\n\n11. **Add Comprehensive Tests**: Ensure behavior remains consistent during migration.\n\n12. **Remove Legacy Imports**: After fully migrating a component, remove all legacy imports.\n\n13. **Add ESLint Rules**: Create custom ESLint rules to prevent new usage of legacy helpers:\n    ```js\n    // .eslintrc.js\n    module.exports = {\n      rules: {\n        'no-restricted-imports': ['error', {\n          paths: [{\n            name: 'svelte/legacy',\n            message: 'Legacy imports should not be used in new code. Migrate to Svelte 5 patterns.'\n          }]\n        }]\n      }\n    };\n    ```\n\n14. **Track Migration Progress**: Create a migration dashboard to track progress across the codebase.\n\n### Best Practices During Migration\n\n- **Don't Rush**: Migrate incrementally to maintain stability.\n- **One Pattern at a Time**: Focus on migrating one pattern (e.g., event modifiers) across the codebase before moving to the next.\n- **Update Documentation**: Keep internal documentation updated with new patterns.\n- **Train the Team**: Ensure all developers understand both the legacy helpers and the new Svelte 5 patterns.\n- **Leverage TypeScript**: Use TypeScript to catch migration issues early.\n\n### Example Migration Roadmap\n\n1. **Month 1**: Audit codebase, introduce legacy helpers where needed\n2. **Month 2-3**: Migrate event modifiers and handlers\n3. **Month 4-5**: Migrate component structure and bubbling\n4. **Month 6-8**: Migrate to new reactivity system\n5. **Month 9**: Testing and performance optimization\n6. **Month 10-12**: Cleanup and removal of all legacy imports\n\nBy following this strategic approach, developers can successfully migrate from Svelte 4 to Svelte 5 while maintaining application functionality and code quality throughout the process. The key is to view the `svelte/legacy` module as a temporary bridge that enables incremental migration rather than a permanent solution."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"What are the core classes available in Svelte 5's motion module, and how do they differ in their animation approach?","answer":"Svelte 5's motion module (`svelte/motion`) provides two primary animation classes: `Spring` and `Tween`. \n\nThe `Spring` class creates animations that follow spring physics, simulating the behavior of a spring with properties like stiffness and damping. This results in more natural, bounce-like movements.\n\nThe `Tween` class creates animations that move at a controlled pace from one value to another, using easing functions and specified durations.\n\nHere's a comparison of both approaches:\n\n```svelte\n<script>\n  import { Spring, Tween } from 'svelte/motion';\n  \n  // Spring animation - physics-based\n  const springValue = new Spring(0, {\n    stiffness: 0.15,  // Controls how \"stiff\" the spring is\n    damping: 0.8      // Controls how quickly the spring settles\n  });\n  \n  // Tween animation - time-based\n  const tweenValue = new Tween(0, {\n    duration: 1000,   // Animation lasts 1000ms\n    easing: t => t    // Linear easing function\n  });\n  \n  function animate() {\n    // Spring will animate based on physics\n    springValue.target = 100;\n    \n    // Tween will animate over the specified duration\n    tweenValue.target = 100;\n  }\n</script>\n\n<button on:click={animate}>Animate</button>\n\n<div>Spring value: {springValue.current}</div>\n<div>Tween value: {tweenValue.current}</div>\n```\n\nThe key difference is that springs are physics-based (they respond to parameters like stiffness and damping), while tweens are time-based (they follow a predetermined duration and easing curve). Springs often feel more natural for interactive elements, while tweens provide more predictable timing for sequenced animations."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"How can you create reactive springs that automatically update when a value changes in Svelte 5?","answer":"In Svelte 5, you can create reactive springs using the `Spring.of()` static method. This creates a spring whose value is automatically bound to the return value of a provided function, which must be called inside an effect root (like during component initialization).\n\nHere's how to use it:\n\n```svelte\n<script>\n  import { Spring } from 'svelte/motion';\n  \n  // Define a reactive value\n  let counter = $state(0);\n  \n  // Create a spring that automatically updates when counter changes\n  const counterSpring = Spring.of(() => counter, {\n    stiffness: 0.1,\n    damping: 0.8\n  });\n  \n  function increment() {\n    counter++;\n  }\n</script>\n\n<button on:click={increment}>Increment: {counter}</button>\n\n<!-- Display the spring-animated value -->\n<div style=\"transform: scale({counterSpring.current / 10 + 1})\">\n  Animated value: {counterSpring.current.toFixed(2)}\n</div>\n```\n\nThis is particularly useful for creating animations that respond to state changes without having to manually update the spring target. The spring will automatically animate to the new value whenever the source value changes.\n\nYou can also use this with props:\n\n```svelte\n<script>\n  import { Spring } from 'svelte/motion';\n  \n  // Using props in Svelte 5\n  let { value } = $props();\n  \n  // Create a spring bound to the prop value\n  const valueSpring = Spring.of(() => value);\n</script>\n\n<div style=\"transform: translateX({valueSpring.current}px)\">\n  Animated element\n</div>\n```\n\nThe `Spring.of()` method simplifies reactive animations by automatically handling the binding between your data and the animated value."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"How can you implement an animated counter in Svelte 5 using the Tween class, and what options can you customize?","answer":"You can implement an animated counter in Svelte 5 using the `Tween` class, which provides smooth transitions between numeric values. The `Tween` class allows you to customize several aspects of the animation through its options.\n\nHere's a complete example of an animated counter:\n\n```svelte\n<script>\n  import { Tween } from 'svelte/motion';\n  import { cubicOut } from 'svelte/easing';\n  \n  // Initial counter value\n  let count = $state(0);\n  \n  // Create a tween with custom options\n  const animatedCount = new Tween(0, {\n    duration: 800,         // Animation duration in milliseconds\n    easing: cubicOut,      // Easing function for the animation\n    interpolate: (a, b) => {\n      // Custom interpolation function for integers\n      return t => Math.round(a + (b - a) * t);\n    }\n  });\n  \n  // Update the tween target whenever count changes\n  $effect(() => {\n    animatedCount.target = count;\n  });\n  \n  function increment() {\n    count += 1;\n  }\n  \n  function incrementBy10() {\n    count += 10;\n    \n    // You can also override options when setting the target\n    animatedCount.set(count, {\n      duration: 1500,  // Longer duration for bigger changes\n    });\n  }\n  \n  function reset() {\n    count = 0;\n    \n    // You can make changes instant with duration: 0\n    animatedCount.set(0, { duration: 0 });\n  }\n</script>\n\n<div class=\"counter\">\n  <h2>Animated count: {animatedCount.current.toFixed(0)}</h2>\n  <h3>Actual count: {count}</h3>\n  \n  <button on:click={increment}>+1</button>\n  <button on:click={incrementBy10}>+10</button>\n  <button on:click={reset}>Reset</button>\n</div>\n\n<style>\n  .counter {\n    font-size: 2em;\n    text-align: center;\n  }\n</style>\n```\n\nThe customizable options for the `Tween` class include:\n\n1. `duration`: How long the transition takes (in milliseconds)\n2. `delay`: How long to wait before starting the transition\n3. `easing`: A function that transforms the time parameter (from 0 to 1)\n4. `interpolate`: A custom function to interpolate between values (useful for non-numeric values)\n\nYou can also use `Tween.of()` to create a tween that automatically tracks a value:\n\n```svelte\n<script>\n  import { Tween } from 'svelte/motion';\n  \n  let { value } = $props();\n  \n  // Automatically tracks changes to the value prop\n  const animatedValue = Tween.of(() => value, {\n    duration: 400,\n    easing: t => t * t  // Custom quadratic easing\n  });\n</script>\n\n<div>Animated: {animatedValue.current.toFixed(2)}</div>\n```\n\nThis makes it easy to create smooth transitions between changing values in your application."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"How does Svelte 5's `prefersReducedMotion` feature work, and how can you use it to create accessible animations?","answer":"Svelte 5's `prefersReducedMotion` is a media query feature that detects if a user has enabled the \"reduced motion\" setting in their operating system. This setting is important for accessibility, as some users may experience discomfort or health issues (like vestibular disorders) when viewing certain animations.\n\nThe `prefersReducedMotion` feature returns a `MediaQuery` object that you can use to conditionally modify or disable animations based on the user's preference.\n\nHere's how to use it:\n\n```svelte\n<script>\n  import { prefersReducedMotion } from 'svelte/motion';\n  import { Spring } from 'svelte/motion';\n  import { fly } from 'svelte/transition';\n  \n  let showElement = $state(false);\n  \n  // Create a spring with reduced motion when appropriate\n  const animatedValue = new Spring(0, {\n    // Use lower stiffness when reduced motion is preferred\n    stiffness: prefersReducedMotion.current ? 0.05 : 0.2,\n    // Use higher damping when reduced motion is preferred\n    damping: prefersReducedMotion.current ? 1 : 0.5\n  });\n  \n  function animate() {\n    animatedValue.target = animatedValue.target === 0 ? 100 : 0;\n  }\n  \n  function toggle() {\n    showElement = !showElement;\n  }\n</script>\n\n<button on:click={animate}>Animate Spring</button>\n<button on:click={toggle}>Toggle Element</button>\n\n<!-- Animated div using spring -->\n<div \n  style=\"\n    transform: translateX({animatedValue.current}px);\n    transition: transform {prefersReducedMotion.current ? '0.5s linear' : '0.2s ease-out'};\n  \"\n>\n  Spring-animated element\n</div>\n\n<!-- Using with Svelte transitions -->\n{#if showElement}\n  <div transition:fly={{ \n    y: prefersReducedMotion.current ? 0 : 200,\n    duration: prefersReducedMotion.current ? 0 : 500\n  }}>\n    This element flies in, unless reduced motion is preferred\n  </div>\n{/if}\n```\n\nBest practices for using `prefersReducedMotion`:\n\n1. For essential animations, provide a less intense alternative when `prefersReducedMotion.current` is `true`\n2. For decorative animations, consider disabling them entirely\n3. For transitions, use minimal movement or fade transitions instead of motion-heavy animations\n4. For spring animations, use higher damping and lower stiffness values to reduce bouncing\n\nYou can also create a utility function to help with animation parameters:\n\n```svelte\n<script>\n  import { prefersReducedMotion } from 'svelte/motion';\n  \n  // Helper function to get animation parameters based on motion preference\n  function getAnimationParams(regularParams, reducedParams) {\n    return prefersReducedMotion.current ? reducedParams : regularParams;\n  }\n  \n  // Usage\n  const flyParams = getAnimationParams(\n    { y: 100, duration: 500 },  // Regular motion\n    { y: 0, duration: 0 }       // Reduced motion\n  );\n</script>\n\n{#if visible}\n  <div transition:fly={flyParams}>\n    Content\n  </div>\n{/if}\n```\n\nBy respecting the user's motion preferences, you create a more accessible and comfortable experience for all users."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"What is the difference between the deprecated `spring` function and the new `Spring` class in Svelte 5?","answer":"In Svelte 5, the `spring` function has been deprecated in favor of the new `Spring` class. While they both create spring-based animations, there are several key differences in their implementation and usage:\n\n### Key Differences:\n\n1. **Class vs. Store**:\n   - `Spring` is a class with properties and methods\n   - `spring` returns a store with a subscribe method\n\n2. **Access to Values**:\n   - `Spring`: Uses `.current` and `.target` properties\n   - `spring`: Uses store subscription or the `$` syntax\n\n3. **Reactivity Model**:\n   - `Spring`: Aligns with Svelte 5's runes-based reactivity\n   - `spring`: Uses Svelte's traditional store-based reactivity\n\n4. **Static Methods**:\n   - `Spring` includes `Spring.of()` for creating reactive springs\n   - `spring` doesn't have equivalent functionality\n\nHere's a comparison of both approaches:\n\n```svelte\n<script>\n  // Old approach with spring function (deprecated)\n  import { spring } from 'svelte/motion';\n  \n  const oldSpring = spring(0, {\n    stiffness: 0.1,\n    damping: 0.8\n  });\n  \n  // New approach with Spring class\n  import { Spring } from 'svelte/motion';\n  \n  const newSpring = new Spring(0, {\n    stiffness: 0.1,\n    damping: 0.8\n  });\n  \n  function animate() {\n    // Old way: set the value\n    oldSpring.set(100);\n    \n    // New way: set the target\n    newSpring.target = 100;\n    \n    // Alternative new way with options\n    newSpring.set(100, { stiffness: 0.2 });\n  }\n</script>\n\n<!-- Old way: using the $ syntax or subscription -->\n<div>Old spring value: {$oldSpring}</div>\n\n<!-- New way: using the .current property -->\n<div>New spring value: {newSpring.current}</div>\n```\n\n### Migration from old to new:\n\nIf you're migrating from the old `spring` function to the new `Spring` class, here are the changes you'll need to make:\n\n```svelte\n<script>\n  // Before (deprecated)\n  import { spring } from 'svelte/motion';\n  const value = spring(0, { stiffness: 0.1, damping: 0.8 });\n  \n  // After\n  import { Spring } from 'svelte/motion';\n  const value = new Spring(0, { stiffness: 0.1, damping: 0.8 });\n  \n  function updateValue() {\n    // Before\n    value.set(100);\n    // or\n    value.update(n => n + 10);\n    \n    // After\n    value.target = 100;\n    // or\n    value.set(100);\n    // or (for update-like behavior)\n    value.target = value.current + 10;\n  }\n</script>\n\n<!-- Before -->\n<div>{$value}</div>\n\n<!-- After -->\n<div>{value.current}</div>\n```\n\nAnother significant improvement in the new `Spring` class is the ability to create reactive springs with `Spring.of()`:\n\n```svelte\n<script>\n  import { Spring } from 'svelte/motion';\n  \n  let count = $state(0);\n  \n  // This automatically updates when count changes\n  const animatedCount = Spring.of(() => count);\n  \n  function increment() {\n    count++;\n  }\n</script>\n\n<button on:click={increment}>Count: {count}</button>\n<div>Animated: {animatedCount.current.toFixed(2)}</div>\n```\n\nThis was not possible with the old `spring` function without manually updating the spring value whenever the source value changed."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"How can you implement a draggable element with momentum using Svelte 5's Spring class?","answer":"Implementing a draggable element with momentum using Svelte 5's `Spring` class is a great way to create natural-feeling interactions. The `preserveMomentum` option in the `Spring.set()` method allows the spring to continue on its current trajectory for a specified time, creating a smooth, physics-based feel.\n\nHere's a complete implementation of a draggable element with momentum:\n\n```svelte\n<script>\n  import { Spring } from 'svelte/motion';\n  import { onMount } from 'svelte';\n  \n  // Create springs for x and y positions\n  const x = new Spring(0, { stiffness: 0.1, damping: 0.8 });\n  const y = new Spring(0, { stiffness: 0.1, damping: 0.8 });\n  \n  // Track velocity for momentum calculations\n  let lastX = 0;\n  let lastY = 0;\n  let velocityX = 0;\n  let velocityY = 0;\n  let lastTime = 0;\n  let isDragging = false;\n  \n  // Element reference\n  let element;\n  \n  onMount(() => {\n    // Initial position\n    const rect = element.getBoundingClientRect();\n    x.target = window.innerWidth / 2 - rect.width / 2;\n    y.target = window.innerHeight / 2 - rect.height / 2;\n    \n    // Update position when window resizes\n    window.addEventListener('resize', () => {\n      if (!isDragging) {\n        x.target = window.innerWidth / 2 - rect.width / 2;\n        y.target = window.innerHeight / 2 - rect.height / 2;\n      }\n    });\n  });\n  \n  function startDrag(event) {\n    isDragging = true;\n    lastX = event.clientX || event.touches[0].clientX;\n    lastY = event.clientY || event.touches[0].clientY;\n    lastTime = Date.now();\n    \n    // Set up event listeners for drag and release\n    window.addEventListener('mousemove', drag);\n    window.addEventListener('touchmove', drag);\n    window.addEventListener('mouseup', endDrag);\n    window.addEventListener('touchend', endDrag);\n  }\n  \n  function drag(event) {\n    if (!isDragging) return;\n    \n    const clientX = event.clientX || event.touches[0].clientX;\n    const clientY = event.clientY || event.touches[0].clientY;\n    const currentTime = Date.now();\n    const deltaTime = currentTime - lastTime;\n    \n    // Calculate new position\n    const deltaX = clientX - lastX;\n    const deltaY = clientY - lastY;\n    \n    // Update springs with new targets\n    x.target = x.current + deltaX;\n    y.target = y.current + deltaY;\n    \n    // Calculate velocity for momentum\n    if (deltaTime > 0) {\n      velocityX = deltaX / deltaTime * 1000; // pixels per second\n      velocityY = deltaY / deltaTime * 1000;\n    }\n    \n    // Update last values\n    lastX = clientX;\n    lastY = clientY;\n    lastTime = currentTime;\n  }\n  \n  function endDrag() {\n    isDragging = false;\n    \n    // Remove event listeners\n    window.removeEventListener('mousemove', drag);\n    window.removeEventListener('touchmove', drag);\n    window.removeEventListener('mouseup', endDrag);\n    window.removeEventListener('touchend', endDrag);\n    \n    // Apply momentum based on velocity\n    const momentumDuration = 500; // milliseconds of momentum\n    \n    // The higher the velocity, the longer the momentum\n    const velocityMagnitude = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n    const momentumFactor = Math.min(velocityMagnitude / 1000, 1);\n    const adjustedDuration = momentumDuration * momentumFactor;\n    \n    if (adjustedDuration > 50) {\n      // Calculate final position with momentum\n      const momentumX = x.current + (velocityX * adjustedDuration / 1000);\n      const momentumY = y.current + (velocityY * adjustedDuration / 1000);\n      \n      // Apply momentum with preserveMomentum option\n      x.set(momentumX, { preserveMomentum: adjustedDuration });\n      y.set(momentumY, { preserveMomentum: adjustedDuration });\n    }\n  }\n</script>\n\n<div \n  bind:this={element}\n  class=\"draggable\"\n  style=\"transform: translate({x.current}px, {y.current}px)\"\n  on:mousedown={startDrag}\n  on:touchstart={startDrag}\n>\n  Drag me\n</div>\n\n<style>\n  .draggable {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n    background-color: #ff3e00;\n    color: white;\n    border-radius: 8px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    user-select: none;\n    cursor: grab;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n    touch-action: none; /* Prevents scrolling on touch devices */\n  }\n  \n  .draggable:active {\n    cursor: grabbing;\n  }\n</style>\n```\n\nKey aspects of this implementation:\n\n1. **Velocity Tracking**: We calculate the velocity by measuring the distance moved over time.\n\n2. **Momentum Application**: When the drag ends, we use the `preserveMomentum` option with `Spring.set()` to continue the movement with a natural deceleration.\n\n3. **Adaptive Momentum**: The momentum duration is scaled based on the velocity magnitude, so faster flicks result in longer momentum effects.\n\n4. **Touch Support**: The implementation works with both mouse and touch events.\n\nYou can enhance this further with:\n\n- Boundary constraints to keep the element within the viewport\n- Rotation or scaling based on multi-touch gestures\n- Snapping to a grid or specific positions\n- Different spring configurations for different directions or states\n\nFor example, adding boundary constraints:\n\n```svelte\nfunction endDrag() {\n  // ... existing code ...\n  \n  // After applying momentum, add boundary checks\n  $effect(() => {\n    // Get element dimensions\n    const rect = element.getBoundingClientRect();\n    \n    // Check if out of bounds\n    if (x.current < 0) {\n      x.target = 0;\n    } else if (x.current + rect.width > window.innerWidth) {\n      x.target = window.innerWidth - rect.width;\n    }\n    \n    if (y.current < 0) {\n      y.target = 0;\n    } else if (y.current + rect.height > window.innerHeight) {\n      y.target = window.innerHeight - rect.height;\n    }\n  });\n}\n```\n\nThis creates a natural, physics-based draggable element that responds to user input with realistic momentum."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"How can you create a coordinated animation sequence using multiple Tween instances in Svelte 5?","answer":"Creating coordinated animation sequences with multiple `Tween` instances in Svelte 5 allows you to build complex, choreographed animations. By chaining promises returned from the `set()` method, you can create sequential animations, while running tweens in parallel creates simultaneous animations.\n\nHere's a comprehensive example of a coordinated animation sequence:\n\n```svelte\n<script>\n  import { Tween } from 'svelte/motion';\n  import { cubicOut, elasticOut, backInOut } from 'svelte/easing';\n  \n  // Create multiple tweens for different properties\n  const x = new Tween(0);\n  const y = new Tween(0);\n  const scale = new Tween(1);\n  const rotation = new Tween(0);\n  const opacity = new Tween(0);\n  \n  let isAnimating = $state(false);\n  \n  // Function to run a sequence of animations\n  async function runAnimationSequence() {\n    if (isAnimating) return;\n    isAnimating = true;\n    \n    try {\n      // Reset all values instantly\n      await Promise.all([\n        x.set(0, { duration: 0 }),\n        y.set(0, { duration: 0 }),\n        scale.set(0.5, { duration: 0 }),\n        rotation.set(-45, { duration: 0 }),\n        opacity.set(0, { duration: 0 })\n      ]);\n      \n      // Step 1: Fade in and scale up (parallel animations)\n      await Promise.all([\n        opacity.set(1, { duration: 800, easing: cubicOut }),\n        scale.set(1, { duration: 1000, easing: elasticOut })\n      ]);\n      \n      // Step 2: Move to the right\n      await x.set(200, { \n        duration: 1000, \n        easing: cubicOut \n      });\n      \n      // Step 3: Move down while rotating (parallel)\n      await Promise.all([\n        y.set(100, { duration: 800, easing: cubicOut }),\n        rotation.set(360, { duration: 1200, easing: backInOut })\n      ]);\n      \n      // Step 4: Return to center with a bounce\n      await Promise.all([\n        x.set(0, { duration: 1500, easing: elasticOut }),\n        y.set(0, { duration: 1500, easing: elasticOut })\n      ]);\n      \n      // Step 5: Final flourish - spin and fade out\n      await Promise.all([\n        rotation.set(720, { duration: 1200, easing: cubicOut }),\n        scale.set(0.2, { duration: 1000, easing: backInOut }),\n        opacity.set(0, { duration: 800, easing: cubicOut, delay: 400 })\n      ]);\n      \n    } finally {\n      isAnimating = false;\n    }\n  }\n</script>\n\n<button on:click={runAnimationSequence} disabled={isAnimating}>\n  {isAnimating ? 'Animating...' : 'Run Animation Sequence'}\n</button>\n\n<div class=\"animation-container\">\n  <div \n    class=\"animated-element\"\n    style=\"\n      transform: translate({x.current}px, {y.current}px) \n                rotate({rotation.current}deg) \n                scale({scale.current});\n      opacity: {opacity.current};\n    \"\n  >\n    <span>ð</span>\n  </div>\n</div>\n\n<style>\n  .animation-container {\n    position: relative;\n    height: 400px;\n    border: 1px solid #ccc;\n    overflow: hidden;\n    margin-top: 20px;\n  }\n  \n  .animated-element {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    width: 80px;\n    height: 80px;\n    margin-left: -40px;\n    margin-top: -40px;\n    background: #ff3e00;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 2em;\n  }\n</style>\n```\n\n### Creating Reusable Animation Sequences\n\nYou can also create reusable animation functions that can be composed together:\n\n```svelte\n<script>\n  import { Tween } from 'svelte/motion';\n  \n  // Create tweens for different elements\n  const element1 = {\n    x: new Tween(0),\n    y: new Tween(0),\n    opacity: new Tween(1)\n  };\n  \n  const element2 = {\n    x: new Tween(0),\n    y: new Tween(0),\n    opacity: new Tween(1)\n  };\n  \n  // Reusable animation functions\n  async function fadeIn(element, duration = 500) {\n    return element.opacity.set(1, { duration });\n  }\n  \n  async function fadeOut(element, duration = 500) {\n    return element.opacity.set(0, { duration });\n  }\n  \n  async function moveTo(element, x, y, duration = 1000) {\n    return Promise.all([\n      element.x.set(x, { duration }),\n      element.y.set(y, { duration })\n    ]);\n  }\n  \n  // Compose animations into a sequence\n  async function animateEntrance() {\n    // First element fades in and moves\n    await fadeIn(element1, 300);\n    await moveTo(element1, 200, 0, 800);\n    \n    // Second element follows after first\n    await fadeIn(element2, 300);\n    await moveTo(element2, 0, 100, 800);\n    \n    // Both elements move together\n    await Promise.all([\n      moveTo(element1, 100, 100, 1200),\n      moveTo(element2, 100, 0, 1200)\n    ]);\n  }\n</script>\n\n<button on:click={animateEntrance}>Animate Entrance</button>\n\n<div class=\"stage\">\n  <div class=\"element element-1\" \n       style=\"transform: translate({element1.x.current}px, {element1.y.current}px);\n              opacity: {element1.opacity.current};\">\n    Element 1\n  </div>\n  \n  <div class=\"element element-2\"\n       style=\"transform: translate({element2.x.current}px, {element2.y.current}px);\n              opacity: {element2.opacity.current};\">\n    Element 2\n  </div>\n</div>\n```\n\n### Timing and Coordination Tips:\n\n1. **Parallel Animations**: Use `Promise.all()` to run multiple animations simultaneously\n2. **Sequential Animations**: Chain promises with `await` to run animations one after another\n3. **Staggered Timing**: Use the `delay` option to start animations at different times\n4. **Dynamic Durations**: Calculate durations based on distance or complexity\n5. **Error Handling**: Wrap sequences in try/catch to handle interruptions\n6. **Cancellation**: Keep references to running animations to cancel them if needed\n\nFor example, to create a staggered animation of multiple elements:\n\n```svelte\n<script>\n  import { Tween } from 'svelte/motion';\n  \n  // Create an array of elements with their own tweens\n  const elements = Array(5).fill().map(() => ({\n    y: new Tween(100),\n    opacity: new Tween(0)\n  }));\n  \n  async function staggeredEntrance() {\n    const staggerDelay = 100; // ms between each element\n    \n    // Animate each element with increasing delay\n    await Promise.all(elements.map((element, i) => {\n      return Promise.all([\n        element.y.set(0, { \n          duration: 800, \n          delay: i * staggerDelay \n        }),\n        element.opacity.set(1, { \n          duration: 600, \n          delay: i * staggerDelay \n        })\n      ]);\n    }));\n  }\n</script>\n```\n\nBy combining these techniques, you can create sophisticated animation sequences that enhance your user interface with smooth, coordinated motion."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"How can you implement a custom interpolation function with the Tween class to animate between non-numeric values?","answer":"The `Tween` class in Svelte 5 can animate between non-numeric values by using a custom interpolation function. This allows you to animate colors, arrays, objects, or any other type of data by defining how values should be interpolated during the animation.\n\nThe `interpolate` option takes a function that receives the start and end values and returns another function that takes a progress parameter (`t` between 0 and 1) and returns the interpolated value.\n\nHere's how to implement custom interpolations for different data types:\n\n```svelte\n<script>\n  import { Tween } from 'svelte/motion';\n  import { cubicOut } from 'svelte/easing';\n  \n  // 1. Color interpolation\n  const colorTween = new Tween('#ff3e00', {\n    duration: 1000,\n    easing: cubicOut,\n    interpolate: (startColor, endColor) => {\n      // Parse hex colors to RGB\n      const parseColor = (hex) => {\n        const r = parseInt(hex.slice(1, 3), 16);\n        const g = parseInt(hex.slice(3, 5), 16);\n        const b = parseInt(hex.slice(5, 7), 16);\n        return { r, g, b };\n      };\n      \n      const start = parseColor(startColor);\n      const end = parseColor(endColor);\n      \n      // Return interpolation function\n      return (t) => {\n        // Calculate interpolated RGB values\n        const r = Math.round(start.r + (end.r - start.r) * t);\n        const g = Math.round(start.g + (end.g - start.g) * t);\n        const b = Math.round(start.b + (end.b - start.b) * t);\n        \n        // Convert back to hex\n        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n      };\n    }\n  });\n  \n  // 2. Array interpolation (e.g., for path coordinates)\n  const pathTween = new Tween(\n    [0, 20, 50, 80, 100],  // Start array\n    {\n      duration: 1500,\n      interpolate: (startArray, endArray) => {\n        return (t) => {\n          // Ensure arrays are the same length\n          const maxLength = Math.max(startArray.length, endArray.length);\n          const result = [];\n          \n          for (let i = 0; i < maxLength; i++) {\n            const startVal = startArray[i] || 0;\n            const endVal = endArray[i] || 0;\n            result[i] = startVal + (endVal - startVal) * t;\n          }\n          \n          return result;\n        };\n      }\n    }\n  );\n  \n  // 3. Object interpolation\n  const positionTween = new Tween(\n    { x: 0, y: 0, scale: 1, rotation: 0 },\n    {\n      duration: 1200,\n      interpolate: (startObj, endObj) => {\n        return (t) => {\n          const result = {};\n          \n          // Interpolate each property in the object\n          for (const key in endObj) {\n            if (typeof endObj[key] === 'number') {\n              const startVal = startObj[key] || 0;\n              const endVal = endObj[key];\n              result[key] = startVal + (endVal - startVal) * t;\n            } else {\n              // For non-numeric properties, just switch at the midpoint\n              result[key] = t < 0.5 ? startObj[key] : endObj[key];\n            }\n          }\n          \n          return result;\n        };\n      }\n    }\n  );\n  \n  // 4. Text interpolation (character by character)\n  const textTween = new Tween(\"Hello\", {\n    duration: 2000,\n    interpolate: (startText, endText) => {\n      return (t) => {\n        // Calculate how many characters of the end text to show\n        const endLength = Math.round(endText.length * t);\n        return endText.substring(0, endLength);\n      };\n    }\n  });\n  \n  // Functions to trigger animations\n  function animateColor() {\n    colorTween.target = colorTween.target === '#ff3e00' ? '#0088ff' : '#ff3e00';\n  }\n  \n  function animatePath() {\n    pathTween.target = pathTween.target[0] === 0 \n      ? [100, 80, 60, 40, 20, 0]\n      : [0, 20, 50, 80, 100];\n  }\n  \n  function animatePosition() {\n    const currentPos = positionTween.current;\n    positionTween.target = {\n      x: currentPos.x === 0 ? 200 : 0,\n      y: currentPos.y === 0 ? 100 : 0,\n      scale: currentPos.scale === 1 ? 1.5 : 1,\n      rotation: currentPos.rotation === 0 ? 180 : 0\n    };\n  }\n  \n  function animateText() {\n    textTween.target = textTween.target === \"Hello\" \n      ? \"Hello, Svelte Animation!\" \n      : \"Hello\";\n  }\n</script>\n\n<div class=\"demo-container\">\n  <!-- Color interpolation demo -->\n  <div class=\"demo-section\">\n    <h3>Color Interpolation</h3>\n    <div class=\"color-box\" style=\"background-color: {colorTween.current}\"></div>\n    <button on:click={animateColor}>Toggle Color</button>\n  </div>\n  \n  <!-- Path interpolation demo -->\n  <div class=\"demo-section\">\n    <h3>Path Interpolation</h3>\n    <svg width=\"300\" height=\"100\">\n      <polyline\n        points={pathTween.current.map((val, i) => `${i * 50}, ${100-val}`).join(' ')}\n        fill=\"none\"\n        stroke=\"#ff3e00\"\n        stroke-width=\"3\"\n      />\n    </svg>\n    <button on:click={animatePath}>Toggle Path</button>\n  </div>\n  \n  <!-- Object interpolation demo -->\n  <div class=\"demo-section\">\n    <h3>Object Interpolation</h3>\n    <div \n      class=\"position-box\"\n      style=\"\n        transform: translate({positionTween.current.x}px, {positionTween.current.y}px) \n                  scale({positionTween.current.scale}) \n                  rotate({positionTween.current.rotation}deg);\n      \"\n    ></div>\n    <button on:click={animatePosition}>Toggle Position</button>\n  </div>\n  \n  <!-- Text interpolation demo -->\n  <div class=\"demo-section\">\n    <h3>Text Interpolation</h3>\n    <div class=\"text-display\">{textTween.current}</div>\n    <button on:click={animateText}>Toggle Text</button>\n  </div>\n</div>\n\n<style>\n  .demo-container {\n    display: flex;\n    flex-direction: column;\n    gap: 30px;\n  }\n  \n  .demo-section {\n    border: 1px solid #ccc;\n    padding: 20px;\n    border-radius: 8px;\n  }\n  \n  .color-box {\n    width: 100px;\n    height: 100px;\n    border-radius: 8px;\n    margin-bottom: 10px;\n  }\n  \n  .position-box {\n    width: 50px;\n    height: 50px;\n    background-color: #ff3e00;\n    border-radius: 8px;\n    margin-bottom: 10px;\n  }\n  \n  .text-display {\n    font-size: 1.2em;\n    height: 2em;\n    margin-bottom: 10px;\n  }\n</style>\n```\n\n### Advanced Interpolation Techniques:\n\n1. **SVG Path Interpolation**:\n\n```svelte\n<script>\n  import { Tween } from 'svelte/motion';\n  \n  // Interpolate between SVG paths\n  const svgPathTween = new Tween(\n    \"M10,10 L90,10 L90,90 L10,90 Z\", // Square\n    {\n      duration: 2000,\n      interpolate: (startPath, endPath) => {\n        // This requires a more complex path parsing library in real usage\n        // For demonstration, we'll use a simplified approach\n        return (t) => {\n          if (t < 0.01) return startPath;\n          if (t > 0.99) return endPath;\n          \n          // For a proper implementation, use a library like flubber\n          // https://github.com/veltman/flubber\n          \n          // Simplified interpolation (just for demonstration)\n          const morphPath = \"M\" + (10 + 40 * t) + \",\" + (10 + 40 * t) + \n                           \" L\" + (90 - 40 * t) + \",\" + (10 + 40 * t) + \n                           \" L\" + (90 - 40 * t) + \",\" + (90 - 40 * t) + \n                           \" L\" + (10 + 40 * t) + \",\" + (90 - 40 * t) + \" Z\";\n          \n          return morphPath;\n        };\n      }\n    }\n  );\n  \n  function togglePath() {\n    svgPathTween.target = svgPathTween.target.startsWith(\"M10,10\") \n      ? \"M50,10 L90,50 L50,90 L10,50 Z\"  // Diamond\n      : \"M10,10 L90,10 L90,90 L10,90 Z\"; // Square\n  }\n</script>\n\n<svg width=\"100\" height=\"100\">\n  <path d={svgPathTween.current} fill=\"#ff3e00\" />\n</svg>\n<button on:click={togglePath}>Toggle Shape</button>\n```\n\n2. **Custom Easing Combined with Interpolation**:\n\n```svelte\n<script>\n  import { Tween } from 'svelte/motion';\n  \n  // Custom interpolation with per-property easing\n  const multiPropTween = new Tween(\n    { x: 0, y: 0, opacity: 0 },\n    {\n      duration: 1500,\n      interpolate: (start, end) => {\n        // Different easing for each property\n        const easings = {\n          x: t => 1 - Math.pow(1 - t, 3), // cubic out\n          y: t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2, // quad inout\n          opacity: t => t // linear\n        };\n        \n        return (t) => {\n          const result = {};\n          \n          for (const key in end) {\n            const startVal = start[key] || 0;\n            const endVal = end[key];\n            // Apply property-specific easing\n            const easedT = easings[key] ? easings[key](t) : t;\n            result[key] = startVal + (endVal - startVal) * easedT;\n          }\n          \n          return result;\n        };\n      }\n    }\n  );\n</script>\n```\n\nBy implementing custom interpolation functions, you can animate virtually any type of data in Svelte 5, creating rich, complex animations that go beyond simple numeric transitions."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"How can you use the Spring class to create a realistic physics-based animation system with multiple interacting objects?","answer":"Creating a realistic physics-based animation system with multiple interacting objects using Svelte 5's `Spring` class involves setting up springs with appropriate parameters and establishing relationships between them. This approach can simulate physical behaviors like gravity, collisions, and connected objects.\n\nHere's a comprehensive example of a physics-based animation system with multiple interacting objects:\n\n```svelte\n<script>\n  import { Spring } from 'svelte/motion';\n  import { onMount } from 'svelte';\n  \n  // Physics constants\n  const GRAVITY = 0.5;\n  const FRICTION = 0.98;\n  const BOUNCE = 0.8;\n  \n  // Canvas dimensions\n  let width = 800;\n  let height = 600;\n  \n  // Create a set of particles with physics properties\n  const particles = Array(15).fill().map((_, i) => {\n    return {\n      id: i,\n      // Position springs\n      x: new Spring(Math.random() * width, { stiffness: 0.1, damping: 0.6 }),\n      y: new Spring(Math.random() * height * 0.5, { stiffness: 0.1, damping: 0.6 }),\n      // Physics properties\n      vx: Math.random() * 4 - 2, // Velocity X\n      vy: 0,                     // Velocity Y\n      radius: Math.random() * 20 + 10,\n      mass: 0,                   // Will be set based on radius\n      color: `hsl(${Math.random() * 360}, 70%, 60%)`,\n      // Whether this particle is being dragged\n      dragging: false\n    };\n  });\n  \n  // Set mass based on radius (area)\n  particles.forEach(p => {\n    p.mass = p.radius * p.radius * 0.01;\n  });\n  \n  // Create springs between particles (connections)\n  const connections = [];\n  \n  // Connect some particles with springs\n  for (let i = 0; i < particles.length - 1; i += 2) {\n    connections.push({\n      p1: particles[i],\n      p2: particles[i + 1],\n      restLength: 100,           // Natural spring length\n      stiffness: 0.02,           // Spring stiffness\n      damping: 0.1               // Spring damping\n    });\n  }\n  \n  // Animation loop\n  let animationFrame;\n  let canvas;\n  let ctx;\n  let mouseX = 0;\n  let mouseY = 0;\n  let draggedParticle = null;\n  \n  onMount(() => {\n    ctx = canvas.getContext('2d');\n    animate();\n    \n    return () => {\n      cancelAnimationFrame(animationFrame);\n    };\n  });\n  \n  function animate() {\n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    // Update physics\n    updatePhysics();\n    \n    // Draw connections first (so they appear behind particles)\n    drawConnections();\n    \n    // Draw particles\n    drawParticles();\n    \n    // Continue animation loop\n    animationFrame = requestAnimationFrame(animate);\n  }\n  \n  function updatePhysics() {\n    // Update particle physics\n    particles.forEach(p => {\n      if (p.dragging) {\n        // If being dragged, move toward mouse\n        p.x.target = mouseX;\n        p.y.target = mouseY;\n        \n        // Reset velocity when dragging\n        p.vx = 0;\n        p.vy = 0;\n      } else {\n        // Apply gravity\n        p.vy += GRAVITY * p.mass;\n        \n        // Apply friction\n        p.vx *= FRICTION;\n        p.vy *= FRICTION;\n        \n        // Update position based on velocity\n        p.x.target = p.x.current + p.vx;\n        p.y.target = p.y.current + p.vy;\n        \n        // Boundary collisions\n        if (p.x.current < p.radius) {\n          p.x.target = p.radius;\n          p.vx *= -BOUNCE;\n        } else if (p.x.current > width - p.radius) {\n          p.x.target = width - p.radius;\n          p.vx *= -BOUNCE;\n        }\n        \n        if (p.y.current < p.radius) {\n          p.y.target = p.radius;\n          p.vy *= -BOUNCE;\n        } else if (p.y.current > height - p.radius) {\n          p.y.target = height - p.radius;\n          p.vy *= -BOUNCE;\n        }\n      }\n      \n      // Track velocity based on spring movement\n      // This allows us to maintain momentum when releasing a dragged particle\n      if (!p.dragging) {\n        p.vx = p.x.current - p.x.target + p.vx * 0.5;\n        p.vy = p.y.current - p.y.target + p.vy * 0.5;\n      }\n    });\n    \n    // Update spring connections\n    connections.forEach(conn => {\n      const p1 = conn.p1;\n      const p2 = conn.p2;\n      \n      // Calculate distance between particles\n      const dx = p2.x.current - p1.x.current;\n      const dy = p2.y.current - p1.y.current;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      // Calculate spring force\n      const springForce = (distance - conn.restLength) * conn.stiffness;\n      \n      // Direction unit vector\n      const dirX = dx / distance;\n      const dirY = dy / distance;\n      \n      // Don't apply forces to dragged particles\n      if (!p1.dragging) {\n        p1.vx += dirX * springForce;\n        p1.vy += dirY * springForce;\n      }\n      \n      if (!p2.dragging) {\n        p2.vx -= dirX * springForce;\n        p2.vy -= dirY * springForce;\n      }\n    });\n    \n    // Check for particle collisions\n    for (let i = 0; i < particles.length; i++) {\n      for (let j = i + 1; j < particles.length; j++) {\n        const p1 = particles[i];\n        const p2 = particles[j];\n        \n        // Calculate distance between particles\n        const dx = p2.x.current - p1.x.current;\n        const dy = p2.y.current - p1.y.current;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        // Check for collision\n        const minDistance = p1.radius + p2.radius;\n        \n        if (distance < minDistance) {\n          // Collision detected\n          const angle = Math.atan2(dy, dx);\n          const overlap = minDistance - distance;\n          \n          // Direction unit vector\n          const dirX = Math.cos(angle);\n          const dirY = Math.sin(angle);\n          \n          // Move particles away from each other\n          if (!p1.dragging) {\n            p1.x.target -= dirX * overlap * 0.5;\n            p1.y.target -= dirY * overlap * 0.5;\n          }\n          \n          if (!p2.dragging) {\n            p2.x.target += dirX * overlap * 0.5;\n            p2.y.target += dirY * overlap * 0.5;\n          }\n          \n          // Calculate collision response\n          // Conservation of momentum formula\n          const v1x = p1.vx;\n          const v1y = p1.vy;\n          const v2x = p2.vx;\n          const v2y = p2.vy;\n          \n          // Don't modify velocity of dragged particles\n          if (!p1.dragging && !p2.dragging) {\n            // Simplified collision response\n            p1.vx = (v1x * (p1.mass - p2.mass) + 2 * p2.mass * v2x) / (p1.mass + p2.mass) * BOUNCE;\n            p1.vy = (v1y * (p1.mass - p2.mass) + 2 * p2.mass * v2y) / (p1.mass + p2.mass) * BOUNCE;\n            \n            p2.vx = (v2x * (p2.mass - p1.mass) + 2 * p1.mass * v1x) / (p1.mass + p2.mass) * BOUNCE;\n            p2.vy = (v2y * (p2.mass - p1.mass) + 2 * p1.mass * v1y) / (p1.mass + p2.mass) * BOUNCE;\n          }\n        }\n      }\n    }\n  }\n  \n  function drawParticles() {\n    particles.forEach(p => {\n      ctx.beginPath();\n      ctx.arc(p.x.current, p.y.current, p.radius, 0, Math.PI * 2);\n      ctx.fillStyle = p.color;\n      ctx.fill();\n      \n      // Draw a small dot in the center for visual interest\n      ctx.beginPath();\n      ctx.arc(p.x.current, p.y.current, p.radius * 0.3, 0, Math.PI * 2);\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.fill();\n    });\n  }\n  \n  function drawConnections() {\n    connections.forEach(conn => {\n      const p1 = conn.p1;\n      const p2 = conn.p2;\n      \n      // Calculate spring tension for visual feedback\n      const dx = p2.x.current - p1.x.current;\n      const dy = p2.y.current - p1.y.current;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      const tension = Math.min(Math.abs(distance - conn.restLength) / 100, 1);\n      \n      // Draw spring line\n      ctx.beginPath();\n      ctx.moveTo(p1.x.current, p1.y.current);\n      ctx.lineTo(p2.x.current, p2.y.current);\n      ctx.strokeStyle = `rgba(255, ${255 * (1 - tension)}, ${255 * (1 - tension)}, 0.5)`;\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    });\n  }\n  \n  // Mouse event handlers\n  function handleMouseDown(e) {\n    const rect = canvas.getBoundingClientRect();\n    mouseX = e.clientX - rect.left;\n    mouseY = e.clientY - rect.top;\n    \n    // Check if we're clicking on a particle\n    for (const p of particles) {\n      const dx = p.x.current - mouseX;\n      const dy = p.y.current - mouseY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      if (distance < p.radius) {\n        // Start dragging this particle\n        p.dragging = true;\n        draggedParticle = p;\n        break;\n      }\n    }\n  }\n  \n  function handleMouseMove(e) {\n    if (draggedParticle) {\n      const rect = canvas.getBoundingClientRect();\n      mouseX = e.clientX - rect.left;\n      mouseY = e.clientY - rect.top;\n    }\n  }\n  \n  function handleMouseUp() {\n    if (draggedParticle) {\n      // Calculate release velocity based on spring current vs target\n      const vx = (draggedParticle.x.current - draggedParticle.x.target) * 0.2;\n      const vy = (draggedParticle.y.current - draggedParticle.y.target) * 0.2;\n      \n      draggedParticle.vx = vx;\n      draggedParticle.vy = vy;\n      draggedParticle.dragging = false;\n      draggedParticle = null;\n    }\n  }\n  \n  function addRandomParticle() {\n    const newParticle = {\n      id: particles.length,\n      x: new Spring(Math.random() * width, { stiffness: 0.1, damping: 0.6 }),\n      y: new Spring(50, { stiffness: 0.1, damping: 0.6 }),\n      vx: Math.random() * 10 - 5,\n      vy: 0,\n      radius: Math.random() * 20 + 10,\n      color: `hsl(${Math.random() * 360}, 70%, 60%)`,\n      dragging: false\n    };\n    \n    newParticle.mass = newParticle.radius * newParticle.radius * 0.01;\n    particles.push(newParticle);\n    \n    // Optionally connect to a random existing particle\n    if (particles.length > 1 && Math.random() > 0.5) {\n      const randomIndex = Math.floor(Math.random() * (particles.length - 1));\n      connections.push({\n        p1: newParticle,\n        p2: particles[randomIndex],\n        restLength: 100 + Math.random() * 50,\n        stiffness: 0.01 + Math.random() * 0.02,\n        damping: 0.1\n      });\n    }\n  }\n  \n  function resetSimulation() {\n    particles.forEach((p, i) => {\n      p.x.target = Math.random() * width;\n      p.y.target = Math.random() * height * 0.5;\n      p.vx = Math.random() * 4 - 2;\n      p.vy = 0;\n      p.dragging = false;\n    });\n    \n    draggedParticle = null;\n  }\n</script>\n\n<div class=\"physics-container\">\n  <div class=\"controls\">\n    <button on:click={addRandomParticle}>Add Particle</button>\n    <button on:click={resetSimulation}>Reset</button>\n  </div>\n  \n  <canvas \n    bind:this={canvas} \n    width={width} \n    height={height}\n    on:mousedown={handleMouseDown}\n    on:mousemove={handleMouseMove}\n    on:mouseup={handleMouseUp}\n    on:mouseleave={handleMouseUp}\n  ></canvas>\n</div>\n\n<style>\n  .physics-container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    gap: 10px;\n  }\n  \n  canvas {\n    background-color: #f0f0f0;\n    border-radius: 8px;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n  }\n  \n  .controls {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n  }\n  \n  button {\n    padding: 8px 16px;\n    background-color: #ff3e00;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  \n  button:hover {\n    background-color: #ff6b3d;\n  }\n</style>\n```\n\n### Key Physics Concepts Implemented:\n\n1. **Spring-Based Motion**: Using `Spring` instances to create smooth, physically-based movement\n2. **Gravity**: Constant acceleration applied to particles\n3. **Friction**: Velocity damping to simulate air resistance\n4. **Collisions**: Detecting and responding to collisions between particles\n5. **Conservation of Momentum**: Realistic collision responses based on mass\n6. **Spring Connections**: Simulating connections between particles\n7. **Boundary Constraints**: Keeping particles within the canvas boundaries\n8. **User Interaction**: Dragging and throwing particles\n\n### Enhancing the Physics System:\n\n1. **Variable Time Step**:\n\n```js\nlet lastTime = 0;\n\nfunction animate(timestamp) {\n  const deltaTime = lastTime ? (timestamp - lastTime) / 16.667 : 1;\n  lastTime = timestamp;\n  \n  // Apply time scaling to all physics calculations\n  const timeScale = Math.min(deltaTime, 2); // Cap at 2x to prevent large jumps\n  \n  // Use timeScale in physics calculations\n  particles.forEach(p => {\n    p.vy += GRAVITY * p.mass * timeScale;\n    // ...other calculations\n  });\n  \n  // Continue animation\n  animationFrame = requestAnimationFrame(animate);\n}\n```\n\n2. **Verlet Integration** for more stable physics:\n\n```js\nparticles.forEach(p => {\n  if (!p.dragging) {\n    // Store old position\n    const oldX = p.x.current;\n    const oldY = p.y.current;\n    \n    // Verlet integration\n    const newX = 2 * p.x.current - p.prevX + GRAVITY * 0;\n    const newY = 2 * p.y.current - p.prevY + GRAVITY * p.mass;\n    \n    // Update position\n    p.x.target = newX;\n    p.y.target = newY;\n    \n    // Store current position for next frame\n    p.prevX = p.x.current;\n    p.prevY = p.y.current;\n  }\n});\n```\n\n3. **Spatial Partitioning** for efficient collision detection:\n\n```js\n// Create a grid for spatial partitioning\nconst CELL_SIZE = 50;\nconst grid = {};\n\n// Place particles in grid cells\nparticles.forEach(p => {\n  const cellX = Math.floor(p.x.current / CELL_SIZE);\n  const cellY = Math.floor(p.y.current / CELL_SIZE);\n  const cellKey = `${cellX},${cellY}`;\n  \n  if (!grid[cellKey]) {\n    grid[cellKey] = [];\n  }\n  \n  grid[cellKey].push(p);\n});\n\n// Check collisions only with particles in nearby cells\nparticles.forEach(p1 => {\n  const cellX = Math.floor(p1.x.current / CELL_SIZE);\n  const cellY = Math.floor(p1.y.current / CELL_SIZE);\n  \n  // Check the 9 cells around the particle\n  for (let x = -1; x <= 1; x++) {\n    for (let y = -1; y <= 1; y++) {\n      const checkCellKey = `${cellX + x},${cellY + y}`;\n      const cellParticles = grid[checkCellKey] || [];\n      \n      // Check collisions with particles in this cell\n      cellParticles.forEach(p2 => {\n        if (p1 !== p2) {\n          // Collision detection code...\n        }\n      });\n    }\n  }\n});\n```\n\nBy using Svelte 5's `Spring` class as the foundation, you can create sophisticated physics simulations with realistic behaviors. The spring physics provides natural-looking motion while the custom physics code handles interactions between objects."}
{"source":"docs/svelte/98-reference/21-svelte-motion.md","question":"How can you optimize performance when using multiple Spring and Tween instances in a complex Svelte 5 application?","answer":"When building complex animations with multiple `Spring` and `Tween` instances in Svelte 5, performance optimization becomes crucial. Here are comprehensive strategies for ensuring smooth animations even with many animated elements:\n\n### 1. Reduce the Number of Active Animations\n\n```svelte\n<script>\n  import { Spring, Tween } from 'svelte/motion';\n  import { onMount, onDestroy } from 'svelte';\n  \n  // Track visibility state for elements\n  let visibleItems = $state([]);\n  const allItems = Array(100).fill().map((_, i) => ({ id: i }));\n  \n  // Create springs only for visible elements\n  $effect(() => {\n    // Create animation instances only for visible items\n    visibleItems.forEach(item => {\n      if (!item.spring) {\n        item.spring = new Spring(0, { stiffness: 0.1, damping: 0.7 });\n        item.spring.target = 1; // Animate in\n      }\n    });\n  });\n  \n  // Function to update visible items based on scroll position\n  function updateVisibleItems() {\n    const viewportTop = window.scrollY;\n    const viewportBottom = viewportTop + window.innerHeight;\n    \n    // Determine which items are in or near the viewport\n    visibleItems = allItems.filter(item => {\n      const element = document.getElementById(`item-${item.id}`);\n      if (!element) return false;\n      \n      const rect = element.getBoundingClientRect();\n      const elementTop = rect.top + viewportTop;\n      const elementBottom = rect.bottom + viewportTop;\n      \n      // Include items slightly outside the viewport for smoother transitions\n      return (\n        (elementBottom >= viewportTop - 200) && \n        (elementTop <= viewportBottom + 200)\n      );\n    });\n  }\n  \n  onMount(() => {\n    updateVisibleItems();\n    window.addEventListener('scroll', updateVisibleItems);\n    window.addEventListener('resize', updateVisibleItems);\n    \n    return () => {\n      window.removeEventListener('scroll', updateVisibleItems);\n      window.removeEventListener('resize', updateVisibleItems);\n    };\n  });\n</script>\n\n<div class=\"virtual-scroller\">\n  {#each allItems as item (item.id)}\n    <div \n      id={`item-${item.id}`} \n      class=\"item\"\n      style=\"opacity: {item.spring ? item.spring.current : 0}; \n             transform: scale({item.spring ? 0.5 + item.spring.current * 0.5 : 0.5});\"\n    >\n      Item {item.id}\n    </div>\n  {/each}\n</div>\n```\n\n### 2. Batch Animation Updates\n\n```svelte\n<script>\n  import { Spring, Tween } from 'svelte/motion';\n  import { onMount } from 'svelte';\n  \n  // Create many animation instances\n  const items = Array(100).fill().map((_, i) => ({\n    id: i,\n    x: new Spring(0),\n    y: new Spring(0),\n    opacity: new Tween(0)\n  }));\n  \n  // Batch updates using requestAnimationFrame\n  let isUpdating = false;\n  let pendingUpdates = [];\n  \n  function scheduleUpdate(item, newX, newY) {\n    // Add to pending updates\n    pendingUpdates.push({ item, newX, newY });\n    \n    // If not already updating, schedule batch update\n    if (!isUpdating) {\n      isUpdating = true;\n      requestAnimationFrame(processBatchUpdates);\n    }\n  }\n  \n  function processBatchUpdates() {\n    // Apply all pending updates at once\n    pendingUpdates.forEach(update => {\n      update.item.x.target = update.newX;\n      update.item.y."}
{"source":"docs/svelte/98-reference/21-svelte-reactivity-window.md","question":"What is the `svelte/reactivity/window` module and how does it differ from using `<svelte:window>` bindings?","answer":"The `svelte/reactivity/window` module in Svelte 5 provides reactive versions of various `window` properties that can be used directly in JavaScript without requiring the `<svelte:window>` component. Each exported value has a `.current` property that can be referenced in reactive contexts such as templates, `$derived` expressions, and `$effect` blocks.\n\nThe key difference from `<svelte:window>` bindings is that these reactive values can be imported and used directly in JavaScript code, making them more flexible and allowing them to be used outside of the template. They automatically track changes to the underlying window properties without requiring manual event listeners.\n\nHere's an example of using the module:\n\n```svelte\n<script>\n  import { innerWidth, innerHeight, scrollY } from 'svelte/reactivity/window';\n  \n  // These values automatically update when the window properties change\n  $effect(() => {\n    console.log(`Window size: ${innerWidth.current}x${innerHeight.current}`);\n  });\n  \n  // Can be used directly in derived values\n  const isNarrowScreen = $derived(innerWidth.current < 768);\n  \n  // Can be used to trigger side effects when scroll position changes\n  $effect(() => {\n    if (scrollY.current > 200) {\n      // Show back-to-top button\n    }\n  });\n</script>\n\n<div>\n  <p>Current window size: {innerWidth.current}x{innerHeight.current}</p>\n  {#if isNarrowScreen}\n    <p>Mobile view active</p>\n  {/if}\n</div>\n```\n\nThis approach is cleaner than manually setting up event listeners for window resize or scroll events and provides a more reactive programming model that aligns with Svelte's philosophy."}
{"source":"docs/svelte/98-reference/21-svelte-reactivity-window.md","question":"Explain how the reactive window values behave during server-side rendering (SSR) and what considerations developers should keep in mind when using them.","answer":"In server-side rendering (SSR) scenarios, all reactive window values from the `svelte/reactivity/window` module have their `.current` property set to `undefined`. This is because there is no actual browser window or DOM available during server rendering.\n\nThis behavior has important implications for developers:\n\n1. **Always handle the undefined case**: When using these values, you should account for the possibility that they might be undefined during initial rendering.\n\n```svelte\n<script>\n  import { innerWidth } from 'svelte/reactivity/window';\n  \n  // Handle the undefined case with a fallback\n  const screenSize = $derived(innerWidth.current === undefined \n    ? 'unknown' \n    : innerWidth.current > 1024 \n      ? 'large' \n      : 'small');\n</script>\n\n<p>Your screen is: {screenSize}</p>\n```\n\n2. **Conditional logic for client/server**: You may need to use conditional logic to provide different behavior on the server versus the client.\n\n```svelte\n<script>\n  import { innerWidth, innerHeight } from 'svelte/reactivity/window';\n  import { browser } from '$app/environment'; // SvelteKit utility\n  \n  // Default values for SSR\n  const defaultWidth = 1024;\n  const defaultHeight = 768;\n  \n  // Use default values during SSR, actual values on client\n  const width = $derived(innerWidth.current ?? defaultWidth);\n  const height = $derived(innerHeight.current ?? defaultHeight);\n  \n  // Alternatively, with SvelteKit's browser utility\n  $effect(() => {\n    if (browser) {\n      console.log(`Window dimensions: ${innerWidth.current}x${innerHeight.current}`);\n    }\n  });\n</script>\n```\n\n3. **Hydration considerations**: Be aware that there might be a \"hydration mismatch\" if your component renders differently based on window properties. The server-rendered HTML (with undefined values) will be replaced by the client-rendered version (with actual values) which could cause layout shifts or visual flickers.\n\n```svelte\n<script>\n  import { innerWidth } from 'svelte/reactivity/window';\n  \n  // This might cause a hydration mismatch\n  const isMobile = $derived(innerWidth.current !== undefined && innerWidth.current < 768);\n</script>\n\n{#if isMobile}\n  <MobileNavigation />\n{:else}\n  <DesktopNavigation />\n{/if}\n```\n\nTo avoid hydration issues, you can:\n- Use a loading state initially and only render the conditional content after hydration\n- Use CSS media queries for responsive layouts instead of JS-based conditions\n- Ensure your server and client rendering produce the same initial output\n\nUnderstanding these SSR limitations is crucial for building robust applications with Svelte 5's reactive window values."}
{"source":"docs/svelte/98-reference/21-svelte-reactivity-window.md","question":"How would you create a responsive component that changes its layout based on window width using the `svelte/reactivity/window` module?","answer":"Creating a responsive component using the `svelte/reactivity/window` module is straightforward. Here's how you can build a component that adapts its layout based on the window width:\n\n```svelte\n<script>\n  import { innerWidth } from 'svelte/reactivity/window';\n  \n  // Define breakpoints\n  const BREAKPOINTS = {\n    mobile: 480,\n    tablet: 768,\n    desktop: 1024\n  };\n  \n  // Reactive values for current device type\n  const isMobile = $derived(\n    innerWidth.current !== undefined && \n    innerWidth.current < BREAKPOINTS.tablet\n  );\n  \n  const isTablet = $derived(\n    innerWidth.current !== undefined && \n    innerWidth.current >= BREAKPOINTS.tablet && \n    innerWidth.current < BREAKPOINTS.desktop\n  );\n  \n  const isDesktop = $derived(\n    innerWidth.current !== undefined && \n    innerWidth.current >= BREAKPOINTS.desktop\n  );\n  \n  // Reactive layout class\n  const layoutClass = $derived(\n    isMobile ? 'layout-mobile' :\n    isTablet ? 'layout-tablet' :\n    'layout-desktop'\n  );\n  \n  // Component props\n  export let title = 'Responsive Component';\n  export let items = [];\n</script>\n\n<div class=\"responsive-container {layoutClass}\">\n  <h2>{title}</h2>\n  \n  {#if isMobile}\n    <!-- Mobile layout: stacked items -->\n    <div class=\"items-stack\">\n      {#each items as item}\n        <div class=\"item item-mobile\">\n          <h3>{item.title}</h3>\n          <p>{item.summary}</p>\n        </div>\n      {/each}\n    </div>\n  {:else if isTablet}\n    <!-- Tablet layout: 2-column grid -->\n    <div class=\"items-grid items-grid-2\">\n      {#each items as item}\n        <div class=\"item item-tablet\">\n          <h3>{item.title}</h3>\n          <p>{item.summary}</p>\n          <button>Read more</button>\n        </div>\n      {/each}\n    </div>\n  {:else}\n    <!-- Desktop layout: 3-column grid with more details -->\n    <div class=\"items-grid items-grid-3\">\n      {#each items as item}\n        <div class=\"item item-desktop\">\n          <img src={item.image} alt={item.title} />\n          <h3>{item.title}</h3>\n          <p>{item.description}</p>\n          <div class=\"actions\">\n            <button class=\"primary\">Read more</button>\n            <button class=\"secondary\">Save</button>\n          </div>\n        </div>\n      {/each}\n    </div>\n  {/if}\n</div>\n\n<style>\n  .responsive-container {\n    width: 100%;\n    margin: 0 auto;\n  }\n  \n  .layout-mobile {\n    max-width: 100%;\n    padding: 10px;\n  }\n  \n  .layout-tablet {\n    max-width: 90%;\n    padding: 20px;\n  }\n  \n  .layout-desktop {\n    max-width: 1200px;\n    padding: 30px;\n  }\n  \n  .items-stack {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n  }\n  \n  .items-grid {\n    display: grid;\n    gap: 20px;\n  }\n  \n  .items-grid-2 {\n    grid-template-columns: repeat(2, 1fr);\n  }\n  \n  .items-grid-3 {\n    grid-template-columns: repeat(3, 1fr);\n  }\n  \n  .item {\n    border-radius: 8px;\n    background: #f9f9f9;\n    padding: 15px;\n  }\n  \n  .item-desktop {\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n  }\n</style>\n```\n\nA few important considerations in this implementation:\n\n1. **SSR Handling**: We check if `innerWidth.current` is undefined to account for server-side rendering.\n\n2. **Reactive Breakpoints**: We use `$derived` to create reactive values that automatically update when the window size changes.\n\n3. **Conditional Rendering**: Different layouts are rendered based on the current device type.\n\n4. **CSS Classes**: We apply different CSS classes based on the current layout, which helps with styling.\n\n5. **Component Flexibility**: The component accepts props like `title` and `items`, making it reusable.\n\nFor more advanced usage, you could also:\n\n```svelte\n<script>\n  import { innerWidth, innerHeight } from 'svelte/reactivity/window';\n  \n  // Create a reactive aspect ratio\n  const aspectRatio = $derived(\n    innerWidth.current && innerHeight.current\n      ? innerWidth.current / innerHeight.current\n      : 16/9 // Default fallback\n  );\n  \n  // Determine if the screen is portrait or landscape\n  const isPortrait = $derived(aspectRatio < 1);\n  \n  // Create a debounced resize handler to avoid too many updates\n  let resizeTimeout;\n  $effect(() => {\n    const width = innerWidth.current;\n    const height = innerHeight.current;\n    \n    clearTimeout(resizeTimeout);\n    resizeTimeout = setTimeout(() => {\n      console.log(`Window resized to ${width}x${height}`);\n    }, 200);\n  });\n</script>\n\n<!-- Use both width and orientation for responsive design -->\n<div class={isPortrait ? 'portrait-layout' : 'landscape-layout'}>\n  <!-- Content adapts to both screen size and orientation -->\n</div>\n```\n\nThis approach gives you a powerful way to create truly responsive components that react to window size changes without manually managing event listeners."}
{"source":"docs/svelte/98-reference/21-svelte-reactivity-window.md","question":"How can the `scrollX` and `scrollY` reactive values be used to create an animated scroll-based effect in Svelte 5?","answer":"The `scrollX` and `scrollY` reactive values from the `svelte/reactivity/window` module can be leveraged to create sophisticated scroll-based animations. Here's how you can implement a parallax scrolling effect and a scroll progress indicator:\n\n```svelte\n<script>\n  import { scrollY } from 'svelte/reactivity/window';\n  import { spring } from 'svelte/motion';\n  \n  // Create a spring-based animation that follows scrollY\n  // This adds a nice \"easing\" effect to the scroll animation\n  const smoothScrollY = spring(0, {\n    stiffness: 0.1,\n    damping: 0.8\n  });\n  \n  // Update the spring value when scrollY changes\n  $effect(() => {\n    if (scrollY.current !== undefined) {\n      smoothScrollY.set(scrollY.current);\n    }\n  });\n  \n  // Calculate various parallax values based on scroll position\n  const parallaxSlow = $derived(smoothScrollY * 0.2);\n  const parallaxMedium = $derived(smoothScrollY * 0.5);\n  const parallaxFast = $derived(smoothScrollY * 0.8);\n  \n  // Calculate scroll progress percentage (0-100)\n  let documentHeight = 0;\n  let windowHeight = 0;\n  \n  // Get initial measurements after component mounts\n  let container;\n  $effect(() => {\n    if (container) {\n      documentHeight = container.scrollHeight;\n      windowHeight = window.innerHeight;\n    }\n  });\n  \n  // Calculate scroll progress percentage\n  const scrollProgress = $derived(\n    documentHeight > windowHeight && scrollY.current !== undefined\n      ? (scrollY.current / (documentHeight - windowHeight)) * 100\n      : 0\n  );\n</script>\n\n<div bind:this={container} class=\"parallax-container\">\n  <!-- Progress bar that shows scroll position -->\n  <div class=\"progress-bar\" style=\"width: {scrollProgress}%\"></div>\n  \n  <!-- Parallax layers -->\n  <div class=\"parallax-layer background\" style=\"transform: translateY({parallaxSlow}px)\">\n    <div class=\"stars\"></div>\n  </div>\n  \n  <div class=\"parallax-layer mountains\" style=\"transform: translateY({parallaxMedium}px)\">\n    <img src=\"/images/mountains.png\" alt=\"Mountains\" />\n  </div>\n  \n  <div class=\"parallax-layer foreground\" style=\"transform: translateY({parallaxFast}px)\">\n    <img src=\"/images/trees.png\" alt=\"Trees\" />\n  </div>\n  \n  <!-- Main content that scrolls normally -->\n  <div class=\"content\">\n    <section>\n      <h1>Parallax Scrolling Demo</h1>\n      <p>Scroll down to see the parallax effect in action!</p>\n    </section>\n    \n    <!-- Scroll-triggered animations -->\n    {#each Array(5) as _, i}\n      <section class=\"fade-in-section\" \n        style=\"opacity: {Math.min(1, Math.max(0, (scrollY.current ?? 0) / 100 - i * 2))};\">\n        <h2>Section {i + 1}</h2>\n        <p>This section fades in as you scroll down.</p>\n        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>\n      </section>\n    {/each}\n  </div>\n</div>\n\n<style>\n  .parallax-container {\n    position: relative;\n    height: 400vh; /* Make the container tall enough to scroll */\n    overflow-x: hidden;\n  }\n  \n  .progress-bar {\n    position: fixed;\n    top: 0;\n    left: 0;\n    height: 4px;\n    background: linear-gradient(90deg, #ff3e00, #ff8700);\n    z-index: 1000;\n    transition: width 0.05s linear;\n  }\n  \n  .parallax-layer {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100vh;\n    will-change: transform;\n  }\n  \n  .background {\n    background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);\n    z-index: 1;\n  }\n  \n  .stars {\n    background-image: \n      radial-gradient(2px 2px at 20px 30px, #eee, rgba(0,0,0,0)),\n      radial-gradient(2px 2px at 40px 70px, #fff, rgba(0,0,0,0)),\n      radial-gradient(1px 1px at 90px 40px, #fff, rgba(0,0,0,0));\n    background-repeat: repeat;\n    background-size: 200px 200px;\n    height: 100%;\n    opacity: 0.5;\n  }\n  \n  .mountains {\n    z-index: 2;\n  }\n  \n  .mountains img, .foreground img {\n    width: 100%;\n    height: 100vh;\n    object-fit: cover;\n  }\n  \n  .foreground {\n    z-index: 3;\n  }\n  \n  .content {\n    position: relative;\n    z-index: 4;\n    padding-top: 100vh; /* Start content after the viewport height */\n  }\n  \n  section {\n    min-height: 80vh;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    padding: 2rem;\n    background: rgba(255, 255, 255, 0.8);\n    margin: 2rem;\n    border-radius: 8px;\n  }\n  \n  .fade-in-section {\n    transition: opacity 0.5s ease-out;\n  }\n  \n  h1 {\n    font-size: 3rem;\n    margin-bottom: 1rem;\n  }\n  \n  h2 {\n    font-size: 2rem;\n  }\n</style>\n```\n\nFor a more complex implementation, you could create a scroll-based animation system:\n\n```svelte\n<script>\n  import { scrollY } from 'svelte/reactivity/window';\n  \n  // Define animation keyframes based on scroll position\n  const animations = [\n    {\n      element: 'header',\n      properties: [\n        {\n          property: 'opacity',\n          startValue: 1,\n          endValue: 0,\n          startScroll: 0,\n          endScroll: 200,\n        },\n        {\n          property: 'transform',\n          startValue: 'translateY(0px)',\n          endValue: 'translateY(-50px)',\n          startScroll: 0,\n          endScroll: 200,\n        }\n      ]\n    },\n    {\n      element: '.hero-image',\n      properties: [\n        {\n          property: 'transform',\n          startValue: 'scale(1)',\n          endValue: 'scale(1.2)',\n          startScroll: 0,\n          endScroll: 500,\n        }\n      ]\n    },\n    // More animations...\n  ];\n  \n  // Calculate current animation values based on scroll position\n  function calculateAnimationValues(scroll) {\n    const currentStyles = {};\n    \n    animations.forEach(animation => {\n      if (!currentStyles[animation.element]) {\n        currentStyles[animation.element] = {};\n      }\n      \n      animation.properties.forEach(prop => {\n        // Calculate progress (0 to 1) based on scroll position\n        const scrollProgress = Math.max(0, Math.min(1, \n          (scroll - prop.startScroll) / (prop.endScroll - prop.startScroll)\n        ));\n        \n        // For numeric values (like opacity)\n        if (!isNaN(parseFloat(prop.startValue))) {\n          const startVal = parseFloat(prop.startValue);\n          const endVal = parseFloat(prop.endValue);\n          currentStyles[animation.element][prop.property] = \n            startVal + (endVal - startVal) * scrollProgress;\n        } \n        // For values with units or complex transforms\n        else {\n          // This is a simplified approach - a real implementation would need\n          // to handle different types of values more robustly\n          currentStyles[animation.element][prop.property] = \n            scrollProgress < 0.5 ? prop.startValue : prop.endValue;\n        }\n      });\n    });\n    \n    return currentStyles;\n  }\n  \n  // Reactive animation styles based on current scroll position\n  const animationStyles = $derived(\n    scrollY.current !== undefined\n      ? calculateAnimationValues(scrollY.current)\n      : {}\n  );\n  \n  // Create a scroll-triggered timeline\n  const timelineEvents = [\n    { position: 100, event: 'start' },\n    { position: 500, event: 'middle' },\n    { position: 900, event: 'end' }\n  ];\n  \n  let currentTimelineEvent = 'initial';\n  \n  $effect(() => {\n    if (scrollY.current === undefined) return;\n    \n    for (const event of timelineEvents) {\n      if (scrollY.current >= event.position) {\n        currentTimelineEvent = event.event;\n      }\n    }\n  });\n</script>\n\n<div class=\"scroll-animation-container\">\n  <!-- Apply the calculated styles to elements -->\n  <header style=\"opacity: {animationStyles['header']?.opacity ?? 1}; \n                transform: {animationStyles['header']?.transform ?? 'translateY(0)'}\">\n    <h1>Scroll Animation Demo</h1>\n  </header>\n  \n  <div class=\"hero-image\" \n       style=\"transform: {animationStyles['.hero-image']?.transform ?? 'scale(1)'}\">\n    <img src=\"/images/hero.jpg\" alt=\"Hero\" />\n  </div>\n  \n  <!-- Timeline indicator -->\n  <div class=\"timeline\">\n    <div class=\"timeline-marker\" class:active={currentTimelineEvent === 'start'}>Start</div>\n    <div class=\"timeline-marker\" class:active={currentTimelineEvent === 'middle'}>Middle</div>\n    <div class=\"timeline-marker\" class:active={currentTimelineEvent === 'end'}>End</div>\n  </div>\n  \n  <!-- More content... -->\n</div>\n\n<style>\n  /* Styling for the animation elements */\n  .scroll-animation-container {\n    position: relative;\n    min-height: 200vh;\n  }\n  \n  header {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    padding: 1rem;\n    background: rgba(0, 0, 0, 0.7);\n    color: white;\n    z-index: 10;\n    will-change: opacity, transform;\n  }\n  \n  .hero-image {\n    height: 100vh;\n    width: 100%;\n    overflow: hidden;\n    will-change: transform;\n  }\n  \n  .hero-image img {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n  }\n  \n  .timeline {\n    position: fixed;\n    right: 20px;\n    top: 50%;\n    transform: translateY(-50%);\n    display: flex;\n    flex-direction: column;\n    gap: 20px;\n  }\n  \n  .timeline-marker {\n    padding: 5px 10px;\n    background: #ddd;\n    border-radius: 4px;\n    transition: background-color 0.3s;\n  }\n  \n  .timeline-marker.active {\n    background: #ff3e00;\n    color: white;\n  }\n</style>\n```\n\nThese examples demonstrate how `scrollY` (and similarly `scrollX`) can be used to create sophisticated scroll-based animations in Svelte 5. The reactive nature of these values means your animations will automatically update as the user scrolls, without needing to manually set up scroll event listeners."}
{"source":"docs/svelte/98-reference/21-svelte-reactivity-window.md","question":"How could you implement a responsive layout system that uses the `innerWidth` reactive value to dynamically load different components based on screen size?","answer":"Creating a responsive layout system that dynamically loads different components based on screen size is a powerful pattern for optimizing user experience across devices. Here's how you can implement this using Svelte 5's `innerWidth` reactive value:\n\n```svelte\n<script>\n  import { innerWidth } from 'svelte/reactivity/window';\n  import { onMount } from 'svelte';\n  \n  // Define breakpoints for different device sizes\n  const BREAKPOINTS = {\n    mobile: 480,\n    tablet: 768,\n    desktop: 1024,\n    widescreen: 1440\n  };\n  \n  // Component props\n  export let mobileFallback = true; // Whether to use mobile as fallback during SSR\n  \n  // Track which components have been loaded\n  let loadedComponents = {\n    mobile: false,\n    tablet: false,\n    desktop: false,\n    widescreen: false\n  };\n  \n  // Determine current device type\n  const deviceType = $derived(() => {\n    // During SSR, innerWidth.current is undefined\n    if (innerWidth.current === undefined) {\n      return mobileFallback ? 'mobile' : 'desktop';\n    }\n    \n    if (innerWidth.current < BREAKPOINTS.mobile) return 'mobile';\n    if (innerWidth.current < BREAKPOINTS.tablet) return 'tablet';\n    if (innerWidth.current < BREAKPOINTS.desktop) return 'desktop';\n    return 'widescreen';\n  });\n  \n  // Component references - will be loaded dynamically\n  let MobileComponent;\n  let TabletComponent;\n  let DesktopComponent;\n  let WidescreenComponent;\n  \n  // Dynamically load components based on current device type\n  $effect(async () => {\n    // Mark the current device type as needed\n    if (!loadedComponents[deviceType]) {\n      try {\n        switch (deviceType) {\n          case 'mobile':\n            if (!MobileComponent) {\n              const module = await import('./MobileLayout.svelte');\n              MobileComponent = module.default;\n              loadedComponents.mobile = true;\n            }\n            break;\n          case 'tablet':\n            if (!TabletComponent) {\n              const module = await import('./TabletLayout.svelte');\n              TabletComponent = module.default;\n              loadedComponents.tablet = true;\n            }\n            break;\n          case 'desktop':\n            if (!DesktopComponent) {\n              const module = await import('./DesktopLayout.svelte');\n              DesktopComponent = module.default;\n              loadedComponents.desktop = true;\n            }\n            break;\n          case 'widescreen':\n            if (!WidescreenComponent) {\n              const module = await import('./WidescreenLayout.svelte');\n              WidescreenComponent = module.default;\n              loadedComponents.widescreen = true;\n            }\n            break;\n        }\n      } catch (error) {\n        console.error(`Failed to load component for ${deviceType}:`, error);\n      }\n    }\n  });\n  \n  // Optionally preload other layouts after initial render\n  onMount(() => {\n    // Preload the tablet layout if we're on mobile\n    if (deviceType === 'mobile') {\n      setTimeout(async () => {\n        if (!loadedComponents.tablet) {\n          const module = await import('./TabletLayout.svelte');\n          TabletComponent = module.default;\n          loadedComponents.tablet = true;\n        }\n      }, 2000);\n    }\n  });\n  \n  // Props to pass to the layout components\n  export let title = 'Responsive App';\n  export let user = null;\n  export let content = [];\n</script>\n\n<!-- Show loading state while component is being loaded -->\n{#if !loadedComponents[deviceType]}\n  <div class=\"loading-layout\">\n    <p>Loading {deviceType} layout...</p>\n    <!-- You could add a spinner or skeleton UI here -->\n  </div>\n{:else}\n  <!-- Render the appropriate component based on device type -->\n  {#if deviceType === 'mobile' && MobileComponent}\n    <MobileComponent {title} {user} {content} />\n  {:else if deviceType === 'tablet' && TabletComponent}\n    <TabletComponent {title} {user} {content} />\n  {:else if deviceType === 'desktop' && DesktopComponent}\n    <DesktopComponent {title} {user} {content} />\n  {:else if deviceType === 'widescreen' && WidescreenComponent}\n    <WidescreenComponent {title} {user} {content} />\n  {:else}\n    <!-- Fallback if something goes wrong with loading -->\n    <div class=\"fallback-layout\">\n      <h1>{title}</h1>\n      {#if user}\n        <p>Welcome, {user.name}</p>\n      {/if}\n      <div class=\"content\">\n        {#each content as item}\n          <div class=\"content-item\">\n            <h2>{item.title}</h2>\n            <p>{item.description}</p>\n          </div>\n        {/each}\n      </div>\n    </div>\n  {/if}\n</div>\n\n<style>\n  .loading-layout, .fallback-layout {\n    padding: 20px;\n    max-width: 1200px;\n    margin: 0 auto;\n  }\n  \n  .loading-layout {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    min-height: 200px;\n    background: #f9f9f9;\n    border-radius: 8px;\n  }\n  \n  .content {\n    display: grid;\n    gap: 20px;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n  }\n  \n  .content-item {\n    background: #f0f0f0;\n    padding: 15px;\n    border-radius: 8px;\n  }\n</style>\n```\n\nNow, let's look at what each layout component might look like:\n\n**MobileLayout.svelte**\n```svelte\n<script>\n  export let title;\n  export let user;\n  export let content;\n</script>\n\n<div class=\"mobile-layout\">\n  <header class=\"mobile-header\">\n    <button class=\"menu-button\">â°</button>\n    <h1>{title}</h1>\n    {#if user}\n      <div class=\"avatar\">\n        <img src={user.avatar} alt={user.name} />\n      </div>\n    {/if}\n  </header>\n  \n  <main class=\"mobile-content\">\n    {#each content as item}\n      <div class=\"mobile-card\">\n        <h2>{item.title}</h2>\n        <p>{item.summary}</p> <!-- Mobile shows summary instead of full description -->\n        <button>Read more</button>\n      </div>\n    {/each}\n  </main>\n  \n  <nav class=\"mobile-nav\">\n    <button>Home</button>\n    <button>Search</button>\n    <button>Profile</button>\n  </nav>\n</div>\n\n<style>\n  .mobile-layout {\n    display: flex;\n    flex-direction: column;\n    min-height: 100vh;\n  }\n  \n  .mobile-header {\n    display: flex;\n    align-items: center;\n    padding: 10px;\n    background: #333;\n    color: white;\n  }\n  \n  .menu-button {\n    margin-right: 10px;\n  }\n  \n  .mobile-content {\n    flex: 1;\n    padding: 10px;\n    overflow-y: auto;\n  }\n  \n  .mobile-card {\n    margin-bottom: 15px;\n    padding: 15px;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  }\n  \n  .mobile-nav {\n    display: flex;\n    justify-content: space-around;\n    padding: 10px;\n    background: #f0f0f0;\n    border-top: 1px solid #ddd;\n  }\n</style>\n```\n\n**DesktopLayout.svelte**\n```svelte\n<script>\n  export let title;\n  export let user;\n  export let content;\n</script>\n\n<div class=\"desktop-layout\">\n  <aside class=\"sidebar\">\n    <div class=\"logo\">\n      <h2>{title}</h2>\n    </div>\n    \n    <nav class=\"desktop-nav\">\n      <ul>\n        <li><a href=\"/\">Dashboard</a></li>\n        <li><a href=\"/analytics\">Analytics</a></li>\n        <li><a href=\"/settings\">Settings</a></li>\n        <li><a href=\"/help\">Help</a></li>\n      </ul>\n    </nav>\n    \n    {#if user}\n      <div class=\"user-profile\">\n        <img src={user.avatar} alt={user.name} />\n        <div class=\"user-info\">\n          <p class=\"user-name\">{user.name}</p>\n          <p class=\"user-role\">{user.role}</p>\n        </div>\n      </div>\n    {/if}\n  </aside>\n  \n  <main class=\"desktop-content\">\n    <header class=\"content-header\">\n      <h1>Dashboard</h1>\n      <div class=\"actions\">\n        <button class=\"primary\">New Item</button>\n        <button>Export</button>\n      </div>\n    </header>\n    \n    <div class=\"content-grid\">\n      {#each content as item}\n        <div class=\"desktop-card\">\n          <div class=\"card-header\">\n            <h2>{item.title}</h2>\n            <button class=\"icon-button\">â®</button>\n          </div>\n          <p>{item.description}</p>\n          <div class=\"card-footer\">\n            <span class=\"timestamp\">{item.date}</span>\n            <div class=\"card-actions\">\n              <button>Edit</button>\n              <button>Share</button>\n            </div>\n          </div>\n        </div>\n      {/each}\n    </div>\n  </main>\n</div>\n\n<style>\n  .desktop-layout {\n    display: grid;\n    grid-template-columns: 250px 1fr;\n    min-height: 100vh;\n  }\n  \n  .sidebar {\n    background: #2c3e50;\n    color: white;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n  }\n  \n  .logo {\n    margin-bottom: 30px;\n  }\n  \n  .desktop-nav ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n  }\n  \n  .desktop-nav li {\n    margin-bottom: 10px;\n  }\n  \n  .desktop-nav a {\n    color: #ecf0f1;\n    text-decoration: none;\n    display: block;\n    padding: 8px 10px;\n    border-radius: 4px;\n  }\n  \n  .desktop-nav a:hover {\n    background: rgba(255,255,255,0.1);\n  }\n  \n  .user-profile {\n    margin-top: auto;\n    display: flex;\n    align-items: center;\n    padding: 15px 0;\n    border-top: 1px solid rgba(255,255,255,0.1);\n  }\n  \n  .user-profile img {\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    margin-right: 10px;\n  }\n  \n  .desktop-content {\n    background: #f5f7fa;\n    padding: 20px;\n  }\n  \n  .content-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 20px;\n  }\n  \n  .content-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 20px;\n  }\n  \n  .desktop-card {\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n    padding: 20px;\n  }\n  \n  .card-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n  }\n  \n  .card-footer {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-top: 15px;\n    padding-top: 15px;\n    border-top: 1px solid #eee;\n  }\n</style>\n```\n\nThis approach offers several advantages:\n\n1. **Code splitting**: Each layout is loaded only when needed, reducing initial bundle size.\n\n2. **Optimized for each device**: Each layout is specifically designed for the target device size.\n\n3. **Performance optimization**: Components are loaded asynchronously and can be preloaded intelligently.\n\n4. **Graceful fallbacks**: The system handles SSR scenarios and loading states appropriately.\n\n5. **Reactive updates**: If the user resizes their browser window, the appropriate layout will be loaded and displayed automatically.\n\nYou could extend this system further by:\n\n- Adding a caching mechanism to avoid reloading components\n- Implementing a more sophisticated preloading strategy\n- Creating transition animations between layouts\n- Adding media query-based CSS as a fallback during component loading\n\nThis pattern is particularly useful for complex applications where the optimal UI varies significantly between device sizes."}
{"source":"docs/svelte/98-reference/21-svelte-reactivity-window.md","question":"How does the `devicePixelRatio` reactive value differ from other window values in terms of browser behavior, and how might you use it in a practical application?","answer":"The `devicePixelRatio` reactive value has some unique characteristics compared to other window values in the `svelte/reactivity/window` module. Understanding these differences is important for proper implementation in applications.\n\n### Differences in Browser Behavior\n\nAs noted in the documentation:\n\n> Note that behaviour differs between browsers â on Chrome it will respond to the current zoom level, on Firefox and Safari it won't.\n\nThis is a key distinction from other window values like `innerWidth` or `scrollY`, which behave consistently across browsers. The `devicePixelRatio` value:\n\n1. In Chrome: Changes when the user zooms in or out, reflecting the current zoom level\n2. In Firefox and Safari: Remains constant regardless of zoom level, only reflecting the physical pixel ratio of the device\n\n### Practical Applications\n\nHere's how you might use `devicePixelRatio` in a practical application:\n\n```svelte\n<script>\n  import { devicePixelRatio, innerWidth } from 'svelte/reactivity/window';\n  \n  // High-DPI detection\n  const isHighDPI = $derived(devicePixelRatio.current !== undefined && devicePixelRatio.current > 1);\n  \n  // Zoom level detection (works in Chrome)\n  const zoomLevel = $derived(\n    devicePixelRatio.current !== undefined \n      ? Math.round(devicePixelRatio.current * 100) \n      : 100\n  );\n  \n  // Select appropriate image resolution based on device pixel ratio\n  const getOptimalImageUrl = (baseUrl, options = {}) => {\n    const { \n      defaultSize = 1,\n      maxSize = 3,\n      format = 'jpg'\n    } = options;\n    \n    if (devicePixelRatio.current === undefined) {\n      return `${baseUrl}_${defaultSize}x.${format}`;\n    }\n    \n    // Limit to maxSize even on very high DPI displays\n    const dpr = Math.min(Math.ceil(devicePixelRatio.current), maxSize);\n    return `${baseUrl}_${dpr}x.${format}`;\n  };\n  \n  // Adjust canvas rendering for crisp graphics\n  let canvas;\n  \n  $effect(() => {\n    if (!canvas || devicePixelRatio.current === undefined) return;\n    \n    const ctx = canvas.getContext('2d');\n    const dpr = devicePixelRatio.current;\n    \n    // Set display size (css pixels)\n    const displayWidth = canvas.clientWidth;\n    const displayHeight = canvas.clientHeight;\n    \n    // Set actual size in memory (scaled to account for extra pixel density)\n    canvas.width = Math.floor(displayWidth * dpr);\n    canvas.height = Math.floor(displayHeight * dpr);\n    \n    // Scale context to ensure correct drawing operations\n    ctx.scale(dpr, dpr);\n    \n    // Clear and draw\n    ctx.clearRect(0, 0, displayWidth, displayHeight);\n    drawCanvasContent(ctx, displayWidth, displayHeight);\n  });\n  \n  function drawCanvasContent(ctx, width, height) {\n    // Draw a simple shape\n    ctx.fillStyle = '#ff3e00';\n    ctx.beginPath();\n    ctx.arc(width / 2, height / 2, Math.min(width, height) / 4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Add text\n    ctx.fillStyle = 'white';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('Hi-DPI Canvas', width / 2, height / 2);\n  }\n  \n  // Browser detection for showing zoom warning\n  let isChrome = false;\n  \n  $effect(() => {\n    if (typeof navigator !== 'undefined') {\n      isChrome = navigator.userAgent.indexOf('Chrome') !== -1;\n    }\n  });\n</script>\n\n<div class=\"dpi-aware-component\">\n  <div class=\"info-panel\">\n    <h2>Display Information</h2>\n    <p>Device Pixel Ratio: {devicePixelRatio.current ?? 'Unknown'}</p>\n    <p>Display Type: {isHighDPI ? 'High-DPI (Retina)' : 'Standard DPI'}</p>\n    <p>Window Width: {innerWidth.current ?? 'Unknown'} CSS pixels</p>\n    <p>Physical Pixels: {innerWidth.current !== undefined && devicePixelRatio.current !== undefined \n      ? Math.round(innerWidth.current * devicePixelRatio.current) \n      : 'Unknown'}</p>\n    \n    {#if isChrome}\n      <p>Current Zoom: {zoomLevel}%</p>\n      {#if zoomLevel !== 100}\n        <div class=\"zoom-warning\">\n          <p>â ï¸ Page is zoomed. This may affect the device pixel ratio.</p>\n        </div>\n      {/if}\n    {/if}\n  </div>\n  \n  <div class=\"demo-section\">\n    <h3>Optimized Images for Your Display</h3>\n    <div class=\"image-comparison\">\n      <div>\n        <h4>Standard Image</h4>\n        <img src=\"/images/sample_1x.jpg\" alt=\"Standard resolution\" />\n      </div>\n      <div>\n        <h4>DPI-Optimized Image</h4>\n        <img \n          src={getOptimalImageUrl('/images/sample', { maxSize: 3 })} \n          alt=\"Optimized for your display\" \n        />\n      </div>\n    </div>\n    \n    <h3>Hi-DPI Canvas Rendering</h3>\n    <canvas \n      bind:this={canvas} \n      width=\"300\" \n      height=\"200\" \n      style=\"width: 300px; height: 200px;\"\n    ></canvas>\n    \n    <h3>Font Rendering Sample</h3>\n    <div class=\"font-sample\" style=\"font-size: {isHighDPI ? '14px' : '16px'}\">\n      <p>This text is optimized for your display density.</p>\n      <p>On high-DPI displays, it's slightly smaller to maintain visual consistency.</p>\n    </div>\n  </div>\n</div>\n\n<style>\n  .dpi-aware-component {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 20px;\n    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;\n  }\n  \n  .info-panel {\n    background: #f5f7fa;\n    border-radius: 8px;\n    padding: 20px;\n    margin-bottom: 30px;\n  }\n  \n  .zoom-warning {\n    background: #fff3cd;\n    border: 1px solid #ffeeba;\n    color: #856404;\n    padding: 10px;\n    border-radius: 4px;\n    margin-top: 10px;\n  }\n  \n  .demo-section h3 {\n    margin-top: 30px;\n    margin-bottom: 15px;\n    border-bottom: 1px solid #eee;\n    padding-bottom: 10px;\n  }\n  \n  .image-comparison {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 20px;\n  }\n  \n  .image-comparison img {\n    max-width: 100%;\n    border: 1px solid #ddd;\n  }\n  \n  canvas {\n    border: 1px solid #ddd;\n    background: #f9f9f9;\n  }\n  \n  .font-sample {\n    line-height: 1.5;\n    background: white;\n    padding: 15px;\n    border: 1px solid #eee;\n    border-radius: 4px;\n  }\n</style>\n```\n\n### Additional Use Cases for `devicePixelRatio`\n\n1. **WebGL and Three.js Optimization**:\n```svelte\n<script>\n  import { devicePixelRatio } from 'svelte/reactivity/window';\n  import { onMount } from 'svelte';\n  import * as THREE from 'three';\n  \n  let container;\n  let renderer, scene, camera;\n  \n  onMount(() => {\n    // Setup Three.js scene\n    scene = new THREE.Scene();\n    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    renderer = new THREE.WebGLRenderer({ antialias: true });\n    \n    // Add to DOM\n    container.appendChild(renderer.domElement);\n    \n    // Add a simple cube\n    const geometry = new THREE.BoxGeometry();\n    const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\n    const cube = new THREE.Mesh(geometry, material);\n    scene.add(cube);\n    \n    // Add lighting\n    const light = new THREE.DirectionalLight(0xffffff, 1);\n    light.position.set(1, 1, 1);\n    scene.add(light);\n    \n    camera.position.z = 5;\n    \n    // Start animation loop\n    animate();\n    \n    function animate() {\n      requestAnimationFrame(animate);\n      cube.rotation.x += 0.01;\n      cube.rotation.y += 0.01;\n      renderer.render(scene, camera);\n    }\n    \n    // Handle resize\n    const handleResize = () => {\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n      camera.aspect = width / height;\n      camera.updateProjectionMatrix();\n      renderer.setSize(width, height);\n    };\n    \n    // Initial size setup\n    handleResize();\n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  });\n  \n  // Update renderer pixel ratio when devicePixelRatio changes\n  $effect(() => {\n    if (!renderer || devicePixelRatio.current === undefined) return;\n    \n    // Set pixel ratio for renderer (limit to 2 for performance on very high DPI displays)\n    renderer.setPixelRatio(Math.min(devicePixelRatio.current, 2));\n  });\n</script>\n\n<div class=\"webgl-container\" bind:this={container}></div>\n\n<style>\n  .webgl-container {\n    width: 100%;\n    height: 400px;\n  }\n</style>\n```\n\n2. **Dynamic SVG Quality Control**:\n```svelte\n<script>\n  import { devicePixelRatio } from 'svelte/reactivity/window';\n  \n  // Adjust SVG complexity based on device capabilities\n  const svgQuality = $derived(\n    devicePixelRatio.current === undefined \n      ? 'medium' \n      : devicePixelRatio.current <= 1 \n        ? 'low' \n        : devicePixelRatio.current <= 2 \n          ? 'medium' \n          : 'high'\n  );\n  \n  // Number of particles to render based on quality\n  const particleCount = $derived(\n    svgQuality === 'low' ? 50 :\n    svgQuality === 'medium' ? 150 :\n    300\n  );\n  \n  // Generate random particles\n  let particles = [];\n  \n  $effect(() => {\n    particles = Array(particleCount).fill().map(() => ({\n      x: Math.random() * 100,\n      y: Math.random() * 100,\n      size: Math.random() * 3 + 1,\n      opacity: Math.random() * 0.5 + 0.2\n    }));\n  });\n</script>\n\n<div class=\"svg-container\">\n  <div class=\"quality-indicator\">\n    <span>SVG Quality: {svgQuality.toUpperCase()}</span>\n    <span>Particles: {particleCount}</span>\n    <span>DPR: {devicePixelRatio.current ?? 'Unknown'}</span>\n  </div>\n  \n  <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\">\n    <!-- Background -->\n    <rect width=\"100\" height=\"100\" fill=\"#1a1a2e\" />\n    \n    <!-- Particles -->\n    {#each particles as particle}\n      <circle \n        cx={particle.x} \n        cy={particle.y} \n        r={particle.size} \n        fill=\"white\" \n        opacity={particle.opacity} \n      />\n    {/each}\n    \n    <!-- Main shape -->\n    <circle cx=\"50\" cy=\"50\" r=\"20\" fill=\"#ff3e00\" />\n    \n    <!-- Add more detailed elements for higher quality -->\n    {#if svgQuality === 'medium' || svgQuality === 'high'}\n      <path d=\"M50,30 L55,45 L70,45 L60,55 L65,70 L50,60 L35,70 L40,55 L30,45 L45,45 Z\" fill=\"#ffaa00\" />\n    {/if}\n    \n    {#if svgQuality === 'high'}\n      <!-- Extra details only for high DPI displays -->\n      <filter id=\"glow\">\n        <feGaussianBlur stdDeviation=\"2\" result=\"blur\" />\n        <feComposite in=\"SourceGraphic\" in2=\"blur\" operator=\"over\" />\n      </filter>\n      \n      <circle cx=\"50\" cy=\"50\" r=\"25\" fill=\"none\" stroke=\"#ff3e00\" stroke-width=\"0.5\" opacity=\"0.6\" filter=\"url(#glow)\" />\n      <circle cx=\"50\" cy=\"50\" r=\"30\" fill=\"none\" stroke=\"#ff3e00\" stroke-width=\"0.3\" opacity=\"0.4\" />\n      <circle cx=\"50\" cy=\"50\" r=\"35\" fill=\"none\" stroke=\"#ff3e00\" stroke-width=\"0.2\" opacity=\"0.2\" />\n    {/if}\n  </svg>\n</div>\n\n<style>\n  .svg-container {\n    max-width: 500px;\n    margin: 0 auto;\n    position: relative;\n  }\n  \n  svg {\n    width: 100%;\n    height: auto;\n    display: block;\n  }\n  \n  .quality-indicator {\n    position: absolute;\n    top: 10px;\n    left: 10px;\n    background: rgba(0,0,0,0.7);\n    color: white;\n    padding: 5px 10px;\n    border-radius: 4px;\n    font-size: 12px;\n    display: flex;\n    flex-direction: column;\n  }\n</style>\n```\n\n### Handling Browser Inconsistencies\n\nTo work around the browser inconsistencies with `devicePixelRatio`, you might implement a more robust detection system:\n\n```svelte\n<script>\n  import { devicePixelRatio, innerWidth } from 'svelte/reactivity/window';\n  import { onMount } from 'svelte';\n  \n  // Track the base devicePixelRatio (unaffected by zoom)\n  let baseDevicePixelRatio = undefined;\n  let isZoomed = false;\n  let browserType = 'unknown';\n  \n  onMount(() => {\n    // Detect browser\n    if (navigator.userAgent.indexOf('Chrome') !== -1) {\n      browserType = 'chrome';\n    } else if (navigator.userAgent.indexOf('Firefox') !== -1) {\n      browserType = 'firefox';\n    } else if (navigator.userAgent.indexOf('Safari') !== -1) {\n      browserType = 'safari';\n    }\n    \n    // Store the initial DPR\n    baseDevicePixelRatio = window.devicePixelRatio;\n    \n    // For Firefox and Safari, we need to detect zoom differently\n    if (browserType === 'firefox' || browserType === 'safari') {\n      // One approach is to compare CSS pixel ratio to actual pixels\n      const mediaQueryList = window.matchMedia('(resolution: 1dppx)');\n      \n      const updateZoomState = () => {\n        // If the media query doesn't match, we're zoomed\n        isZoomed = !mediaQueryList.matches;\n      };\n      \n      updateZoomState();\n      mediaQueryList.addEventListener('change', updateZoomState);\n      \n      return () => {\n        mediaQueryList.removeEventListener('change', updateZoomState);\n      };\n    }\n  });\n  \n  // For Chrome, we can detect zoom by watching devicePixelRatio changes\n  $effect(() => {\n    if (browserType === 'chrome' && baseDevicePixelRatio !== undefined && devicePixelRatio.current !== undefined) {\n      isZoomed = Math.abs(devicePixelRatio.current - baseDevicePixelRatio) > 0.001;\n    }\n  });\n  \n  // Estimate zoom level across browsers\n  const estimatedZoomLevel = $derived(() => {\n    if (devicePixelRatio.current === undefined || baseDevicePixelRatio === undefined) {\n      return 100;\n    }\n    \n    if (browserType === 'chrome') {\n      // In Chrome, devicePixelRatio directly reflects zoom\n      return Math.round((devicePixelRatio.current / baseDevicePixelRatio) * 100);\n    } else {\n      // For Firefox/Safari, we can use innerWidth if we know the base width\n      // This is a rough approximation and would need refinement\n      return isZoomed ? 'Unknown %' : '100%';\n    }\n  });\n</script>\n\n<div class=\"dpr-info\">\n  <h2>Cross-Browser DevicePixelRatio Info</h2>\n  <p>Browser detected: {browserType}</p>\n  <p>Device Pixel Ratio: {devicePixelRatio.current ?? 'Unknown'}</p>\n  <p>Base DPR (unaffected by zoom): {baseDevicePixelRatio ?? 'Unknown'}</p>\n  <p>Page is zoomed: {isZoomed ? 'Yes' : 'No'}</p>\n  <p>Estimated zoom level: {estimatedZoomLevel}</p>\n</div>\n```\n\nIn summary, `devicePixelRatio` is unique among window reactive values because of its browser-specific behavior with zoom levels. It's particularly useful for optimizing graphics, canvas rendering, and ensuring proper display on high-DPI screens, but requires careful handling to account for browser differences."}
{"source":"docs/svelte/98-reference/21-svelte-reactivity-window.md","question":"What are the key differences between using the `scrollY` reactive value from `svelte/reactivity/window` and the traditional approach of adding a scroll event listener?","answer":"The `scrollY` reactive value from `svelte/reactivity/window` represents a significant improvement over traditional scroll event listeners. Let's explore the key differences between these approaches and understand why the reactive approach is generally preferable in Svelte 5 applications.\n\n### Key Differences\n\n#### 1. Declarative vs. Imperative\n\n**Traditional Event Listener (Imperative):**\n```svelte\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  let scrollPosition = 0;\n  \n  function handleScroll() {\n    scrollPosition = window.scrollY;\n    // Any additional scroll-based logic\n  }\n  \n  onMount(() => {\n    window.addEventListener('scroll', handleScroll);\n    // Need to call once to initialize\n    handleScroll();\n  });\n  \n  onDestroy(() => {\n    window.removeEventListener('scroll', handleScroll);\n  });\n</script>\n\n<div style=\"opacity: {1 - Math.min(1, scrollPosition / 300)}\">\n  This content fades as you scroll down.\n</div>\n```\n\n**Reactive Approach (Declarative):**\n```svelte\n<script>\n  import { scrollY } from 'svelte/reactivity/window';\n  \n  const opacity = $derived(\n    1 - Math.min(1, (scrollY.current ?? 0) / 300)\n  );\n</script>\n\n<div style=\"opacity: {opacity}\">\n  This content fades as you scroll down.\n</div>\n```\n\n#### 2. Lifecycle Management\n\n**Traditional:** You must manually set up and tear down event listeners using `onMount` and `onDestroy`. Forgetting to remove event listeners can cause memory leaks.\n\n**Reactive:** The `scrollY` reactive value handles all event listener lifecycle management internally. You don't need to worry about adding or removing event listeners.\n\n#### 3. Performance Considerations\n\n**Traditional:** Every component that needs scroll position adds its own event listener, potentially causing performance issues if many components are listening to scroll events.\n\n**Reactive:** The `scrollY` value is implemented with a single shared event listener under the hood, improving performance when multiple components need the scroll position.\n\n#### 4. Server-Side Rendering Support\n\n**Traditional:** Requires conditional logic to avoid errors during server-side rendering since `window` is not available.\n\n**Reactive:** Automatically handles SSR scenarios by setting `scrollY.current` to `undefined` on the server.\n\n#### 5. Reactivity Integration\n\n**Traditional:** Requires manual integration with Svelte's reactivity system, often using reactive statements or stores.\n\n**Reactive:** Seamlessly integrates with Svelte 5's reactivity system, including `$derived` expressions and `$effect` blocks.\n\n#### 6. Code Readability and Maintainability\n\n**Traditional:** More boilerplate code, with event handling logic scattered across lifecycle methods.\n\n**Reactive:** Cleaner, more concise code that focuses on what you want to accomplish rather than how to set up the event listeners.\n\n### Practical Comparison Example\n\nLet's implement a more complex scroll-based feature using both approaches to highlight the differences:\n\n**Traditional Approach:**\n```svelte\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  // State variables\n  let scrollY = 0;\n  let ticking = false;\n  let sections = [];\n  let activeSectionIndex = 0;\n  \n  // Get references to sections\n  function initializeSections() {\n    sections = Array.from(document.querySelectorAll('.content-section'));\n  }\n  \n  // Update active section based on scroll position\n  function updateActiveSection() {\n    if (sections.length === 0) return;\n    \n    const viewportMiddle = scrollY + window.innerHeight / 2;\n    \n    for (let i = 0; i < sections.length; i++) {\n      const section = sections[i];\n      const rect = section.getBoundingClientRect();\n      const sectionTop = rect.top + scrollY;\n      const sectionBottom = sectionTop + rect.height;\n      \n      if (viewportMiddle >= sectionTop && viewportMiddle <= sectionBottom) {\n        activeSectionIndex = i;\n        break;\n      }\n    }\n  }\n  \n  // Scroll event handler with requestAnimationFrame for performance\n  function handleScroll() {\n    scrollY = window.scrollY;\n    \n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        updateActiveSection();\n        ticking = false;\n      });\n      ticking = true;\n    }\n  }\n  \n  // Initialize on mount\n  onMount(() => {\n    // Wait for DOM to be fully rendered\n    setTimeout(initializeSections, 100);\n    \n    // Set up scroll listener\n    window.addEventListener('scroll', handleScroll);\n    \n    // Initial call to set starting state\n    handleScroll();\n    \n    // Handle window resize (section positions might change)\n    const handleResize = () => {\n      initializeSections();\n      updateActiveSection();\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      window.removeEventListener('resize', handleResize);\n    };\n  });\n</script>\n\n<div class=\"page-container\">\n  <nav class=\"section-nav\">\n    {#each ['Introduction', 'Features', 'Pricing', 'FAQ', 'Contact'] as section, i}\n      <a \n        href={`#section-${i}`} \n        class:active={activeSectionIndex === i}\n        on:click|preventDefault={() => {\n          document.getElementById(`section-${i}`).scrollIntoView({ \n            behavior: 'smooth' \n          });\n        }}\n      >\n        {section}\n      </a>\n    {/each}\n  </nav>\n  \n  <main>\n    {#each ['Introduction', 'Features', 'Pricing', 'FAQ', 'Contact'] as section, i}\n      <section \n        id={`section-${i}`} \n        class=\"content-section\"\n        class:active={activeSectionIndex === i}\n      >\n        <h2>{section}</h2>\n        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit...</p>\n        <!-- More content -->\n      </section>\n    {/each}\n  </main>\n  \n  <div class=\"scroll-indicator\" style=\"transform: translateY({scrollY}px)\">\n    â\n  </div>\n</div>\n```\n\n**Reactive Approach:**\n```svelte\n<script>\n  import { scrollY } from 'svelte/reactivity/window';\n  import { onMount } from 'svelte';\n  \n  const sections = ['Introduction', 'Features', 'Pricing', 'FAQ', 'Contact'];\n  let sectionElements = [];\n  let sectionPositions = [];\n  \n  // Get section positions after mount\n  onMount(() => {\n    // Get references to section elements\n    sectionElements = sections.map((_, i) => \n      document.getElementById(`section-${i}`)\n    );\n    \n    // Update section positions\n    updateSectionPositions();\n    \n    // Update positions on window resize\n    window.addEventListener('resize', updateSectionPositions);\n    return () => {\n      window.removeEventListener('resize', updateSectionPositions);\n    };\n  });\n  \n  function updateSectionPositions() {\n    sectionPositions = sectionElements.map(el => {\n      if (!el) return 0;\n      return el.offsetTop;\n    });\n  }\n  \n  // Calculate active section based on scroll position\n  const activeSectionIndex = $derived(() => {\n    if (scrollY.current === undefined || sectionPositions.length === 0) return 0;\n    \n    const viewportMiddle = scrollY.current + (window.innerHeight / 2);\n    \n    for (let i = sectionPositions.length - 1; i >= 0; i--) {\n      if (viewportMiddle >= sectionPositions[i]) {\n        return i;\n      }\n    }\n    \n    return 0;\n  });\n  \n  // Scroll to section function\n  function scrollToSection(index) {\n    document.getElementById(`section-${index}`).scrollIntoView({ \n      behavior: 'smooth' \n    });\n  }\n</script>\n\n<div class=\"page-container\">\n  <nav class=\"section-nav\">\n    {#each sections as section, i}\n      <a \n        href={`#section-${i}`} \n        class:active={activeSectionIndex === i}\n        on:click|preventDefault={() => scrollToSection(i)}\n      >\n        {section}\n      </a>\n    {/each}\n  </nav>\n  \n  <main>\n    {#each sections as section, i}\n      <section \n        id={`section-${i}`} \n        class=\"content-section\"\n        class:active={activeSectionIndex === i}\n      >\n        <h2>{section}</h2>\n        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit...</p>\n        <!-- More content -->\n      </section>\n    {/each}\n  </main>\n  \n  <div class=\"scroll-indicator\" \n       style=\"transform: translateY({scrollY.current ?? 0}px)\">\n    â\n  </div>\n</div>\n```\n\n### Advantages of the Reactive Approach\n\n1. **"}
{"source":"docs/svelte/99-legacy/21-legacy-$$slots.md","question":"What is the purpose of the `$$slots` object in Svelte's legacy mode, and how does it differ from how slots are handled in runes mode?","answer":"In Svelte's legacy mode, the `$$slots` object is a special variable that allows components to determine which slots have been passed to them by parent components. The keys of this object correspond to the names of the slots that were provided.\n\nThe main purpose of `$$slots` is to conditionally render content based on whether a particular named slot was provided by the parent component. This is especially useful for optional UI elements.\n\nIn contrast, runes mode handles slots differently. In runes mode, snippets (the runes-mode equivalent of slots) are treated as normal props passed to a component, making it more straightforward to check for their existence without needing a special `$$slots` object.\n\nHere's an example of using `$$slots` in legacy mode:\n\n```svelte\n<!-- Card.svelte -->\n<div class=\"card\">\n  <div class=\"card-header\">\n    <slot name=\"title\">Default Title</slot>\n  </div>\n  \n  {#if $$slots.description}\n    <div class=\"card-description\">\n      <slot name=\"description\"></slot>\n    </div>\n  {/if}\n  \n  <div class=\"card-body\">\n    <slot></slot>\n  </div>\n  \n  {#if $$slots.footer}\n    <div class=\"card-footer\">\n      <slot name=\"footer\"></slot>\n    </div>\n  {/if}\n</div>\n```\n\nIn this example, the Card component will only render the description and footer sections if slots with those names are provided by the parent component."}
{"source":"docs/svelte/99-legacy/21-legacy-$$slots.md","question":"How would you implement a component that conditionally renders multiple optional sections based on whether specific slots are provided?","answer":"To implement a component with multiple conditional sections based on provided slots, you can use the `$$slots` object to check for the existence of each named slot. Here's a comprehensive example of a `ProfileCard` component that conditionally renders different sections:\n\n```svelte\n<!-- ProfileCard.svelte -->\n<div class=\"profile-card\">\n  <div class=\"profile-header\">\n    {#if $$slots.avatar}\n      <div class=\"avatar-container\">\n        <slot name=\"avatar\">\n          <!-- Default avatar as fallback -->\n          <div class=\"default-avatar\">ð¤</div>\n        </slot>\n      </div>\n    {/if}\n    \n    <div class=\"name-container\">\n      <slot name=\"name\">Anonymous User</slot>\n    </div>\n  </div>\n  \n  {#if $$slots.bio}\n    <div class=\"bio-section\">\n      <h3>Biography</h3>\n      <slot name=\"bio\"></slot>\n    </div>\n  {/if}\n  \n  {#if $$slots.skills}\n    <div class=\"skills-section\">\n      <h3>Skills</h3>\n      <slot name=\"skills\"></slot>\n    </div>\n  {/if}\n  \n  {#if $$slots.contact}\n    <div class=\"contact-section\">\n      <h3>Contact Information</h3>\n      <slot name=\"contact\"></slot>\n    </div>\n  {/if}\n  \n  {#if $$slots.projects}\n    <div class=\"projects-section\">\n      <h3>Projects</h3>\n      <slot name=\"projects\"></slot>\n    </div>\n  {/if}\n  \n  {#if $$slots.footer}\n    <div class=\"profile-footer\">\n      <slot name=\"footer\"></slot>\n    </div>\n  {/if}\n</div>\n\n<style>\n  .profile-card {\n    border: 1px solid #ddd;\n    border-radius: 8px;\n    padding: 20px;\n    max-width: 600px;\n    margin: 0 auto;\n  }\n  \n  .profile-header {\n    display: flex;\n    align-items: center;\n    margin-bottom: 20px;\n  }\n  \n  .avatar-container {\n    margin-right: 15px;\n  }\n  \n  .default-avatar {\n    font-size: 2rem;\n    background: #eee;\n    width: 50px;\n    height: 50px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: 50%;\n  }\n  \n  h3 {\n    border-bottom: 1px solid #eee;\n    padding-bottom: 5px;\n    margin-top: 20px;\n  }\n</style>\n```\n\nThis component can then be used like this:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import ProfileCard from './ProfileCard.svelte';\n</script>\n\n<ProfileCard>\n  <img slot=\"avatar\" src=\"/images/profile.jpg\" alt=\"User profile\" />\n  <h2 slot=\"name\">Jane Doe</h2>\n  \n  <p slot=\"bio\">\n    Frontend developer with 5 years of experience specializing in Svelte and React.\n  </p>\n  \n  <ul slot=\"skills\">\n    <li>Svelte</li>\n    <li>JavaScript</li>\n    <li>CSS</li>\n    <li>Responsive Design</li>\n  </ul>\n  \n  <!-- Not including contact section will make it not appear -->\n  \n  <div slot=\"projects\">\n    <a href=\"/project1\">Project 1</a>\n    <a href=\"/project2\">Project 2</a>\n  </div>\n  \n  <p slot=\"footer\">Last updated: August 2023</p>\n</ProfileCard>\n```\n\nIn this example, the ProfileCard component checks for the existence of each named slot using `$$slots` and only renders the corresponding sections if those slots are provided. The \"contact\" section will not be rendered because no content was provided for that slot."}
{"source":"docs/svelte/99-legacy/21-legacy-$$slots.md","question":"Can you explain how to provide default content for slots while still using `$$slots` to check if a slot was provided?","answer":"In Svelte, you can provide default content for slots that will be used when the parent component doesn't provide content for that slot. This works independently from using `$$slots` to check if a slot was provided.\n\nHere's how to combine both concepts:\n\n```svelte\n<!-- FeatureBox.svelte -->\n<div class=\"feature-box\">\n  <div class=\"feature-header\">\n    <!-- Default content for the title slot -->\n    <slot name=\"title\">\n      <h2>Default Feature Title</h2>\n    </slot>\n  </div>\n  \n  <div class=\"feature-content\">\n    <!-- Default content for the main/default slot -->\n    <slot>\n      <p>This feature has no description yet.</p>\n    </slot>\n  </div>\n  \n  <!-- Only render this section if the \"details\" slot is provided -->\n  {#if $$slots.details}\n    <div class=\"feature-details\">\n      <h3>Additional Details</h3>\n      <slot name=\"details\"></slot>\n    </div>\n  {/if}\n  \n  <!-- Icon section with default, but only if the slot is provided -->\n  {#if $$slots.icon}\n    <div class=\"feature-icon\">\n      <slot name=\"icon\">\n        <div class=\"default-icon\">ð</div>\n      </slot>\n    </div>\n  {/if}\n  \n  <!-- Footer always renders but has default content -->\n  <div class=\"feature-footer\">\n    <slot name=\"footer\">\n      <p>Learn more about this feature in our documentation.</p>\n    </slot>\n  </div>\n</div>\n\n<style>\n  .feature-box {\n    border: 1px solid #eee;\n    padding: 20px;\n    margin: 10px 0;\n    border-radius: 5px;\n  }\n  .feature-details {\n    margin-top: 15px;\n    padding-top: 15px;\n    border-top: 1px dashed #ccc;\n  }\n  .feature-footer {\n    margin-top: 20px;\n    font-size: 0.9em;\n    color: #666;\n  }\n  .feature-icon {\n    position: absolute;\n    top: 10px;\n    right: 10px;\n  }\n  .default-icon {\n    font-size: 1.5rem;\n  }\n</style>\n```\n\nWhen using this component:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import FeatureBox from './FeatureBox.svelte';\n</script>\n\n<!-- Example 1: With minimal content, will use defaults -->\n<FeatureBox>\n  <p>This is a simple feature description.</p>\n</FeatureBox>\n\n<!-- Example 2: With custom content for most slots -->\n<FeatureBox>\n  <h2 slot=\"title\">Custom Authentication</h2>\n  <p>Our authentication system supports multiple providers.</p>\n  \n  <div slot=\"details\">\n    <p>Supports OAuth, JWT, and session-based authentication.</p>\n    <p>Easy integration with popular providers like Google, Facebook, and GitHub.</p>\n  </div>\n  \n  <div slot=\"icon\">ð</div>\n  \n  <p slot=\"footer\">See the authentication API documentation for implementation details.</p>\n</FeatureBox>\n\n<!-- Example 3: With icon but using default footer -->\n<FeatureBox>\n  <h2 slot=\"title\">Data Visualization</h2>\n  <p>Create beautiful charts and graphs with our visualization tools.</p>\n  \n  <div slot=\"icon\">ð</div>\n  <!-- No footer slot provided, so it will use the default -->\n</FeatureBox>\n```\n\nIn this example:\n1. The `title` and default slots have default content, but will be replaced if the parent provides content\n2. The `details` section only renders if the parent provides that slot\n3. The `icon` section only renders if the parent provides that slot, but has default content if it does render\n4. The `footer` always renders and has default content that will be used if the parent doesn't provide content for that slot\n\nThis pattern gives you fine-grained control over which parts of your component are optional, which parts have defaults, and which combinations of these behaviors you want for each section."}
{"source":"docs/svelte/99-legacy/21-legacy-$$slots.md","question":"How can you use `$$slots` to create a component with a dynamic layout that adapts based on which slots are provided?","answer":"You can use `$$slots` to create components with dynamic layouts that adapt their structure based on which slots are provided. This approach is particularly useful for creating flexible UI components that can handle different content arrangements.\n\nHere's an example of a `DashboardPanel` component that changes its layout based on which slots are provided:\n\n```svelte\n<!-- DashboardPanel.svelte -->\n<script>\n  // Determine the layout class based on which slots are provided\n  let layoutClass = '';\n  \n  $: {\n    const hasHeader = $$slots.header;\n    const hasSidebar = $$slots.sidebar;\n    const hasFooter = $$slots.footer;\n    \n    if (hasHeader && hasSidebar && hasFooter) {\n      layoutClass = 'full-layout';\n    } else if (hasHeader && hasSidebar) {\n      layoutClass = 'header-sidebar-layout';\n    } else if (hasHeader && hasFooter) {\n      layoutClass = 'header-footer-layout';\n    } else if (hasSidebar && hasFooter) {\n      layoutClass = 'sidebar-footer-layout';\n    } else if (hasHeader) {\n      layoutClass = 'header-only-layout';\n    } else if (hasSidebar) {\n      layoutClass = 'sidebar-only-layout';\n    } else if (hasFooter) {\n      layoutClass = 'footer-only-layout';\n    } else {\n      layoutClass = 'content-only-layout';\n    }\n  }\n</script>\n\n<div class=\"dashboard-panel {layoutClass}\">\n  {#if $$slots.header}\n    <div class=\"panel-header\">\n      <slot name=\"header\"></slot>\n    </div>\n  {/if}\n  \n  <div class=\"panel-body\">\n    {#if $$slots.sidebar}\n      <div class=\"panel-sidebar\">\n        <slot name=\"sidebar\"></slot>\n      </div>\n    {/if}\n    \n    <div class=\"panel-content\">\n      <slot></slot>\n    </div>\n  </div>\n  \n  {#if $$slots.footer}\n    <div class=\"panel-footer\">\n      <slot name=\"footer\"></slot>\n    </div>\n  {/if}\n</div>\n\n<style>\n  .dashboard-panel {\n    display: flex;\n    flex-direction: column;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    overflow: hidden;\n    height: 100%;\n    min-height: 300px;\n  }\n  \n  .panel-body {\n    display: flex;\n    flex: 1;\n    overflow: hidden;\n  }\n  \n  .panel-header, .panel-footer {\n    padding: 15px;\n    background: #f5f5f5;\n  }\n  \n  .panel-header {\n    border-bottom: 1px solid #ddd;\n  }\n  \n  .panel-footer {\n    border-top: 1px solid #ddd;\n  }\n  \n  .panel-sidebar {\n    width: 250px;\n    border-right: 1px solid #ddd;\n    padding: 15px;\n    overflow-y: auto;\n  }\n  \n  .panel-content {\n    flex: 1;\n    padding: 15px;\n    overflow-y: auto;\n  }\n  \n  /* Responsive adjustments for different layouts */\n  .sidebar-only-layout .panel-body,\n  .sidebar-footer-layout .panel-body {\n    flex-direction: row;\n  }\n  \n  .content-only-layout .panel-content,\n  .header-only-layout .panel-content,\n  .footer-only-layout .panel-content,\n  .header-footer-layout .panel-content {\n    padding: 20px;\n  }\n  \n  @media (max-width: 768px) {\n    .panel-body {\n      flex-direction: column;\n    }\n    \n    .panel-sidebar {\n      width: 100%;\n      border-right: none;\n      border-bottom: 1px solid #ddd;\n    }\n  }\n</style>\n```\n\nThis component can be used in various ways to create different layouts:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import DashboardPanel from './DashboardPanel.svelte';\n</script>\n\n<div class=\"dashboard-grid\">\n  <!-- Panel with all slots -->\n  <DashboardPanel>\n    <div slot=\"header\">\n      <h2>Complete Panel</h2>\n    </div>\n    \n    <div slot=\"sidebar\">\n      <nav>\n        <ul>\n          <li><a href=\"#home\">Home</a></li>\n          <li><a href=\"#analytics\">Analytics</a></li>\n          <li><a href=\"#settings\">Settings</a></li>\n        </ul>\n      </nav>\n    </div>\n    \n    <div>\n      <h3>Main Content</h3>\n      <p>This is the main content area of the panel.</p>\n    </div>\n    \n    <div slot=\"footer\">\n      <p>Â© 2023 Dashboard Example</p>\n    </div>\n  </DashboardPanel>\n  \n  <!-- Panel with only header and content -->\n  <DashboardPanel>\n    <div slot=\"header\">\n      <h2>Header & Content Only</h2>\n    </div>\n    \n    <div>\n      <p>This panel has a header but no sidebar or footer.</p>\n    </div>\n  </DashboardPanel>\n  \n  <!-- Panel with only sidebar and content -->\n  <DashboardPanel>\n    <div slot=\"sidebar\">\n      <h3>Quick Links</h3>\n      <ul>\n        <li><a href=\"#link1\">Link 1</a></li>\n        <li><a href=\"#link2\">Link 2</a></li>\n      </ul>\n    </div>\n    \n    <div>\n      <p>This panel has a sidebar but no header or footer.</p>\n    </div>\n  </DashboardPanel>\n  \n  <!-- Panel with only content -->\n  <DashboardPanel>\n    <div>\n      <h3>Simple Panel</h3>\n      <p>This panel only has content, no header, sidebar, or footer.</p>\n    </div>\n  </DashboardPanel>\n</div>\n\n<style>\n  .dashboard-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));\n    gap: 20px;\n    padding: 20px;\n  }\n</style>\n```\n\nThis example demonstrates how to:\n\n1. Dynamically determine a layout class based on which slots are provided\n2. Apply different CSS styles to each layout variation\n3. Structure the component to handle various combinations of slots\n4. Make the layout responsive for different screen sizes\n\nThe component adapts its structure and styling based on which slots are provided, creating a flexible UI component that can be used in many different contexts within your application."}
{"source":"docs/svelte/99-legacy/21-legacy-$$slots.md","question":"What are the limitations of using `$$slots` in legacy mode, and how might you work around them?","answer":"Using `$$slots` in Svelte's legacy mode has several limitations compared to the newer runes mode approach. Here are the key limitations and potential workarounds:\n\n### Limitations:\n\n1. **Static Detection Only**: `$$slots` only tells you if a slot was provided, not whether it has meaningful content. A slot with empty content will still appear in `$$slots`.\n\n2. **No Direct Access to Slot Content**: You can check if a slot exists, but you can't programmatically access or manipulate its content directly.\n\n3. **No Dynamic Slot Names**: You can't dynamically generate or reference slot names in the `$$slots` object using variables.\n\n4. **Limited Slot Props Communication**: In legacy mode, passing data back to slot content (slot props) is more limited compared to runes mode.\n\n5. **No Reactive Updates**: If slots are conditionally rendered in the parent component, `$$slots` won't reactively update after initial component creation.\n\n### Workarounds:\n\n1. **For Empty Slot Content**:\n   You can combine `$$slots` with default slot content that checks for emptiness:\n\n```svelte\n<!-- Component.svelte -->\n{#if $$slots.header}\n  <header class=\"panel-header\">\n    <slot name=\"header\">\n      <!-- This will only show if the slot exists but has no content -->\n      <em>No header content provided</em>\n    </slot>\n  </header>\n{/if}\n```\n\n2. **For Content Access**:\n   Use slot props to communicate with the parent and have the parent pass data back:\n\n```svelte\n<!-- Component.svelte -->\n<slot name=\"content\" {items} onSelect={handleSelect}></slot>\n\n<!-- Parent.svelte -->\n<Component let:items let:onSelect>\n  <div slot=\"content\">\n    {#each items as item}\n      <button on:click={() => onSelect(item)}>{item.name}</button>\n    {/each}\n  </div>\n</Component>\n```\n\n3. **For Dynamic Slot Names**:\n   Pre-define all possible slots and conditionally render content in the parent:\n\n```svelte\n<!-- Component.svelte -->\n{#if $$slots.section1}\n  <div class=\"section\"><slot name=\"section1\"></slot></div>\n{/if}\n{#if $$slots.section2}\n  <div class=\"section\"><slot name=\"section2\"></slot></div>\n{/if}\n{#if $$slots.section3}\n  <div class=\"section\"><slot name=\"section3\"></slot></div>\n{/if}\n\n<!-- Parent.svelte -->\n<script>\n  let activeSectionIndex = 1;\n  $: activeSection = `section${activeSectionIndex}`;\n</script>\n\n<Component>\n  {#if activeSection === 'section1'}\n    <div slot=\"section1\">Content for section 1</div>\n  {/if}\n  {#if activeSection === 'section2'}\n    <div slot=\"section2\">Content for section 2</div>\n  {/if}\n  {#if activeSection === 'section3'}\n    <div slot=\"section3\">Content for section 3</div>\n  {/if}\n</Component>\n```\n\n4. **For Advanced Slot Management**:\n   Create a wrapper component that uses context API to provide more flexible slot management:\n\n```svelte\n<!-- SlotManager.svelte -->\n<script>\n  import { setContext } from 'svelte';\n  import { writable } from 'svelte/store';\n  \n  const slots = writable({});\n  \n  export function registerSlot(name, hasContent) {\n    slots.update(s => ({...s, [name]: hasContent}));\n  }\n  \n  setContext('slots', {\n    register: registerSlot,\n    slots\n  });\n</script>\n\n<slot></slot>\n\n<!-- SlotProvider.svelte -->\n<script>\n  import { getContext, onMount } from 'svelte';\n  \n  export let name;\n  export let hasContent = true;\n  \n  const { register } = getContext('slots');\n  \n  onMount(() => {\n    register(name, hasContent);\n    return () => register(name, false);\n  });\n</script>\n\n<slot></slot>\n\n<!-- AdvancedPanel.svelte -->\n<script>\n  import SlotManager from './SlotManager.svelte';\n  import { getContext } from 'svelte';\n  \n  let slotsStore;\n  let slotsData = {};\n  \n  function setup() {\n    const { slots } = getContext('slots');\n    slotsStore = slots;\n    \n    return slotsStore.subscribe(value => {\n      slotsData = value;\n    });\n  }\n</script>\n\n<SlotManager>\n  {#key setup()}\n    <div class=\"panel\">\n      {#if slotsData.header}\n        <header><slot name=\"header\"></slot></header>\n      {/if}\n      \n      <main><slot></slot></main>\n      \n      {#if slotsData.footer}\n        <footer><slot name=\"footer\"></slot></footer>\n      {/if}\n    </div>\n  {/key}\n</SlotManager>\n\n<!-- Usage in App.svelte -->\n<script>\n  import AdvancedPanel from './AdvancedPanel.svelte';\n  import SlotProvider from './SlotProvider.svelte';\n  \n  let showFooter = false;\n</script>\n\n<AdvancedPanel>\n  <SlotProvider name=\"header\">\n    <h1>Dynamic Panel</h1>\n  </SlotProvider>\n  \n  <p>Main content here</p>\n  \n  {#if showFooter}\n    <SlotProvider name=\"footer\">\n      <p>Footer content</p>\n    </SlotProvider>\n  {/if}\n</AdvancedPanel>\n\n<button on:click={() => showFooter = !showFooter}>\n  {showFooter ? 'Hide' : 'Show'} Footer\n</button>\n```\n\n5. **Migration to Runes Mode**:\n   The most comprehensive solution is to migrate to Svelte 5's runes mode, which provides a more intuitive and powerful approach to handling slots (called snippets in runes mode). In runes mode, snippets are just normal props, making them easier to work with and eliminating many of the limitations of `$$slots`.\n\nThese workarounds can help you overcome the limitations of `$$slots` in legacy mode, but they add complexity to your code. For new projects or when migrating to Svelte 5, consider using runes mode for a more straightforward approach to component composition."}
{"source":"docs/svelte/99-legacy/21-legacy-$$slots.md","question":"How does `$$slots` help with conditional rendering in Svelte components, and what are some practical examples of when to use it?","answer":"The `$$slots` object in Svelte's legacy mode is a powerful tool for conditional rendering based on whether specific slots have been provided by a parent component. This enables more flexible component design where parts of the UI can be optional based on the needs of the parent component.\n\n### How `$$slots` Works for Conditional Rendering\n\nWhen a parent component provides content for a named slot, that slot name becomes a key in the `$$slots` object of the child component. You can then use this to conditionally render parts of your component:\n\n```svelte\n{#if $$slots.header}\n  <header class=\"card-header\">\n    <slot name=\"header\"></slot>\n  </header>\n{/if}\n```\n\n### Practical Examples\n\nHere are several practical examples of when and how to use `$$slots` for conditional rendering:\n\n#### 1. Flexible Card Component\n\n```svelte\n<!-- Card.svelte -->\n<div class=\"card {$$slots.image ? 'has-image' : ''}\">\n  {#if $$slots.image}\n    <div class=\"card-image\">\n      <slot name=\"image\"></slot>\n    </div>\n  {/if}\n  \n  <div class=\"card-content\">\n    {#if $$slots.title}\n      <div class=\"card-title\">\n        <slot name=\"title\"></slot>\n      </div>\n    {/if}\n    \n    <div class=\"card-body\">\n      <slot></slot>\n    </div>\n    \n    {#if $$slots.footer}\n      <div class=\"card-footer\">\n        <slot name=\"footer\"></slot>\n      </div>\n    {/if}\n  </div>\n</div>\n\n<style>\n  .card {\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    overflow: hidden;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  }\n  \n  .has-image .card-content {\n    padding-top: 0;\n  }\n  \n  .card-image img {\n    width: 100%;\n    display: block;\n  }\n  \n  .card-content {\n    padding: 16px;\n  }\n  \n  .card-title {\n    margin-bottom: 12px;\n    font-weight: bold;\n  }\n  \n  .card-footer {\n    margin-top: 16px;\n    padding-top: 16px;\n    border-top: 1px solid #eee;\n    font-size: 0.9em;\n  }\n</style>\n```\n\nUsage:\n\n```svelte\n<!-- Simple card -->\n<Card>\n  <p>This is a basic card with just content.</p>\n</Card>\n\n<!-- Card with image and title -->\n<Card>\n  <img slot=\"image\" src=\"/images/mountain.jpg\" alt=\"Mountain view\" />\n  <h2 slot=\"title\">Mountain Retreat</h2>\n  <p>Discover our peaceful mountain getaway with stunning views.</p>\n</Card>\n\n<!-- Complete card -->\n<Card>\n  <img slot=\"image\" src=\"/images/product.jpg\" alt=\"Product\" />\n  <h2 slot=\"title\">Premium Headphones</h2>\n  <p>Noise-cancelling headphones with 20-hour battery life.</p>\n  <div slot=\"footer\">\n    <button>Add to Cart</button>\n    <span>$199.99</span>\n  </div>\n</Card>\n```\n\n#### 2. Modal Dialog with Optional Parts\n\n```svelte\n<!-- Modal.svelte -->\n<script>\n  export let isOpen = false;\n  export let onClose = () => {};\n  \n  function handleBackdropClick(e) {\n    if (e.target === e.currentTarget) {\n      onClose();\n    }\n  }\n</script>\n\n{#if isOpen}\n  <div class=\"modal-backdrop\" on:click={handleBackdropClick}>\n    <div class=\"modal-container\">\n      {#if $$slots.header}\n        <div class=\"modal-header\">\n          <slot name=\"header\"></slot>\n          <button class=\"close-button\" on:click={onClose}>Ã</button>\n        </div>\n      {:else}\n        <button class=\"close-button standalone\" on:click={onClose}>Ã</button>\n      {/if}\n      \n      <div class=\"modal-body\">\n        <slot></slot>\n      </div>\n      \n      {#if $$slots.footer}\n        <div class=\"modal-footer\">\n          <slot name=\"footer\"></slot>\n        </div>\n      {/if}\n    </div>\n  </div>\n{/if}\n\n<style>\n  .modal-backdrop {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.5);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 1000;\n  }\n  \n  .modal-container {\n    background: white;\n    border-radius: 4px;\n    max-width: 500px;\n    width: 100%;\n    max-height: 90vh;\n    overflow: hidden;\n    display: flex;\n    flex-direction: column;\n    position: relative;\n  }\n  \n  .modal-header {\n    padding: 16px;\n    border-bottom: 1px solid #eee;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n  \n  .modal-body {\n    padding: 16px;\n    overflow-y: auto;\n    flex: 1;\n  }\n  \n  .modal-footer {\n    padding: 16px;\n    border-top: 1px solid #eee;\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n  }\n  \n  .close-button {\n    background: none;\n    border: none;\n    font-size: 24px;\n    cursor: pointer;\n    padding: 0;\n    line-height: 1;\n  }\n  \n  .close-button.standalone {\n    position: absolute;\n    top: 10px;\n    right: 10px;\n  }\n</style>\n```\n\nUsage:\n\n```svelte\n<script>\n  import Modal from './Modal.svelte';\n  let showModal = false;\n</script>\n\n<button on:click={() => showModal = true}>Open Modal</button>\n\n<!-- Simple modal -->\n<Modal isOpen={showModal} onClose={() => showModal = false}>\n  <p>This is a simple modal with just content.</p>\n</Modal>\n\n<!-- Modal with header and footer -->\n<Modal isOpen={showModal} onClose={() => showModal = false}>\n  <h2 slot=\"header\">Confirm Action</h2>\n  <p>Are you sure you want to delete this item? This action cannot be undone.</p>\n  <div slot=\"footer\">\n    <button on:click={() => showModal = false}>Cancel</button>\n    <button class=\"primary\" on:click={() => { /* handle deletion */ showModal = false; }}>\n      Delete\n    </button>\n  </div>\n</Modal>\n```\n\n#### 3. Form Layout with Optional Sections\n\n```svelte\n<!-- FormLayout.svelte -->\n<form on:submit|preventDefault>\n  {#if $$slots.header}\n    <div class=\"form-header\">\n      <slot name=\"header\"></slot>\n    </div>\n  {/if}\n  \n  {#if $$slots.errors}\n    <div class=\"form-errors\">\n      <slot name=\"errors\"></slot>\n    </div>\n  {/if}\n  \n  <div class=\"form-body\">\n    <slot></slot>\n  </div>\n  \n  {#if $$slots.actions}\n    <div class=\"form-actions\">\n      <slot name=\"actions\">\n        <!-- Default submit button if no custom actions provided -->\n        <button type=\"submit\">Submit</button>\n      </slot>\n    </div>\n  {/if}\n  \n  {#if $$slots.footer}\n    <div class=\"form-footer\">\n      <slot name=\"footer\"></slot>\n    </div>\n  {/if}\n</form>\n\n<style>\n  form {\n    max-width: 600px;\n    margin: 0 auto;\n  }\n  \n  .form-header {\n    margin-bottom: 20px;\n  }\n  \n  .form-errors {\n    margin-bottom: 20px;\n    padding: 12px;\n    background: #fff8f8;\n    border-left: 4px solid #ff5555;\n    color: #d32f2f;\n  }\n  \n  .form-body {\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    margin-bottom: 20px;\n  }\n  \n  .form-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 12px;\n    margin-top: 24px;\n  }\n  \n  .form-footer {\n    margin-top: 16px;\n    padding-top: 16px;\n    border-top: 1px solid #eee;\n    font-size: 0.9em;\n    color: #666;\n  }\n</style>\n```\n\nUsage:\n\n```svelte\n<script>\n  import FormLayout from './FormLayout.svelte';\n  \n  let name = '';\n  let email = '';\n  let errors = [];\n  \n  function validateForm() {\n    errors = [];\n    \n    if (!name) errors.push('Name is required');\n    if (!email) errors.push('Email is required');\n    else if (!/\\S+@\\S+\\.\\S+/.test(email)) errors.push('Email is invalid');\n    \n    return errors.length === 0;\n  }\n  \n  function handleSubmit() {\n    if (validateForm()) {\n      // Submit form data\n      console.log('Form submitted:', { name, email });\n    }\n  }\n</script>\n\n<FormLayout on:submit={handleSubmit}>\n  <h2 slot=\"header\">Contact Form</h2>\n  \n  {#if errors.length > 0}\n    <div slot=\"errors\">\n      <p>Please correct the following errors:</p>\n      <ul>\n        {#each errors as error}\n          <li>{error}</li>\n        {/each}\n      </ul>\n    </div>\n  {/if}\n  \n  <div class=\"form-field\">\n    <label for=\"name\">Name</label>\n    <input id=\"name\" type=\"text\" bind:value={name} required />\n  </div>\n  \n  <div class=\"form-field\">\n    <label for=\"email\">Email</label>\n    <input id=\"email\" type=\"email\" bind:value={email} required />\n  </div>\n  \n  <div slot=\"actions\">\n    <button type=\"button\" class=\"secondary\">Cancel</button>\n    <button type=\"submit\" class=\"primary\">Submit</button>\n  </div>\n  \n  <p slot=\"footer\">\n    By submitting this form, you agree to our <a href=\"/terms\">Terms of Service</a>.\n  </p>\n</FormLayout>\n```\n\n#### 4. Dashboard Layout with Optional Regions\n\n```svelte\n<!-- DashboardLayout.svelte -->\n<div class=\"dashboard {$$slots.sidebar ? 'has-sidebar' : ''} {$$slots.rightPanel ? 'has-right-panel' : ''}\">\n  {#if $$slots.navbar}\n    <nav class=\"dashboard-navbar\">\n      <slot name=\"navbar\"></slot>\n    </nav>\n  {/if}\n  \n  <div class=\"dashboard-main\">\n    {#if $$slots.sidebar}\n      <aside class=\"dashboard-sidebar\">\n        <slot name=\"sidebar\"></slot>\n      </aside>\n    {/if}\n    \n    <main class=\"dashboard-content\">\n      {#if $$slots.header}\n        <header class=\"content-header\">\n          <slot name=\"header\"></slot>\n        </header>\n      {/if}\n      \n      <div class=\"content-body\">\n        <slot></slot>\n      </div>\n      \n      {#if $$slots.footer}\n        <footer class=\"content-footer\">\n          <slot name=\"footer\"></slot>\n        </footer>\n      {/if}\n    </main>\n    \n    {#if $$slots.rightPanel}\n      <aside class=\"dashboard-right-panel\">\n        <slot name=\"rightPanel\"></slot>\n      </aside>\n    {/if}\n  </div>\n</div>\n\n<style>\n  .dashboard {\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n  \n  .dashboard-navbar {\n    height: 60px;\n    background: #2c3e50;\n    color: white;\n  }\n  \n  .dashboard-main {\n    display: flex;\n    flex: 1;\n    overflow: hidden;\n  }\n  \n  .dashboard-sidebar {\n    width: 250px;\n    background: #f5f5f5;\n    overflow-y: auto;\n    border-right: 1px solid #ddd;\n  }\n  \n  .dashboard-content {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n  }\n  \n  .content-header {\n    padding: 16px;\n    border-bottom: 1px solid #eee;\n  }\n  \n  .content-body {\n    flex: 1;\n    padding: 20px;\n    overflow-y: auto;\n  }\n  \n  .content-footer {\n    padding: 16px;\n    border-top: 1px solid #eee;\n    background: #f9f9f9;\n  }\n  \n  .dashboard-right-panel {\n    width: 300px;\n    background: #f5f5f5;\n    overflow-y: auto;\n    border-left: 1px solid #ddd;\n  }\n  \n  @media (max-width: 768px) {\n    .has-sidebar .dashboard-main {\n      flex-direction: column;\n    }\n    \n    .dashboard-sidebar,\n    .dashboard-right-panel {\n      width: 100%;\n      height: auto;\n      max-height: 200px;\n    }\n    \n    .dashboard-sidebar {\n      border-right: none;\n      border-bottom: 1px solid #ddd;\n    }\n    \n    .dashboard-right-panel {\n      border-left: none;\n      border-top: 1px solid #ddd;\n    }\n  }\n</style>\n```\n\nThese examples demonstrate how `$$slots` enables you to create highly flexible components that adapt their rendering based on the slots provided by the parent component. This pattern is particularly useful for:\n\n1. UI components that need to work in multiple contexts\n2. Layout components that support different configurations\n3. Components that have optional sections or features\n4. Creating component libraries with consistent but customizable interfaces\n\nBy using `$$slots` for conditional rendering, you can build components that are more reusable and adaptable to different requirements without needing to create multiple specialized versions."}
{"source":"docs/svelte/99-legacy/21-legacy-$$slots.md","question":"How does `$$slots` differ from other Svelte special variables like `$$props` and `$$restProps`, and when would you use each one?","answer":"Svelte provides several special variables that start with `$$` to give components access to information that would otherwise be difficult to obtain. Here's how `$$slots` compares to other special variables and when to use each one:\n\n### `$$slots`\n\n**Purpose**: Provides information about which named slots have been passed to a component.\n\n**Type**: An object where the keys are the names of slots provided to the component.\n\n**Usage**: Used to conditionally render parts of a component based on whether specific slots were provided.\n\n**Example**:\n```svelte\n{#if $$slots.header}\n  <header><slot name=\"header\"></slot></header>\n{/if}\n```\n\n**When to use**:\n- When you need to check if a specific named slot was provided\n- For conditional rendering of component sections\n- To adapt layouts based on available content\n- When creating flexible component templates\n\n### `$$props`\n\n**Purpose**: Provides access to all props passed to a component, including ones not explicitly declared.\n\n**Type**: An object containing all props passed to the component.\n\n**Usage**: Used when you need to access all props or forward them to another component.\n\n**Example**:\n```svelte\n<script>\n  // Access a prop dynamically\n  $: dynamicProp = $$props[propName];\n  \n  // Log all props for debugging\n  $: console.log('All props:', $$props);\n</script>\n\n<!-- Forward all props to a child component -->\n<ChildComponent {...$$props} />\n```\n\n**When to use**:\n- When creating wrapper components that need to forward all props\n- For debugging to see all props passed to a component\n- When accessing props dynamically by name\n- When you don't know all possible props in advance\n\n### `$$restProps`\n\n**Purpose**: Contains only the props that were not explicitly declared in the component's `export` statements.\n\n**Type**: An object containing props that weren't explicitly declared.\n\n**Usage**: Used to forward \"extra\" props to an element or child component.\n\n**Example**:\n```svelte\n<script>\n  export let title;\n  export let description;\n  // $$restProps will contain any props other than title and description\n</script>\n\n<button class=\"btn\" {...$$restProps}>\n  {title}\n</button>\n```\n\n**When to use**:\n- When creating component wrappers around HTML elements\n- To allow passing HTML attributes (like `aria-*`, `data-*`) to underlying elements\n- For component libraries to support standard HTML attributes without listing them all\n- When you want to be explicit about which props you handle vs. which ones you pass through\n\n### Comparison and Usage Guidelines\n\n#### `$$slots` vs `$$props`/`$$restProps`\n\n- **Different purposes**: `$$slots` is about component composition and structure, while `$$props`/`$$restProps` are about property handling and forwarding.\n- **Different phases**: `$$slots` affects component structure and rendering, while props affect component behavior and data.\n\n#### When to Use Each\n\n1. **Use `$$slots` when**:\n   - You're designing a component with optional sections\n   - You need to check if certain content was provided\n   - You're creating layout components with flexible structure\n\n2. **Use `$$props` when**:\n   - You need to access or forward all props\n   - You're working with dynamically named props\n   - You're creating a pass-through component\n\n3. **Use `$$restProps` when**:\n   - You want to explicitly handle some props but forward others\n   - You're wrapping HTML elements and want to support standard attributes\n   - You're creating components that should behave like enhanced HTML elements\n\n### Practical Example Using All Three\n\nHere's an example of a component that uses all three special variables:\n\n```svelte\n<!-- EnhancedButton.svelte -->\n<script>\n  // Explicitly declared props\n  export let variant = 'primary';\n  export let size = 'medium';\n  export let disabled = false;\n  \n  // Compute class based on declared props\n  $: buttonClass = `btn btn-${variant} btn-${size} ${disabled ? 'disabled' : ''}`;\n  \n  // For debugging - see all props passed to this component\n  $: console.log('All button props:', $$props);\n</script>\n\n<!-- Use $$slots to check for optional content -->\n<button \n  class={buttonClass} \n  {disabled} \n  {...$$restProps} <!-- Forward any additional HTML attributes -->\n>\n  {#if $$slots.icon}\n    <span class=\"btn-icon\">\n      <slot name=\"icon\"></slot>\n    </span>\n  {/if}\n  \n  <span class=\"btn-content\">\n    <slot></slot>\n  </span>\n  \n  {#if $$slots.badge}\n    <span class=\"btn-badge\">\n      <slot name=\"badge\"></slot>\n    </span>\n  {/if}\n</button>\n\n<style>\n  .btn {\n    display: inline-flex;\n    align-items: center;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  \n  .btn-icon {\n    margin-right: 8px;\n  }\n  \n  .btn-badge {\n    margin-left: 8px;\n  }\n  \n  .btn-primary { background-color: #3498db; color: white; }\n  .btn-secondary { background-color: #95a5a6; color: white; }\n  .btn-danger { background-color: #e74c3c; color: white; }\n  \n  .btn-small { padding: 4px 8px; font-size: 12px; }\n  .btn-medium { padding: 8px 16px; font-size: 14px; }\n  .btn-large { padding: 12px 24px; font-size: 16px; }\n  \n  .btn.disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n</style>\n```\n\nUsage:\n\n```svelte\n<script>\n  import EnhancedButton from './EnhancedButton.svelte';\n  \n  function handleClick() {\n    alert('Button clicked!');\n  }\n</script>\n\n<!-- Basic usage -->\n<EnhancedButton>Click Me</EnhancedButton>\n\n<!-- With slots and props -->\n<EnhancedButton \n  variant=\"danger\" \n  size=\"large\" \n  on:click={handleClick}\n  aria-label=\"Delete item\"\n  data-testid=\"delete-btn\"\n>\n  <svg slot=\"icon\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n    <path d=\"M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z\"/>\n    <path fill-rule=\"evenodd\" d=\"M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z\"/>\n  </svg>\n  \n  Delete Item\n  \n  <span slot=\"badge\" class=\"count-badge\">3</span>\n</EnhancedButton>\n```\n\nIn this example:\n- `$$slots` is used to check for optional icon and badge slots\n- `$$props` is used for debugging (logging all props)\n- `$$restProps` is used to forward additional HTML attributes like `aria-label` and `data-testid`\n\nBy understanding the differences and appropriate use cases for each special variable, you can create more flexible and reusable components in Svelte."}
{"source":"docs/svelte/99-legacy/21-legacy-$$slots.md","question":"How can you combine `$$slots` with other Svelte features like context API to create more advanced component composition patterns?","answer":"Combining `$$slots` with Svelte's context API and other features can create powerful component composition patterns. This approach allows for more sophisticated component communication, state sharing, and dynamic slot management. Here's a comprehensive exploration of these advanced patterns:\n\n### 1. Using Context API with Slots for Component Communication\n\nThe context API allows components to share data without explicitly passing props through each level of the component tree. When combined with `$$slots`, it enables slot content to communicate with its parent component.\n\n```svelte\n<!-- TabContainer.svelte -->\n<script>\n  import { setContext } from 'svelte';\n  import { writable } from 'svelte/store';\n  \n  // Create a store for the active tab\n  const activeTabId = writable(null);\n  \n  // Expose methods to register tabs and activate tabs\n  const tabs = writable([]);\n  \n  function registerTab(id, label) {\n    tabs.update(allTabs => {\n      const newTabs = [...allTabs, { id, label }];\n      \n      // If this is the first tab, make it active\n      if (newTabs.length === 1) {\n        activeTabId.set(id);\n      }\n      \n      return newTabs;\n    });\n    \n    return {\n      // Return a function to unregister the tab\n      unregister: () => {\n        tabs.update(allTabs => allTabs.filter(tab => tab.id !== id));\n        activeTabId.update(currentId => {\n          if (currentId === id) {\n            // Find another tab to activate\n            const remainingTabs = get(tabs);\n            return remainingTabs.length > 0 ? remainingTabs[0].id : null;\n          }\n          return currentId;\n        });\n      }\n    };\n  }\n  \n  function activateTab(id) {\n    activeTabId.set(id);\n  }\n  \n  // Set the context for child components to use\n  setContext('tabs', {\n    registerTab,\n    activateTab,\n    activeTabId,\n    tabs\n  });\n</script>\n\n<div class=\"tab-container\">\n  {#if $$slots.tabList}\n    <div class=\"tab-list\">\n      <slot name=\"tabList\"></slot>\n    </div>\n  {:else}\n    <!-- Auto-generated tab list if not explicitly provided -->\n    <div class=\"tab-list\">\n      {#each $tabs as tab}\n        <button \n          class=\"tab-button {$activeTabId === tab.id ? 'active' : ''}\"\n          on:click={() => activateTab(tab.id)}\n        >\n          {tab.label}\n        </button>\n      {/each}\n    </div>\n  {/if}\n  \n  <div class=\"tab-content\">\n    <slot></slot>\n  </div>\n</div>\n\n<style>\n  .tab-container {\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    overflow: hidden;\n  }\n  \n  .tab-list {\n    display: flex;\n    background: #f5f5f5;\n    border-bottom: 1px solid #ddd;\n  }\n  \n  .tab-button {\n    padding: 10px 15px;\n    border: none;\n    background: none;\n    cursor: pointer;\n  }\n  \n  .tab-button.active {\n    background: white;\n    border-bottom: 2px solid #3498db;\n    font-weight: bold;\n  }\n  \n  .tab-content {\n    padding: 15px;\n  }\n</style>\n```\n\n```svelte\n<!-- Tab.svelte -->\n<script>\n  import { getContext, onMount, onDestroy } from 'svelte';\n  \n  export let id;\n  export let label;\n  \n  const { registerTab, activeTabId } = getContext('tabs');\n  \n  // Register this tab with the container\n  let unregister;\n  onMount(() => {\n    const registration = registerTab(id, label);\n    unregister = registration.unregister;\n  });\n  \n  onDestroy(() => {\n    if (unregister) unregister();\n  });\n  \n  // Only show this tab's content when it's active\n  $: isActive = $activeTabId === id;\n</script>\n\n{#if isActive}\n  <div class=\"tab-panel\">\n    <slot></slot>\n  </div>\n{/if}\n```\n\nUsage:\n\n```svelte\n<script>\n  import TabContainer from './TabContainer.svelte';\n  import Tab from './Tab.svelte';\n</script>\n\n<TabContainer>\n  <!-- Optional custom tab list -->\n  <div slot=\"tabList\">\n    <button class=\"custom-tab\">Profile</button>\n    <button class=\"custom-tab\">Settings</button>\n    <button class=\"custom-tab\">Notifications</button>\n  </div>\n  \n  <Tab id=\"profile\" label=\"Profile\">\n    <h2>User Profile</h2>\n    <p>Edit your personal information here.</p>\n  </Tab>\n  \n  <Tab id=\"settings\" label=\"Settings\">\n    <h2>Account Settings</h2>\n    <p>Manage your account preferences.</p>\n  </Tab>\n  \n  <Tab id=\"notifications\" label=\"Notifications\">\n    <h2>Notification Settings</h2>\n    <p>Configure how you receive notifications.</p>\n  </Tab>\n</TabContainer>\n```\n\n### 2. Dynamic Slot Management with Stores\n\nYou can use Svelte stores to create reactive slot management that can update as the application state changes:\n\n```svelte\n<!-- DynamicLayout.svelte -->\n<script>\n  import { setContext } from 'svelte';\n  import { writable } from 'svelte/store';\n  \n  // Define available regions in the layout\n  const regions = ['header', 'sidebar', 'main', 'footer'];\n  \n  // Create a store to track which regions have content\n  const activeRegions = writable({});\n  \n  // Function to register content for a region\n  function registerRegionContent(region, hasContent = true) {\n    if (!regions.includes(region)) {\n      console.warn(`Region \"${region}\" is not defined in this layout`);\n      return;\n    }\n    \n    activeRegions.update(regions => ({\n      ...regions,\n      [region]: hasContent\n    }));\n    \n    return () => {\n      activeRegions.update(regions => ({\n        ...regions,\n        [region]: false\n      }));\n    };\n  }\n  \n  setContext('layout', {\n    registerRegionContent,\n    activeRegions\n  });\n  \n  // Reactive layout class based on active regions\n  $: layoutClass = Object.entries($activeRegions)\n    .filter(([_, active]) => active)\n    .map(([region, _]) => `has-${region}`)\n    .join(' ');\n</script>\n\n<div class=\"layout {layoutClass}\">\n  {#if $$slots.header || $activeRegions.header}\n    <header class=\"layout-header\">\n      <slot name=\"header\"></slot>\n    </header>\n  {/if}\n  \n  <div class=\"layout-body\">\n    {#if $$slots.sidebar || $activeRegions.sidebar}\n      <aside class=\"layout-sidebar\">\n        <slot name=\"sidebar\"></slot>\n      </aside>\n    {/if}\n    \n    <main class=\"layout-main\">\n      <slot></slot>\n    </main>\n  </div>\n  \n  {#if $$slots.footer || $activeRegions.footer}\n    <footer class=\"layout-footer\">\n      <slot name=\"footer\"></slot>\n    </footer>\n  {/if}\n</div>\n\n<style>\n  .layout {\n    display: flex;\n    flex-direction: column;\n    min-height: 100vh;\n  }\n  \n  .layout-body {\n    display: flex;\n    flex: 1;\n  }\n  \n  .layout-header, .layout-footer {\n    padding: 1rem;\n    background: #f5f5f5;\n  }\n  \n  .layout-sidebar {\n    width: 250px;\n    background: #e9e9e9;\n    padding: 1rem;\n  }\n  \n  .layout-main {\n    flex: 1;\n    padding: 1rem;\n  }\n  \n  /* Responsive adjustments */\n  @media (max-width: 768px) {\n    .layout-body {\n      flex-direction: column;\n    }\n    \n    .layout-sidebar {\n      width: 100%;\n    }\n  }\n</style>\n```\n\n```svelte\n<!-- RegionContent.svelte -->\n<script>\n  import { getContext, onMount, onDestroy } from 'svelte';\n  \n  export let region;\n  \n  const { registerRegionContent } = getContext('layout');\n  \n  let unregister;\n  onMount(() => {\n    unregister = registerRegionContent(region, true);\n  });\n  \n  onDestroy(() => {\n    if (unregister) unregister();\n  });\n</script>\n\n<slot></slot>\n```\n\nUsage:\n\n```svelte\n<script>\n  import DynamicLayout from './DynamicLayout.svelte';\n  import RegionContent from './RegionContent.svelte';\n  \n  let showSidebar = true;\n  let showFooter = false;\n</script>\n\n<DynamicLayout>\n  <div slot=\"header\">\n    <h1>My Application</h1>\n    <nav>\n      <a href=\"/\">Home</a>\n      <a href=\"/about\">About</a>\n    </nav>\n  </div>\n  \n  {#if showSidebar}\n    <RegionContent region=\"sidebar\">\n      <h3>Navigation</h3>\n      <ul>\n        <li><a href=\"/dashboard\">Dashboard</a></li>\n        <li><a href=\"/profile\">Profile</a></li>\n        <li><a href=\"/settings\">Settings</a></li>\n      </ul>\n    </RegionContent>\n  {/if}\n  \n  <div>\n    <h2>Main Content</h2>\n    <p>This is the main content area of the page.</p>\n    \n    <button on:click={() => showSidebar = !showSidebar}>\n      {showSidebar ? 'Hide' : 'Show'} Sidebar\n    </button>\n    \n    <button on:click={() => showFooter = !showFooter}>\n      {showFooter ? 'Hide' : 'Show'} Footer\n    </button>\n  </div>\n  \n  {#if showFooter}\n    <RegionContent region=\"footer\">\n      <p>Â© 2023 My Application</p>\n    </RegionContent>\n  {/if}\n</DynamicLayout>\n```\n\n### 3. Creating a Slot Registry for Complex Components\n\nFor complex components with many potential slots, you can create a registry system:\n\n```svelte\n<!-- SlotRegistry.svelte -->\n<script>\n  import { setContext } from 'svelte';\n  import { writable, derived } from 'svelte/store';\n  \n  // Create a store to track registered slots\n  const registeredSlots = writable({});\n  \n  // Function to register a slot\n  function registerSlot(name, props = {}) {\n    registeredSlots.update(slots => ({\n      ...slots,\n      [name]: { active: true, props }\n    }));\n    \n    return () => {\n      registeredSlots.update(slots => {\n        const newSlots = { ...slots };\n        delete newSlots[name];\n        return newSlots;\n      });\n    };\n  }\n  \n  // Create a derived store that returns just the active slot names\n  const activeSlots = derived(registeredSlots, $slots => \n    Object.entries($slots)\n      .filter(([_, data]) => data.active)\n      .reduce((acc, [name, data]) => {\n        acc[name] = data.props;\n        return acc;\n      }, {})\n  );\n  \n  // Set the context for child components\n  setContext('slots', {\n    registerSlot,\n    registeredSlots,\n    activeSlots\n  });\n</script>\n\n<slot></slot>\n```\n\n```svelte\n<!-- SlotProvider.svelte -->\n<script>\n  import { getContext, onMount, onDestroy } from 'svelte';\n  \n  export let name;\n  export let props = {};\n  \n  const { registerSlot } = getContext('slots');\n  \n  let unregister;\n  onMount(() => {\n    unregister = registerSlot(name, props);\n  });\n  \n  onDestroy(() => {\n    if (unregister) unregister();\n  });\n</script>\n\n<slot></slot>\n```\n\n```svelte\n<!-- ComplexDashboard.svelte -->\n<script>\n  import SlotRegistry from './SlotRegistry.svelte';\n  import { getContext } from 'svelte';\n  \n  // Get active slots from context\n  const { activeSlots } = getContext('slots');\n</script>\n\n<SlotRegistry>\n  <div class=\"dashboard {Object.keys($activeSlots).join(' ')}\">\n    {#if $$slots.topbar || $activeSlots.topbar}\n      <div class=\"dashboard-topbar\">\n        <slot name=\"topbar\"></slot>\n      </div>\n    {/if}\n    \n    <div class=\"dashboard-body\">\n      {#if $$slots.sidebar || $activeSlots.sidebar}\n        <div class=\"dashboard-sidebar\" style=\"width: {$activeSlots.sidebar?.width || '250px'}\">\n          <slot name=\"sidebar\"></slot>\n        </div>\n      {/if}\n      \n      <div class=\"dashboard-content\">\n        {#if $$slots.header || $activeSlots.header}\n          <div class=\"dashboard-header\">\n            <slot name=\"header\"></slot>\n          </div>\n        {/if}\n        \n        <div class=\"dashboard-main\">\n          <slot></slot>\n        </div>\n        \n        {#if $$slots.footer || $activeSlots.footer}\n          <div class=\"dashboard-footer\">\n            <slot name=\"footer\"></slot>\n          </div>\n        {/if}\n      </div>\n      \n      {#if $$slots.rightPanel || $activeSlots.rightPanel}\n        <div class=\"dashboard-right-panel\" style=\"width: {$activeSlots.rightPanel?.width || '300px'}\">\n          <slot name=\"rightPanel\"></slot>\n        </div>\n      {/if}\n    </div>\n  </div>\n</SlotRegistry>\n```\n\nUsage:\n\n```svelte\n<script>\n  import ComplexDashboard from './ComplexDashboard.svelte';\n  import SlotProvider from './SlotProvider.svelte';\n  \n  let showRightPanel = false;\n</script>\n\n<ComplexDashboard>\n  <div slot=\"topbar\">\n    <h1>Admin Dashboard</h1>\n    <div class=\"user-menu\">Welcome, Admin</div>\n  </div>\n  \n  <SlotProvider name=\"sidebar\" props={{ width: '280px' }}>\n    <nav>\n      <ul>\n        <li><a href=\"/dashboard\">Dashboard</a></li>\n        <li><a href=\"/users\">Users</a></li>\n        <li><a href=\"/settings\">Settings</a></li>\n      </ul>\n    </nav>\n  </SlotProvider>\n  \n  <div slot=\"header\">\n    <h2>Dashboard Overview</h2>\n    <button on:click={() => showRightPanel = !showRightPanel}>\n      {showRightPanel ? 'Hide' : 'Show'} Details Panel\n    </button>\n  </div>\n  \n  <div>\n    <p>Main dashboard content goes here...</p>\n  </div>\n  \n  {#if showRightPanel}\n    <SlotProvider name=\"rightPanel\" props={{ width: '350px' }}>\n      <h3>Details Panel</h3>\n      <p>Additional information and context about the current view.</p>\n    </SlotProvider>\n  {/if}\n</ComplexDashboard>\n```\n\n### 4. Slot-Driven State Management\n\nYou can use slots to drive application state by combining `$$slots` with stores and actions:\n\n```svelte\n<!-- Wizard.svelte -->\n<script>\n  import { setContext } from 'svelte';\n  import { writable, derived } from 'svelte/store';\n  \n  // Create stores for wizard state\n  const steps = writable([]);\n  const currentStepIndex = writable(0);\n  \n  // Derived store for the current step\n  const currentStep = derived(\n    [steps, currentStepIndex],\n    ([$steps, $currentStepIndex]) => $steps[$currentStepIndex] || null\n  );\n  \n  // Derived store for navigation state\n  const navigation = derived(\n    [steps, currentStepIndex],\n    ([$steps, $currentStepIndex]) => ({\n      canGoBack: $currentStepIndex > 0,\n      canGoNext: $currentStepIndex < $steps.length - 1,\n      currentIndex: $currentStepIndex,\n      totalSteps: $steps.length\n    })\n  );\n  \n  // Navigation functions\n  function goToStep(index) {\n    currentStepIndex.set(Math.max(0, Math.min(index, $steps.length - 1)));\n  }"}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"What is the purpose of the `<svelte:fragment>` element in Svelte, and why would you use it instead of a regular DOM element?","answer":"The `<svelte:fragment>` element in Svelte serves a specific purpose for working with named slots without affecting the DOM structure. Its primary purpose is to allow developers to place content in a named slot without introducing an additional wrapper DOM element.\n\nWhen you assign content to a named slot using a regular DOM element with the `slot` attribute, that element becomes the container for your slotted content. However, sometimes you don't want this extra wrapper element as it can interfere with styling, layout, or semantics.\n\n`<svelte:fragment>` solves this problem by acting as a virtual container that doesn't render in the final DOM. This keeps the flow layout of your document intact while still allowing you to organize content into named slots.\n\nFor example, instead of:\n```svelte\n<div slot=\"footer\">\n  <p>All rights reserved.</p>\n  <p>Copyright (c) 2019 Svelte Industries</p>\n</div>\n```\n\nYou can use:\n```svelte\n<svelte:fragment slot=\"footer\">\n  <p>All rights reserved.</p>\n  <p>Copyright (c) 2019 Svelte Industries</p>\n</svelte:fragment>\n```\n\nThe difference is that the first example adds a `<div>` wrapper in the DOM, while the second example places the paragraph elements directly in the slot without any wrapper.\n\nIt's worth noting that in Svelte 5+, this concept has become obsolete because snippets don't create a wrapping element by default."}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"How does `<svelte:fragment>` affect the DOM structure compared to using a regular element with a slot attribute?","answer":"When using `<svelte:fragment>`, the key difference in the DOM structure is the absence of an additional wrapper element around your slotted content. Let's examine this with a concrete example:\n\nConsider a component `Widget.svelte` that accepts header and footer slots:\n\n```svelte\n<!-- Widget.svelte -->\n<div class=\"widget\">\n  <slot name=\"header\">No header was provided</slot>\n  <div class=\"content\">\n    <p>Main widget content</p>\n  </div>\n  <slot name=\"footer\" />\n</div>\n```\n\nNow, let's compare two ways of using this component:\n\n**Approach 1: Using regular DOM elements with slot attributes**\n```svelte\n<Widget>\n  <div slot=\"header\">\n    <h1>Widget Title</h1>\n    <p>Subtitle text</p>\n  </div>\n  \n  <div slot=\"footer\">\n    <p>All rights reserved.</p>\n    <p>Copyright (c) 2019 Svelte Industries</p>\n  </div>\n</Widget>\n```\n\n**Approach 2: Using `<svelte:fragment>` for the footer**\n```svelte\n<Widget>\n  <div slot=\"header\">\n    <h1>Widget Title</h1>\n    <p>Subtitle text</p>\n  </div>\n  \n  <svelte:fragment slot=\"footer\">\n    <p>All rights reserved.</p>\n    <p>Copyright (c) 2019 Svelte Industries</p>\n  </svelte:fragment>\n</Widget>\n```\n\nThe resulting DOM for Approach 1 would look like:\n```html\n<div class=\"widget\">\n  <div> <!-- Extra wrapper from slot=\"header\" -->\n    <h1>Widget Title</h1>\n    <p>Subtitle text</p>\n  </div>\n  <div class=\"content\">\n    <p>Main widget content</p>\n  </div>\n  <div> <!-- Extra wrapper from slot=\"footer\" -->\n    <p>All rights reserved.</p>\n    <p>Copyright (c) 2019 Svelte Industries</p>\n  </div>\n</div>\n```\n\nWhile the DOM for Approach 2 would be:\n```html\n<div class=\"widget\">\n  <div> <!-- Extra wrapper from slot=\"header\" -->\n    <h1>Widget Title</h1>\n    <p>Subtitle text</p>\n  </div>\n  <div class=\"content\">\n    <p>Main widget content</p>\n  </div>\n  <!-- No extra wrapper here for the footer content -->\n  <p>All rights reserved.</p>\n  <p>Copyright (c) 2019 Svelte Industries</p>\n</div>\n```\n\nThe key difference is that `<svelte:fragment>` doesn't add an extra wrapper element in the DOM, which can be important for:\n- Maintaining CSS grid or flexbox layouts\n- Preserving list semantics (e.g., when working with `<ul>` and `<li>` elements)\n- Keeping the DOM cleaner and more semantic\n- Avoiding unwanted styling effects from extra containers"}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"In what scenarios would using `<svelte:fragment>` be particularly beneficial for maintaining layout integrity?","answer":"`<svelte:fragment>` is particularly beneficial in several specific scenarios where maintaining layout integrity is crucial:\n\n1. **CSS Grid and Flexbox Layouts**: When working with grid or flexbox layouts, extra wrapper elements can disrupt the intended layout. For example:\n\n```svelte\n<!-- GridComponent.svelte -->\n<div class=\"grid-container\">\n  <slot name=\"grid-items\" />\n</div>\n\n<style>\n  .grid-container {\n    display: grid;\n    grid-template-columns: repeat(3, 1fr);\n    gap: 1rem;\n  }\n</style>\n```\n\nUsing `<svelte:fragment>` to provide multiple grid items:\n```svelte\n<GridComponent>\n  <svelte:fragment slot=\"grid-items\">\n    <div class=\"item\">Item 1</div>\n    <div class=\"item\">Item 2</div>\n    <div class=\"item\">Item 3</div>\n    <div class=\"item\">Item 4</div>\n    <div class=\"item\">Item 5</div>\n  </svelte:fragment>\n</GridComponent>\n```\n\nWithout `<svelte:fragment>`, an extra wrapper would break the grid layout by creating a single grid cell containing all items.\n\n2. **List Structures**: When working with semantic list elements:\n\n```svelte\n<!-- List.svelte -->\n<ul>\n  <li>Fixed item 1</li>\n  <slot name=\"additional-items\" />\n  <li>Fixed item last</li>\n</ul>\n```\n\n```svelte\n<List>\n  <svelte:fragment slot=\"additional-items\">\n    <li>Dynamic item 1</li>\n    <li>Dynamic item 2</li>\n  </svelte:fragment>\n</List>\n```\n\nThis maintains proper list semantics without nesting lists incorrectly.\n\n3. **Table Structures**: Similar to lists, table structures require specific parent-child relationships:\n\n```svelte\n<!-- Table.svelte -->\n<table>\n  <thead>\n    <tr>\n      <th>Name</th>\n      <th>Age</th>\n    </tr>\n  </thead>\n  <tbody>\n    <slot name=\"rows\" />\n  </tbody>\n</table>\n```\n\n```svelte\n<Table>\n  <svelte:fragment slot=\"rows\">\n    <tr>\n      <td>Alice</td>\n      <td>24</td>\n    </tr>\n    <tr>\n      <td>Bob</td>\n      <td>32</td>\n    </tr>\n  </svelte:fragment>\n</Table>\n```\n\n4. **Adjacent Text Nodes**: When you need to slot in multiple text nodes or mixed content:\n\n```svelte\n<!-- TextWrapper.svelte -->\n<div class=\"text-container\">\n  <slot name=\"content\" />\n</div>\n```\n\n```svelte\n<TextWrapper>\n  <svelte:fragment slot=\"content\">\n    This is some text.\n    <strong>This is bold text.</strong>\n    And this is more regular text.\n  </svelte:fragment>\n</TextWrapper>\n```\n\n5. **Transition and Animation Contexts**: When using Svelte's transition or animation features, extra wrapper elements can sometimes interfere with the intended effect.\n\nIn all these cases, `<svelte:fragment>` helps maintain the intended DOM structure while still allowing you to organize your code using Svelte's slot system. The absence of an extra wrapper element ensures that CSS layout properties, semantic HTML structures, and browser rendering behave as expected."}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"How does the behavior of `<svelte:fragment>` differ between Svelte 4 and Svelte 5?","answer":"The behavior of `<svelte:fragment>` has undergone a significant change between Svelte 4 and Svelte 5, effectively making it obsolete in Svelte 5. Here's a detailed explanation of the differences:\n\n**In Svelte 4 (and earlier versions):**\n- `<svelte:fragment>` is a special element that allows developers to group content for a named slot without adding a wrapper DOM element.\n- It's necessary because regular elements with a `slot` attribute always create a wrapper element in the final DOM.\n- It's commonly used to maintain layout integrity, particularly in grid, flex, list, and table contexts.\n\nExample in Svelte 4:\n```svelte\n<!-- ComponentWithSlots.svelte -->\n<div>\n  <slot name=\"header\">Default header</slot>\n  <div class=\"content\">Main content</div>\n  <slot name=\"footer\" />\n</div>\n```\n\n```svelte\n<!-- Usage in Svelte 4 -->\n<ComponentWithSlots>\n  <h1 slot=\"header\">Custom Header</h1>\n  \n  <!-- Using svelte:fragment to avoid extra wrapper -->\n  <svelte:fragment slot=\"footer\">\n    <p>Footer paragraph 1</p>\n    <p>Footer paragraph 2</p>\n  </svelte:fragment>\n</ComponentWithSlots>\n```\n\n**In Svelte 5:**\nAccording to the documentation note, \"In Svelte 5+, this concept is obsolete, as snippets don't create a wrapping element.\"\n\nThis suggests a fundamental change in how slot content is handled in Svelte 5. The new \"snippets\" feature in Svelte 5 appears to have the non-wrapping behavior built-in by default, eliminating the need for a special element like `<svelte:fragment>`.\n\nIn Svelte 5, you might be able to do something like:\n```svelte\n<!-- Usage in Svelte 5 (hypothetical based on documentation note) -->\n<ComponentWithSlots>\n  <h1 slot=\"header\">Custom Header</h1>\n  \n  <!-- No need for svelte:fragment anymore -->\n  <slot=\"footer\">\n    <p>Footer paragraph 1</p>\n    <p>Footer paragraph 2</p>\n  </slot>\n</ComponentWithSlots>\n```\n\nOr potentially even simpler syntax might be available in Svelte 5.\n\nThe key takeaway is that Svelte 5 has improved the default behavior of slots to avoid unnecessary wrapper elements, making the special `<svelte:fragment>` element redundant. This change simplifies the developer experience by removing the need to know about and use this special element while still maintaining the desired DOM structure.\n\nThis is part of Svelte's evolution toward a more intuitive and streamlined development experience, reducing special cases and making the framework more consistent."}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"Can you explain how to use `<svelte:fragment>` with conditional rendering and show a practical example?","answer":"`<svelte:fragment>` can be combined with Svelte's conditional rendering to dynamically include or exclude groups of elements in a named slot without adding wrapper elements. Here's a detailed explanation with practical examples:\n\n### Basic Conditional Rendering with `<svelte:fragment>`\n\nYou can use Svelte's `{#if}` blocks inside a `<svelte:fragment>` to conditionally render content in a slot:\n\n```svelte\n<!-- TabContainer.svelte -->\n<div class=\"tabs\">\n  <div class=\"tab-headers\">\n    <slot name=\"tab-headers\">No tabs defined</slot>\n  </div>\n  <div class=\"tab-content\">\n    <slot name=\"tab-content\" />\n  </div>\n</div>\n```\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import TabContainer from './TabContainer.svelte';\n  \n  let activeTab = 'profile';\n  let showAdminTab = false;\n  \n  function switchTab(tab) {\n    activeTab = tab;\n  }\n</script>\n\n<TabContainer>\n  <!-- Tab headers -->\n  <svelte:fragment slot=\"tab-headers\">\n    <button \n      class:active={activeTab === 'profile'} \n      on:click={() => switchTab('profile')}\n    >\n      Profile\n    </button>\n    <button \n      class:active={activeTab === 'settings'} \n      on:click={() => switchTab('settings')}\n    >\n      Settings\n    </button>\n    \n    {#if showAdminTab}\n      <button \n        class:active={activeTab === 'admin'} \n        on:click={() => switchTab('admin')}\n      >\n        Admin\n      </button>\n    {/if}\n  </svelte:fragment>\n  \n  <!-- Tab content -->\n  <svelte:fragment slot=\"tab-content\">\n    {#if activeTab === 'profile'}\n      <h2>User Profile</h2>\n      <p>Edit your profile information here.</p>\n      <form><!-- profile form fields --></form>\n    {:else if activeTab === 'settings'}\n      <h2>Settings</h2>\n      <p>Adjust your account settings.</p>\n      <div class=\"settings-grid\">\n        <!-- settings options -->\n      </div>\n    {:else if activeTab === 'admin' && showAdminTab}\n      <h2>Admin Panel</h2>\n      <p>Administrative controls.</p>\n      <div class=\"admin-controls\">\n        <!-- admin controls -->\n      </div>\n    {/if}\n  </svelte:fragment>\n</TabContainer>\n\n<label>\n  <input type=\"checkbox\" bind:checked={showAdminTab}>\n  Show admin tab\n</label>\n```\n\n### Advanced Example: Dynamic Form Fields\n\nHere's a more complex example showing how to use `<svelte:fragment>` with conditional rendering for a dynamic form component:\n\n```svelte\n<!-- DynamicForm.svelte -->\n<form on:submit|preventDefault={handleSubmit}>\n  <slot name=\"form-header\">\n    <h2>Default Form Title</h2>\n  </slot>\n  \n  <div class=\"form-fields\">\n    <slot name=\"form-fields\">\n      <p>No fields provided</p>\n    </slot>\n  </div>\n  \n  <div class=\"form-actions\">\n    <slot name=\"form-actions\">\n      <button type=\"submit\">Submit</button>\n    </slot>\n  </div>\n</form>\n\n<script>\n  function handleSubmit() {\n    // Form submission logic\n  }\n</script>\n```\n\n```svelte\n<!-- UserForm.svelte -->\n<script>\n  import DynamicForm from './DynamicForm.svelte';\n  \n  let formType = 'personal';\n  let isBusinessAccount = false;\n  let includePaymentInfo = false;\n  \n  function submitForm() {\n    // Handle form submission\n  }\n</script>\n\n<div class=\"form-type-selector\">\n  <label>\n    <input type=\"radio\" bind:group={formType} value=\"personal\">\n    Personal Information\n  </label>\n  <label>\n    <input type=\"radio\" bind:group={formType} value=\"contact\">\n    Contact Information\n  </label>\n</div>\n\n<label>\n  <input type=\"checkbox\" bind:checked={isBusinessAccount}>\n  Business Account\n</label>\n\n<label>\n  <input type=\"checkbox\" bind:checked={includePaymentInfo}>\n  Include Payment Information\n</label>\n\n<DynamicForm on:submit={submitForm}>\n  <h2 slot=\"form-header\">\n    {formType === 'personal' ? 'Personal Information' : 'Contact Details'}\n    {#if isBusinessAccount} (Business Account) {/if}\n  </h2>\n  \n  <svelte:fragment slot=\"form-fields\">\n    {#if formType === 'personal'}\n      <div class=\"field\">\n        <label for=\"name\">Full Name</label>\n        <input id=\"name\" type=\"text\" required>\n      </div>\n      \n      <div class=\"field\">\n        <label for=\"dob\">Date of Birth</label>\n        <input id=\"dob\" type=\"date\">\n      </div>\n      \n      {#if isBusinessAccount}\n        <div class=\"field\">\n          <label for=\"company\">Company Name</label>\n          <input id=\"company\" type=\"text\" required>\n        </div>\n        \n        <div class=\"field\">\n          <label for=\"tax-id\">Tax ID</label>\n          <input id=\"tax-id\" type=\"text\">\n        </div>\n      {/if}\n    {:else if formType === 'contact'}\n      <div class=\"field\">\n        <label for=\"email\">Email Address</label>\n        <input id=\"email\" type=\"email\" required>\n      </div>\n      \n      <div class=\"field\">\n        <label for=\"phone\">Phone Number</label>\n        <input id=\"phone\" type=\"tel\">\n      </div>\n      \n      <div class=\"field\">\n        <label for=\"address\">Address</label>\n        <textarea id=\"address\"></textarea>\n      </div>\n    {/if}\n    \n    {#if includePaymentInfo}\n      <hr>\n      <h3>Payment Information</h3>\n      \n      <div class=\"field\">\n        <label for=\"card\">Credit Card Number</label>\n        <input id=\"card\" type=\"text\" pattern=\"[0-9]{16}\">\n      </div>\n      \n      <div class=\"field-row\">\n        <div class=\"field\">\n          <label for=\"expiry\">Expiry Date</label>\n          <input id=\"expiry\" type=\"text\" placeholder=\"MM/YY\">\n        </div>\n        \n        <div class=\"field\">\n          <label for=\"cvv\">CVV</label>\n          <input id=\"cvv\" type=\"text\" pattern=\"[0-9]{3,4}\">\n        </div>\n      </div>\n    {/if}\n  </svelte:fragment>\n  \n  <svelte:fragment slot=\"form-actions\">\n    <button type=\"button\" class=\"secondary\">Cancel</button>\n    <button type=\"submit\" class=\"primary\">\n      {formType === 'personal' ? 'Save Personal Info' : 'Save Contact Info'}\n    </button>\n  </svelte:fragment>\n</DynamicForm>\n```\n\nThe key benefits of using `<svelte:fragment>` with conditional rendering in these examples are:\n\n1. **DOM Cleanliness**: No extra wrapper elements are introduced in the rendered output\n2. **Layout Preservation**: The form fields flow naturally without disruption from wrapper divs\n3. **Semantic HTML**: The relationship between form elements remains clear\n4. **Flexibility**: You can conditionally render different groups of elements based on application state\n5. **Code Organization**: The slot system keeps the component API clean while allowing for complex conditional content\n\nThis approach is particularly valuable in form UIs, data tables, and other structured content where maintaining the correct DOM hierarchy is important for both styling and accessibility."}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"How does `<svelte:fragment>` interact with Svelte's slot props feature? Can you provide an example showing both features used together?","answer":"`<svelte:fragment>` can be used together with Svelte's slot props feature to create flexible, reusable components that pass data to slotted content without adding extra wrapper elements. This combination is particularly powerful for creating components with rich customization options.\n\n### Understanding Slot Props\n\nSlot props allow a component to pass data back to the parent that's using the component. The parent can then access this data in the slotted content using the `let:` directive.\n\n### Combining `<svelte:fragment>` with Slot Props\n\nHere's a detailed example showing how to use `<svelte:fragment>` with slot props:\n\n**1. Creating a component with slot props:**\n\n```svelte\n<!-- DataTable.svelte -->\n<script>\n  export let items = [];\n  export let pageSize = 10;\n  \n  let currentPage = 0;\n  \n  $: totalPages = Math.ceil(items.length / pageSize);\n  $: paginatedItems = items.slice(\n    currentPage * pageSize, \n    (currentPage + 1) * pageSize\n  );\n  \n  function nextPage() {\n    if (currentPage < totalPages - 1) currentPage++;\n  }\n  \n  function prevPage() {\n    if (currentPage > 0) currentPage--;\n  }\n</script>\n\n<div class=\"data-table\">\n  <div class=\"table-header\">\n    <slot name=\"header\" {totalPages} {currentPage} {pageSize} />\n  </div>\n  \n  <table>\n    <thead>\n      <tr>\n        <slot name=\"column-headers\" />\n      </tr>\n    </thead>\n    <tbody>\n      {#each paginatedItems as item, i}\n        <tr>\n          <slot name=\"row\" {item} index={i + (currentPage * pageSize)} />\n        </tr>\n      {/each}\n    </tbody>\n  </table>\n  \n  <div class=\"table-footer\">\n    <slot \n      name=\"footer\" \n      {totalPages} \n      {currentPage} \n      {nextPage} \n      {prevPage}\n    />\n  </div>\n</div>\n```\n\n**2. Using the component with `<svelte:fragment>` and slot props:**\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import DataTable from './DataTable.svelte';\n  \n  const users = [\n    { id: 1, name: 'Alice', email: 'alice@example.com', role: 'Admin' },\n    { id: 2, name: 'Bob', email: 'bob@example.com', role: 'User' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com', role: 'Editor' },\n    // ... more users\n  ];\n  \n  let searchTerm = '';\n  \n  $: filteredUsers = users.filter(user => \n    user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    user.email.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n</script>\n\n<div class=\"search-container\">\n  <input \n    type=\"text\" \n    placeholder=\"Search users...\" \n    bind:value={searchTerm}\n  >\n</div>\n\n<DataTable items={filteredUsers} pageSize={5}>\n  <!-- Table header with slot props -->\n  <svelte:fragment \n    slot=\"header\" \n    let:totalPages \n    let:currentPage\n    let:pageSize\n  >\n    <h2>User Management</h2>\n    <p>\n      Showing page {currentPage + 1} of {totalPages} \n      ({pageSize} items per page)\n    </p>\n    {#if searchTerm}\n      <p class=\"search-results\">\n        Search results for: \"{searchTerm}\"\n      </p>\n    {/if}\n  </svelte:fragment>\n  \n  <!-- Column headers -->\n  <svelte:fragment slot=\"column-headers\">\n    <th>ID</th>\n    <th>Name</th>\n    <th>Email</th>\n    <th>Role</th>\n    <th>Actions</th>\n  </svelte:fragment>\n  \n  <!-- Table rows with slot props -->\n  <svelte:fragment slot=\"row\" let:item let:index>\n    <td>{item.id}</td>\n    <td>{item.name}</td>\n    <td>{item.email}</td>\n    <td>\n      <span class=\"role-badge role-{item.role.toLowerCase()}\">\n        {item.role}\n      </span>\n    </td>\n    <td>\n      <button on:click={() => editUser(item.id)}>Edit</button>\n      <button on:click={() => deleteUser(item.id)}>Delete</button>\n    </td>\n  </svelte:fragment>\n  \n  <!-- Footer with pagination controls using slot props -->\n  <svelte:fragment \n    slot=\"footer\" \n    let:totalPages \n    let:currentPage \n    let:nextPage \n    let:prevPage\n  >\n    <div class=\"pagination\">\n      <button \n        on:click={prevPage} \n        disabled={currentPage === 0}\n      >\n        Previous\n      </button>\n      \n      <span class=\"page-indicator\">\n        Page {currentPage + 1} of {totalPages}\n      </span>\n      \n      <button \n        on:click={nextPage} \n        disabled={currentPage === totalPages - 1}\n      >\n        Next\n      </button>\n    </div>\n    \n    <p class=\"total-count\">\n      Total users: {filteredUsers.length}\n    </p>\n  </svelte:fragment>\n</DataTable>\n```\n\n### Key Benefits of Combining These Features\n\n1. **Clean DOM Structure**: `<svelte:fragment>` ensures no extra wrapper elements are added, which is particularly important for table rows and columns.\n\n2. **Data Access**: Slot props provide access to component data and functions in the parent, enabling rich interactivity.\n\n3. **Flexible Layouts**: Without wrapper elements, you can maintain proper HTML semantics and CSS layouts.\n\n4. **Reusable Components**: This pattern allows for highly reusable components that can be customized extensively without modification.\n\n5. **Separation of Concerns**: The component handles data management and pagination logic, while the parent controls presentation.\n\n### Advanced Example: List Component with Drag and Drop\n\nHere's another example showing a more advanced use case with drag and drop functionality:\n\n```svelte\n<!-- SortableList.svelte -->\n<script>\n  export let items = [];\n  \n  let draggedItem = null;\n  let draggedOverIndex = null;\n  \n  function handleDragStart(item) {\n    draggedItem = item;\n  }\n  \n  function handleDragOver(index) {\n    draggedOverIndex = index;\n  }\n  \n  function handleDragEnd() {\n    if (draggedItem && draggedOverIndex !== null) {\n      // Reorder the list\n      const newItems = [...items];\n      const draggedIndex = items.indexOf(draggedItem);\n      newItems.splice(draggedIndex, 1);\n      newItems.splice(draggedOverIndex, 0, draggedItem);\n      items = newItems;\n    }\n    \n    // Reset drag state\n    draggedItem = null;\n    draggedOverIndex = null;\n  }\n</script>\n\n<ul class=\"sortable-list\">\n  {#each items as item, i}\n    <li \n      draggable={true}\n      on:dragstart={() => handleDragStart(item)}\n      on:dragover|preventDefault={() => handleDragOver(i)}\n      on:dragend={handleDragEnd}\n      class:dragged={item === draggedItem}\n      class:drag-over={i === draggedOverIndex}\n    >\n      <slot \n        name=\"item\" \n        {item} \n        index={i} \n        isDragging={item === draggedItem}\n        isDragTarget={i === draggedOverIndex}\n      />\n    </li>\n  {/each}\n</ul>\n\n<div class=\"list-actions\">\n  <slot name=\"actions\" {items} />\n</div>\n```\n\n```svelte\n<!-- TaskList.svelte -->\n<script>\n  import SortableList from './SortableList.svelte';\n  \n  let tasks = [\n    { id: 1, title: 'Complete project proposal', done: false, priority: 'high' },\n    { id: 2, title: 'Review pull requests', done: true, priority: 'medium' },\n    { id: 3, title: 'Fix navigation bug', done: false, priority: 'high' },\n    // More tasks...\n  ];\n  \n  function toggleTask(id) {\n    tasks = tasks.map(task => \n      task.id === id ? { ...task, done: !task.done } : task\n    );\n  }\n  \n  function addTask() {\n    const newId = Math.max(0, ...tasks.map(t => t.id)) + 1;\n    tasks = [...tasks, { id: newId, title: 'New task', done: false, priority: 'medium' }];\n  }\n  \n  function deleteTask(id) {\n    tasks = tasks.filter(task => task.id !== id);\n  }\n</script>\n\n<h1>Task List</h1>\n<p>Drag tasks to reorder them by priority</p>\n\n<SortableList items={tasks}>\n  <!-- Custom task item display with slot props -->\n  <svelte:fragment \n    slot=\"item\" \n    let:item \n    let:isDragging \n    let:isDragTarget\n  >\n    <div class=\"task-item\" class:dragging={isDragging} class:target={isDragTarget}>\n      <input \n        type=\"checkbox\" \n        checked={item.done} \n        on:change={() => toggleTask(item.id)}\n      />\n      \n      <span class=\"task-title\" class:completed={item.done}>\n        {item.title}\n      </span>\n      \n      <span class=\"priority-badge priority-{item.priority}\">\n        {item.priority}\n      </span>\n      \n      <button on:click={() => deleteTask(item.id)}>Delete</button>\n    </div>\n  </svelte:fragment>\n  \n  <!-- List actions with slot props -->\n  <svelte:fragment slot=\"actions\" let:items>\n    <button on:click={addTask}>Add Task</button>\n    <span class=\"task-count\">\n      {items.filter(t => !t.done).length} remaining / \n      {items.length} total\n    </span>\n  </svelte:fragment>\n</SortableList>\n```\n\nThis combination of `<svelte:fragment>` with slot props creates a powerful pattern for building complex, reusable components while maintaining clean DOM structure and providing rich customization options."}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"How would you refactor a component that uses `<svelte:fragment>` in Svelte 4 to work with Svelte 5's new approach?","answer":"Refactoring a component that uses `<svelte:fragment>` in Svelte 4 to work with Svelte 5's new approach requires understanding the changes in how Svelte 5 handles slot content. According to the documentation, in Svelte 5+, the concept of `<svelte:fragment>` is obsolete because \"snippets don't create a wrapping element\" by default.\n\nLet's walk through a complete refactoring example:\n\n### Original Svelte 4 Component and Usage\n\nFirst, let's look at a typical component using `<svelte:fragment>` in Svelte 4:\n\n**CardComponent.svelte (Svelte 4)**\n```svelte\n<div class=\"card\">\n  <div class=\"card-header\">\n    <slot name=\"header\">\n      <h2>Default Card Title</h2>\n    </slot>\n  </div>\n  \n  <div class=\"card-body\">\n    <slot />\n  </div>\n  \n  <div class=\"card-footer\">\n    <slot name=\"footer\" />\n  </div>\n</div>\n```\n\n**App.svelte (Svelte 4 Usage)**\n```svelte\n<script>\n  import CardComponent from './CardComponent.svelte';\n  \n  let showExtraActions = false;\n</script>\n\n<CardComponent>\n  <h2 slot=\"header\">User Profile</h2>\n  \n  <p>This is the main content of the card.</p>\n  <img src=\"profile.jpg\" alt=\"User profile picture\" />\n  \n  <svelte:fragment slot=\"footer\">\n    <button>Save</button>\n    <button>Cancel</button>\n    \n    {#if showExtraActions}\n      <button>Delete</button>\n      <button>Archive</button>\n    {/if}\n  </svelte:fragment>\n</CardComponent>\n\n<label>\n  <input type=\"checkbox\" bind:checked={showExtraActions} />\n  Show extra actions\n</label>\n```\n\n### Refactored for Svelte 5\n\nBased on the documentation note that \"snippets don't create a wrapping element\" in Svelte 5, we can refactor this code to use Svelte 5's new approach:\n\n**CardComponent.svelte (Svelte 5)**\n```svelte\n<!-- The component itself doesn't need to change -->\n<div class=\"card\">\n  <div class=\"card-header\">\n    <slot name=\"header\">\n      <h2>Default Card Title</h2>\n    </slot>\n  </div>\n  \n  <div class=\"card-body\">\n    <slot />\n  </div>\n  \n  <div class=\"card-footer\">\n    <slot name=\"footer\" />\n  </div>\n</div>\n```\n\n**App.svelte (Svelte 5 Usage)**\n```svelte\n<script>\n  import CardComponent from './CardComponent.svelte';\n  \n  let showExtraActions = false;\n</script>\n\n<CardComponent>\n  <h2 slot=\"header\">User Profile</h2>\n  \n  <p>This is the main content of the card.</p>\n  <img src=\"profile.jpg\" alt=\"User profile picture\" />\n  \n  <!-- In Svelte 5, we can directly use multiple elements with the same slot attribute -->\n  <button slot=\"footer\">Save</button>\n  <button slot=\"footer\">Cancel</button>\n  \n  {#if showExtraActions}\n    <button slot=\"footer\">Delete</button>\n    <button slot=\"footer\">Archive</button>\n  {/if}\n</CardComponent>\n\n<label>\n  <input type=\"checkbox\" bind:checked={showExtraActions} />\n  Show extra actions\n</label>\n```\n\n### More Complex Example with Slot Props\n\nLet's look at a more complex example that uses both `<svelte:fragment>` and slot props:\n\n**DataList.svelte (Svelte 4)**\n```svelte\n<script>\n  export let items = [];\n  export let loading = false;\n</script>\n\n<div class=\"data-list\">\n  <div class=\"list-header\">\n    <slot name=\"header\" itemCount={items.length} />\n  </div>\n  \n  {#if loading}\n    <div class=\"loading\">Loading...</div>\n  {:else if items.length === 0}\n    <div class=\"empty-state\">\n      <slot name=\"empty\">\n        <p>No items available</p>\n      </slot>\n    </div>\n  {:else}\n    <ul class=\"items-list\">\n      {#each items as item, i}\n        <li>\n          <slot name=\"item\" {item} index={i} />\n        </li>\n      {/each}\n    </ul>\n  {/if}\n  \n  <div class=\"list-footer\">\n    <slot name=\"footer\" itemCount={items.length} />\n  </div>\n</div>\n```\n\n**App.svelte (Svelte 4 Usage)**\n```svelte\n<script>\n  import DataList from './DataList.svelte';\n  \n  let users = [\n    { id: 1, name: 'Alice', role: 'Admin' },\n    { id: 2, name: 'Bob', role: 'User' },\n    { id: 3, name: 'Charlie', role: 'Editor' }\n  ];\n  \n  let loading = false;\n  \n  function deleteUser(id) {\n    users = users.filter(user => user.id !== id);\n  }\n</script>\n\n<DataList items={users} {loading}>\n  <svelte:fragment slot=\"header\" let:itemCount>\n    <h2>User List</h2>\n    <p>Showing {itemCount} users</p>\n    <div class=\"controls\">\n      <input type=\"search\" placeholder=\"Search users...\" />\n      <button>Add User</button>\n    </div>\n  </svelte:fragment>\n  \n  <svelte:fragment slot=\"item\" let:item let:index>\n    <span>{index + 1}. {item.name}</span>\n    <span class=\"role\">{item.role}</span>\n    <button on:click={() => deleteUser(item.id)}>Delete</button>\n  </svelte:fragment>\n  \n  <svelte:fragment slot=\"empty\">\n    <p>No users found</p>\n    <button>Add your first user</button>\n  </svelte:fragment>\n  \n  <svelte:fragment slot=\"footer\" let:itemCount>\n    <p>Total users: {itemCount}</p>\n    <button disabled={itemCount === 0}>Export Users</button>\n  </svelte:fragment>\n</DataList>\n```\n\n**Refactored App.svelte for Svelte 5**\n```svelte\n<script>\n  import DataList from './DataList.svelte';\n  \n  let users = [\n    { id: 1, name: 'Alice', role: 'Admin' },\n    { id: 2, name: 'Bob', role: 'User' },\n    { id: 3, name: 'Charlie', role: 'Editor' }\n  ];\n  \n  let loading = false;\n  \n  function deleteUser(id) {\n    users = users.filter(user => user.id !== id);\n  }\n</script>\n\n<DataList items={users} {loading}>\n  <!-- In Svelte 5, we can use snippets directly with slot props -->\n  <h2 slot=\"header\" let:itemCount>User List</h2>\n  <p slot=\"header\" let:itemCount>Showing {itemCount} users</p>\n  <div class=\"controls\" slot=\"header\">\n    <input type=\"search\" placeholder=\"Search users...\" />\n    <button>Add User</button>\n  </div>\n  \n  <!-- Item template -->\n  <span slot=\"item\" let:item let:index>{index + 1}. {item.name}</span>\n  <span class=\"role\" slot=\"item\" let:item>{item.role}</span>\n  <button slot=\"item\" let:item on:click={() => deleteUser(item.id)}>Delete</button>\n  \n  <!-- Empty state -->\n  <p slot=\"empty\">No users found</p>\n  <button slot=\"empty\">Add your first user</button>\n  \n  <!-- Footer -->\n  <p slot=\"footer\" let:itemCount>Total users: {itemCount}</p>\n  <button slot=\"footer\" let:itemCount disabled={itemCount === 0}>Export Users</button>\n</DataList>\n```\n\n### Key Changes in the Refactoring\n\n1. **Removed `<svelte:fragment>`**: We completely removed all instances of `<svelte:fragment>` since Svelte 5 doesn't require it.\n\n2. **Direct Slot Assignment**: Multiple elements can now directly use the same slot name without being wrapped.\n\n3. **Slot Props Still Work**: The `let:` directive for accessing slot props still works with individual elements.\n\n4. **Conditional Content**: Conditional content with `{#if}` blocks can still be used directly with slotted elements.\n\n5. **Component Definition Unchanged**: The component that defines the slots doesn't need to change at all.\n\n### Benefits of the Svelte 5 Approach\n\n1. **Simpler Syntax**: No need to learn and use a special element.\n2. **Less Nesting**: Reduced nesting in templates makes the code cleaner.\n3. **More Intuitive**: The behavior is more in line with what developers would expect.\n4. **Better Performance**: Potentially better runtime performance with fewer wrapper elements.\n\nThis refactoring approach maintains all the functionality of the original components while taking advantage of Svelte 5's improved handling of slot content."}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"What are the limitations of using `<svelte:fragment>` in Svelte 4, and how does Svelte 5 address these limitations?","answer":"`<svelte:fragment>` in Svelte 4 has several limitations that can make component development more complex. Svelte 5 addresses many of these limitations with its new approach to handling slot content. Let's examine these limitations in detail and how Svelte 5 improves the situation:\n\n### Limitations of `<svelte:fragment>` in Svelte 4\n\n1. **Special Syntax Requirement**\n   \n   In Svelte 4, developers need to know about and remember to use the special `<svelte:fragment>` element when they want to group multiple elements in a slot without adding a wrapper element to the DOM. This is a non-standard HTML element that requires specific knowledge of Svelte.\n\n   ```svelte\n   <!-- Svelte 4 requires this special element -->\n   <svelte:fragment slot=\"footer\">\n     <button>Save</button>\n     <button>Cancel</button>\n   </svelte:fragment>\n   ```\n\n2. **Verbose Nested Structures**\n   \n   When working with complex slot structures, especially with conditional rendering and slot props, the nesting can become verbose and harder to read:\n\n   ```svelte\n   <svelte:fragment slot=\"content\">\n     {#if condition}\n       <svelte:fragment let:data>\n         <!-- More nested content -->\n       </svelte:fragment>\n     {/if}\n   </svelte:fragment>\n   ```\n\n3. **Inconsistent Mental Model**\n   \n   Developers have to maintain two different mental models:\n   - Regular elements with a `slot` attribute create a wrapper in the DOM\n   - `<svelte:fragment>` with a `slot` attribute doesn't create a wrapper\n\n   This inconsistency can be confusing, especially for newcomers to Svelte.\n\n4. **Additional Cognitive Load**\n   \n   Developers need to constantly think about whether they need a wrapper element or not, and choose between a regular element or `<svelte:fragment>` accordingly.\n\n5. **Difficult Refactoring**\n   \n   When refactoring components, changing from a single element to multiple elements in a slot often requires adding `<svelte:fragment>` to maintain the same DOM structure.\n\n6. **Limited Documentation**\n   \n   The usage and best practices around `<svelte:fragment>` weren't as well documented as other Svelte features, leading to inconsistent usage patterns.\n\n7. **No Direct Styling**\n   \n   Since `<svelte:fragment>` doesn't render in the DOM, you can't apply styles or event handlers to the group of elements as a whole.\n\n### How Svelte 5 Addresses These Limitations\n\nAccording to the documentation note, \"In Svelte 5+, this concept is obsolete, as snippets don't create a wrapping element.\" This suggests several improvements:\n\n1. **Simplified Syntax**\n   \n   In Svelte 5, you can directly use multiple elements with the same slot attribute without needing a special wrapper element:\n\n   ```svelte\n   <!-- Svelte 5 - much simpler -->\n   <button slot=\"footer\">Save</button>\n   <button slot=\"footer\">Cancel</button>\n   ```\n\n2. **More Intuitive Behavior**\n   \n   The default behavior now matches what most developers would intuitively expect - elements with the same slot name are grouped together in that slot without an extra wrapper.\n\n3. **Consistent Mental Model**\n   \n   There's now a single, consistent approach to using slots - you simply add the slot attribute to any element you want to place in a named slot.\n\n4. **Reduced Cognitive Load**\n   \n   Developers no longer need to make the decision between using a regular element or `<svelte:fragment>` - they can just use regular elements.\n\n5. **Easier Refactoring**\n   \n   When refactoring components, changing from a single element to multiple elements in a slot doesn't require adding any special wrapper.\n\n6. **Better Performance**\n   \n   With fewer wrapper elements in the DOM, there's potentially better runtime performance and less memory usage.\n\n7. **Cleaner DOM**\n   \n   The resulting DOM is cleaner with fewer unnecessary wrapper elements, making debugging and styling easier.\n\n### Example Comparison\n\n**Svelte 4 Approach:**\n```svelte\n<Tabs>\n  <div slot=\"tab\" let:active={isActive} let:index>\n    Tab {index + 1}\n  </div>\n  \n  <svelte:fragment slot=\"content\">\n    <p>First paragraph of content</p>\n    <p>Second paragraph of content</p>\n    \n    {#if showExtraContent}\n      <p>Extra content</p>\n    {/if}\n  </svelte:fragment>\n</Tabs>\n```\n\n**Svelte 5 Approach:**\n```svelte\n<Tabs>\n  <div slot=\"tab\" let:active={isActive} let:index>\n    Tab {index + 1}\n  </div>\n  \n  <p slot=\"content\">First paragraph of content</p>\n  <p slot=\"content\">Second paragraph of content</p>\n  \n  {#if showExtraContent}\n    <p slot=\"content\">Extra content</p>\n  {/if}\n</Tabs>\n```\n\n### Benefits of Svelte 5's Approach\n\n1. **Less Boilerplate**: The code is more concise without the need for `<svelte:fragment>`.\n2. **More Declarative**: The relationship between elements and their slots is more directly expressed.\n3. **Better Developer Experience**: Fewer special cases to remember makes development more straightforward.\n4. **Easier to Learn**: New developers have fewer Svelte-specific concepts to learn.\n5. **More Maintainable**: Code is easier to read and maintain with less nesting.\n\nBy eliminating the need for `<svelte:fragment>`, Svelte 5 makes slot content handling more intuitive and aligned with developers' expectations, addressing the limitations present in Svelte 4."}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"When working with nested slots in complex components, how would `<svelte:fragment>` be used in Svelte 4, and how would this pattern change in Svelte 5?","answer":"Working with nested slots in complex components can be challenging. Let's explore how `<svelte:fragment>` would be used in Svelte 4 for nested slots, and how this pattern would change in Svelte 5.\n\n### Nested Slots with `<svelte:fragment>` in Svelte 4\n\nIn Svelte 4, when dealing with complex components that have nested slots, you often need to use `<svelte:fragment>` at multiple levels to avoid unwanted wrapper elements. Here's a detailed example:\n\n#### Component Hierarchy in Svelte 4\n\nLet's imagine a dashboard layout with several nested components:\n\n**DashboardLayout.svelte (Top-level component)**\n```svelte\n<div class=\"dashboard\">\n  <header class=\"dashboard-header\">\n    <slot name=\"header\">\n      <h1>Dashboard</h1>\n    </slot>\n  </header>\n  \n  <div class=\"dashboard-content\">\n    <div class=\"sidebar\">\n      <slot name=\"sidebar\" />\n    </div>\n    \n    <main class=\"main-content\">\n      <slot />\n    </main>\n  </div>\n  \n  <footer class=\"dashboard-footer\">\n    <slot name=\"footer\" />\n  </footer>\n</div>\n```\n\n**WidgetContainer.svelte (Mid-level component)**\n```svelte\n<script>\n  export let title = 'Widget';\n  export let collapsible = false;\n  export let collapsed = false;\n</script>\n\n<section class=\"widget-container\">\n  <header class=\"widget-header\">\n    <slot name=\"widget-header\" {collapsed} {title}>\n      <h2>{title}</h2>\n      {#if collapsible}\n        <button on:click={() => collapsed = !collapsed}>\n          {collapsed ? 'Expand' : 'Collapse'}\n        </button>\n      {/if}\n    </slot>\n  </header>\n  \n  {#if !collapsed}\n    <div class=\"widget-content\">\n      <slot name=\"widget-content\" />\n    </div>\n    \n    <footer class=\"widget-footer\">\n      <slot name=\"widget-footer\" />\n    </footer>\n  {/if}\n</section>\n```\n\n**DataWidget.svelte (Leaf component)**\n```svelte\n<script>\n  export let data = [];\n  export let loading = false;\n</script>\n\n<div class=\"data-widget\">\n  <div class=\"data-controls\">\n    <slot name=\"controls\" {data} />\n  </div>\n  \n  <div class=\"data-display\">\n    {#if loading}\n      <div class=\"loading\">Loading...</div>\n    {:else if data.length === 0}\n      <slot name=\"empty\">\n        <p>No data available</p>\n      </slot>\n    {:else}\n      <slot {data} />\n    {/if}\n  </div>\n  \n  <div class=\"data-footer\">\n    <slot name=\"data-footer\" itemCount={data.length} />\n  </div>\n</div>\n```\n\n#### Using These Components in Svelte 4 with `<svelte:fragment>`\n\n```svelte\n<script>\n  import DashboardLayout from './DashboardLayout.svelte';\n  import WidgetContainer from './WidgetContainer.svelte';\n  import DataWidget from './DataWidget.svelte';\n  \n  let userData = [/* user data */];\n  let salesData = [/* sales data */];\n  let userDataLoading = false;\n  let salesDataLoading = false;\n</script>\n\n<DashboardLayout>\n  <h1 slot=\"header\">Admin Dashboard</h1>\n  \n  <svelte:fragment slot=\"sidebar\">\n    <nav>\n      <ul>\n        <li><a href=\"#users\">Users</a></li>\n        <li><a href=\"#sales\">Sales</a></li>\n        <li><a href=\"#settings\">Settings</a></li>\n      </ul>\n    </nav>\n    \n    <div class=\"sidebar-footer\">\n      <button>Collapse Sidebar</button>\n    </div>\n  </svelte:fragment>\n  \n  <!-- Main content (default slot) -->\n  <div class=\"widgets-grid\">\n    <WidgetContainer title=\"User Statistics\" collapsible={true}>\n      <svelte:fragment slot=\"widget-header\" let:collapsed let:title>\n        <h2>{title} ({userData.length} users)</h2>\n        <div class=\"widget-controls\">\n          <button>Refresh</button>\n          <button>{collapsed ? 'Expand' : 'Collapse'}</button>\n        </div>\n      </svelte:fragment>\n      \n      <svelte:fragment slot=\"widget-content\">\n        <DataWidget data={userData} loading={userDataLoading}>\n          <svelte:fragment slot=\"controls\" let:data>\n            <input type=\"search\" placeholder=\"Search users...\" />\n            <select>\n              <option>Sort by Name</option>\n              <option>Sort by Date</option>\n            </select>\n          </svelte:fragment>\n          \n          <svelte:fragment let:data>\n            <ul class=\"user-list\">\n              {#each data as user}\n                <li>{user.name} - {user.email}</li>\n              {/each}\n            </ul>\n          </svelte:fragment>\n          \n          <svelte:fragment slot=\"data-footer\" let:itemCount>\n            <p>Showing {itemCount} users</p>\n            <button>View All</button>\n          </svelte:fragment>\n        </DataWidget>\n      </svelte:fragment>\n      \n      <svelte:fragment slot=\"widget-footer\">\n        <button>Export User Data</button>\n        <button>Print Report</button>\n      </svelte:fragment>\n    </WidgetContainer>\n    \n    <WidgetContainer title=\"Sales Overview\" collapsible={true}>\n      <!-- Similar nested structure for sales widget -->\n      <!-- Multiple uses of svelte:fragment -->\n    </WidgetContainer>\n  </div>\n  \n  <svelte:fragment slot=\"footer\">\n    <p>Â© 2023 Company Name</p>\n    <div class=\"footer-links\">\n      <a href=\"/privacy\">Privacy Policy</a>\n      <a href=\"/terms\">Terms of Service</a>\n    </div>\n  </svelte:fragment>\n</DashboardLayout>\n```\n\n### How This Pattern Changes in Svelte 5\n\nIn Svelte 5, since \"snippets don't create a wrapping element,\" the need for `<svelte:fragment>` is eliminated. The same complex nested component structure can be expressed more clearly:\n\n```svelte\n<script>\n  import DashboardLayout from './DashboardLayout.svelte';\n  import WidgetContainer from './WidgetContainer.svelte';\n  import DataWidget from './DataWidget.svelte';\n  \n  let userData = [/* user data */];\n  let salesData = [/* sales data */];\n  let userDataLoading = false;\n  let salesDataLoading = false;\n</script>\n\n<DashboardLayout>\n  <h1 slot=\"header\">Admin Dashboard</h1>\n  \n  <!-- No svelte:fragment needed for sidebar -->\n  <nav slot=\"sidebar\">\n    <ul>\n      <li><a href=\"#users\">Users</a></li>\n      <li><a href=\"#sales\">Sales</a></li>\n      <li><a href=\"#settings\">Settings</a></li>\n    </ul>\n  </nav>\n  \n  <div class=\"sidebar-footer\" slot=\"sidebar\">\n    <button>Collapse Sidebar</button>\n  </div>\n  \n  <!-- Main content (default slot) -->\n  <div class=\"widgets-grid\">\n    <WidgetContainer title=\"User Statistics\" collapsible={true}>\n      <!-- Direct slot props usage without svelte:fragment -->\n      <h2 slot=\"widget-header\" let:collapsed let:title>\n        {title} ({userData.length} users)\n      </h2>\n      \n      <div class=\"widget-controls\" slot=\"widget-header\" let:collapsed>\n        <button>Refresh</button>\n        <button>{collapsed ? 'Expand' : 'Collapse'}</button>\n      </div>\n      \n      <!-- No svelte:fragment needed for widget-content -->\n      <DataWidget slot=\"widget-content\" data={userData} loading={userDataLoading}>\n        <!-- Direct slot assignment for controls -->\n        <input \n          type=\"search\" \n          placeholder=\"Search users...\" \n          slot=\"controls\"\n        />\n        \n        <select slot=\"controls\">\n          <option>Sort by Name</option>\n          <option>Sort by Date</option>\n        </select>\n        \n        <!-- Default slot with props -->\n        <ul class=\"user-list\" let:data>\n          {#each data as user}\n            <li>{user.name} - {user.email}</li>\n          {/each}\n        </ul>\n        \n        <!-- Footer content -->\n        <p slot=\"data-footer\" let:itemCount>Showing {itemCount} users</p>\n        <button slot=\"data-footer\">View All</button>\n      </DataWidget>\n      \n      <!-- Widget footer buttons -->\n      <button slot=\"widget-footer\">Export User Data</button>\n      <button slot=\"widget-footer\">Print Report</button>\n    </WidgetContainer>\n    \n    <WidgetContainer title=\"Sales Overview\" collapsible={true}>\n      <!-- Similar nested structure for sales widget -->\n      <!-- No svelte:fragment needed anywhere -->\n    </WidgetContainer>\n  </div>\n  \n  <!-- Footer content -->\n  <p slot=\"footer\">Â© 2023 Company Name</p>\n  \n  <div class=\"footer-links\" slot=\"footer\">\n    <a href=\"/privacy\">Privacy Policy</a>\n    <a href=\"/terms\">Terms of Service</a>\n  </div>\n</DashboardLayout>\n```\n\n### Key Differences in Svelte 5\n\n1. **Elimination of `<svelte:fragment>`**\n   \n   All instances of `<svelte:fragment>` are removed, as elements can be directly assigned to slots without creating wrapper elements.\n\n2. **Flatter Structure**\n   \n   The code structure is flatter and easier to read, with less nesting.\n\n3. **Direct Slot Assignment**\n   \n   Multiple elements can be directly assigned to the same slot without a wrapper.\n\n4. **Slot Props Still Work**\n   \n   Slot props using the `let:` directive still work with individual elements.\n\n5. **Cleaner Conditional Content**\n   \n   Conditional content can be added directly to slots without needing to wrap it in `<svelte:fragment>`.\n\n6. **More Intuitive Nesting**\n   \n   The nesting of components and slots becomes more intuitive and follows a more natural pattern.\n\n### Benefits of Svelte 5's Approach for Nested Slots\n\n1. **Reduced Complexity**: The code is less complex with fewer special elements and less nesting.\n\n2. **Better Readability**: The component structure is easier to understand at a glance.\n\n3. **Easier Maintenance**: Simpler code structure makes maintenance easier.\n\n4. **More Intuitive Development**: The slot system behaves more in line with developer expectations.\n\n5. **Better Performance**: Potentially better runtime performance with fewer wrapper elements.\n\n6. **Easier Refactoring**: Changing component structures and slot assignments becomes simpler.\n\n7. **Reduced Learning Curve**: New developers have fewer special cases to learn.\n\nThe Svelte 5 approach significantly simplifies working with nested slots in complex component hierarchies by eliminating the need for the special `<svelte:fragment>` element while maintaining all the flexibility and power of Svelte's slot system."}
{"source":"docs/svelte/99-legacy/22-legacy-svelte-fragment.md","question":"How does `<svelte:fragment>` compare to similar concepts in other frameworks, and what advantages does Svelte 5's approach offer over these alternatives?","answer":"`<svelte:fragment>` in Svelte 4 and earlier serves a specific purpose that has parallels in other frontend frameworks. Let's compare it with similar concepts in other frameworks and then examine how Svelte 5's new approach offers advantages over these alternatives.\n\n### Comparison with Other Frameworks\n\n#### 1. React: Fragments (`<>...</>` or `<React.Fragment>`)\n\n**React's Approach:**\nReact introduced Fragments to allow returning multiple elements from a component without adding extra nodes to the DOM.\n\n```jsx\n// Using React Fragment\nreturn (\n  <React.Fragment>\n    <h1>Title</h1>\n    <p>Paragraph</p>\n  </React.Fragment>\n);\n\n// Using shorthand syntax\nreturn (\n  <>\n    <h1>Title</h1>\n    <p>Paragraph</p>\n  </>\n);\n```\n\n**Similarities with `<svelte:fragment>`:**\n- Both avoid adding unnecessary wrapper elements to the DOM\n- Both allow grouping multiple elements together\n\n**Differences:**\n- React Fragments are primarily used for returning multiple elements from a component\n- `<svelte:fragment>` in Svelte 4 is specifically for named slots\n- React doesn't have a concept directly equivalent to Svelte's slots\n\n#### 2. Vue: Template Fragments and Slot Templates\n\n**Vue's Approach:**\nVue 3 introduced fragment support, allowing components to have multiple root nodes. For slots, Vue uses `<template>` with slot directives.\n\n```vue\n<!-- Vue component with multiple slots -->\n<template>\n  <div class=\"container\">\n    <header>\n      <slot name=\"header\"></slot>\n    </header>\n    <main>\n      <slot></slot>\n    </main>\n    <footer>\n      <slot name=\"footer\"></slot>\n    </footer>\n  </div>\n</template>\n\n<!-- Using the component with template slots -->\n<MyComponent>\n  <template v-slot:header>\n    <h1>Title</h1>\n    <p>Subtitle</p>\n  </template>\n  \n  <p>Main content</p>\n  \n  <template v-slot:footer>\n    <button>Save</button>\n    <button>Cancel</button>\n  </template>\n</MyComponent>\n```\n\n**Similarities with `<svelte:fragment>`:**\n- Both allow grouping content for slots\n- Both avoid adding extra DOM nodes\n\n**Differences:**\n- Vue uses the standard `<template>` element with special directives\n- Vue's slot system has a different syntax with `v-slot` directives\n- Vue's template is more explicit about its purpose as a non-rendering element\n\n#### 3. Angular: `<ng-container>` and `<ng-template>`\n\n**Angular's Approach:**\nAngular uses `<ng-container>` for grouping elements without adding extra DOM nodes, and `<ng-template>` for defining content that isn't rendered immediately.\n\n```html\n<!-- Angular component with content projection (Angular's slots) -->\n<div class=\"card\">\n  <div class=\"card-header\">\n    <ng-content select=\"[header]\"></ng-content>\n  </div>\n  <div class=\"card-body\">\n    <ng-content></ng-content>\n  </div>\n  <div class=\"card-footer\">\n    <ng-content select=\"[footer]\"></ng-content>\n  </div>\n</div>\n\n<!-- Using the component -->\n<app-card>\n  <ng-container header>\n    <h2>Card Title</h2>\n    <p>Subtitle</p>\n  </ng-container>\n  \n  <p>Main content</p>\n  \n  <ng-container footer>\n    <button>Save</button>\n    <button>Cancel</button>\n  </ng-container>\n</app-card>\n```\n\n**Similarities with `<svelte:fragment>`:**\n- Both `<ng-container>` and `<svelte:fragment>` don't render in the final DOM\n- Both are used for grouping elements\n\n**Differences:**\n- Angular's content projection system works differently from Svelte's slots\n- Angular uses attribute selectors rather than named slots\n- Angular has separate concepts for templates (`<ng-template>`) and containers (`<ng-container>`)\n\n### Advantages of Svelte 5's New Approach\n\nSvelte 5 takes a different approach by making fragments unnecessary since \"snippets don't create a wrapping element\" by default. Here's how this approach offers advantages over the alternatives:\n\n#### 1. Simplicity and Intuitiveness\n\n**Svelte 5:**\n```svelte\n<Card>\n  <h2 slot=\"header\">Title</h2>\n  <p slot=\"header\">Subtitle</p>\n  \n  <p>Main content</p>\n  \n  <button slot=\"footer\">Save</button>\n  <button slot=\"footer\">Cancel</button>\n</Card>\n```\n\n**Advantages:**\n- No special syntax or elements needed\n- The code reads naturally and is immediately understandable\n- Less cognitive load for developers\n- What you write is closer to the final DOM structure\n\n#### 2. Reduced Boilerplate\n\n**Compared to React:**\nReact still requires fragments when returning multiple elements:\n```jsx\nreturn (\n  <>\n    <h1>Title</h1>\n    <p>Paragraph</p>\n  </>\n);\n```\n\n**Compared to Vue:**\nVue requires template tags with directives:\n```vue\n<template v-slot:header>\n  <h1>Title</h1>\n  <p>Subtitle</p>\n</template>\n```\n\n**Compared to Angular:**\nAngular requires `<ng-container>` with attribute selectors:\n```html\n<ng-container header>\n  <h2>Card Title</h2>\n  <p>Subtitle</p>\n</ng-container>\n```\n\n**Svelte 5's Advantage:**\n- Less code to write\n- No wrapper elements or special syntax\n- Cleaner, more concise templates\n\n#### 3. More Consistent Mental Model\n\n**Svelte 5's Approach:**\n- Elements with the same slot name are grouped together naturally\n- No special cases to remember\n- The behavior matches what developers would intuitively expect\n\n**Advantage over other frameworks:**\n- React, Vue, and Angular all require learning special elements or syntax\n- Svelte 5 reduces the number of special cases and exceptions\n- The mental model is simpler and more consistent\n\n#### 4. Better Developer Experience\n\n**Svelte 5's Advantages:**\n- Less syntax to learn\n- Easier for newcomers to understand\n- Fewer opportunities for errors\n- More direct mapping between what you write and what renders\n- Easier refactoring when changing component structures\n\n#### 5. Performance Benefits\n\n**Potential Performance Advantages:**\n- Fewer wrapper elements means less memory usage\n- Potentially faster rendering with a flatter DOM\n- Less work for the compiler and runtime\n\n#### 6. Progressive Enhancement\n\n**Svelte 5's Approach:**\n- Builds on Svelte's existing slot system while simplifying it\n- Maintains backward compatibility with existing patterns\n- Allows for gradual migration from older patterns\n\n### Practical Example Comparing All Approaches\n\nLet's look at a practical example of creating a tabbed interface component:\n\n**React:**\n```jsx\n// TabPanel.jsx\nfunction TabPanel({ tabs }) {\n  const [activeTab, setActiveTab] = useState(0);\n  \n  return (\n    <div className=\"tab-panel\">\n      <div className=\"tab-headers\">\n        {tabs.map((tab, index) => (\n          <button \n            key={index}\n            onClick={() => setActiveTab(index)}\n            className={activeTab === index ? 'active' : ''}\n          >\n            {tab.title}\n          </button>\n        ))}\n      </div>\n      <div className=\"tab-content\">\n        {tabs[activeTab].content}\n      </div>\n    </div>\n  );\n}\n\n// Usage\nfunction App() {\n  const tabs = [\n    {\n      title: 'Tab 1',\n      content: (\n        <React.Fragment>\n          <h2>Tab 1 Content</h2>\n          <p>This is the content for tab 1.</p>\n          <button>Action</button>\n        </React.Fragment>\n      )\n    },\n    // More tabs...\n  ];\n  \n  return <TabPanel tabs={tabs} />;\n}\n```\n\n**Vue:**\n```vue\n<!-- TabPanel.vue -->\n<template>\n  <div class=\"tab-panel\">\n    <div class=\"tab-headers\">\n      <slot name=\"tab-headers\" :active-tab=\"activeTab"}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"What is the key difference between using `<MyComponent>` directly versus using `<svelte:component this={MyComponent}>` in Svelte 5's runes mode compared to legacy mode?","answer":"In Svelte 5, there's a fundamental difference in how component references are handled between runes mode and legacy mode:\n\nIn **runes mode**, when you use `<MyComponent>` directly, the component will automatically re-render if the value of `MyComponent` changes. This means if you have a variable that holds a component reference and that reference changes, Svelte will intelligently update the DOM by destroying the old component instance and creating a new one with the updated component type.\n\nIn **legacy mode**, direct component references like `<MyComponent>` won't re-render if the value of `MyComponent` changes. Instead, you must explicitly use the `<svelte:component>` syntax with the `this` prop to achieve dynamic component rendering:\n\n```svelte\n<svelte:component this={MyComponent} />\n```\n\nThis special syntax tells Svelte to destroy and recreate the component instance whenever the value of the `this` expression changes, enabling dynamic component switching.\n\nThis difference is significant enough that the Svelte 5 migration guide specifically mentions that `<svelte:component>` is no longer necessary in many cases when using runes mode, as the direct component reference now handles the dynamic behavior automatically."}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"How would you conditionally render a component in Svelte 5's legacy mode, and what happens if the component reference becomes falsy?","answer":"In Svelte 5's legacy mode, you can conditionally render a component using the `<svelte:component>` element with the `this` prop. When the value of the `this` expression becomes falsy, no component is rendered.\n\nHere's how you would implement conditional component rendering:\n\n```svelte\n<script>\n  import ComponentA from './ComponentA.svelte';\n  import ComponentB from './ComponentB.svelte';\n  \n  let condition = true;\n  $: currentComponent = condition ? ComponentA : ComponentB;\n  \n  function toggleComponent() {\n    condition = !condition;\n  }\n  \n  // You can also set it to null/undefined to render nothing\n  function removeComponent() {\n    currentComponent = null;\n  }\n</script>\n\n<button on:click={toggleComponent}>Toggle Component</button>\n<button on:click={removeComponent}>Remove Component</button>\n\n<svelte:component this={currentComponent} />\n```\n\nIn this example:\n1. We switch between ComponentA and ComponentB based on a condition\n2. When the `removeComponent` function is called, `currentComponent` becomes `null`\n3. Since `null` is falsy, no component will be rendered in that case\n\nThis behavior is particularly useful for implementing features like tab interfaces, wizard flows, or any UI that needs to dynamically swap components based on application state."}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"What are the implications of moving from legacy mode to runes mode in Svelte 5 regarding the `<svelte:component>` syntax?","answer":"Moving from legacy mode to runes mode in Svelte 5 has significant implications for how you handle dynamic components:\n\nIn legacy mode, `<svelte:component this={Component}>` was the only way to dynamically switch between different component types at runtime. However, in runes mode, this special syntax is largely unnecessary because regular component references now automatically update when their values change.\n\n**Legacy Mode (requires `<svelte:component>`):**\n```svelte\n<script>\n  import ComponentA from './ComponentA.svelte';\n  import ComponentB from './ComponentB.svelte';\n  \n  let currentComponent = ComponentA;\n  \n  function switchComponent() {\n    currentComponent = currentComponent === ComponentA ? ComponentB : ComponentA;\n  }\n</script>\n\n<button on:click={switchComponent}>Switch Component</button>\n\n<!-- Must use svelte:component for dynamic switching -->\n<svelte:component this={currentComponent} />\n```\n\n**Runes Mode (direct reference works):**\n```svelte\n<script>\n  import ComponentA from './ComponentA.svelte';\n  import ComponentB from './ComponentB.svelte';\n  \n  let currentComponent = $state(ComponentA);\n  \n  function switchComponent() {\n    currentComponent = currentComponent === ComponentA ? ComponentB : ComponentA;\n  }\n</script>\n\n<button on:click={switchComponent}>Switch Component</button>\n\n<!-- Direct reference automatically updates when currentComponent changes -->\n<svelte:element this={currentComponent} />\n```\n\nThe Svelte 5 migration guide specifically mentions this change as one of the improvements in the runes mode. This simplification makes code more intuitive and consistent, as components behave more like other values in your application.\n\nWhile `<svelte:component>` still works in runes mode for backward compatibility, new code should take advantage of the improved reactivity of direct component references."}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"How would you implement a dynamic component loader in Svelte 5's legacy mode that can handle asynchronously loaded components?","answer":"Implementing a dynamic component loader for asynchronously loaded components in Svelte 5's legacy mode requires combining `<svelte:component>` with JavaScript's dynamic import capabilities. Here's how you can create such a loader:\n\n```svelte\n<script>\n  // Track the currently loaded component\n  let dynamicComponent = null;\n  \n  // Track loading state\n  let isLoading = false;\n  let hasError = false;\n  let errorMessage = '';\n  \n  // Function to dynamically load a component by name\n  async function loadComponent(componentName) {\n    isLoading = true;\n    hasError = false;\n    \n    try {\n      // Reset current component while loading\n      dynamicComponent = null;\n      \n      // Dynamically import the component\n      const module = await import(`../components/${componentName}.svelte`);\n      \n      // Get the default export (the component)\n      dynamicComponent = module.default;\n    } catch (error) {\n      hasError = true;\n      errorMessage = `Failed to load component: ${error.message}`;\n      console.error(error);\n    } finally {\n      isLoading = false;\n    }\n  }\n</script>\n\n<div>\n  <button on:click={() => loadComponent('UserProfile')}>Load User Profile</button>\n  <button on:click={() => loadComponent('Dashboard')}>Load Dashboard</button>\n  <button on:click={() => loadComponent('Settings')}>Load Settings</button>\n</div>\n\n<div class=\"component-container\">\n  {#if isLoading}\n    <div class=\"loading\">Loading component...</div>\n  {:else if hasError}\n    <div class=\"error\">{errorMessage}</div>\n  {:else}\n    <!-- Use svelte:component to render the dynamically loaded component -->\n    <svelte:component this={dynamicComponent} />\n  {/if}\n</div>\n\n<style>\n  .component-container {\n    border: 1px solid #ccc;\n    padding: 1rem;\n    margin-top: 1rem;\n    min-height: 200px;\n  }\n  \n  .loading {\n    color: blue;\n  }\n  \n  .error {\n    color: red;\n  }\n</style>\n```\n\nThis implementation:\n1. Uses dynamic imports to load components on demand\n2. Handles loading states and errors gracefully\n3. Uses `<svelte:component this={dynamicComponent}>` to render the loaded component\n4. Takes advantage of the fact that when `this` is falsy (null in this case), nothing is rendered\n\nThis pattern is particularly useful for large applications where you want to split your code into smaller chunks that are loaded only when needed, improving initial load time and performance."}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"Can you pass props and event handlers to components rendered with `<svelte:component>` in Svelte 5's legacy mode? If so, how?","answer":"Yes, you can absolutely pass props and event handlers to components rendered with `<svelte:component>` in Svelte 5's legacy mode. The syntax is identical to how you would pass props and bind events to a regular component.\n\nHere's a comprehensive example demonstrating various ways to interact with dynamically rendered components:\n\n```svelte\n<script>\n  import UserCard from './UserCard.svelte';\n  import AdminCard from './AdminCard.svelte';\n  import GuestCard from './GuestCard.svelte';\n  \n  // Sample data\n  let userData = {\n    name: 'Jane Doe',\n    email: 'jane@example.com',\n    role: 'user'\n  };\n  \n  // Determine which component to use based on user role\n  $: componentByRole = {\n    'admin': AdminCard,\n    'user': UserCard,\n    'guest': GuestCard\n  };\n  \n  $: currentComponent = componentByRole[userData.role] || GuestCard;\n  \n  // Event handlers\n  function handleUserUpdate(event) {\n    console.log('User data updated:', event.detail);\n    userData = { ...userData, ...event.detail };\n  }\n  \n  function handleLogout() {\n    console.log('User logged out');\n    userData.role = 'guest';\n  }\n  \n  // Toggle between roles for demonstration\n  function cycleRole() {\n    const roles = ['user', 'admin', 'guest'];\n    const currentIndex = roles.indexOf(userData.role);\n    const nextIndex = (currentIndex + 1) % roles.length;\n    userData.role = roles[nextIndex];\n  }\n</script>\n\n<button on:click={cycleRole}>\n  Change role (current: {userData.role})\n</button>\n\n<!-- Using svelte:component with props and event handlers -->\n<svelte:component \n  this={currentComponent}\n  userName={userData.name}\n  userEmail={userData.email}\n  isVerified={true}\n  permissions={['read', 'write']}\n  on:update={handleUserUpdate}\n  on:logout={handleLogout}\n/>\n```\n\nAnd here's what one of the component implementations might look like:\n\n```svelte\n<!-- UserCard.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte';\n  \n  // Props\n  export let userName;\n  export let userEmail;\n  export let isVerified = false;\n  export let permissions = [];\n  \n  const dispatch = createEventDispatcher();\n  \n  function updateEmail(newEmail) {\n    dispatch('update', { email: newEmail });\n  }\n  \n  function logoutUser() {\n    dispatch('logout');\n  }\n</script>\n\n<div class=\"user-card\">\n  <h2>{userName} {isVerified ? 'â' : ''}</h2>\n  <p>Email: {userEmail}</p>\n  \n  <div class=\"permissions\">\n    <strong>Permissions:</strong>\n    <ul>\n      {#each permissions as permission}\n        <li>{permission}</li>\n      {/each}\n    </ul>\n  </div>\n  \n  <div class=\"actions\">\n    <button on:click={() => updateEmail('new@example.com')}>\n      Update Email\n    </button>\n    <button on:click={logoutUser}>\n      Logout\n    </button>\n  </div>\n</div>\n\n<style>\n  .user-card {\n    border: 1px solid #ddd;\n    padding: 1rem;\n    border-radius: 4px;\n  }\n  \n  .actions {\n    margin-top: 1rem;\n  }\n</style>\n```\n\nIn this example:\n1. We pass multiple props to the dynamically rendered component (primitives, objects, arrays)\n2. We listen for custom events dispatched from the component (`update` and `logout`)\n3. The component is swapped based on the user's role, with all props and event handlers being applied correctly\n4. Each component can have its own implementation but share a common interface of props and events\n\nThis approach maintains all the benefits of Svelte's component model while adding the flexibility of dynamic component selection."}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"What is the purpose of the `this` prop in `<svelte:component>` and how does it differ from other props you might pass to a component?","answer":"The `this` prop in `<svelte:component>` serves a special purpose that's fundamentally different from other props you might pass to components in Svelte 5's legacy mode.\n\n### Purpose of the `this` prop\n\nThe `this` prop is used to specify which component constructor should be instantiated and rendered. It expects a component definition (constructor function) rather than a data value like most props.\n\n```svelte\n<svelte:component this={MyComponent} />\n```\n\n### Key differences from regular props:\n\n1. **Special handling by Svelte**: The `this` prop is not actually passed to the component being rendered. Instead, it's intercepted by Svelte's runtime to determine which component to create.\n\n2. **Reactivity behavior**: When the value of `this` changes, Svelte completely destroys the current component instance and creates a new instance of the different component type. This is more dramatic than a regular prop update, which would just trigger a re-render of the same component.\n\n3. **Type expectations**: While regular props can be any JavaScript value (strings, numbers, objects, arrays, functions), the `this` prop specifically expects a Svelte component constructor or a falsy value.\n\n4. **Falsy behavior**: If `this` is falsy (null, undefined, false, 0, etc.), no component is rendered at all. With regular props, falsy values are just passed to the component as-is.\n\n### Example demonstrating the difference:\n\n```svelte\n<script>\n  import ComponentA from './ComponentA.svelte';\n  import ComponentB from './ComponentB.svelte';\n  \n  let activeComponent = ComponentA;\n  let regularProp = 'Initial value';\n  \n  function switchComponent() {\n    activeComponent = activeComponent === ComponentA ? ComponentB : ComponentA;\n  }\n  \n  function updateProp() {\n    regularProp = 'Updated value';\n  }\n</script>\n\n<button on:click={switchComponent}>Switch Component</button>\n<button on:click={updateProp}>Update Prop</button>\n\n<svelte:component \n  this={activeComponent} \n  someProp={regularProp}\n/>\n```\n\nIn this example:\n- When `switchComponent()` is called, the current component instance is completely destroyed, and a new instance of the other component type is created.\n- When `updateProp()` is called, the same component instance remains alive but receives the new prop value, triggering a re-render with the updated value.\n\nThis special behavior is what makes `<svelte:component>` valuable for implementing UI patterns that need to completely swap out components rather than just updating their props."}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"In what scenarios might you still need to use `<svelte:component>` in Svelte 5's runes mode, even though direct component references now update automatically?","answer":"While Svelte 5's runes mode makes direct component references reactive, there are still several scenarios where using `<svelte:component>` might be necessary or beneficial:\n\n### 1. When working with components loaded from external sources\n\nIf you're loading components dynamically from an API or another external source where the component isn't a direct import, `<svelte:component>` provides explicit clarity:\n\n```svelte\n<script>\n  let componentRegistry = $state({});\n  \n  // Load components from a plugin system\n  async function loadPluginComponents() {\n    const response = await fetch('/api/plugins/components');\n    const plugins = await response.json();\n    \n    // Register each plugin's components\n    for (const plugin of plugins) {\n      const module = await import(`/plugins/${plugin.path}`);\n      componentRegistry[plugin.name] = module.default;\n    }\n  }\n  \n  let activePluginName = $state('default');\n  $derived activeComponent = componentRegistry[activePluginName];\n</script>\n\n<svelte:component this={activeComponent} />\n```\n\n### 2. For code that needs to maintain compatibility with both legacy and runes mode\n\nIf you're writing a library or components that need to work in both modes, using `<svelte:component>` ensures consistent behavior:\n\n```svelte\n<!-- Works the same in both legacy and runes mode -->\n<svelte:component this={dynamicComponent} {...props} />\n```\n\n### 3. When dealing with conditional rendering with many conditions\n\nFor complex conditional rendering with many possible components, `<svelte:component>` can be more readable than multiple `{#if}` blocks:\n\n```svelte\n<script>\n  import ComponentA from './ComponentA.svelte';\n  import ComponentB from './ComponentB.svelte';\n  import ComponentC from './ComponentC.svelte';\n  import ComponentD from './ComponentD.svelte';\n  \n  let condition = $state('a');\n  \n  $derived componentMap = {\n    'a': ComponentA,\n    'b': ComponentB,\n    'c': ComponentC,\n    'd': ComponentD,\n    'none': null\n  };\n  \n  $derived currentComponent = componentMap[condition] || componentMap.none;\n</script>\n\n<!-- Cleaner than multiple if blocks -->\n<svelte:component this={currentComponent} />\n```\n\n### 4. For explicit self-documentation of dynamic behavior\n\nEven though direct references work in runes mode, using `<svelte:component>` can make code more self-documenting by explicitly indicating that a component is being dynamically selected:\n\n```svelte\n<!-- More explicitly communicates that this is a dynamic component -->\n<svelte:component this={selectedView} />\n\n<!-- Versus -->\n<svelte:element this={selectedView} />\n```\n\n### 5. When working with component factories or higher-order components\n\nIf you're using patterns that generate components programmatically:\n\n```svelte\n<script>\n  import { createComponentWithTheme } from './theme-factory';\n  \n  let theme = $state('dark');\n  $derived ThemedButton = createComponentWithTheme('Button', theme);\n  $derived ThemedCard = createComponentWithTheme('Card', theme);\n</script>\n\n<svelte:component this={ThemedButton}>Click Me</svelte:component>\n<svelte:component this={ThemedCard}>Card Content</svelte:component>\n```\n\nWhile the direct component reference approach in runes mode covers many use cases, `<svelte:component>` still has its place for these specific scenarios where its explicit nature or compatibility benefits outweigh the simplicity of direct references."}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"How would you implement a component switcher with animation transitions in Svelte 5's legacy mode using `<svelte:component>`?","answer":"Implementing a component switcher with animation transitions in Svelte 5's legacy mode requires combining `<svelte:component>` with Svelte's built-in transition system. Here's a comprehensive example:\n\n```svelte\n<script>\n  import { fade, fly, slide, scale } from 'svelte/transition';\n  import { quintOut } from 'svelte/easing';\n  \n  // Import components\n  import HomeView from './views/HomeView.svelte';\n  import ProfileView from './views/ProfileView.svelte';\n  import SettingsView from './views/SettingsView.svelte';\n  import AboutView from './views/AboutView.svelte';\n  \n  // Define available views\n  const views = {\n    home: { component: HomeView, label: 'Home' },\n    profile: { component: ProfileView, label: 'Profile' },\n    settings: { component: SettingsView, label: 'Settings' },\n    about: { component: AboutView, label: 'About' }\n  };\n  \n  // Current view state\n  let currentView = 'home';\n  \n  // Transition configuration\n  let transitionType = 'fade';\n  \n  const transitions = {\n    fade: (node, params) => fade(node, { duration: 300, ...params }),\n    fly: (node, params) => fly(node, { x: 300, duration: 500, ...params }),\n    slide: (node, params) => slide(node, { duration: 300, ...params }),\n    scale: (node, params) => scale(node, { \n      start: 0.9, \n      duration: 400, \n      easing: quintOut,\n      ...params \n    })\n  };\n  \n  // Function to switch views\n  function switchView(view) {\n    if (views[view]) {\n      currentView = view;\n    }\n  }\n  \n  // Get current transition function\n  $: transitionFn = transitions[transitionType] || transitions.fade;\n</script>\n\n<!-- Navigation -->\n<div class=\"navigation\">\n  {#each Object.entries(views) as [key, { label }]}\n    <button \n      class:active={currentView === key}\n      on:click={() => switchView(key)}\n    >\n      {label}\n    </button>\n  {/each}\n</div>\n\n<!-- Transition selector -->\n<div class=\"transition-selector\">\n  <label>\n    Transition:\n    <select bind:value={transitionType}>\n      <option value=\"fade\">Fade</option>\n      <option value=\"fly\">Fly</option>\n      <option value=\"slide\">Slide</option>\n      <option value=\"scale\">Scale</option>\n    </select>\n  </label>\n</div>\n\n<!-- Component container with transitions -->\n<div class=\"component-container\">\n  {#key currentView}\n    <div in:transitionFn out:transitionFn|local>\n      <svelte:component this={views[currentView].component} />\n    </div>\n  {/key}\n</div>\n\n<style>\n  .navigation {\n    display: flex;\n    gap: 0.5rem;\n    margin-bottom: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    border: 1px solid #ccc;\n    background: #f5f5f5;\n    cursor: pointer;\n  }\n  \n  button.active {\n    background: #007bff;\n    color: white;\n    border-color: #0069d9;\n  }\n  \n  .transition-selector {\n    margin-bottom: 1rem;\n  }\n  \n  .component-container {\n    border: 1px solid #ddd;\n    padding: 1rem;\n    border-radius: 4px;\n    min-height: 300px;\n    position: relative;\n  }\n</style>\n```\n\nKey aspects of this implementation:\n\n1. **Component Registry**: We maintain a registry of available components with their labels.\n\n2. **Transition System**: We use Svelte's built-in transition functions and allow the user to select between different transition types.\n\n3. **Key Block**: The `{#key currentView}` block ensures that the component is completely destroyed and recreated when the view changes, which is necessary for the transitions to work properly.\n\n4. **Transition Directives**: We use both `in:` and `out:` directives to control how components enter and exit. The `|local` modifier on the `out:` transition ensures that the outgoing component doesn't affect the layout while it's animating out.\n\n5. **svelte:component**: Inside the keyed block, we use `<svelte:component>` to render the current component based on the selected view.\n\nThis approach provides a smooth user experience when switching between components, with the ability to customize the transition effects. It's particularly useful for single-page applications where you want to create a sense of navigation between different views without actual page reloads."}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"How can you handle slot content and slot props when using `<svelte:component>` in Svelte 5's legacy mode?","answer":"When using `<svelte:component>` in Svelte 5's legacy mode, you can handle slot content and slot props just like you would with regular components. The dynamic nature of `<svelte:component>` doesn't change how slots work. Here's a comprehensive guide:\n\n### Basic Slot Content\n\nYou can pass content to the default slot by placing it between the opening and closing tags:\n\n```svelte\n<script>\n  import CardComponent from './Card.svelte';\n  import PanelComponent from './Panel.svelte';\n  \n  let activeContainer = CardComponent;\n  \n  function toggleContainer() {\n    activeContainer = activeContainer === CardComponent ? PanelComponent : CardComponent;\n  }\n</script>\n\n<button on:click={toggleContainer}>\n  Switch Container\n</button>\n\n<svelte:component this={activeContainer}>\n  <!-- This content goes into the default slot -->\n  <h2>My Content</h2>\n  <p>This content will be placed in the default slot of whichever component is active.</p>\n</svelte:component>\n```\n\n### Named Slots\n\nYou can also use named slots with `<svelte:component>` by using the `slot` attribute:\n\n```svelte\n<script>\n  import TabContainer from './TabContainer.svelte';\n  import AccordionContainer from './AccordionContainer.svelte';\n  \n  let containerType = TabContainer;\n</script>\n\n<svelte:component this={containerType}>\n  <!-- Default slot content -->\n  <p>This goes in the default slot</p>\n  \n  <!-- Named slots -->\n  <div slot=\"header\">\n    <h2>Dynamic Container Title</h2>\n  </div>\n  \n  <div slot=\"footer\">\n    <button>Save</button>\n    <button>Cancel</button>\n  </div>\n</svelte:component>\n```\n\n### Slot Props (Let Directives)\n\nSlot props work with `<svelte:component>` as well, allowing the dynamic component to pass data back to the slot content:\n\n```svelte\n<script>\n  import DataTable from './DataTable.svelte';\n  import DataList from './DataList.svelte';\n  \n  let viewType = DataTable;\n  let items = [\n    { id: 1, name: 'Item 1', value: 100 },\n    { id: 2, name: 'Item 2', value: 200 },\n    { id: 3, name: 'Item 3', value: 300 }\n  ];\n  \n  function toggleView() {\n    viewType = viewType === DataTable ? DataList : DataTable;\n  }\n</script>\n\n<button on:click={toggleView}>\n  Toggle View: {viewType === DataTable ? 'Table' : 'List'}\n</button>\n\n<svelte:component this={viewType} {items}>\n  <svelte:fragment slot=\"item\" let:item let:index>\n    <div class=\"item-wrapper\">\n      <span class=\"item-index\">{index + 1}.</span>\n      <span class=\"item-name\">{item.name}</span>\n      <span class=\"item-value\">${item.value}</span>\n      <button on:click={() => console.log(`Edit item ${item.id}`)}>\n        Edit\n      </button>\n    </div>\n  </svelte:fragment>\n</svelte:component>\n```\n\nHere's what the implementation of one of these components might look like:\n\n```svelte\n<!-- DataTable.svelte -->\n<script>\n  export let items = [];\n</script>\n\n<table>\n  <thead>\n    <tr>\n      <th>#</th>\n      <th>Name</th>\n      <th>Value</th>\n      <th>Actions</th>\n    </tr>\n  </thead>\n  <tbody>\n    {#each items as item, index}\n      <tr>\n        <td>{index + 1}</td>\n        <td>{item.name}</td>\n        <td>${item.value}</td>\n        <td>\n          <slot name=\"item\" {item} {index}>\n            <!-- Default fallback if no slot content provided -->\n            <button>View</button>\n          </slot>\n        </td>\n      </tr>\n    {/each}\n  </tbody>\n</table>\n```\n\n```svelte\n<!-- DataList.svelte -->\n<script>\n  export let items = [];\n</script>\n\n<ul class=\"data-list\">\n  {#each items as item, index}\n    <li>\n      <slot name=\"item\" {item} {index}>\n        <!-- Default fallback -->\n        <div>{item.name}: ${item.value}</div>\n      </slot>\n    </li>\n  {/each}\n</ul>\n\n<style>\n  .data-list {\n    list-style: none;\n    padding: 0;\n  }\n  \n  li {\n    padding: 0.5rem;\n    border-bottom: 1px solid #eee;\n  }\n</style>\n```\n\n### Complex Example with Nested Components and Slots\n\nHere's a more complex example showing how to use `<svelte:component>` with nested components and slots:\n\n```svelte\n<script>\n  import ModalLayout from './layouts/ModalLayout.svelte';\n  import SidebarLayout from './layouts/SidebarLayout.svelte';\n  import FullscreenLayout from './layouts/FullscreenLayout.svelte';\n  \n  const layouts = {\n    modal: ModalLayout,\n    sidebar: SidebarLayout,\n    fullscreen: FullscreenLayout\n  };\n  \n  let currentLayout = 'modal';\n  \n  function setLayout(layout) {\n    if (layouts[layout]) {\n      currentLayout = layout;\n    }\n  }\n</script>\n\n<div class=\"layout-switcher\">\n  <button on:click={() => setLayout('modal')}>Modal</button>\n  <button on:click={() => setLayout('sidebar')}>Sidebar</button>\n  <button on:click={() => setLayout('fullscreen')}>Fullscreen</button>\n</div>\n\n<svelte:component this={layouts[currentLayout]}>\n  <svelte:fragment slot=\"header\" let:close>\n    <h2>Dynamic Layout Example</h2>\n    {#if close}\n      <button on:click={close}>Ã</button>\n    {/if}\n  </svelte:fragment>\n  \n  <div slot=\"content\">\n    <p>This is the main content area that adapts to different layouts.</p>\n    <p>Current layout: <strong>{currentLayout}</strong></p>\n  </div>\n  \n  <svelte:fragment slot=\"footer\" let:layout let:confirm>\n    <p>Layout-specific footer for {layout} view</p>\n    {#if confirm}\n      <button on:click={confirm}>Confirm</button>\n    {/if}\n  </svelte:fragment>\n</svelte:component>\n```\n\nIn these examples, the slot content and slot props work consistently regardless of which component is currently active. This allows you to create flexible UI systems where the container component can change while maintaining a consistent interface for the content."}
{"source":"docs/svelte/99-legacy/30-legacy-svelte-component.md","question":"How does Svelte 5's handling of dynamic components compare between legacy mode and runes mode, and what are the migration considerations?","answer":"Svelte 5 introduces significant changes to how dynamic components are handled when moving from legacy mode to runes mode. Understanding these differences is crucial for successful migration.\n\n### Core Differences\n\n**Legacy Mode:**\n- Requires `<svelte:component this={Component}>` for dynamic component rendering\n- Component references don't automatically update when the reference changes\n- Explicit syntax needed to destroy and recreate component instances\n\n**Runes Mode:**\n- Direct component references (`<Component />`) automatically update when the reference changes\n- `<svelte:component>` is still supported but often unnecessary\n- More intuitive and consistent with how other reactive values work\n\n### Migration Considerations\n\n#### 1. Direct Component References\n\n**Legacy Mode:**\n```svelte\n<script>\n  import ComponentA from './ComponentA.svelte';\n  import ComponentB from './ComponentB.svelte';\n  \n  let current = ComponentA;\n  \n  function toggle() {\n    current = current === ComponentA ? ComponentB : ComponentA;\n  }\n</script>\n\n<button on:click={toggle}>Toggle</button>\n\n<!-- Must use svelte:component for dynamic behavior -->\n<svelte:component this={current} />\n```\n\n**Runes Mode:**\n```svelte\n<script>\n  import ComponentA from './ComponentA.svelte';\n  import ComponentB from './ComponentB.svelte';\n  \n  let current = $state(ComponentA);\n  \n  function toggle() {\n    current = current === ComponentA ? ComponentB : ComponentA;\n  }\n</script>\n\n<button on:click={toggle}>Toggle</button>\n\n<!-- Direct reference works dynamically -->\n<svelte:element this={current} />\n```\n\n#### 2. Conditional Component Rendering\n\n**Legacy Mode:**\n```svelte\n<script>\n  import UserView from './UserView.svelte';\n  import GuestView from './GuestView.svelte';\n  \n  export let isLoggedIn = false;\n  \n  $: component = isLoggedIn ? UserView : GuestView;\n</script>\n\n<svelte:component this={component} />\n```\n\n**Runes Mode:**\n```svelte\n<script>\n  import UserView from './UserView.svelte';\n  import GuestView from './GuestView.svelte';\n  \n  export let isLoggedIn = $prop(false);\n  \n  $derived component = isLoggedIn ? UserView : GuestView;\n</script>\n\n<!-- Can use either syntax -->\n<svelte:element this={component} />\n<!-- or -->\n{#if isLoggedIn}\n  <UserView />\n{:else}\n  <GuestView />\n{/if}\n```\n\n#### 3. Component Maps and Lookups\n\n**Legacy Mode:**\n```svelte\n<script>\n  import Home from './pages/Home.svelte';\n  import About from './pages/About.svelte';\n  import Contact from './pages/Contact.svelte';\n  \n  const pages = {\n    home: Home,\n    about: About,\n    contact: Contact\n  };\n  \n  let currentPage = 'home';\n</script>\n\n<nav>\n  <button on:click={() => currentPage = 'home'}>Home</button>\n  <button on:click={() => currentPage = 'about'}>About</button>\n  <button on:click={() => currentPage = 'contact'}>Contact</button>\n</nav>\n\n<svelte:component this={pages[currentPage]} />\n```\n\n**Runes Mode:**\n```svelte\n<script>\n  import Home from './pages/Home.svelte';\n  import About from './pages/About.svelte';\n  import Contact from './pages/Contact.svelte';\n  \n  const pages = {\n    home: Home,\n    about: About,\n    contact: Contact\n  };\n  \n  let currentPage = $state('home');\n  $derived currentComponent = pages[currentPage];\n</script>\n\n<nav>\n  <button on:click={() => currentPage = 'home'}>Home</button>\n  <button on:click={() => currentPage = 'about'}>About</button>\n  <button on:click={() => currentPage = 'contact'}>Contact</button>\n</nav>\n\n<!-- Both work -->\n<svelte:element this={currentComponent} />\n<!-- or -->\n<svelte:component this={currentComponent} />\n```\n\n### Migration Strategy\n\nWhen migrating from legacy mode to runes mode, consider these steps:\n\n1. **Identify Dynamic Component Usage**: Find all instances of `<svelte:component>` in your codebase.\n\n2. **Evaluate Each Case**: Determine if direct component references would be clearer and more maintainable.\n\n3. **Update State Management**: Convert reactive statements to use `$state` and `$derived` for component references.\n\n4. **Test Thoroughly**: The behavior should be the same, but test to ensure components update correctly when references change.\n\n5. **Consider Special Cases**: For more complex scenarios (like async components), you might want to keep using `<svelte:component>` for clarity.\n\n### Backward Compatibility Considerations\n\nIf you're building a library that needs to work with both legacy and runes mode:\n\n```svelte\n<script>\n  // Detect if we're in runes mode\n  const isRunesMode = typeof $state === 'function';\n  \n  // Component reference that works in both modes\n  let componentRef = isRunesMode ? $state(DefaultComponent) : DefaultComponent;\n  \n  // Update function that works in both modes\n  function updateComponent(newComponent) {\n    componentRef = newComponent;\n  }\n</script>\n\n<!-- Works in both modes -->\n<svelte:component this={componentRef} />\n```\n\n### Performance Considerations\n\nIn runes mode, the automatic reactivity of component references might lead to unnecessary re-renders if you're not careful. Consider memoizing component references that are derived from complex calculations:\n\n```svelte\n<script>\n  // Avoid unnecessary recalculations\n  $derived:memoized expensiveComponent = calculateExpensiveComponent(someData);\n</script>\n```\n\nBy understanding these differences and migration considerations, you can effectively transition your dynamic component rendering from legacy mode to runes mode while taking advantage of the simpler and more intuitive approach in Svelte 5's runes mode."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"What is the purpose of the `<svelte:self>` element in Svelte, and what problem does it solve?","answer":"The `<svelte:self>` element in Svelte allows a component to recursively include itself within its own template. This solves the problem of creating recursive component structures without having to define separate components.\n\nThe primary use case is for rendering recursive data structures like trees, nested comments, or any hierarchical data where the same component logic needs to be applied at each level of nesting.\n\nWithout `<svelte:self>`, developers would need workarounds like creating separate but identical components or using complex dynamic imports, which would be less elegant and more difficult to maintain.\n\n```svelte\n<script>\n\texport let count;\n</script>\n\n{#if count > 0}\n\t<p>counting down... {count}</p>\n\t<svelte:self count={count - 1} />\n{:else}\n\t<p>lift-off!</p>\n{/if}\n```\n\nIn this example, the component recursively renders itself with a decremented count until reaching zero, demonstrating how `<svelte:self>` enables a clean implementation of a countdown."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"What restrictions exist when using the `<svelte:self>` element and why are these restrictions necessary?","answer":"When using the `<svelte:self>` element, there are important restrictions to prevent infinite rendering loops:\n\n1. It cannot appear at the top level of your markup\n2. It must be inside an if block, each block, or passed to a component's slot\n\nThese restrictions are necessary because without them, the component would try to render itself infinitely, causing the application to crash. By requiring conditional rendering or iteration, Svelte ensures there's a termination condition for the recursion.\n\nFor example, this would cause an infinite loop and is not allowed:\n\n```svelte\n<!-- DON'T DO THIS - will cause infinite recursion -->\n<script>\n\texport let data;\n</script>\n\n<div>Some content</div>\n<svelte:self data={data} /> <!-- ERROR: Unconditional recursion -->\n```\n\nInstead, you must use it within a conditional block that has a termination case:\n\n```svelte\n<script>\n\texport let items = [];\n</script>\n\n<ul>\n\t{#each items as item}\n\t\t<li>\n\t\t\t{item.name}\n\t\t\t{#if item.children && item.children.length}\n\t\t\t\t<svelte:self items={item.children} />\n\t\t\t{/if}\n\t\t</li>\n\t{/each}\n</ul>\n```\n\nThis properly renders a nested tree structure with a clear termination condition."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"How has the approach to recursive components evolved in newer versions of Svelte compared to the legacy `<svelte:self>` approach?","answer":"In newer versions of Svelte, the `<svelte:self>` element is considered obsolete. The modern approach allows components to simply import themselves directly, which is more intuitive and consistent with how other component imports work.\n\nLegacy approach with `<svelte:self>`:\n```svelte\n<script>\n\texport let count;\n</script>\n\n{#if count > 0}\n\t<p>counting down... {count}</p>\n\t<svelte:self count={count - 1} />\n{:else}\n\t<p>lift-off!</p>\n{/if}\n```\n\nModern approach with self-import:\n```svelte\n<!--- file: App.svelte --->\n<script>\n\timport Self from './App.svelte'\n\texport let count;\n</script>\n\n{#if count > 0}\n\t<p>counting down... {count}</p>\n\t<Self count={count - 1} />\n{:else}\n\t<p>lift-off!</p>\n{/if}\n```\n\nThe evolution reflects Svelte's philosophy of using standard JavaScript module imports where possible rather than introducing special syntax. This change makes recursive components more consistent with how other components are used and may be easier for newcomers to understand since it doesn't require learning a special element.\n\nThe self-import approach also provides better editor support, including features like auto-completion and type checking, since the import is explicit and recognized by development tools."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"What are some practical use cases where you might want to use recursive components in Svelte applications?","answer":"Recursive components are particularly useful for rendering hierarchical or nested data structures. Here are some practical use cases:\n\n1. **File/Folder Tree Views**: Displaying nested directory structures where folders can contain both files and other folders.\n\n```svelte\n<script>\n\timport Self from './FileTree.svelte';\n\texport let files = [];\n</script>\n\n<ul class=\"file-tree\">\n\t{#each files as file}\n\t\t<li>\n\t\t\t<span class={file.type}>{file.name}</span>\n\t\t\t{#if file.type === 'folder' && file.children.length}\n\t\t\t\t<Self files={file.children} />\n\t\t\t{/if}\n\t\t</li>\n\t{/each}\n</ul>\n```\n\n2. **Comment Threads**: Rendering nested comments and their replies, common in forums or social media applications.\n\n```svelte\n<script>\n\timport Self from './Comment.svelte';\n\texport let comment;\n</script>\n\n<div class=\"comment\">\n\t<div class=\"content\">\n\t\t<h3>{comment.author}</h3>\n\t\t<p>{comment.text}</p>\n\t</div>\n\t\n\t{#if comment.replies && comment.replies.length}\n\t\t<div class=\"replies\">\n\t\t\t{#each comment.replies as reply}\n\t\t\t\t<Self comment={reply} />\n\t\t\t{/each}\n\t\t</div>\n\t{/if}\n</div>\n```\n\n3. **Menu Systems**: Creating multi-level navigation menus where each item might have its own sub-menu.\n\n4. **Organization Charts**: Displaying company hierarchies or team structures.\n\n5. **JSON/XML Viewers**: Creating expandable/collapsible views of nested data structures.\n\n6. **Category Trees**: Showing product categories and subcategories in e-commerce applications.\n\n7. **Decision Trees**: Visualizing branching decision paths in applications like surveys or diagnostic tools.\n\nThe key advantage in all these cases is that the same component logic can be reused at every level of nesting, making the code more maintainable and DRY (Don't Repeat Yourself)."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"How would you implement a recursive component to display a nested JSON object with expandable/collapsible nodes?","answer":"Here's how to implement a recursive component for displaying a nested JSON object with expandable/collapsible nodes:\n\n```svelte\n<!-- JSONViewer.svelte -->\n<script>\n\timport JSONViewer from './JSONViewer.svelte';\n\t\n\texport let data;\n\texport let name = '';\n\texport let isRoot = false;\n\t\n\tlet expanded = isRoot;\n\t\n\tfunction toggle() {\n\t\texpanded = !expanded;\n\t}\n\t\n\tfunction getType(value) {\n\t\tif (Array.isArray(value)) return 'array';\n\t\treturn typeof value;\n\t}\n\t\n\tfunction getChildrenCount(value) {\n\t\tif (Array.isArray(value)) return value.length;\n\t\tif (typeof value === 'object' && value !== null) return Object.keys(value).length;\n\t\treturn 0;\n\t}\n</script>\n\n<div class=\"json-item\">\n\t{#if name}\n\t\t<span class=\"key\">{name}: </span>\n\t{/if}\n\t\n\t{#if ['object', 'array'].includes(getType(data)) && data !== null}\n\t\t<span \n\t\t\tclass=\"toggle {expanded ? 'expanded' : 'collapsed'}\" \n\t\t\ton:click={toggle}\n\t\t>\n\t\t\t{expanded ? 'â¼' : 'âº'}\n\t\t</span>\n\t\t\n\t\t<span class=\"preview\" on:click={toggle}>\n\t\t\t{getType(data) === 'array' ? '[' : '{'}\n\t\t\t{#if !expanded}\n\t\t\t\t<em>{getChildrenCount(data)} items</em>\n\t\t\t{/if}\n\t\t\t{getType(data) === 'array' ? ']' : '}'}\n\t\t</span>\n\t\t\n\t\t{#if expanded}\n\t\t\t<div class=\"children\">\n\t\t\t\t{#if getType(data) === 'array'}\n\t\t\t\t\t{#each data as item, i}\n\t\t\t\t\t\t<JSONViewer data={item} name={i.toString()} />\n\t\t\t\t\t{/each}\n\t\t\t\t{:else}\n\t\t\t\t\t{#each Object.entries(data) as [key, value]}\n\t\t\t\t\t\t<JSONViewer data={value} name={key} />\n\t\t\t\t\t{/each}\n\t\t\t\t{/if}\n\t\t\t</div>\n\t\t{/if}\n\t{:else}\n\t\t<span class=\"value {getType(data)}\">\n\t\t\t{#if data === null}\n\t\t\t\tnull\n\t\t\t{:else if typeof data === 'string'}\n\t\t\t\t\"{data}\"\n\t\t\t{:else if typeof data === 'undefined'}\n\t\t\t\tundefined\n\t\t\t{:else}\n\t\t\t\t{String(data)}\n\t\t\t{/if}\n\t\t</span>\n\t{/if}\n</div>\n\n<style>\n\t.json-item {\n\t\tfont-family: monospace;\n\t\tmargin-left: 1.5em;\n\t}\n\t\n\t.key {\n\t\tcolor: #881391;\n\t}\n\t\n\t.value {\n\t\tdisplay: inline;\n\t}\n\t\n\t.value.string {\n\t\tcolor: #c41a16;\n\t}\n\t\n\t.value.number {\n\t\tcolor: #1c00cf;\n\t}\n\t\n\t.value.boolean {\n\t\tcolor: #1c00cf;\n\t}\n\t\n\t.toggle {\n\t\tcursor: pointer;\n\t\tfont-size: 0.8em;\n\t\tmargin-right: 0.3em;\n\t}\n\t\n\t.preview {\n\t\tcursor: pointer;\n\t}\n\t\n\t.preview em {\n\t\tcolor: #777;\n\t\tfont-style: italic;\n\t}\n\t\n\t.children {\n\t\tmargin-left: 1em;\n\t\tborder-left: 1px dotted #ccc;\n\t\tpadding-left: 0.5em;\n\t}\n</style>\n```\n\nUsage example:\n\n```svelte\n<script>\n\timport JSONViewer from './JSONViewer.svelte';\n\t\n\tconst sampleData = {\n\t\tname: \"Project\",\n\t\tversion: 1.0,\n\t\tactive: true,\n\t\tcontributors: [\n\t\t\t{\n\t\t\t\tname: \"Alice\",\n\t\t\t\trole: \"Developer\",\n\t\t\t\tskills: [\"JavaScript\", \"Svelte\", \"CSS\"]\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Bob\",\n\t\t\t\trole: \"Designer\",\n\t\t\t\tskills: [\"Figma\", \"UI/UX\", \"CSS\"]\n\t\t\t}\n\t\t],\n\t\tmetadata: {\n\t\t\tcreated: \"2023-01-15\",\n\t\t\tlastModified: null,\n\t\t\tconfig: {\n\t\t\t\tdebug: false,\n\t\t\t\tenvironment: \"production\"\n\t\t\t}\n\t\t}\n\t};\n</script>\n\n<div class=\"json-viewer-container\">\n\t<h2>JSON Viewer Example</h2>\n\t<JSONViewer data={sampleData} isRoot={true} />\n</div>\n```\n\nThis implementation:\n1. Recursively renders each level of the JSON structure\n2. Provides expand/collapse functionality\n3. Color-codes different data types\n4. Shows a preview of collapsed objects/arrays with item counts\n5. Handles all JSON data types (objects, arrays, strings, numbers, booleans, null)\n\nThe component uses the modern self-import approach rather than the legacy `<svelte:self>` syntax."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"How would performance considerations differ between using `<svelte:self>` and directly importing a component for recursion?","answer":"When comparing the performance between using `<svelte:self>` and directly importing a component for recursion, several considerations come into play:\n\n**Bundle Size**:\n- **Self-import**: May slightly increase the initial bundle size because the import statement creates a more explicit dependency that bundlers need to handle.\n- **`<svelte:self>`**: May result in a slightly smaller initial bundle since it's a special element handled internally by Svelte.\n\n**Compilation Efficiency**:\n- **Self-import**: The Svelte compiler needs to process the explicit import, which could potentially lead to more complex compilation.\n- **`<svelte:self>`**: The compiler recognizes this as a special case and can optimize for it specifically.\n\n**Runtime Performance**:\n- In practice, there should be virtually no runtime performance difference between the two approaches. Both create the same component instances and DOM structures at runtime.\n- The actual performance bottleneck in recursive components is typically the depth of recursion rather than the method used to achieve it.\n\n**Code Splitting**:\n- **Self-import**: May work better with modern bundlers for code-splitting optimizations since the import is explicit.\n- **`<svelte:self>`**: Might be treated as a special case that doesn't integrate as well with code-splitting.\n\n**Memory Usage**:\n- Both approaches will have identical memory usage patterns as they create the same component tree structure.\n\nExample of potential performance optimization with either approach (applicable to both):\n\n```svelte\n<script>\n\timport Self from './TreeNode.svelte'; // Or use <svelte:self> below\n\t\n\texport let node;\n\texport let maxDepth = Infinity;\n\texport let currentDepth = 0;\n\t\n\t// Prevent excessive recursion depth\n\tconst nextDepth = currentDepth + 1;\n\tconst canRecurse = nextDepth <= maxDepth;\n</script>\n\n<div class=\"node\">\n\t<span>{node.label}</span>\n\t\n\t{#if node.children && node.children.length && canRecurse}\n\t\t<div class=\"children\">\n\t\t\t{#each node.children as child}\n\t\t\t\t<!-- Using import -->\n\t\t\t\t<Self node={child} maxDepth={maxDepth} currentDepth={nextDepth} />\n\t\t\t\t\n\t\t\t\t<!-- Or using <svelte:self> -->\n\t\t\t\t<!-- <svelte:self node={child} maxDepth={maxDepth} currentDepth={nextDepth} /> -->\n\t\t\t{/each}\n\t\t</div>\n\t{:else if node.children && node.children.length}\n\t\t<div class=\"max-depth-reached\">\n\t\t\t<span>{node.children.length} more items (max depth reached)</span>\n\t\t</div>\n\t{/if}\n</div>\n```\n\nIn summary, while there might be subtle differences in how the compiler and bundler handle these two approaches, the runtime performance is nearly identical. The choice between them should be based more on code style preferences and whether you're using the latest Svelte features rather than performance concerns."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"What potential issues might arise when using recursive components, and how can you prevent infinite recursion?","answer":"Recursive components can introduce several potential issues if not implemented carefully:\n\n### Potential Issues\n\n1. **Infinite Recursion**: The most critical issue is the possibility of infinite recursion, which will crash the browser by exceeding the call stack limit.\n\n2. **Performance Degradation**: Even with finite recursion, deeply nested structures can cause performance issues with many component instances.\n\n3. **Memory Leaks**: Improper cleanup of recursive components can lead to memory leaks, especially if event listeners or subscriptions are involved.\n\n4. **SEO Problems**: Excessive DOM nesting from deep recursion can make content less accessible to search engines.\n\n5. **Accessibility Issues**: Deeply nested interactive elements might create navigation challenges for assistive technologies.\n\n### Preventing Infinite Recursion\n\nHere are strategies to prevent infinite recursion:\n\n1. **Conditional Rendering**: Always wrap `<svelte:self>` or the recursive component import in a conditional block:\n\n```svelte\n<script>\n\timport TreeNode from './TreeNode.svelte';\n\texport let node;\n</script>\n\n<div>{node.name}</div>\n\n{#if node.children && node.children.length}\n\t{#each node.children as child}\n\t\t<TreeNode node={child} />\n\t{/each}\n{/if}\n```\n\n2. **Depth Limiting**: Explicitly track and limit recursion depth:\n\n```svelte\n<script>\n\timport TreeNode from './TreeNode.svelte';\n\texport let node;\n\texport let currentDepth = 0;\n\texport let maxDepth = 10; // Set a reasonable limit\n</script>\n\n<div>{node.name}</div>\n\n{#if node.children && node.children.length && currentDepth < maxDepth}\n\t<div class=\"children\">\n\t\t{#each node.children as child}\n\t\t\t<TreeNode \n\t\t\t\tnode={child}\n\t\t\t\tcurrentDepth={currentDepth + 1}\n\t\t\t\tmaxDepth={maxDepth}\n\t\t\t/>\n\t\t{/each}\n\t</div>\n{:else if node.children && node.children.length}\n\t<div class=\"more-indicator\">More items not shown...</div>\n{/if}\n```\n\n3. **Path Tracking**: For tree structures where cycles might exist, track the path:\n\n```svelte\n<script>\n\timport TreeNode from './TreeNode.svelte';\n\texport let node;\n\texport let path = [];\n\t\n\t// Check if this node is already in the ancestry path (cycle detection)\n\tconst hasCycle = path.includes(node.id);\n\t\n\t// Create a new path array with current node added\n\tconst newPath = [...path, node.id];\n</script>\n\n<div>\n\t{node.name}\n\t{#if hasCycle}\n\t\t<span class=\"cycle-warning\">(Circular reference detected)</span>\n\t{/if}\n</div>\n\n{#if node.children && node.children.length && !hasCycle}\n\t<div class=\"children\">\n\t\t{#each node.children as child}\n\t\t\t<TreeNode \n\t\t\t\tnode={child}\n\t\t\t\tpath={newPath}\n\t\t\t/>\n\t\t{/each}\n\t</div>\n{/if}\n```\n\n4. **Lazy Loading**: For large trees, implement lazy loading to render branches only when needed:\n\n```svelte\n<script>\n\timport TreeNode from './TreeNode.svelte';\n\texport let node;\n\t\n\tlet expanded = false;\n\t\n\tfunction toggleExpand() {\n\t\texpanded = !expanded;\n\t}\n</script>\n\n<div>\n\t<button on:click={toggleExpand}>\n\t\t{expanded ? 'â¼' : 'âº'} {node.name}\n\t</button>\n\t\n\t{#if expanded && node.children && node.children.length}\n\t\t<div class=\"children\">\n\t\t\t{#each node.children as child}\n\t\t\t\t<TreeNode node={child} />\n\t\t\t{/each}\n\t\t</div>\n\t{/if}\n</div>\n```\n\n5. **Virtualization**: For very large data sets, consider a virtualized list that only renders visible items:\n\n```svelte\n<script>\n\timport { onMount } from 'svelte';\n\timport TreeNode from './TreeNode.svelte';\n\texport let nodes = [];\n\t\n\tlet visibleNodes = [];\n\t\n\tonMount(() => {\n\t\t// Logic to determine which nodes should be visible\n\t\t// based on viewport and scroll position\n\t\t// This is simplified - a real implementation would use\n\t\t// intersection observers or scroll events\n\t\tvisibleNodes = nodes.slice(0, 20);\n\t});\n</script>\n\n<div class=\"virtual-tree\">\n\t{#each visibleNodes as node}\n\t\t<TreeNode node={node} />\n\t{/each}\n</div>\n```\n\nBy implementing these strategies, you can create robust recursive components that avoid infinite recursion and perform well even with complex nested data structures."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"How can you implement a recursive component for rendering a threaded comment system with replies in Svelte?","answer":"Here's a comprehensive implementation of a threaded comment system with replies using recursive components in Svelte:\n\n```svelte\n<!-- Comment.svelte -->\n<script>\n\timport { fly, slide } from 'svelte/transition';\n\timport Comment from './Comment.svelte'; // Self-import for recursion\n\timport { formatDistanceToNow } from 'date-fns';\n\t\n\texport let comment;\n\texport let depth = 0;\n\texport let maxDepth = 8;\n\t\n\t// UI state\n\tlet replying = false;\n\tlet replyText = '';\n\tlet showReplies = true;\n\t\n\t// Mock user data - in a real app, this would come from auth\n\tconst currentUser = {\n\t\tid: 'user123',\n\t\tname: 'Current User',\n\t\tavatar: 'https://placekitten.com/100/100'\n\t};\n\t\n\t// Format the comment date\n\t$: formattedDate = formatDistanceToNow(new Date(comment.date), { addSuffix: true });\n\t\n\t// Determine if we've reached max nesting depth\n\t$: canShowNestedReplies = depth < maxDepth;\n\t\n\t// Toggle reply form\n\tfunction toggleReply() {\n\t\treplying = !replying;\n\t\tif (replying) {\n\t\t\t// Focus the textarea when opening the reply form\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.getElementById(`reply-${comment.id}`).focus();\n\t\t\t}, 0);\n\t\t}\n\t}\n\t\n\t// Toggle showing replies\n\tfunction toggleReplies() {\n\t\tshowReplies = !showReplies;\n\t}\n\t\n\t// Submit a reply\n\tfunction submitReply() {\n\t\tif (!replyText.trim()) return;\n\t\t\n\t\t// In a real app, this would make an API call\n\t\tconst newReply = {\n\t\t\tid: `reply-${Date.now()}`,\n\t\t\tauthor: currentUser.name,\n\t\t\tauthorId: currentUser.id,\n\t\t\tavatar: currentUser.avatar,\n\t\t\tcontent: replyText,\n\t\t\tdate: new Date().toISOString(),\n\t\t\tlikes: 0,\n\t\t\treplies: []\n\t\t};\n\t\t\n\t\t// Add the reply to the comment\n\t\tcomment.replies = [newReply, ...comment.replies];\n\t\t\n\t\t// Reset form\n\t\treplyText = '';\n\t\treplying = false;\n\t\tshowReplies = true;\n\t}\n\t\n\t// Like a comment\n\tfunction likeComment() {\n\t\tcomment.likes += 1;\n\t\t// In a real app, make an API call to update the like count\n\t}\n</script>\n\n<div class=\"comment\" style=\"margin-left: {depth * 20}px\">\n\t<div class=\"comment-header\">\n\t\t<img src={comment.avatar} alt={comment.author} class=\"avatar\" />\n\t\t<div class=\"meta\">\n\t\t\t<span class=\"author\">{comment.author}</span>\n\t\t\t<span class=\"date\">{formattedDate}</span>\n\t\t</div>\n\t</div>\n\t\n\t<div class=\"comment-body\">\n\t\t<p>{comment.content}</p>\n\t</div>\n\t\n\t<div class=\"comment-actions\">\n\t\t<button class=\"action-btn\" on:click={likeComment}>\n\t\t\tð {comment.likes}\n\t\t</button>\n\t\t<button class=\"action-btn\" on:click={toggleReply}>\n\t\t\tReply\n\t\t</button>\n\t\t{#if comment.replies && comment.replies.length > 0}\n\t\t\t<button class=\"action-btn\" on:click={toggleReplies}>\n\t\t\t\t{showReplies ? 'Hide replies' : `Show replies (${comment.replies.length})`}\n\t\t\t</button>\n\t\t{/if}\n\t</div>\n\t\n\t{#if replying}\n\t\t<div class=\"reply-form\" transition:slide={{ duration: 200 }}>\n\t\t\t<textarea \n\t\t\t\tid=\"reply-{comment.id}\"\n\t\t\t\tbind:value={replyText} \n\t\t\t\tplaceholder=\"Write your reply...\"\n\t\t\t\trows=\"3\"\n\t\t\t></textarea>\n\t\t\t<div class=\"form-actions\">\n\t\t\t\t<button class=\"cancel-btn\" on:click={toggleReply}>Cancel</button>\n\t\t\t\t<button class=\"submit-btn\" on:click={submitReply} disabled={!replyText.trim()}>\n\t\t\t\t\tSubmit\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t</div>\n\t{/if}\n\t\n\t{#if comment.replies && comment.replies.length > 0 && showReplies}\n\t\t<div class=\"replies\" transition:slide={{ duration: 200 }}>\n\t\t\t{#if canShowNestedReplies}\n\t\t\t\t{#each comment.replies as reply (reply.id)}\n\t\t\t\t\t<div transition:fly={{ y: 20, duration: 200 }}>\n\t\t\t\t\t\t<Comment comment={reply} depth={depth + 1} maxDepth={maxDepth} />\n\t\t\t\t\t</div>\n\t\t\t\t{/each}\n\t\t\t{:else}\n\t\t\t\t<div class=\"max-depth-notice\">\n\t\t\t\t\t<a href={`/comments/${comment.id}/replies`}>\n\t\t\t\t\t\tView {comment.replies.length} more replies\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t{/if}\n\t\t</div>\n\t{/if}\n</div>\n\n<style>\n\t.comment {\n\t\tbackground-color: #f9f9f9;\n\t\tborder-radius: 8px;\n\t\tpadding: 16px;\n\t\tmargin-bottom: 16px;\n\t\tbox-shadow: 0 1px 3px rgba(0,0,0,0.1);\n\t}\n\t\n\t.comment-header {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tmargin-bottom: 12px;\n\t}\n\t\n\t.avatar {\n\t\twidth: 40px;\n\t\theight: 40px;\n\t\tborder-radius: 50%;\n\t\tmargin-right: 12px;\n\t\tobject-fit: cover;\n\t}\n\t\n\t.meta {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t}\n\t\n\t.author {\n\t\tfont-weight: bold;\n\t\tfont-size: 16px;\n\t}\n\t\n\t.date {\n\t\tfont-size: 12px;\n\t\tcolor: #666;\n\t}\n\t\n\t.comment-body {\n\t\tmargin-bottom: 12px;\n\t\tline-height: 1.5;\n\t}\n\t\n\t.comment-actions {\n\t\tdisplay: flex;\n\t\tgap: 12px;\n\t\tmargin-bottom: 12px;\n\t}\n\t\n\t.action-btn {\n\t\tbackground: transparent;\n\t\tborder: none;\n\t\tcursor: pointer;\n\t\tcolor: #555;\n\t\tfont-size: 14px;\n\t\tpadding: 4px 8px;\n\t\tborder-radius: 4px;\n\t}\n\t\n\t.action-btn:hover {\n\t\tbackground-color: #eee;\n\t}\n\t\n\t.reply-form {\n\t\tmargin-top: 12px;\n\t\tmargin-bottom: 16px;\n\t}\n\t\n\ttextarea {\n\t\twidth: 100%;\n\t\tpadding: 12px;\n\t\tborder: 1px solid #ddd;\n\t\tborder-radius: 4px;\n\t\tresize: vertical;\n\t\tfont-family: inherit;\n\t\tfont-size: 14px;\n\t}\n\t\n\t.form-actions {\n\t\tdisplay: flex;\n\t\tjustify-content: flex-end;\n\t\tgap: 8px;\n\t\tmargin-top: 8px;\n\t}\n\t\n\t.cancel-btn {\n\t\tbackground: transparent;\n\t\tborder: 1px solid #ddd;\n\t\tpadding: 6px 12px;\n\t\tborder-radius: 4px;\n\t\tcursor: pointer;\n\t}\n\t\n\t.submit-btn {\n\t\tbackground: #4a76a8;\n\t\tcolor: white;\n\t\tborder: none;\n\t\tpadding: 6px 12px;\n\t\tborder-radius: 4px;\n\t\tcursor: pointer;\n\t}\n\t\n\t.submit-btn:disabled {\n\t\tbackground: #cccccc;\n\t\tcursor: not-allowed;\n\t}\n\t\n\t.replies {\n\t\tmargin-top: 16px;\n\t}\n\t\n\t.max-depth-notice {\n\t\tpadding: 12px;\n\t\tbackground-color: #f0f0f0;\n\t\tborder-radius: 4px;\n\t\ttext-align: center;\n\t}\n\t\n\t.max-depth-notice a {\n\t\tcolor: #4a76a8;\n\t\ttext-decoration: none;\n\t\tfont-weight: bold;\n\t}\n</style>\n```\n\nTo use this comment component, create a parent component:\n\n```svelte\n<!-- CommentSection.svelte -->\n<script>\n\timport Comment from './Comment.svelte';\n\t\n\t// Sample data - in a real app, this would come from an API\n\tlet comments = [\n\t\t{\n\t\t\tid: 'comment1',\n\t\t\tauthor: 'Jane Smith',\n\t\t\tauthorId: 'user456',\n\t\t\tavatar: 'https://placekitten.com/101/101',\n\t\t\tcontent: 'This is a great article! I learned a lot about Svelte components.',\n\t\t\tdate: '2023-06-15T10:30:00Z',\n\t\t\tlikes: 5,\n\t\t\treplies: [\n\t\t\t\t{\n\t\t\t\t\tid: 'reply1',\n\t\t\t\t\tauthor: 'John Doe',\n\t\t\t\t\tauthorId: 'user789',\n\t\t\t\t\tavatar: 'https://placekitten.com/102/102',\n\t\t\t\t\tcontent: 'I agree! The recursive component examples were particularly helpful.',\n\t\t\t\t\tdate: '2023-06-15T11:15:00Z',\n\t\t\t\t\tlikes: 2,\n\t\t\t\t\treplies: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: 'reply2',\n\t\t\t\t\t\t\tauthor: 'Jane Smith',\n\t\t\t\t\t\t\tauthorId: 'user456',\n\t\t\t\t\t\t\tavatar: 'https://placekitten.com/101/101',\n\t\t\t\t\t\t\tcontent: 'Yes, I\\'m going to use that pattern in my next project!',\n\t\t\t\t\t\t\tdate: '2023-06-15T12:00:00Z',\n\t\t\t\t\t\t\tlikes: 1,\n\t\t\t\t\t\t\treplies: []\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\tid: 'comment2',\n\t\t\tauthor: 'Alex Johnson',\n\t\t\tauthorId: 'user101',\n\t\t\tavatar: 'https://placekitten.com/103/103',\n\t\t\tcontent: 'Has anyone tried using this with TypeScript? Any gotchas I should be aware of?',\n\t\t\tdate: '2023-06-16T09:45:00Z',\n\t\t\tlikes: 3,\n\t\t\treplies: []\n\t\t}\n\t];\n\t\n\t// New comment state\n\tlet newCommentText = '';\n\t\n\t// Current user info\n\tconst currentUser = {\n\t\tid: 'user123',\n\t\tname: 'Current User',\n\t\tavatar: 'https://placekitten.com/100/100'\n\t};\n\t\n\t// Add a new top-level comment\n\tfunction addComment() {\n\t\tif (!newCommentText.trim()) return;\n\t\t\n\t\tconst newComment = {\n\t\t\tid: `comment-${Date.now()}`,\n\t\t\tauthor: currentUser.name,\n\t\t\tauthorId: currentUser.id,\n\t\t\tavatar: currentUser.avatar,\n\t\t\tcontent: newCommentText,\n\t\t\tdate: new Date().toISOString(),\n\t\t\tlikes: 0,\n\t\t\treplies: []\n\t\t};\n\t\t\n\t\tcomments = [newComment, ...comments];\n\t\tnewCommentText = '';\n\t}\n</script>\n\n<div class=\"comment-section\">\n\t<h2>Comments ({comments.length})</h2>\n\t\n\t<div class=\"new-comment\">\n\t\t<img src={currentUser.avatar} alt={currentUser.name} class=\"avatar\" />\n\t\t<div class=\"input-area\">\n\t\t\t<textarea \n\t\t\t\tbind:value={newCommentText} \n\t\t\t\tplaceholder=\"Add a comment...\"\n\t\t\t\trows=\"3\"\n\t\t\t></textarea>\n\t\t\t<button \n\t\t\t\tclass=\"post-btn\" \n\t\t\t\ton:click={addComment} \n\t\t\t\tdisabled={!newCommentText.trim()}\n\t\t\t>\n\t\t\t\tPost Comment\n\t\t\t</button>\n\t\t</div>\n\t</div>\n\t\n\t<div class=\"comments-list\">\n\t\t{#each comments as comment (comment.id)}\n\t\t\t<Comment {comment} />\n\t\t{/each}\n\t</div>\n</div>\n\n<style>\n\t.comment-section {\n\t\tmax-width: 800px;\n\t\tmargin: 0 auto;\n\t\tpadding: 20px;\n\t}\n\t\n\th2 {\n\t\tmargin-bottom: 24px;\n\t\tcolor: #333;\n\t}\n\t\n\t.new-comment {\n\t\tdisplay: flex;\n\t\tgap: 16px;\n\t\tmargin-bottom: 32px;\n\t}\n\t\n\t.avatar {\n\t\twidth: 40px;\n\t\theight: 40px;\n\t\tborder-radius: 50%;\n\t\tobject-fit: cover;\n\t}\n\t\n\t.input-area {\n\t\tflex: 1;\n\t}\n\t\n\ttextarea {\n\t\twidth: 100%;\n\t\tpadding: 12px;\n\t\tborder: 1px solid #ddd;\n\t\tborder-radius: 4px;\n\t\tresize: vertical;\n\t\tfont-family: inherit;\n\t\tfont-size: 14px;\n\t\tmargin-bottom: 8px;\n\t}\n\t\n\t.post-btn {\n\t\tbackground: #4a76a8;\n\t\tcolor: white;\n\t\tborder: none;\n\t\tpadding: 8px 16px;\n\t\tborder-radius: 4px;\n\t\tcursor: pointer;\n\t\tfloat: right;\n\t}\n\t\n\t.post-btn:disabled {\n\t\tbackground: #cccccc;\n\t\tcursor: not-allowed;\n\t}\n</style>\n```\n\nThis implementation includes:\n\n1. Proper recursion with depth limiting to prevent excessive nesting\n2. Interactive features (replying, liking, showing/hiding replies)\n3. Animations for a better user experience\n4. Responsive design considerations\n5. Form validation\n6. Accessibility considerations with proper labeling and focus management\n7. Performance optimizations by conditionally rendering replies\n\nThe component uses the modern self-import approach instead of `<svelte:self>`, making it compatible with newer Svelte versions."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"What are the differences in the way Svelte handles recursive components compared to other popular frameworks like React or Vue?","answer":"# Recursive Components: Svelte vs. React vs. Vue\n\nRecursive components are handled differently across the major frontend frameworks. Here's a detailed comparison:\n\n## Svelte's Approach\n\nSvelte has two ways to create recursive components:\n\n1. **Legacy `<svelte:self>` Special Element**:\n```svelte\n<script>\n\texport let items = [];\n</script>\n\n<ul>\n\t{#each items as item}\n\t\t<li>\n\t\t\t{item.name}\n\t\t\t{#if item.children?.length}\n\t\t\t\t<svelte:self items={item.children} />\n\t\t\t{/if}\n\t\t</li>\n\t{/each}\n</ul>\n```\n\n2. **Modern Self-Import** (Preferred in newer versions):\n```svelte\n<script>\n\timport TreeNode from './TreeNode.svelte';\n\texport let items = [];\n</script>\n\n<ul>\n\t{#each items as item}\n\t\t<li>\n\t\t\t{item.name}\n\t\t\t{#if item.children?.length}\n\t\t\t\t<TreeNode items={item.children} />\n\t\t\t{/if}\n\t\t</li>\n\t{/each}\n</ul>\n```\n\n**Key Characteristics**:\n- Svelte explicitly prevents infinite recursion by requiring recursive components to be inside conditional blocks\n- The compiler optimizes the component for recursion\n- Svelte's reactivity system efficiently updates only changed parts of the recursive structure\n\n## React's Approach\n\nReact uses standard imports and references for recursive components:\n\n```jsx\nimport React from 'react';\n\nconst TreeNode = ({ items = [] }) => {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={index}>\n          {item.name}\n          {item.children?.length > 0 && (\n            <TreeNode items={item.children} />\n          )}\n        </li>\n      ))}\n    </ul>\n  );\n};\n\nexport default TreeNode;\n```\n\n**Key Characteristics**:\n- React relies on standard JavaScript module imports and references\n- Recursion must be manually guarded with conditional rendering\n- React's virtual DOM diffing algorithm must compare the entire recursive tree on updates\n- No special syntax or elements needed\n\n## Vue's Approach\n\nVue offers multiple ways to create recursive components:\n\n1. **Using component's name**:\n```vue\n<template>\n  <ul>\n    <li v-for=\"(item, index) in items\" :key=\"index\">\n      {{ item.name }}\n      <tree-node \n        v-if=\"item.children && item.children.length\"\n        :items=\"item.children\"\n      />\n    </li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  name: 'TreeNode', // Important for recursion\n  props: {\n    items: {\n      type: Array,\n      default: () => []\n    }\n  }\n};\n</script>\n```\n\n2. **Using local registration**:\n```vue\n<template>\n  <ul>\n    <li v-for=\"(item, index) in items\" :key=\"index\">\n      {{ item.name }}\n      <tree-node \n        v-if=\"item.children && item.children.length\"\n        :items=\"item.children\"\n      />\n    </li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  props: {\n    items: {\n      type: Array,\n      default: () => []\n    }\n  },\n  components: {\n    TreeNode: () => import('./TreeNode.vue') // Self-referential import\n  }\n};\n</script>\n```\n\n**Key Characteristics**:\n- Vue requires the component to have a name for self-reference in templates\n- Vue's reactivity system tracks dependencies and updates only necessary components\n- Conditional rendering must be explicitly added to prevent infinite recursion\n\n## Key Differences\n\n1. **Syntax and Explicitness**:\n   - Svelte: Offers a special `<svelte:self>` element or standard imports\n   - React: Uses standard imports and references\n   - Vue: Requires naming the component or local registration\n\n2. **Compiler Optimizations**:\n   - Svelte: The compiler can optimize recursive patterns specifically\n   - React: No special compiler optimizations for recursion\n   - Vue: Some template optimizations but less specific to recursion\n\n3. **Safeguards Against Infinite Recursion**:\n   - Svelte: Enforces conditional rendering for `<svelte:self>`\n   - React & Vue: Developer must implement safeguards manually\n\n4. **Performance Characteristics**:\n   - Svelte: Very efficient due to compile-time optimizations\n   - React: May be less efficient with deep trees due to virtual DOM diffing\n   - Vue: Efficient with shallow trees but may struggle with very deep recursion\n\n5. **Bundle Size Impact**:\n   - Svelte: Minimal impact on bundle size\n   - React: Component is included only once in the bundle\n   - Vue: Similar to React, included once with proper code-splitting\n\n6. **Developer Experience**:\n   - Svelte: Very clear with dedicated syntax in the legacy approach\n   - React: Follows standard JavaScript patterns\n   - Vue: Requires understanding Vue's component registration system\n\n## Example: Implementing the Same Tree Component\n\nTo illustrate the differences, here's how a tree component would be implemented in each framework:\n\n**Svelte**:\n```svelte\n<script>\n\timport TreeNode from './TreeNode.svelte';\n\texport let node;\n\texport let depth = 0;\n</script>\n\n<div class=\"node\" style=\"margin-left: {depth * 20}px\">\n\t<span>{node.label}</span>\n\t{#if node.children?.length}\n\t\t{#each node.children as child}\n\t\t\t<TreeNode node={child} depth={depth + 1} />\n\t\t{/each}\n\t{/if}\n</div>\n```\n\n**React**:\n```jsx\nimport React from 'react';\n\nconst TreeNode = ({ node, depth = 0 }) => {\n  return (\n    <div className=\"node\" style={{ marginLeft: depth * 20 }}>\n      <span>{node.label}</span>\n      {node.children?.length > 0 && (\n        node.children.map((child, index) => (\n          <TreeNode \n            key={index} \n            node={child} \n            depth={depth + 1} \n          />\n        ))\n      )}\n    </div>\n  );\n};\n\nexport default TreeNode;\n```\n\n**Vue**:\n```vue\n<template>\n  <div class=\"node\" :style=\"{ marginLeft: depth * 20 + 'px' }\">\n    <span>{{ node.label }}</span>\n    <tree-node\n      v-for=\"(child, index) in node.children\"\n      :key=\"index\"\n      :node=\"child\"\n      :depth=\"depth + 1\"\n      v-if=\"node.children && node.children.length\"\n    />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'TreeNode',\n  props: {\n    node: Object,\n    depth: {\n      type: Number,\n      default: 0\n    }\n  }\n};\n</script>\n```\n\nIn conclusion, while all three frameworks can implement recursive components, Svelte's approach tends to be more explicit and potentially more optimized due to its compilation step. The evolution from `<svelte:self>` to self-imports shows Svelte moving toward more standard JavaScript patterns while maintaining its performance advantages."}
{"source":"docs/svelte/99-legacy/31-legacy-svelte-self.md","question":"How would you migrate from using the legacy `<svelte:self>` approach to the modern self-import approach in an existing Svelte application?","answer":"# Migrating from `<svelte:self>` to Self-Import in Svelte\n\nMigrating from the legacy `<svelte:self>` element to the modern self-import approach in an existing Svelte application requires careful planning and execution. Here's a comprehensive guide to this migration process:\n\n## Step 1: Understand the Differences\n\nBefore beginning the migration, understand the key differences between the two approaches:\n\n**Legacy approach with `<svelte:self>`**:\n```svelte\n<script>\n\texport let items;\n</script>\n\n{#if items.length}\n\t<ul>\n\t\t{#each items as item}\n\t\t\t<li>\n\t\t\t\t{item.name}\n\t\t\t\t{#if item.children?.length}\n\t\t\t\t\t<svelte:self items={item.children} />\n\t\t\t\t{/if}\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n{/if}\n```\n\n**Modern approach with self-import**:\n```svelte\n<script>\n\timport TreeNode from './TreeNode.svelte';\n\texport let items;\n</script>\n\n{#if items.length}\n\t<ul>\n\t\t{#each items as item}\n\t\t\t<li>\n\t\t\t\t{item.name}\n\t\t\t\t{#if item.children?.length}\n\t\t\t\t\t<TreeNode items={item.children} />\n\t\t\t\t{/if}\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n{/if}\n```\n\n## Step 2: Create an Inventory of Recursive Components\n\nIdentify all components in your application that use `<svelte:self>`:\n\n```bash\ngrep -r \"<svelte:self\" --include=\"*.svelte\" ./src\n```\n\nCreate a list of these components, noting:\n- File path\n- Component name\n- Props passed to `<svelte:self>`\n- Conditional logic surrounding the recursive calls\n\n## Step 3: Develop a Migration Strategy\n\nChoose between these migration approaches:\n\n1. **Big Bang**: Migrate all components at once (suitable for smaller apps)\n2. **Incremental**: Migrate one component at a time (better for larger apps)\n3. **Parallel**: Create new versions alongside old ones (safest but most work)\n\n## Step 4: Component Migration Process\n\nFor each component, follow these steps:\n\n### 4.1. Add Self-Import\n\nAdd an import statement referencing the component itself:\n\n```svelte\n<script>\n\timport ComponentName from './ComponentName.svelte';\n\t// Existing code...\n</script>\n```\n\n### 4.2. Replace `<svelte:self>` Instances\n\nReplace all instances of `<svelte:self>` with the imported component name:\n\n```diff\n- <svelte:self prop1={value1} prop2={value2} />\n+ <ComponentName prop1={value1} prop2={value2} />\n```\n\n### 4.3. Verify Conditional Logic\n\nEnsure all conditional logic is still properly applied. The modern approach doesn't enforce conditional wrapping like `<svelte:self>` does, so verify that infinite recursion is still prevented:\n\n```svelte\n{#if condition}\n\t<ComponentName {...props} />\n{/if}\n```\n\n## Step 5: Testing Strategy\n\nImplement a thorough testing strategy:\n\n### 5.1. Visual Regression Testing\n\nCompare screenshots before and after migration to ensure visual consistency:\n\n```javascript\n// Example with Playwright\ntest('tree component renders the same after migration', async ({ page }) => {\n  // Capture screenshot of old version\n  await page.goto('/old-version');\n  const oldScreenshot = await page.screenshot();\n  \n  // Capture screenshot of new version\n  await page.goto('/new-version');\n  const newScreenshot = await page.screenshot();\n  \n  // Compare screenshots\n  expect(compareImages(oldScreenshot, newScreenshot)).toBeLessThan(0.01);\n});\n```\n\n### 5.2. Functional Testing\n\nVerify the component behaves correctly:\n\n```javascript\ntest('recursive component handles deep nesting properly', async ({ page }) => {\n  await page.goto('/component-test');\n  \n  // Test expanding nested items\n  await page.click('.tree-node:first-child .expand-button');\n  await expect(page.locator('.tree-node-child')).toBeVisible();\n  \n  // Test expanding a second level\n  await page.click('.tree-node-child:first-child .expand-button');\n  await expect(page.locator('.tree-node-grandchild')).toBeVisible();\n});\n```\n\n### 5.3. Performance Testing\n\nCompare performance metrics before and after:\n\n```javascript\ntest('performance comparison', async ({ page }) => {\n  const oldPerf = await measurePerformance(page, '/old-version');\n  const newPerf = await measurePerformance(page, '/new-version');\n  \n  expect(newPerf.renderTime).toBeLessThanOrEqual(oldPerf.renderTime);\n  expect(newPerf.memoryUsage).toBeLessThanOrEqual(oldPerf.memoryUsage);\n});\n```\n\n## Step 6: Real-World Example\n\nLet's migrate a file explorer component:\n\n**Before migration (FileExplorer.svelte):**\n\n```svelte\n<script>\n\texport let files = [];\n\texport let path = [];\n\t\n\tfunction isFolder(file) {\n\t\treturn file.type === 'folder';\n\t}\n\t\n\tfunction toggleFolder(folder) {\n\t\tfolder.expanded = !folder.expanded;\n\t}\n</script>\n\n<ul class=\"file-explorer\">\n\t{#each files as file}\n\t\t<li class={file.type}>\n\t\t\t<div class=\"file-item\" on:click={() => isFolder(file) && toggleFolder(file)}>\n\t\t\t\t<span class=\"icon\">{isFolder(file) ? 'ð' : 'ð'}</span>\n\t\t\t\t<span class=\"name\">{file.name}</span>\n\t\t\t</div>\n\t\t\t\n\t\t\t{#if isFolder(file) && file.expanded && file.children?.length}\n\t\t\t\t<svelte:self files={file.children} path={[...path, file.name]} />\n\t\t\t{/if}\n\t\t</li>\n\t{/each}\n</ul>\n\n<style>\n\t.file-explorer {\n\t\tlist-style: none;\n\t\tpadding-left: 20px;\n\t}\n\t\n\t.file-item {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tcursor: pointer;\n\t\tpadding: 4px 0;\n\t}\n\t\n\t.folder .file-item:hover {\n\t\tbackground-color: #f0f0f0;\n\t}\n\t\n\t.icon {\n\t\tmargin-right: 8px;\n\t}\n</style>\n```\n\n**After migration:**\n\n```svelte\n<script>\n\timport FileExplorer from './FileExplorer.svelte';\n\t\n\texport let files = [];\n\texport let path = [];\n\t\n\tfunction isFolder(file) {\n\t\treturn file.type === 'folder';\n\t}\n\t\n\tfunction toggleFolder(folder) {\n\t\tfolder.expanded = !folder.expanded;\n\t}\n</script>\n\n<ul class=\"file-explorer\">\n\t{#each files as file}\n\t\t<li class={file.type}>\n\t\t\t<div class=\"file-item\" on:click={() => isFolder(file) && toggleFolder(file)}>\n\t\t\t\t<span class=\"icon\">{isFolder(file) ? 'ð' : 'ð'}</span>\n\t\t\t\t<span class=\"name\">{file.name}</span>\n\t\t\t</div>\n\t\t\t\n\t\t\t{#if isFolder(file) && file.expanded && file.children?.length}\n\t\t\t\t<FileExplorer files={file.children} path={[...path, file.name]} />\n\t\t\t{/if}\n\t\t</li>\n\t{/each}\n</ul>\n\n<style>\n\t/* Style remains unchanged */\n\t.file-explorer {\n\t\tlist-style: none;\n\t\tpadding-left: 20px;\n\t}\n\t\n\t.file-item {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tcursor: pointer;\n\t\tpadding: 4px 0;\n\t}\n\t\n\t.folder .file-item:hover {\n\t\tbackground-color: #f0f0f0;\n\t}\n\t\n\t.icon {\n\t\tmargin-right: 8px;\n\t}\n</style>\n```\n\n## Step 7: Common Challenges and Solutions\n\n### Circular Dependencies\n\n**Problem**: Bundlers may warn about circular dependencies with self-imports.\n\n**Solution**: Use dynamic imports for complex cases:\n\n```svelte\n<script>\n\timport { onMount } from 'svelte';\n\t\n\texport let items;\n\tlet RecursiveComponent;\n\t\n\tonMount(async () => {\n\t\tconst module = await import('./RecursiveComponent.svelte');\n\t\tRecursiveComponent = module.default;\n\t});\n</script>\n\n{#if items.length && RecursiveComponent}\n\t{#each items as item}\n\t\t<svelte:component this={RecursiveComponent} item={item} />\n\t{/each}\n{/if}\n```\n\n### TypeScript Integration\n\n**Problem**: TypeScript may complain about self-referential types.\n\n**Solution**: Define interfaces separately and use them:\n\n```typescript\n// types.ts\nexport interface TreeNode {\n  name: string;\n  children?: TreeNode[];\n  expanded?: boolean;\n}\n```\n\n```svelte\n<script lang=\"ts\">\n\timport type { TreeNode } from './types';\n\timport TreeComponent from './TreeComponent.svelte';\n\t\n\texport let node: TreeNode;\n</script>\n\n<div>{node.name}</div>\n{#if node.children?.length}\n\t{#each node.children as child}\n\t\t<TreeComponent node={child} />\n\t{/each}\n{/if}\n```\n\n### Prop Changes\n\n**Problem**: Different behavior with props between the two approaches.\n\n**Solution**: Verify all props are passed correctly and add tests specifically for prop behavior:\n\n```javascript\ntest('props are correctly passed through recursive levels', async () => {\n  const { getByTestId } = render(RecursiveComponent, {\n    props: {\n      items: [{ name: 'Level 1', children: [{ name: 'Level 2' }] }],\n      testId: 'level-1'\n    }\n  });\n  \n  const level1 = getByTestId('level-1');\n  expect(level1.textContent).toContain('Level 1');\n  \n  const level2 = getByTestId('level-2');\n  expect(level2.textContent).toContain('Level 2');\n});\n```\n\n## Step 8: Documentation Updates\n\nUpdate your project documentation:\n\n1. Note the migration in your CHANGELOG\n2. Update component documentation to reflect the new approach\n3. Add migration guidelines for other developers\n4. Document any edge cases or special considerations\n\nExample documentation entry:\n\n```markdown\n## FileExplorer Component\n\nThe FileExplorer component renders a recursive directory structure.\n\n### Usage\n\n```svelte\n<script>\n  import FileExplorer from './components/FileExplorer.svelte';\n  \n  const files = [\n    {\n      name: 'Documents',\n      type: 'folder',\n      children: [\n        { name: 'report.pdf', type: 'file' }\n      ]\n    }\n  ];\n</script>\n\n<FileExplorer {files} />\n```\n\n**Note**: This component previously used `<svelte:self>` but has been migrated to use self-imports for better compatibility with Svelte 5.\n```\n\nBy following this comprehensive migration guide, you can successfully transition your Svelte application from the legacy `<svelte:self>` approach to the modern self-import approach, ensuring better compatibility with newer Svelte versions while maintaining the same functionality."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"How does component initialization differ between Svelte 4 and Svelte 5? Provide examples of both approaches.","answer":"In Svelte 4, components were initialized as JavaScript classes with a specific options object, while Svelte 5 uses a more functional approach with the `mount` function.\n\n**Svelte 4 approach:**\n```javascript\nimport App from './App.svelte';\n\nconst app = new App({\n  target: document.body,\n  props: {\n    answer: 42\n  },\n  context: new Map([['theme', 'dark']]),\n  intro: true\n});\n```\n\n**Svelte 5 approach:**\n```javascript\nimport { mount } from 'svelte';\nimport App from './App.svelte';\n\nlet props = $state({ answer: 42 });\nconst app = mount(App, {\n  target: document.body,\n  props: props\n});\n\n// Later update props\nprops.answer = 24;\n```\n\nThe key differences are:\n1. Svelte 5 uses the `mount` function instead of instantiating a class\n2. Svelte 5 uses `$state` for reactive props management instead of the `$set` method\n3. Property updates in Svelte 5 are done by directly modifying the state object, rather than using component methods\n4. Svelte 5 eliminates the imperative component API in favor of a more declarative approach with runes\n\nSvelte 5's approach is more aligned with its reactivity system and simplifies the mental model for component lifecycle management."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"How would you handle component cleanup and removal in Svelte 4 versus Svelte 5? What are the implications of each approach?","answer":"Component cleanup and removal differs significantly between Svelte 4 and Svelte 5:\n\n**Svelte 4 approach:**\n```javascript\nimport App from './App.svelte';\n\nconst app = new App({\n  target: document.body,\n  props: { counter: 0 }\n});\n\n// When you need to destroy the component\napp.$destroy();\n```\n\n**Svelte 5 approach:**\n```javascript\nimport { mount, unmount } from 'svelte';\nimport App from './App.svelte';\n\nconst app = mount(App, {\n  target: document.body,\n  props: { counter: 0 }\n});\n\n// When you need to unmount the component\nunmount(app);\n```\n\nThe key differences:\n1. Svelte 4 uses the `$destroy()` method on the component instance\n2. Svelte 5 uses the `unmount()` function, which is imported from the 'svelte' package\n3. In Svelte 4, `$destroy()` was a method on the component instance, making it tied to the component's lifecycle\n4. In Svelte 5, `unmount()` is a separate function that takes the mounted component reference as an argument\n\nBoth approaches trigger the cleanup logic (like running onDestroy callbacks) and remove the component from the DOM. However, Svelte 5's approach is more consistent with its functional programming paradigm and creates a cleaner separation between component definition and lifecycle management."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"Explain how event handling with component events differs between Svelte 4 and Svelte 5. Provide code examples showing both approaches.","answer":"Event handling for component events has evolved significantly from Svelte 4 to Svelte 5:\n\n**Svelte 4 approach:**\n```javascript\n// Parent.svelte\n<script>\n  import Child from './Child.svelte';\n  \n  let selection;\n  let childComponent;\n  \n  function handleSelection(event) {\n    selection = event.detail.selection;\n  }\n</script>\n\n<Child bind:this={childComponent} />\n<button on:click={() => childComponent.$on('selected', handleSelection)}>\n  Listen for events\n</button>\n```\n\n```javascript\n// Child.svelte\n<script>\n  function selectItem(item) {\n    dispatch('selected', { selection: item });\n  }\n  \n  import { createEventDispatcher } from 'svelte';\n  const dispatch = createEventDispatcher();\n</script>\n\n<button on:click={() => selectItem('item1')}>Select Item 1</button>\n```\n\n**Svelte 5 approach:**\n```javascript\n// Parent.svelte\n<script>\n  import Child from './Child.svelte';\n  \n  let selection;\n  \n  function handleSelection(selectedItem) {\n    selection = selectedItem;\n  }\n</script>\n\n<Child onSelected={handleSelection} />\n```\n\n```javascript\n// Child.svelte\n<script>\n  export let onSelected = () => {}; // Default empty function\n  \n  function selectItem(item) {\n    onSelected(item);\n  }\n</script>\n\n<button on:click={() => selectItem('item1')}>Select Item 1</button>\n```\n\nKey differences:\n1. Svelte 4 used the `$on()` method to listen for custom events and an event dispatcher to emit them\n2. Svelte 5 prefers passing callback props (sometimes called \"event props\") directly\n3. In Svelte 4, event data was passed via the `detail` property of the event object\n4. In Svelte 5, data is passed directly as arguments to the callback function\n5. Svelte 5's approach eliminates the need for the event dispatcher pattern entirely\n\nThe Svelte 5 approach is more direct and aligns better with standard JavaScript patterns, making it more intuitive for developers coming from other frameworks."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"How does server-side rendering (SSR) differ between Svelte 4 and Svelte 5? Provide examples of both approaches.","answer":"Server-side rendering approaches differ significantly between Svelte 4 and Svelte 5:\n\n**Svelte 4 approach:**\n```javascript\n// Server-side code (Node.js)\nrequire('svelte/register');\n\nconst App = require('./App.svelte').default;\n\nconst { head, html, css } = App.render({\n  answer: 42,\n}, {\n  context: new Map([['theme', 'dark']])\n});\n\n// Now you can use head, html, and css to construct your full HTML response\nconst fullHtml = `\n<!DOCTYPE html>\n<html>\n  <head>\n    ${head}\n    <style>${css.code}</style>\n  </head>\n  <body>\n    <div id=\"server-rendered-html\">${html}</div>\n    <script src=\"/bundle.js\"></script>\n  </body>\n</html>\n`;\n```\n\n**Svelte 5 approach:**\n```javascript\n// Server-side code (Node.js)\nimport { render } from 'svelte/server';\nimport App from './App.svelte';\n\nconst result = render(App, { \n  props: { answer: 42 },\n  context: { theme: 'dark' }\n});\n\n// The result object contains HTML, CSS, and head content\nconst fullHtml = `\n<!DOCTYPE html>\n<html>\n  <head>\n    ${result.head}\n    <style>${result.css}</style>\n  </head>\n  <body>\n    <div id=\"app\">${result.html}</div>\n    <script src=\"/bundle.js\"></script>\n  </body>\n</html>\n`;\n```\n\nKey differences:\n1. Svelte 4 used a static `render()` method on the component class\n2. Svelte 5 uses a standalone `render()` function imported from 'svelte/server'\n3. In Svelte 4, context was passed as a Map instance\n4. In Svelte 5, context is passed as a regular object\n5. The structure of the returned object is similar in both versions, containing HTML, CSS, and head content\n\nFor hydration, Svelte 5 also simplifies the client-side code:\n\n**Svelte 4 hydration:**\n```javascript\nimport App from './App.svelte';\n\nconst app = new App({\n  target: document.querySelector('#server-rendered-html'),\n  hydrate: true,\n  props: { answer: 42 }\n});\n```\n\n**Svelte 5 hydration:**\n```javascript\nimport { mount } from 'svelte';\nimport App from './App.svelte';\n\nconst app = mount(App, {\n  target: document.querySelector('#app'),\n  hydrate: true,\n  props: { answer: 42 }\n});\n```\n\nSvelte 5's approach provides a more consistent API between client-side and server-side rendering, making it easier to understand and use."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"Explain how prop accessors worked in Svelte 4 and how this concept has changed in Svelte 5. What are the implications for component design?","answer":"Prop accessors in Svelte 4 were a way to directly access and modify component properties from outside the component. This concept has been significantly reimagined in Svelte 5:\n\n**Svelte 4 approach:**\n```javascript\n// Component.svelte\n<script>\n  export let count = 0;\n</script>\n\n<button on:click={() => count++}>\n  Count: {count}\n</button>\n```\n\n```javascript\n// Usage with accessors\nimport Component from './Component.svelte';\n\nconst component = new Component({\n  target: document.body,\n  props: { count: 5 },\n  // If the component was compiled with accessors: true\n});\n\n// Direct property access and modification\nconsole.log(component.count); // Outputs: 5\ncomponent.count += 1; // Synchronously updates the component\n```\n\n**Svelte 5 approach:**\n```javascript\n// Component.svelte\n<script>\n  export let count = 0;\n</script>\n\n<button on:click={() => count++}>\n  Count: {count}\n</button>\n```\n\n```javascript\n// Usage in Svelte 5\nimport { mount } from 'svelte';\nimport Component from './Component.svelte';\n\nlet props = $state({ count: 5 });\nconst component = mount(Component, {\n  target: document.body,\n  props\n});\n\n// Update through the state object\nconsole.log(props.count); // Outputs: 5\nprops.count += 1; // Updates the component reactively\n```\n\nKey differences and implications:\n\n1. **Conceptual shift**: Svelte 4's accessors created a direct link to component internals, while Svelte 5 treats props as a reactive state object that feeds into the component.\n\n2. **Explicit vs. Implicit**: In Svelte 4, accessors needed to be explicitly enabled with the `accessors: true` compiler option. In Svelte 5, the reactivity is built into the `$state` system.\n\n3. **Component encapsulation**: Svelte 5's approach provides better encapsulation. Components expose only what they explicitly export, and the interaction happens through a well-defined props interface.\n\n4. **Consistency**: Svelte 5's approach is more consistent with its overall reactivity model, using the same mechanisms for both internal and external state management.\n\n5. **Custom elements**: In Svelte 4, accessors were enabled by default when compiling to custom elements. In Svelte 5, custom elements can use the standard export pattern to determine which properties are exposed.\n\nThis change aligns with Svelte 5's broader shift toward a more unified reactivity model based on runes, making component interaction more predictable and consistent with other parts of the framework."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"How does the handling of component context differ between Svelte 4 and Svelte 5? Provide examples of setting and using context in both versions.","answer":"Context handling has evolved from Svelte 4 to Svelte 5, with significant changes in how context is set, retrieved, and passed to components:\n\n**Svelte 4 approach:**\n```javascript\n// Parent component setting context\n<script>\n  import { setContext } from 'svelte';\n  import Child from './Child.svelte';\n  \n  // Setting context with a key and value\n  setContext('theme', 'dark');\n</script>\n\n<Child />\n```\n\n```javascript\n// Child component getting context\n<script>\n  import { getContext } from 'svelte';\n  \n  // Getting context using the same key\n  const theme = getContext('theme');\n</script>\n\n<div class={theme}>\n  Theme is {theme}\n</div>\n```\n\n```javascript\n// Passing context during component initialization\nimport App from './App.svelte';\n\nconst app = new App({\n  target: document.body,\n  context: new Map([\n    ['theme', 'dark'],\n    ['user', { name: 'John' }]\n  ])\n});\n```\n\n**Svelte 5 approach:**\n```javascript\n// Parent component setting context\n<script>\n  import Child from './Child.svelte';\n  \n  // Using the $context rune\n  $context('theme', 'dark');\n</script>\n\n<Child />\n```\n\n```javascript\n// Child component getting context\n<script>\n  // Using the $context rune to retrieve context\n  const theme = $context('theme');\n</script>\n\n<div class={theme}>\n  Theme is {theme}\n</div>\n```\n\n```javascript\n// Passing context during component mounting\nimport { mount } from 'svelte';\nimport App from './App.svelte';\n\nconst app = mount(App, {\n  target: document.body,\n  context: {\n    theme: 'dark',\n    user: { name: 'John' }\n  }\n});\n```\n\nKey differences:\n\n1. **API Change**: Svelte 4 used `setContext` and `getContext` functions, while Svelte 5 uses the `$context` rune.\n\n2. **Syntax**: The `$context` rune in Svelte 5 serves dual purposes - when called with two arguments it sets context, and with one argument it retrieves context.\n\n3. **Context Object**: In Svelte 4, root-level context was passed as a `Map` object during component initialization, while Svelte 5 uses a plain JavaScript object.\n\n4. **Reactivity**: In Svelte 5, context values retrieved with the `$context` rune are automatically reactive if the value is a reactive state.\n\n5. **Consistency**: Svelte 5's approach is more consistent with its runes-based reactivity system.\n\nExample of reactive context in Svelte 5:\n```javascript\n// Parent component with reactive context\n<script>\n  let theme = $state('dark');\n  \n  $context('theme', theme);\n  \n  function toggleTheme() {\n    theme = theme === 'dark' ? 'light' : 'dark';\n  }\n</script>\n\n<button on:click={toggleTheme}>Toggle Theme</button>\n<Child />\n```\n\n```javascript\n// Child component with reactive context\n<script>\n  const theme = $context('theme');\n  // theme will automatically update when the parent changes it\n</script>\n\n<div class={theme}>\n  Current theme: {theme}\n</div>\n```\n\nThis demonstrates how Svelte 5's context system is more deeply integrated with its reactivity model."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"How does the hydration process differ between Svelte 4 and Svelte 5? What are the constraints and considerations for each approach?","answer":"Hydration is the process of attaching JavaScript functionality to server-rendered HTML. The approach differs between Svelte 4 and Svelte 5:\n\n**Svelte 4 hydration:**\n```javascript\n// Server-side rendering\nrequire('svelte/register');\nconst App = require('./App.svelte').default;\n\n// Component must be compiled with hydratable: true\nconst { head, html, css } = App.render({\n  user: { name: 'Alice', id: 123 }\n});\n\n// Send this HTML to the client\nconst fullHtml = `\n<!DOCTYPE html>\n<html>\n  <head>${head}<style>${css.code}</style></head>\n  <body>\n    <div id=\"app\">${html}</div>\n    <script src=\"/bundle.js\"></script>\n  </body>\n</html>\n`;\n```\n\n```javascript\n// Client-side hydration\nimport App from './App.svelte';\n\nconst app = new App({\n  target: document.querySelector('#app'),\n  hydrate: true,\n  props: {\n    user: { name: 'Alice', id: 123 }\n  }\n});\n```\n\n**Svelte 5 hydration:**\n```javascript\n// Server-side rendering\nimport { render } from 'svelte/server';\nimport App from './App.svelte';\n\nconst result = render(App, {\n  props: { user: { name: 'Alice', id: 123 } }\n});\n\n// Send this HTML to the client\nconst fullHtml = `\n<!DOCTYPE html>\n<html>\n  <head>${result.head}<style>${result.css}</style></head>\n  <body>\n    <div id=\"app\">${result.html}</div>\n    <script src=\"/bundle.js\"></script>\n  </body>\n</html>\n`;\n```\n\n```javascript\n// Client-side hydration\nimport { mount } from 'svelte';\nimport App from './App.svelte';\n\nconst app = mount(App, {\n  target: document.querySelector('#app'),\n  hydrate: true,\n  props: {\n    user: { name: 'Alice', id: 123 }\n  }\n});\n```\n\nKey differences and considerations:\n\n1. **API Changes**: Svelte 4 used the component's constructor with a `hydrate: true` option, while Svelte 5 uses the `mount` function with the same option.\n\n2. **Compilation Requirements**: \n   - In Svelte 4, components needed to be compiled with `hydratable: true` for both server and client code.\n   - In Svelte 5, the hydration capability is built-in without special compilation flags.\n\n3. **Head Elements**:\n   - In Svelte 4, hydration of `<head>` elements only worked properly if server-side rendering used `hydratable: true`, which added markers to head elements.\n   - In Svelte 5, head hydration is handled more seamlessly without requiring special markers.\n\n4. **Constraints**:\n   - In both versions, when using `hydrate: true`, any existing children of the target element are removed.\n   - In Svelte 4, the `anchor` option couldn't be used alongside `hydrate: true`.\n   - In Svelte 5, similar constraints apply, but the API is more consistent.\n\n5. **DOM Repair**:\n   - Both versions can \"repair\" the DOM if the server-rendered HTML doesn't exactly match what the component would render.\n   - Svelte 5 has improved algorithms for this repair process, making it more efficient.\n\n6. **Progressive Enhancement**:\n   - Svelte 5 has better support for progressive enhancement, where the app can function without JavaScript and then \"upgrade\" when JS loads.\n\nExample of partial hydration in Svelte 5 (a more advanced feature):\n\n```javascript\n// Client-side partial hydration\nimport { mount } from 'svelte';\nimport InteractiveWidget from './InteractiveWidget.svelte';\n\n// Only hydrate specific interactive parts of the page\ndocument.querySelectorAll('[data-hydrate=\"widget\"]').forEach(node => {\n  const props = JSON.parse(node.getAttribute('data-props') || '{}');\n  \n  mount(InteractiveWidget, {\n    target: node,\n    hydrate: true,\n    props\n  });\n});\n```\n\nThis partial hydration approach is more efficient in Svelte 5 and allows for more granular control over which parts of the page become interactive, improving performance for complex applications."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"How would you handle component lifecycle events in Svelte 4 versus Svelte 5? Provide examples of initialization, updates, and cleanup in both versions.","answer":"Component lifecycle handling differs significantly between Svelte 4 and Svelte 5:\n\n**Svelte 4 lifecycle approach:**\n```javascript\n<script>\n  import { onMount, onDestroy, beforeUpdate, afterUpdate } from 'svelte';\n  \n  let count = 0;\n  \n  // Runs when component is mounted to the DOM\n  onMount(() => {\n    console.log('Component mounted');\n    const interval = setInterval(() => count++, 1000);\n    \n    // Return a cleanup function\n    return () => clearInterval(interval);\n  });\n  \n  // Runs before the DOM is updated\n  beforeUpdate(() => {\n    console.log('About to update DOM', count);\n  });\n  \n  // Runs after the DOM is updated\n  afterUpdate(() => {\n    console.log('DOM updated', count);\n  });\n  \n  // Runs when component is destroyed\n  onDestroy(() => {\n    console.log('Component being destroyed');\n  });\n</script>\n\n<div>Count: {count}</div>\n```\n\n**Svelte 5 lifecycle approach:**\n```javascript\n<script>\n  let count = $state(0);\n  let interval;\n  \n  // Initialization and cleanup with $effect\n  $effect(() => {\n    console.log('Component initialized');\n    interval = setInterval(() => count++, 1000);\n    \n    // Cleanup happens automatically when returning a function\n    return () => {\n      console.log('Component being cleaned up');\n      clearInterval(interval);\n    };\n  });\n  \n  // Runs whenever count changes\n  $effect(() => {\n    console.log('Count changed to', count);\n  });\n  \n  // DOM update effects\n  $effect.pre(() => {\n    console.log('About to update DOM', count);\n  });\n  \n  $effect.post(() => {\n    console.log('DOM updated', count);\n  });\n</script>\n\n<div>Count: {count}</div>\n```\n\nKey differences:\n\n1. **API Change**: \n   - Svelte 4 used specific lifecycle functions (`onMount`, `onDestroy`, etc.)\n   - Svelte 5 uses the `$effect` rune and its variants for most lifecycle concerns\n\n2. **Initialization**:\n   - Svelte 4: `onMount` for initialization after the component is first rendered\n   - Svelte 5: `$effect` runs after the component is mounted and can handle initialization\n\n3. **Cleanup**:\n   - Svelte 4: `onDestroy` for cleanup, or return a function from `onMount`\n   - Svelte 5: Return a function from `$effect` for cleanup\n\n4. **Update Lifecycle**:\n   - Svelte 4: `beforeUpdate` and `afterUpdate` for DOM update cycles\n   - Svelte 5: `$effect.pre` and `$effect.post` for the same purpose\n\n5. **Reactivity Integration**:\n   - Svelte 5's effects are more deeply integrated with the reactivity system\n   - Effects automatically track dependencies and re-run when dependencies change\n\n6. **Granularity**:\n   - Svelte 5 allows for more granular control over when effects run based on their dependencies\n\nExample of a more complex Svelte 5 component with multiple effects:\n\n```javascript\n<script>\n  let userData = $state(null);\n  let isLoading = $state(true);\n  let error = $state(null);\n  let userId = $state(1);\n  \n  // Effect for data fetching that re-runs when userId changes\n  $effect(async () => {\n    try {\n      isLoading = true;\n      error = null;\n      const response = await fetch(`https://api.example.com/users/${userId}`);\n      if (!response.ok) throw new Error('Failed to fetch');\n      userData = await response.json();\n    } catch (e) {\n      error = e.message;\n    } finally {\n      isLoading = false;\n    }\n  });\n  \n  // Effect for logging that runs on every render\n  $effect.pre(() => {\n    console.log('Rendering with user ID:', userId);\n  });\n  \n  // Effect for DOM measurements after update\n  $effect.post(() => {\n    if (userData) {\n      const userCard = document.querySelector('.user-card');\n      console.log('User card height:', userCard?.offsetHeight);\n    }\n  });\n  \n  // One-time setup with cleanup\n  $effect(() => {\n    const keyHandler = (e) => {\n      if (e.key === 'ArrowRight') userId++;\n      if (e.key === 'ArrowLeft') userId--;\n    };\n    \n    window.addEventListener('keydown', keyHandler);\n    return () => window.removeEventListener('keydown', keyHandler);\n  });\n</script>\n\n<div>\n  <button on:click={() => userId--} disabled={isLoading}>Previous</button>\n  <button on:click={() => userId++} disabled={isLoading}>Next</button>\n  \n  {#if isLoading}\n    <p>Loading...</p>\n  {:else if error}\n    <p class=\"error\">{error}</p>\n  {:else if userData}\n    <div class=\"user-card\">\n      <h2>{userData.name}</h2>\n      <p>{userData.email}</p>\n    </div>\n  {/if}\n</div>\n```\n\nThis example demonstrates how Svelte 5's effects provide a more flexible and powerful way to handle component lifecycle events compared to Svelte 4's more rigid lifecycle functions."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"How does Svelte 5 change the way we interact with components programmatically compared to Svelte 4? What are the benefits of the new approach?","answer":"Svelte 5 fundamentally changes how we interact with components programmatically, moving from an imperative class-based API to a more functional approach:\n\n**Svelte 4 programmatic component interaction:**\n```javascript\nimport Dialog from './Dialog.svelte';\n\n// Create component instance\nconst dialog = new Dialog({\n  target: document.body,\n  props: {\n    title: 'Confirmation',\n    message: 'Are you sure you want to proceed?'\n  }\n});\n\n// Get a property value\nconsole.log(dialog.title); // Only works if compiled with accessors: true\n\n// Set property values (schedules an update)\ndialog.$set({\n  title: 'Warning',\n  message: 'This action cannot be undone'\n});\n\n// Listen for events\nconst unsubscribe = dialog.$on('confirm', (event) => {\n  console.log('User confirmed:', event.detail);\n  dialog.$destroy();\n});\n\n// Remove event listener\nunsubscribe();\n\n// Later, destroy the component\ndialog.$destroy();\n```\n\n**Svelte 5 programmatic component interaction:**\n```javascript\nimport { mount, unmount } from 'svelte';\nimport Dialog from './Dialog.svelte';\n\n// Create reactive state for props\nlet dialogProps = $state({\n  title: 'Confirmation',\n  message: 'Are you sure you want to proceed?',\n  onConfirm: (data) => {\n    console.log('User confirmed:', data);\n    unmount(dialogInstance);\n  }\n});\n\n// Mount the component\nconst dialogInstance = mount(Dialog, {\n  target: document.body,\n  props: dialogProps\n});\n\n// Update properties reactively\ndialogProps.title = 'Warning';\ndialogProps.message = 'This action cannot be undone';\n\n// Later, unmount the component\nunmount(dialogInstance);\n```\n\nKey differences and benefits:\n\n1. **Component Creation**:\n   - Svelte 4: Used a class constructor with an options object\n   - Svelte 5: Uses the `mount` function with similar options\n   - Benefit: More consistent with modern JavaScript's functional patterns\n\n2. **Updating Properties**:\n   - Svelte 4: Used the `$set` method to schedule updates\n   - Svelte 5: Directly updates properties on a reactive state object\n   - Benefit: More intuitive and consistent with how state is updated inside components\n\n3. **Event Handling**:\n   - Svelte 4: Used `$on` method to attach event listeners\n   - Svelte 5: Uses callback props passed through the state object\n   - Benefit: Simpler mental model, no need for event dispatching system\n\n4. **Component Removal**:\n   - Svelte 4: Called `$destroy` method on the component instance\n   - Svelte 5: Calls `unmount` function with the component reference\n   - Benefit: Clearer separation of concerns\n\n5. **Property Access**:\n   - Svelte 4: Required `accessors: true` compiler option for direct property access\n   - Svelte 5: Uses the reactive state object for both reading and writing\n   - Benefit: No special compiler options needed, more consistent behavior\n\n6. **Reactivity Model**:\n   - Svelte 5's approach is more aligned with its overall reactivity system\n   - Changes to props are handled the same way as other reactive state changes\n   - Benefit: Unified mental model for state management\n\nExample of a more complex scenario in Svelte 5 - creating a toast notification system:\n\n```javascript\nimport { mount, unmount } from 'svelte';\nimport Toast from './Toast.svelte';\n\n// Toast notification system\nfunction createToastSystem() {\n  const toasts = $state([]);\n  \n  function showToast(message, type = 'info', duration = 3000) {\n    const id = Date.now();\n    \n    // Create props for this toast\n    const toastProps = $state({\n      id,\n      message,\n      type,\n      onClose: () => removeToast(id)\n    });\n    \n    // Mount the toast component\n    const instance = mount(Toast, {\n      target: document.getElementById('toast-container'),\n      props: toastProps\n    });\n    \n    // Store the toast info\n    toasts.push({ id, instance, props: toastProps });\n    \n    // Auto-remove after duration\n    if (duration > 0) {\n      setTimeout(() => removeToast(id), duration);\n    }\n    \n    return id;\n  }\n  \n  function removeToast(id) {\n    const index = toasts.findIndex(toast => toast.id === id);\n    if (index !== -1) {\n      // Unmount the component\n      unmount(toasts[index].instance);\n      \n      // Remove from our array\n      toasts.splice(index, 1);\n    }\n  }\n  \n  function updateToast(id, updates) {\n    const toast = toasts.find(toast => toast.id === id);\n    if (toast) {\n      // Update the props reactively\n      Object.assign(toast.props, updates);\n    }\n  }\n  \n  return {\n    showToast,\n    removeToast,\n    updateToast,\n    getActiveToasts: () => toasts.length\n  };\n}\n\n// Usage\nconst toastSystem = createToastSystem();\n\n// Show a toast\nconst id = toastSystem.showToast('Operation successful!', 'success');\n\n// Update it later\nsetTimeout(() => {\n  toastSystem.updateToast(id, { \n    message: 'Operation completed with additional info',\n    type: 'info'\n  });\n}, 1000);\n```\n\nThis example demonstrates how Svelte 5's approach enables more flexible and maintainable patterns for programmatically working with components, with clearer separation of concerns and a more consistent reactivity model."}
{"source":"docs/svelte/99-legacy/40-legacy-component-api.md","question":"Compare and contrast the server-side rendering (SSR) approaches in Svelte 4 and Svelte 5, focusing on the API differences, context handling, and hydration process. How might these changes affect a real-world application?","answer":"Server-side rendering (SSR) has evolved significantly from Svelte 4 to Svelte 5, with changes to the API, context handling, and hydration process:\n\n**Svelte 4 SSR approach:**\n```javascript\n// Server-side (Node.js)\nrequire('svelte/register');\nconst App = require('./App.svelte').default;\n\n// Render the component\nconst { head, html, css } = App.render({\n  user: { name: 'John', isAdmin: true }\n}, {\n  context: new Map([\n    ['apiUrl', 'https://api.example.com'],\n    ['theme', 'dark']\n  ])\n});\n\n// Construct the full HTML\nconst fullHtml = `\n<!DOCTYPE html>\n<html>\n  <head>\n    ${head}\n    <style>${css.code}</style>\n  </head>\n  <body>\n    <div id=\"app\">${html}</div>\n    <script>\n      // Serialize data for hydration\n      window.__INITIAL_DATA__ = ${JSON.stringify({ \n        user: { name: 'John', isAdmin: true } \n      })};\n    </script>\n    <script src=\"/bundle.js\"></script>\n  </body>\n</html>\n`;\n\n// Send the HTML as response\n// ...\n```\n\n```javascript\n// Client-side hydration\nimport App from './App.svelte';\n\n// Hydrate using the serialized data\nconst app = new App({\n  target: document.getElementById('app'),\n  hydrate: true,\n  props: window.__INITIAL_DATA__,\n  context: new Map([\n    ['apiUrl', 'https://api.example.com'],\n    ['theme', 'dark']\n  ])\n});\n```\n\n**Svelte 5 SSR approach:**\n```javascript\n// Server-side (Node.js)\nimport { render } from 'svelte/server';\nimport App from './App.svelte';\n\n// Render the component\nconst result = render(App, {\n  props: { user: { name: 'John', isAdmin: true } },\n  context: {\n    apiUrl: 'https://api.example.com',\n    theme: 'dark'\n  }\n});\n\n// Construct the full HTML\nconst fullHtml = `\n<!DOCTYPE html>\n<html>\n  <head>\n    ${result.head}\n    <style>${result.css}</style>\n  </head>\n  <body>\n    <div id=\"app\">${result.html}</div>\n    <script>\n      // Serialize data for hydration\n      window.__INITIAL_DATA__ = ${JSON.stringify({ \n        user: { name: 'John', isAdmin: true } \n      })};\n    </script>\n    <script src=\"/bundle.js\"></script>\n  </body>\n</html>\n`;\n\n// Send the HTML as response\n// ...\n```\n\n```javascript\n// Client-side hydration\nimport { mount } from 'svelte';\nimport App from './App.svelte';\n\n// Hydrate using the serialized data\nconst app = mount(App, {\n  target: document.getElementById('app'),\n  hydrate: true,\n  props: window.__INITIAL_DATA__,\n  context: {\n    apiUrl: 'https://api.example.com',\n    theme: 'dark'\n  }\n});\n```\n\nKey differences and real-world implications:\n\n1. **API Structure**:\n   - Svelte 4: Used a static `render()` method on the component class\n   - Svelte 5: Uses a standalone `render()` function imported from 'svelte/server'\n   - Real-world impact: Svelte 5's approach is more consistent with modern JavaScript patterns and easier to understand for new developers\n\n2. **Context Handling**:\n   - Svelte 4: Required context to be passed as a `Map` object\n   - Svelte 5: Uses a plain JavaScript object for context\n   - Real-world impact: Simpler and more intuitive context handling, especially when working with complex nested objects\n\n3. **Hydration Requirements**:\n   - Svelte 4: Required components to be compiled with `hydratable: true` option\n   - Svelte 5: No special compilation flag needed for hydration\n   - Real-world impact: Simplified build configuration and less potential for errors from misconfiguration\n\n4. **Head Content Handling**:\n   - Svelte 4: Required special markers for `<head>` element hydration\n   - Svelte 5: Improved head content handling without special markers\n   - Real-world impact: Better SEO capabilities and more reliable metadata management\n\n5. **Performance Optimizations**:\n   - Svelte 5 introduces more efficient hydration algorithms\n   - Better handling of partial and selective hydration\n   - Real-world impact: Faster page interactivity and reduced JavaScript payload\n\nExample of a real-world Svelte 5 SSR implementation with selective hydration:\n\n```javascript\n// server.js\nimport { render } from 'svelte/server';\nimport App from './App.svelte';\nimport { createDataClient } from './data/client.js';\n\nexport async function handleRequest(request) {\n  // Create data client for server-side data fetching\n  const dataClient = createDataClient();\n  \n  // Fetch initial data based on request URL\n  const url = new URL(request.url);\n  const initialData = await dataClient.fetchInitialData(url.pathname);\n  \n  // Render the app\n  const result = render(App, {\n    props: { \n      url: url.pathname,\n      initialData\n    },\n    context: {\n      dataClient,\n      userPreferences: getUserPreferencesFromCookies(request.headers.cookie)\n    }\n  });\n  \n  // Create HTML with selective hydration markers\n  const html = `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        ${result.head}\n        <style>${result.css}</style>\n      </head>\n      <body>\n        <div id=\"app\">${result.html}</div>\n        \n        <!-- Only hydrate interactive parts for users with JS -->\n        <script type=\"module\">\n          window.__INITIAL_DATA__ = ${JSON.stringify(initialData)};\n          \n          // Import the hydration script\n          import('/js/hydrate.js');\n        </script>\n        \n        <!-- Provide fallback behaviors for users without JS -->\n        <noscript>\n          <style>\n            .js-only { display: none; }\n            .no-js-alternative { display: block; }\n          </style>\n        </noscript>\n      </body>\n    </html>\n  `;\n  \n  return new Response(html, {\n    headers: {\n      'Content-Type': 'text/html',\n      'Cache-Control': determineCacheControl(url.pathname)\n    }\n  });\n}\n```\n\n```javascript\n// hydrate.js\nimport { mount } from 'svelte';\nimport App from './App.svelte';\nimport { createDataClient } from './data/client.js';\n\n// Create browser data client\nconst dataClient = createDataClient({\n  // Configure for browser environment\n  useBrowserCache: true\n});\n\n// Hydrate the app\nmount(App, {\n  target: document.getElementById('app'),\n  hydrate: true,\n  props: {\n    url: window.location.pathname,\n    initialData: window.__INITIAL_DATA__\n  },\n  context: {\n    dataClient,\n    userPreferences: getUserPreferencesFromLocalStorage()\n  }\n});\n\n// Selectively hydrate interactive components\ndocument.querySelectorAll('[data-hydrate]').forEach(async (node) => {\n  const componentName = node.dataset.hydrate;\n  const props = JSON.parse(node.dataset.props || '{}');\n  \n  // Dynamic import for code splitting\n  const { default: Component } = await import(`./components/${componentName}.svelte`);\n  \n  mount(Component, {\n    target: node,\n    hydrate: true,\n    props\n  });\n});\n```\n\nThis real-world example demonstrates several advantages of Svelte 5's SSR approach:\n\n1. **Progressive Enhancement**: The application works without JavaScript and enhances when JS is available\n2. **Selective Hydration**: Only interactive parts of the page are hydrated, improving performance\n3. **Code Splitting**: Components are loaded on-demand through dynamic imports\n4. **Consistent Context**: The same context structure is used on both server and client\n5. **Simplified Data Handling**: Initial data is passed through props and serialized for hydration\n\nThese improvements in Svelte 5's SSR capabilities allow for more efficient, maintainable, and user-friendly applications, particularly for content-heavy sites where performance and SEO are critical concerns."}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"What makes Svelte different from other frontend frameworks, and how does its compiler-based approach work based on the documentation?","answer":"Svelte differs fundamentally from other frontend frameworks because it's a compiler rather than a traditional runtime library. As described in the documentation, \"Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript... into lean, tightly optimized JavaScript.\"\n\nThis compiler-based approach offers several key advantages:\n\n1. **Smaller bundle sizes**: Since Svelte compiles components at build time, it doesn't need to ship a large runtime library to the browser.\n\n2. **Better performance**: The compiled code is optimized specifically for your application, resulting in faster initial load times and more efficient updates.\n\n3. **More intuitive development**: Svelte uses a component format that closely resembles standard HTML, CSS, and JavaScript, making it more approachable for developers.\n\nA basic Svelte component looks like this:\n\n```svelte\n<script>\n\tfunction greet() {\n\t\talert('Welcome to Svelte!');\n\t}\n</script>\n\n<button onclick={greet}>click me</button>\n\n<style>\n\tbutton {\n\t\tfont-size: 2em;\n\t}\n</style>\n```\n\nIn this example, Svelte will compile this component into efficient JavaScript that:\n- Creates the button element\n- Attaches the event handler\n- Applies the scoped CSS (the font-size styling will only apply to buttons in this component)\n- Handles cleanup when the component is destroyed\n\nThis is different from frameworks like React or Vue, which interpret your component code at runtime using a virtual DOM diffing algorithm. Svelte instead compiles your components into precise code that directly manipulates the DOM when state changes, avoiding the overhead of runtime interpretation and virtual DOM comparisons.\n\nThe documentation also mentions that Svelte can be used for projects of any scale, \"from standalone components to ambitious full stack apps\" through its companion framework SvelteKit."}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"How does a basic Svelte component structure work, and what are the key parts of the component shown in the documentation example?","answer":"A basic Svelte component consists of three main sections, each enclosed in their own blocks, as demonstrated in the documentation example:\n\n```svelte\n<script>\n\tfunction greet() {\n\t\talert('Welcome to Svelte!');\n\t}\n</script>\n\n<button onclick={greet}>click me</button>\n\n<style>\n\tbutton {\n\t\tfont-size: 2em;\n\t}\n</style>\n```\n\nThe three key parts are:\n\n1. **`<script>` section**: This is where you write JavaScript code for your component. It contains:\n   - Component logic\n   - State declarations\n   - Event handlers (like the `greet` function in the example)\n   - Lifecycle functions\n   - Import statements for other components or modules\n\n   In the example, the script section defines a simple `greet()` function that displays an alert message.\n\n2. **Markup section**: This is the HTML template for your component, which appears between the `<script>` and `<style>` sections (or after the `<script>` if there's no style section). It can include:\n   - HTML elements\n   - Component instances\n   - Expressions (in curly braces)\n   - Control flow statements (if blocks, each blocks, etc.)\n   - Event handlers (like `onclick={greet}` in the example)\n\n   The example shows a button element with an onclick event that calls the `greet` function defined in the script section.\n\n3. **`<style>` section**: This contains CSS that's scoped to the component. Styles defined here will only affect elements within this component, not elsewhere in your application. This built-in CSS scoping helps prevent style conflicts across components.\n\n   In the example, the style increases the font size of the button to 2em, but this styling will only apply to buttons within this specific component.\n\nThe component file typically has a `.svelte` extension (like `App.svelte` in the example) and represents a reusable UI element that can be imported and used in other components.\n\nThis structure demonstrates Svelte's approach of keeping related code (logic, markup, and styling) together in a single file, following the component-based architecture pattern while maintaining clear separation between the different concerns."}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"According to the documentation, what resources are available for learning Svelte, and what would be an appropriate learning path for someone new to the framework?","answer":"The documentation outlines several resources for learning Svelte and suggests a specific learning path for newcomers. Here's a comprehensive overview of the available resources and a recommended learning path based on the documentation:\n\n### Available Resources:\n\n1. **Reference Documentation**: The documentation mentions that the pages serve as \"reference documentation,\" meaning they provide detailed information about Svelte's features, APIs, and concepts for lookup purposes.\n\n2. **Interactive Tutorial**: The documentation explicitly recommends the [interactive tutorial](/tutorial) as a starting point for beginners.\n\n3. **Playground**: There's an online [playground](/playground) where you can try Svelte without setting up a local development environment.\n\n4. **StackBlitz**: For a \"more fully-featured environment,\" the documentation suggests [StackBlitz](https://sveltekit.new), which provides an online IDE experience for Svelte and SvelteKit development.\n\n5. **SvelteKit Documentation**: For building full-stack applications, the documentation mentions Svelte's companion application framework, SvelteKit, which has its own documentation.\n\n### Recommended Learning Path:\n\nBased on the documentation, an appropriate learning path for someone new to Svelte would be:\n\n1. **Start with the Interactive Tutorial**: The documentation explicitly states, \"If you're new to Svelte, we recommend starting with the interactive tutorial and coming back here when you have questions.\" This tutorial likely provides a structured, hands-on introduction to Svelte's core concepts.\n\n2. **Experiment in the Playground**: After gaining basic familiarity through the tutorial, use the Svelte playground to experiment with simple components and concepts.\n\n3. **Reference the Documentation**: As specific questions arise during learning, refer to the reference documentation for detailed explanations of particular features or APIs.\n\n4. **Try More Complex Examples on StackBlitz**: For more realistic development scenarios, use StackBlitz to work with more fully-featured Svelte applications.\n\n5. **Explore SvelteKit**: Once comfortable with Svelte components and basic concepts, explore SvelteKit for building full-stack applications.\n\nThe documentation emphasizes that Svelte can be used for projects of varying complexity \"from standalone components to ambitious full stack apps... and everything in between,\" so learners can scale their projects as they become more comfortable with the framework.\n\nThis learning path follows a progressive approach, starting with guided tutorials and gradually moving toward more independent development with increasingly complex applications, while using the reference documentation as needed throughout the learning journey."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"How does Svelte 5's approach to reactivity differ from Svelte 4, particularly with regard to state declaration?","answer":"Svelte 5 introduces a fundamental shift in reactivity through the use of \"runes\" - special function-like symbols that provide instructions to the Svelte compiler. The most significant difference is in state declaration.\n\nIn Svelte 4, reactivity was implicit for variables declared at the top level of a component:\n```svelte\n<script>\n  let count = 0; // Implicitly reactive in Svelte 4\n</script>\n\n<button on:click={() => count++}>\n  clicks: {count}\n</button>\n```\n\nIn Svelte 5, reactivity is explicitly declared using the `$state` rune:\n```svelte\n<script>\n  let count = $state(0); // Explicitly reactive with the $state rune\n</script>\n\n<button onclick={() => count++}>\n  clicks: {count}\n</button>\n```\n\nThis explicit approach offers several advantages:\n1. Clarity about what is and isn't reactive\n2. The ability to use reactivity in more contexts (like class fields)\n3. Better tooling support for identifying reactive values\n4. More consistent mental model for developers\n\nThe `$state` rune can be used in various contexts, including class fields (both public and private):\n```js\nclass Todo {\n  done = $state(false);\n  #priority = $state(1); // Private field\n  text = $state();\n\n  constructor(text) {\n    this.text = text;\n  }\n}\n```\n\nThis represents a shift from Svelte's previous \"magic\" approach to a more explicit but still concise reactivity system."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"Explain the `$derived` rune in Svelte 5 with examples of how it works and what constraints it enforces on the expressions inside it.","answer":"The `$derived` rune in Svelte 5 is used to create values that are computed from other reactive values. When the dependencies change, the derived value is automatically recalculated.\n\nBasic usage:\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n\n<button onclick={() => count++}>\n  Increment\n</button>\n\n<p>{count} doubled is {doubled}</p>\n```\n\nThe `$derived` rune enforces important constraints on the expressions inside it:\n\n1. **Side-effect free**: The expression must not have side effects. This means operations like `count++` or calling functions that modify state are disallowed.\n\n2. **Pure computation**: The expression should only compute a value based on its inputs, without modifying external state.\n\nFor example, this would cause a compilation error:\n```svelte\n<script>\n  let count = $state(0);\n  // This will error because it contains a side effect\n  let error = $derived(count++);\n</script>\n```\n\nYou can use `$derived` with more complex expressions:\n```svelte\n<script>\n  let firstName = $state(\"John\");\n  let lastName = $state(\"Doe\");\n  let age = $state(30);\n  \n  let fullName = $derived(`${firstName} ${lastName}`);\n  let canVote = $derived(age >= 18);\n  let greeting = $derived(`Hello, ${fullName}! ${canVote ? \"You can vote!\" : \"You cannot vote yet.\"}`);\n</script>\n```\n\n`$derived` can also be used in class fields:\n```js\nclass Person {\n  firstName = $state(\"John\");\n  lastName = $state(\"Doe\");\n  fullName = $derived(`${this.firstName} ${this.lastName}`);\n}\n```\n\nThis replaces the reactive statements with `$:` in Svelte 4:\n```svelte\n<!-- Svelte 4 approach -->\n<script>\n  let count = 0;\n  $: doubled = count * 2;\n</script>\n```\n\nThe `$derived` rune provides better scoping (not limited to top-level component code) and more explicit reactivity."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"What is the purpose of the `$effect` rune in Svelte 5, and how does it differ from the reactive statements in Svelte 4?","answer":"The `$effect` rune in Svelte 5 is designed to handle side effects in response to reactive state changes. It runs a function when the component mounts and re-runs it whenever any reactive values read within the function change.\n\nBasic usage:\n```svelte\n<script>\n  let count = $state(0);\n  \n  $effect(() => {\n    console.log(`The count is now ${count}`);\n    // This will run on mount and whenever count changes\n  });\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nKey characteristics of `$effect`:\n\n1. **Timing**: The effect function runs after the component mounts and after any DOM updates have been applied following state changes.\n\n2. **Batching**: If multiple reactive values change in the same \"tick\", the effect only runs once after all changes are applied.\n\n3. **Dependency tracking**: Svelte automatically tracks which reactive values the effect depends on and only re-runs the effect when those specific values change.\n\nA more complex example with canvas manipulation:\n```svelte\n<script>\n  let size = $state(50);\n  let color = $state('#ff3e00');\n  let canvas;\n\n  $effect(() => {\n    if (!canvas) return; // Guard against canvas not being available yet\n    \n    const context = canvas.getContext('2d');\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    // This will re-run whenever `color` or `size` change\n    context.fillStyle = color;\n    context.fillRect(0, 0, size, size);\n  });\n</script>\n\n<canvas bind:this={canvas} width=\"100\" height=\"100\" />\n<div>\n  <input type=\"range\" min=\"10\" max=\"100\" bind:value={size} />\n  <input type=\"color\" bind:value={color} />\n</div>\n```\n\nDifferences from Svelte 4:\n1. In Svelte 4, side effects were handled with reactive statements using the `$:` syntax:\n   ```svelte\n   <script>\n     let count = 0;\n     \n     $: {\n       console.log(`The count is now ${count}`);\n     }\n   </script>\n   ```\n\n2. Svelte 5's `$effect` is more flexible as it's not limited to the top level of a component, allowing effects to be defined in functions, methods, and other nested scopes.\n\n3. The mental model is clearer - `$effect` is explicitly for side effects, while `$derived` is for derived values, separating these concerns more cleanly than the overloaded `$:` syntax in Svelte 4."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"How can you implement a reactive class using Svelte 5's runes, and what advantages does this offer over Svelte 4's approach?","answer":"Svelte 5's runes enable reactive class implementations, which wasn't directly possible in Svelte 4. This allows for more organized, object-oriented reactive code.\n\nHere's how to implement a reactive class using Svelte 5's runes:\n\n```js\nclass ShoppingCart {\n  items = $state([]);\n  discount = $state(0);\n  \n  // Derived values\n  itemCount = $derived(this.items.length);\n  subtotal = $derived(this.items.reduce((sum, item) => sum + item.price, 0));\n  discountAmount = $derived(this.subtotal * this.discount);\n  total = $derived(this.subtotal - this.discountAmount);\n  \n  constructor(initialDiscount = 0) {\n    this.discount = initialDiscount;\n  }\n  \n  addItem(item) {\n    this.items = [...this.items, item];\n  }\n  \n  removeItem(itemId) {\n    this.items = this.items.filter(item => item.id !== itemId);\n  }\n  \n  applyDiscount(discountPercentage) {\n    this.discount = discountPercentage / 100;\n  }\n}\n```\n\nUsing this class in a component:\n\n```svelte\n<script>\n  import { ShoppingCart } from './ShoppingCart.js';\n  \n  const cart = $state(new ShoppingCart());\n  \n  function handleAddItem() {\n    cart.addItem({\n      id: Math.random().toString(36).substr(2, 9),\n      name: `Product ${cart.itemCount + 1}`,\n      price: Math.floor(Math.random() * 100) + 1\n    });\n  }\n</script>\n\n<button onclick={handleAddItem}>Add Random Item</button>\n<button onclick={() => cart.applyDiscount(10)}>Apply 10% Discount</button>\n\n<div>\n  <h2>Shopping Cart ({cart.itemCount} items)</h2>\n  <ul>\n    {#each cart.items as item}\n      <li>\n        {item.name} - ${item.price}\n        <button onclick={() => cart.removeItem(item.id)}>Remove</button>\n      </li>\n    {/each}\n  </ul>\n  \n  <div>Subtotal: ${cart.subtotal}</div>\n  {#if cart.discount > 0}\n    <div>Discount: ${cart.discountAmount} ({cart.discount * 100}%)</div>\n  {/if}\n  <div><strong>Total: ${cart.total}</strong></div>\n</div>\n```\n\nAdvantages over Svelte 4:\n\n1. **Encapsulation**: Related state and behavior are grouped together in a class, making the code more maintainable.\n\n2. **Reusability**: The reactive class can be instantiated multiple times and used across different components.\n\n3. **Clearer structure**: The class structure provides a clear organization for complex state logic.\n\n4. **Inheritance and composition**: You can use OOP patterns like inheritance and composition with reactive classes.\n\n5. **Better TypeScript support**: Classes work well with TypeScript's type system.\n\nIn Svelte 4, you would typically have to keep all reactive logic at the component level or use stores, which could lead to more scattered code for complex state management:\n\n```svelte\n<!-- Svelte 4 approach -->\n<script>\n  // All logic in the component\n  let items = [];\n  let discount = 0;\n  \n  $: itemCount = items.length;\n  $: subtotal = items.reduce((sum, item) => sum + item.price, 0);\n  $: discountAmount = subtotal * discount;\n  $: total = subtotal - discountAmount;\n  \n  function addItem(item) {\n    items = [...items, item];\n  }\n  \n  function removeItem(itemId) {\n    items = items.filter(item => item.id !== itemId);\n  }\n  \n  function applyDiscount(discountPercentage) {\n    discount = discountPercentage / 100;\n  }\n</script>\n```\n\nThe ability to create reactive classes in Svelte 5 bridges the gap between object-oriented programming and reactive programming paradigms."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"What are the limitations of the `$derived` rune, and how would you handle situations where you need to perform side effects when reactive values change?","answer":"The `$derived` rune in Svelte 5 has specific limitations designed to maintain predictable reactivity:\n\n### Limitations of `$derived`:\n\n1. **No side effects allowed**: The expression inside `$derived()` must be pure and side-effect free. This means you cannot:\n   - Modify state (`count++`)\n   - Call functions that modify state\n   - Make API calls\n   - Manipulate the DOM\n   - Log to the console\n\n2. **Synchronous only**: The expression must be synchronous. You cannot use async/await or Promises inside a `$derived` expression.\n\n3. **Deterministic**: The expression should return the same result given the same inputs. Non-deterministic operations like `Math.random()` are discouraged.\n\nExample of invalid `$derived` usage:\n```svelte\n<script>\n  let count = $state(0);\n  \n  // These will cause errors or unexpected behavior\n  let invalid1 = $derived(count++);                 // Modifies state\n  let invalid2 = $derived(fetch('/api/data'));      // Side effect\n  let invalid3 = $derived(console.log(count));      // Side effect\n  let invalid4 = $derived(document.title = count);  // DOM manipulation\n</script>\n```\n\n### Using `$effect` for Side Effects\n\nFor situations where you need to perform side effects when reactive values change, you should use the `$effect` rune instead:\n\n```svelte\n<script>\n  let count = $state(0);\n  let apiData = $state(null);\n  \n  // Correctly using $derived for computation only\n  let doubled = $derived(count * 2);\n  \n  // Using $effect for side effects\n  $effect(() => {\n    console.log(`Count changed to ${count}`);\n    document.title = `Count: ${count}`;\n  });\n  \n  // API calls in effects\n  $effect(async () => {\n    if (count > 0) {\n      const response = await fetch(`/api/data?count=${count}`);\n      apiData = await response.json();\n    }\n  });\n</script>\n```\n\n### Complex Example: Chart Rendering\n\nHere's a more complex example showing how to combine `$derived` for computations and `$effect` for side effects when building a chart component:\n\n```svelte\n<script>\n  import Chart from 'chart.js';\n  \n  // Props or local state\n  let data = $state([10, 20, 30, 40, 50]);\n  let threshold = $state(25);\n  \n  // Derived values (pure calculations)\n  let average = $derived(data.reduce((sum, val) => sum + val, 0) / data.length);\n  let max = $derived(Math.max(...data));\n  let aboveThreshold = $derived(data.filter(val => val > threshold).length);\n  let percentageAbove = $derived((aboveThreshold / data.length) * 100);\n  \n  // Prepare chart data (pure transformation)\n  let chartData = $derived({\n    labels: data.map((_, i) => `Item ${i+1}`),\n    datasets: [\n      {\n        label: 'Values',\n        data: data,\n        backgroundColor: data.map(val => val > threshold ? 'rgba(255, 99, 132, 0.5)' : 'rgba(54, 162, 235, 0.5)')\n      }\n    ]\n  });\n  \n  let chartCanvas;\n  let chartInstance = null;\n  \n  // Side effect: create and update chart\n  $effect(() => {\n    if (!chartCanvas) return;\n    \n    // Clean up existing chart if it exists\n    if (chartInstance) {\n      chartInstance.destroy();\n    }\n    \n    // Create new chart (side effect)\n    chartInstance = new Chart(chartCanvas.getContext('2d'), {\n      type: 'bar',\n      data: chartData,\n      options: {\n        scales: {\n          y: {\n            beginAtZero: true,\n            max: Math.ceil(max * 1.1)\n          }\n        },\n        plugins: {\n          annotation: {\n            annotations: {\n              line1: {\n                type: 'line',\n                yMin: threshold,\n                yMax: threshold,\n                borderColor: 'rgb(255, 99, 132)',\n                borderWidth: 2\n              }\n            }\n          }\n        }\n      }\n    });\n  });\n  \n  // Another side effect: log analytics\n  $effect(() => {\n    // Only run after initial render\n    if (data.length > 0) {\n      console.log(`Analytics: Average is ${average}, ${percentageAbove}% of values are above threshold`);\n    }\n  });\n</script>\n\n<div>\n  <canvas bind:this={chartCanvas}></canvas>\n  <div>\n    <p>Average: {average.toFixed(2)}</p>\n    <p>{aboveThreshold} values ({percentageAbove.toFixed(1)}%) are above the threshold of {threshold}</p>\n    <label>\n      Threshold:\n      <input type=\"range\" min=\"0\" max={max * 1.5} bind:value={threshold} />\n    </label>\n  </div>\n</div>\n```\n\nThis approach creates a clear separation of concerns:\n- `$derived` for pure data transformations and calculations\n- `$effect` for side effects like DOM manipulation, API calls, and logging"}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"How do Svelte 5's runes handle batching of updates, and why is this important for application performance?","answer":"Svelte 5's runes implement an intelligent batching system for updates that improves application performance by reducing unnecessary DOM updates and computations.\n\n### How Batching Works in Svelte 5\n\nWhen multiple reactive values change in quick succession (within the same \"tick\" of JavaScript's event loop), Svelte batches these updates together:\n\n```svelte\n<script>\n  let first = $state(\"John\");\n  let last = $state(\"Doe\");\n  let age = $state(30);\n  \n  function updatePerson() {\n    // These changes happen in the same \"tick\"\n    first = \"Jane\";\n    last = \"Smith\";\n    age = 28;\n    // Svelte will batch these updates and only trigger one update cycle\n  }\n  \n  $effect(() => {\n    console.log(`Person updated: ${first} ${last}, ${age} years old`);\n    // This effect will only run once after all three values are updated\n  });\n</script>\n\n<button onclick={updatePerson}>Update Person</button>\n```\n\n### The Batching Process\n\n1. **Change Detection**: When a reactive value changes, Svelte marks it as \"dirty\"\n2. **Scheduling**: Svelte schedules an update to run at the end of the current tick\n3. **Batching**: If more reactive values change before the scheduled update runs, they're included in the same batch\n4. **Processing**: When the update runs, Svelte:\n   - Updates all derived values that depend on the changed values\n   - Runs effects that depend on the changed values\n   - Updates the DOM once with all the changes\n\n### Why Batching is Important for Performance\n\n1. **Reduced DOM Operations**: DOM operations are expensive. Without batching, each state change could trigger separate DOM updates:\n\n   ```js\n   // Without batching, this might cause three separate DOM updates\n   first = \"Jane\";  // Update DOM\n   last = \"Smith\";  // Update DOM again\n   age = 28;        // Update DOM yet again\n   ```\n\n   With batching, there's only one DOM update after all state changes.\n\n2. **Avoiding Cascading Updates**: Consider a component with multiple derived values that depend on each other:\n\n   ```svelte\n   <script>\n     let count = $state(0);\n     let doubled = $derived(count * 2);\n     let quadrupled = $derived(doubled * 2);\n     let message = $derived(`Count: ${count}, Quadrupled: ${quadrupled}`);\n     \n     function increment() {\n       count++;\n     }\n   </script>\n   ```\n\n   Without batching, changing `count` might trigger updates in this order:\n   1. `count` changes\n   2. `doubled` recalculates\n   3. `quadrupled` recalculates\n   4. `message` recalculates\n   \n   With batching, Svelte creates a topological ordering of dependencies and updates them efficiently in a single batch.\n\n3. **Efficient Effect Handling**: Effects only run once per batch, even if multiple dependencies change:\n\n   ```svelte\n   <script>\n     let x = $state(0);\n     let y = $state(0);\n     \n     $effect(() => {\n       console.log(`Position: (${x}, ${y})`);\n       updatePositionInDOM(x, y); // Expensive operation\n     });\n     \n     function moveElement() {\n       x += 10;\n       y += 5;\n     }\n   </script>\n   ```\n\n   The effect only runs once after both `x` and `y` are updated, not twice.\n\n### Example: Form with Multiple Fields\n\n```svelte\n<script>\n  let formData = $state({\n    name: \"\",\n    email: \"\",\n    age: 0\n  });\n  \n  let errors = $derived({\n    name: formData.name.length < 3 ? \"Name too short\" : \"\",\n    email: !formData.email.includes(\"@\") ? \"Invalid email\" : \"\",\n    age: formData.age < 18 ? \"Must be 18+\" : \"\"\n  });\n  \n  let hasErrors = $derived(Object.values(errors).some(e => e !== \"\"));\n  let formSummary = $derived(`${formData.name} (${formData.age}) - ${formData.email}`);\n  \n  function resetForm() {\n    // All these updates are batched together\n    formData = {\n      name: \"\",\n      email: \"\",\n      age: 0\n    };\n  }\n  \n  // This effect only runs once after form reset\n  $effect(() => {\n    console.log(\"Form state:\", formData);\n    console.log(\"Errors:\", errors);\n    console.log(\"Can submit:\", !hasErrors);\n  });\n</script>\n\n<form>\n  <!-- Form fields -->\n</form>\n```\n\n### Performance Implications\n\nBatching significantly improves performance in real-world applications:\n\n1. **Animation smoothness**: When animating multiple properties, batching ensures smooth 60fps rendering\n2. **Form responsiveness**: Complex forms with interdependent validations remain responsive\n3. **Data visualization**: Charts and graphs with many data points update efficiently\n4. **Memory usage**: Fewer intermediate calculations and DOM operations reduce memory pressure\n\nThe batching system in Svelte 5 is automatic and transparent to developers, providing optimal performance by default without requiring explicit optimization code."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"How can you transition from Svelte 4's reactive statements to Svelte 5's runes in an existing codebase? Provide a detailed migration strategy with examples.","answer":"Migrating from Svelte 4's reactive statements to Svelte 5's runes requires a systematic approach. Here's a comprehensive migration strategy with examples for different patterns:\n\n### Migration Strategy Overview\n\n1. **Understand the mapping**: Know which Svelte 5 rune replaces each Svelte 4 pattern\n2. **Incremental migration**: Convert components one at a time\n3. **Test thoroughly**: Ensure behavior remains identical after migration\n4. **Leverage tooling**: Use migration tools if available\n\n### Step 1: Basic State Variables\n\n**Svelte 4:**\n```svelte\n<script>\n  let count = 0;\n  let name = \"World\";\n</script>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let count = $state(0);\n  let name = $state(\"World\");\n</script>\n```\n\n### Step 2: Derived Values\n\n**Svelte 4:**\n```svelte\n<script>\n  let count = 0;\n  $: doubled = count * 2;\n  $: message = `Count is ${count}`;\n</script>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n  let message = $derived(`Count is ${count}`);\n</script>\n```\n\n### Step 3: Side Effects\n\n**Svelte 4:**\n```svelte\n<script>\n  let count = 0;\n  \n  $: {\n    console.log(`Count changed to ${count}`);\n    document.title = `Count: ${count}`;\n  }\n  \n  $: if (count > 10) {\n    alert('Count is greater than 10!');\n  }\n</script>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let count = $state(0);\n  \n  $effect(() => {\n    console.log(`Count changed to ${count}`);\n    document.title = `Count: ${count}`;\n  });\n  \n  $effect(() => {\n    if (count > 10) {\n      alert('Count is greater than 10!');\n    }\n  });\n</script>\n```\n\n### Step 4: Complex Reactive Blocks\n\n**Svelte 4:**\n```svelte\n<script>\n  let width = 0;\n  let height = 0;\n  let depth = 0;\n  \n  $: {\n    const volume = width * height * depth;\n    const area = 2 * (width * height + width * depth + height * depth);\n    console.log({ volume, area });\n  }\n</script>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let width = $state(0);\n  let height = $state(0);\n  let depth = $state(0);\n  \n  let volume = $derived(width * height * depth);\n  let area = $derived(2 * (width * height + width * depth + height * depth));\n  \n  $effect(() => {\n    console.log({ volume, area });\n  });\n</script>\n```\n\n### Step 5: Reactive Statements with Conditions\n\n**Svelte 4:**\n```svelte\n<script>\n  let user = null;\n  let loggedIn = false;\n  \n  $: if (user && !loggedIn) {\n    loggedIn = true;\n    console.log('User logged in:', user);\n  }\n</script>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let user = $state(null);\n  let loggedIn = $state(false);\n  \n  $effect(() => {\n    if (user && !loggedIn) {\n      loggedIn = true;\n      console.log('User logged in:', user);\n    }\n  });\n</script>\n```\n\n### Step 6: Array and Object Mutations\n\n**Svelte 4:**\n```svelte\n<script>\n  let todos = [\n    { id: 1, text: 'Learn Svelte', done: false }\n  ];\n  \n  function addTodo(text) {\n    todos = [...todos, { id: Date.now(), text, done: false }];\n  }\n  \n  $: completedCount = todos.filter(todo => todo.done).length;\n</script>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let todos = $state([\n    { id: 1, text: 'Learn Svelte', done: false }\n  ]);\n  \n  function addTodo(text) {\n    todos = [...todos, { id: Date.now(), text, done: false }];\n  }\n  \n  let completedCount = $derived(todos.filter(todo => todo.done).length);\n</script>\n```\n\n### Step 7: Reactive Declarations that Call Functions\n\n**Svelte 4:**\n```svelte\n<script>\n  let searchTerm = '';\n  let items = ['apple', 'banana', 'cherry'];\n  \n  function search(term, list) {\n    return list.filter(item => item.includes(term));\n  }\n  \n  $: results = search(searchTerm, items);\n</script>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let searchTerm = $state('');\n  let items = $state(['apple', 'banana', 'cherry']);\n  \n  function search(term, list) {\n    return list.filter(item => item.includes(term));\n  }\n  \n  let results = $derived(search(searchTerm, items));\n</script>\n```\n\n### Step 8: Lifecycle-dependent Reactive Logic\n\n**Svelte 4:**\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let data = [];\n  let loading = true;\n  \n  onMount(async () => {\n    const response = await fetch('/api/data');\n    data = await response.json();\n    loading = false;\n  });\n  \n  $: processedData = loading ? [] : data.map(item => ({\n    ...item,\n    processed: true\n  }));\n</script>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let data = $state([]);\n  let loading = $state(true);\n  \n  // Use an IIFE to run on mount\n  (() => {\n    $effect(async () => {\n      const response = await fetch('/api/data');\n      data = await response.json();\n      loading = false;\n    });\n  })();\n  \n  let processedData = $derived(loading ? [] : data.map(item => ({\n    ...item,\n    processed: true\n  })));\n</script>\n```\n\n### Step 9: Converting Store Usage\n\n**Svelte 4:**\n```svelte\n<script>\n  import { writable } from 'svelte/store';\n  \n  const count = writable(0);\n  \n  function increment() {\n    count.update(n => n + 1);\n  }\n</script>\n\n<button on:click={increment}>\n  Count: {$count}\n</button>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let count = $state(0);\n  \n  function increment() {\n    count++;\n  }\n</script>\n\n<button onclick={increment}>\n  Count: {count}\n</button>\n```\n\n### Step 10: Complex Component with Multiple Patterns\n\n**Svelte 4:**\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let users = [];\n  let selectedUserId = null;\n  let searchTerm = '';\n  let loading = true;\n  \n  onMount(async () => {\n    users = await fetchUsers();\n    loading = false;\n  });\n  \n  async function fetchUsers() {\n    const response = await fetch('/api/users');\n    return response.json();\n  }\n  \n  function selectUser(id) {\n    selectedUserId = id;\n  }\n  \n  $: filteredUsers = searchTerm \n    ? users.filter(user => \n        user.name.toLowerCase().includes(searchTerm.toLowerCase())\n      )\n    : users;\n    \n  $: selectedUser = users.find(user => user.id === selectedUserId);\n  \n  $: if (selectedUser) {\n    console.log('Selected user:', selectedUser);\n    document.title = `User: ${selectedUser.name}`;\n  }\n</script>\n```\n\n**Svelte 5:**\n```svelte\n<script>\n  let users = $state([]);\n  let selectedUserId = $state(null);\n  let searchTerm = $state('');\n  let loading = $state(true);\n  \n  // Initialize data\n  (() => {\n    $effect(async () => {\n      users = await fetchUsers();\n      loading = false;\n    });\n  })();\n  \n  async function fetchUsers() {\n    const response = await fetch('/api/users');\n    return response.json();\n  }\n  \n  function selectUser(id) {\n    selectedUserId = id;\n  }\n  \n  let filteredUsers = $derived(searchTerm \n    ? users.filter(user => \n        user.name.toLowerCase().includes(searchTerm.toLowerCase())\n      )\n    : users);\n    \n  let selectedUser = $derived(users.find(user => user.id === selectedUserId));\n  \n  $effect(() => {\n    if (selectedUser) {\n      console.log('Selected user:', selectedUser);\n      document.title = `User: ${selectedUser.name}`;\n    }\n  });\n</script>\n```\n\n### Migration Testing Strategy\n\nFor each component you migrate:\n\n1. Create snapshot tests before migration\n2. Migrate the component\n3. Run the snapshot tests again to ensure visual consistency\n4. Add unit tests for critical reactive behavior\n5. Test edge cases like rapid state changes\n\n### Common Migration Challenges\n\n1. **Reactive statements with multiple effects**: Split into separate `$derived` and `$effect` runes\n2. **Reactive statements with mixed calculations and side effects**: Separate pure calculations into `$derived` and side effects into `$effect`\n3. **Reactive statements that depend on component lifecycle**: Use IIFEs with `$effect` to replicate `onMount` behavior\n\nThis systematic approach will help ensure a smooth transition from Svelte 4's reactive statements to Svelte 5's runes while maintaining application behavior."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"What are the benefits of using Svelte 5's explicit reactivity model with runes compared to Svelte 4's implicit reactivity model? Provide examples of scenarios where the new approach shines.","answer":"Svelte 5's explicit reactivity model with runes offers significant advantages over Svelte 4's implicit reactivity. Let's explore these benefits and scenarios where the new approach excels.\n\n### Benefits of Svelte 5's Explicit Reactivity Model\n\n#### 1. Clearer Intent and Readability\n\n**Svelte 4 (Implicit):**\n```svelte\n<script>\n  let count = 0;\n  let doubled; // Is this reactive? Not obvious\n  \n  $: doubled = count * 2;\n</script>\n```\n\n**Svelte 5 (Explicit):**\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2); // Clearly marked as reactive\n</script>\n```\n\nThe explicit nature of runes makes it immediately clear which variables are reactive and which are not, improving code readability and maintainability.\n\n#### 2. Better Scoping and Flexibility\n\n**Svelte 4 (Limited to component top level):**\n```svelte\n<script>\n  let count = 0;\n  \n  // This works\n  $: doubled = count * 2;\n  \n  function increment() {\n    count++;\n    // Can't use reactive declarations here\n    const tripled = count * 3; // Not reactive\n  }\n</script>\n```\n\n**Svelte 5 (Works anywhere):**\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n  \n  function increment() {\n    count++;\n    let tripled = $derived(count * 3); // Works in function scope!\n    console.log(tripled);\n  }\n</script>\n```\n\nRunes can be used in any scope, not just at the component's top level, enabling more flexible code organization.\n\n#### 3. Class-based Reactive Programming\n\n**Svelte 4 (Not directly supported):**\n```js\n// Not possible to have reactive class properties in Svelte 4\nclass Counter {\n  count = 0;\n  \n  increment() {\n    this.count++;\n  }\n}\n```\n\n**Svelte 5 (Fully supported):**\n```js\nclass Counter {\n  count = $state(0);\n  doubled = $derived(this.count * 2);\n  \n  increment() {\n    this.count++;\n  }\n  \n  $effect() {\n    console.log(`Count is now ${this.count}`);\n  }\n}\n```\n\nSvelte 5 enables reactive class-based programming, opening up new architectural patterns and better organization for complex state.\n\n#### 4. Clearer Separation of Concerns\n\n**Svelte 4 (Mixed concerns with `$:`):**\n```svelte\n<script>\n  let count = 0;\n  \n  // Derived value\n  $: doubled = count * 2;\n  \n  // Side effect\n  $: {\n    console.log(`Count is now ${count}`);\n  }\n  \n  // Conditional side effect\n  $: if (count > 10) {\n    alert('Count is high!');\n  }\n</script>\n```\n\n**Svelte 5 (Distinct runes for different concerns):**\n```svelte\n<script>\n  let count = $state(0);\n  \n  // Clearly a derived value\n  let doubled = $derived(count * 2);\n  \n  // Clearly a side effect\n  $effect(() => {\n    console.log(`Count is now ${count}`);\n  });\n  \n  // Clearly a conditional side effect\n  $effect(() => {\n    if (count > 10) {\n      alert('Count is high!');\n    }\n  });\n</script>\n```\n\nDifferent runes for different purposes make the code's intent clearer and separate computation from side effects.\n\n#### 5. Better TypeScript Integration\n\n**Svelte 4 (Limited type inference with reactive declarations):**\n```svelte\n<script lang=\"ts\">\n  let count = 0;\n  \n  // TypeScript often struggles with reactive declarations\n  $: result = someComplexOperation(count);\n  // Type of result might be unclear\n</script>\n```\n\n**Svelte 5 (Better type inference):**\n```svelte\n<script lang=\"ts\">\n  let count = $state(0);\n  \n  // TypeScript can better infer types with runes\n  let result = $derived(someComplexOperation(count));\n  // Type of result is correctly inferred\n</script>\n```\n\nRunes integrate better with TypeScript, providing improved type inference and developer experience.\n\n### Scenarios Where Svelte 5's Approach Shines\n\n#### 1. Complex State Management\n\n**Scenario**: A dashboard with multiple interdependent widgets and filters\n\n**Svelte 5 Solution**:\n```svelte\n<script>\n  // State\n  let filters = $state({\n    dateRange: { start: new Date(), end: new Date() },\n    categories: ['sales', 'marketing'],\n    showArchived: false\n  });\n  \n  let data = $state([]);\n  let isLoading = $state(true);\n  \n  // Derived state\n  let filteredData = $derived(\n    data.filter(item => {\n      const dateInRange = item.date >= filters.dateRange.start && \n                         item.date <= filters.dateRange.end;\n      const categoryMatch = filters.categories.includes(item.category);\n      const archivedMatch = filters.showArchived || !item.archived;\n      \n      return dateInRange && categoryMatch && archivedMatch;\n    })\n  );\n  \n  let stats = $derived({\n    total: filteredData.length,\n    byCategoryCount: filters.categories.map(cat => ({\n      category: cat,\n      count: filteredData.filter(item => item.category === cat).length\n    })),\n    averageValue: filteredData.reduce((sum, item) => sum + item.value, 0) / \n                 (filteredData.length || 1)\n  });\n  \n  // Effects\n  $effect(async () => {\n    isLoading = true;\n    data = await fetchData(filters);\n    isLoading = false;\n  });\n  \n  $effect(() => {\n    console.log('Dashboard stats updated:', stats);\n  });\n</script>\n```\n\nThis approach cleanly separates state, derived values, and side effects in a complex dashboard.\n\n#### 2. Form Validation\n\n**Scenario**: A multi-step form with complex validation rules\n\n**Svelte 5 Solution**:\n```svelte\n<script>\n  let form = $state({\n    step: 1,\n    personal: {\n      name: '',\n      email: '',\n      age: ''\n    },\n    address: {\n      street: '',\n      city: '',\n      zipCode: ''\n    },\n    preferences: {\n      notifications: false,\n      theme: 'light'\n    }\n  });\n  \n  // Validation with clear dependencies\n  let errors = $derived({\n    personal: {\n      name: form.personal.name.length < 2 ? 'Name is too short' : '',\n      email: !form.personal.email.includes('@') ? 'Invalid email' : '',\n      age: isNaN(form.personal.age) || +form.personal.age < 18 ? 'Must be 18+' : ''\n    },\n    address: {\n      street: form.address.street.length < 5 ? 'Street address too short' : '',\n      city: form.address.city.length < 2 ? 'City name too short' : '',\n      zipCode: !/^\\d{5}$/.test(form.address.zipCode) ? 'Invalid zip code' : ''\n    }\n  });\n  \n  // Step validation\n  let stepValid = $derived({\n    1: !errors.personal.name && !errors.personal.email && !errors.personal.age,\n    2: !errors.address.street && !errors.address.city && !errors.address.zipCode,\n    3: true // No validation for preferences\n  });\n  \n  // Form completion status\n  let canSubmit = $derived(\n    stepValid[1] && stepValid[2] && form.step === 3\n  );\n  \n  function nextStep() {\n    if (form.step < 3 && stepValid[form.step]) {\n      form = { ...form, step: form.step + 1 };\n    }\n  }\n  \n  function prevStep() {\n    if (form.step > 1) {\n      form = { ...form, step: form.step - 1 };\n    }\n  }\n  \n  // Track form changes for analytics\n  $effect(() => {\n    if (form.step === 3 && canSubmit) {\n      logAnalytics('form_complete', { formData: form });\n    }\n  });\n</script>\n```\n\nThe explicit reactivity makes it clear how form fields, validation rules, and step navigation are connected.\n\n#### 3. Game Development\n\n**Scenario**: A simple game with reactive state\n\n**Svelte 5 Solution**:\n```svelte\n<script>\n  class GameObject {\n    x = $state(0);\n    y = $state(0);\n    speed = $state(5);\n    health = $state(100);\n    \n    // Derived properties\n    isAlive = $derived(this.health > 0);\n    position = $derived({ x: this.x, y: this.y });\n    \n    move(dx, dy) {\n      this.x += dx * this.speed;\n      this.y += dy * this.speed;\n    }\n    \n    takeDamage(amount) {\n      this.health = Math.max(0, this.health - amount);\n    }\n    \n    // Effect that runs when health changes\n    $effect() {\n      if (this.health < 20) {\n        console.log('Warning: Low health!');\n      }\n      \n      if (!this.isAlive) {\n        console.log('Game object destroyed');\n      }\n    }\n  }\n  \n  let player = $state(new GameObject());\n  let enemies = $state([\n    new GameObject(),\n    new GameObject()\n  ]);\n  \n  let gameState = $state({\n    score: 0,\n    level: 1,\n    isGameOver: false\n  });\n  \n  // Game logic with derived values\n  let activeEnemies = $derived(enemies.filter(e => e.isAlive));\n  let playerInDanger = $derived(player.health < 30);\n  let gameStatus = $derived(\n    gameState.isGameOver ? 'Game Over' :\n    playerInDanger ? 'Danger!' : 'Playing'\n  );\n  \n  // Game loop effect\n  $effect(() => {\n    const gameLoop = setInterval(() => {\n      if (!player.isAlive || gameState.isGameOver) {\n        clearInterval(gameLoop);\n        gameState = { ...gameState, isGameOver: true };\n        return;\n      }\n      \n      // Update game state\n      updateGame();\n    }, 100);\n    \n    // Cleanup on component unmount\n    return () => clearInterval(gameLoop);\n  });\n  \n  function updateGame() {\n    // Game logic here\n  }\n</script>\n```\n\nThe class-based approach with reactive properties makes game state management much cleaner.\n\n#### 4. Data Visualization\n\n**Scenario**: Interactive chart with filtering and calculations\n\n**Svelte 5 Solution**:\n```svelte\n<script>\n  import { Chart } from 'chart.js';\n  \n  // Raw data\n  let salesData = $state([\n    { month: 'Jan', value: 1000, category: 'A' },\n    { month: 'Feb', value: 1500, category: 'B' },\n    // ...more data\n  ]);\n  \n  // Filters\n  let selectedCategories = $state(['A', 'B', 'C']);\n  let timeRange = $state({ start: 0, end: 11 }); // Months (0-11)\n  \n  // Derived data for chart\n  let filteredData = $derived(\n    salesData.filter(item => {\n      const monthIdx = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', \n                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n                        .indexOf(item.month);\n      return selectedCategories.includes(item.category) && \n             monthIdx >= timeRange.start && \n             monthIdx <= timeRange.end;\n    })\n  );\n  \n  let chartData = $derived({\n    labels: [...new Set(filteredData.map(d => d.month))],\n    datasets: selectedCategories.map(category => ({\n      label: `Category ${category}`,\n      data: filteredData\n        .filter(d => d.category === category)\n        .map(d => d.value)\n    }))\n  });\n  \n  // Statistics\n  let stats = $derived({\n    total: filteredData.reduce((sum, item) => sum + item.value, 0),\n    average: filteredData.reduce((sum, item) => sum + item.value, 0) / \n             (filteredData.length || 1),\n    max: Math.max(...filteredData.map(d => d.value), 0),\n    min: Math.min(...filteredData.map(d => d.value), 0)\n  });\n  \n  let chartInstance;\n  let chartCanvas;\n  \n  // Chart rendering effect\n  $effect(() => {\n    if (!chartCanvas) return;\n    \n    if (chartInstance) {\n      chartInstance.destroy();\n    }\n    \n    chartInstance = new Chart(chartCanvas.getContext('2d'), {\n      type: 'line',\n      data: chartData,\n      options: {\n        responsive: true,\n        scales: {\n          y: {\n            min: stats.min * 0.9,\n            max: stats.max * 1.1\n          }\n        }\n      }\n    });\n  });\n</script>\n```\n\nThe explicit dependencies make it clear how filtering affects the chart and statistics.\n\nThese examples demonstrate how Svelte 5's explicit reactivity model provides clearer code organization, better separation of concerns, and more flexible architectural patterns compared to Svelte 4's implicit reactivity."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"How do Svelte 5's runes handle deep reactivity with nested objects and arrays? Provide examples of common patterns and potential pitfalls.","answer":"Svelte 5's runes introduce a new approach to handling deep reactivity with nested objects and arrays. Let's explore how this works, common patterns, and potential pitfalls.\n\n### How Deep Reactivity Works in Svelte 5\n\nWhen using `$state`, Svelte 5 makes the top-level property reactive, but does not automatically make nested properties deeply reactive. To update nested properties reactively, you need to create new object references.\n\n### Basic Nested Object Reactivity\n\n```svelte\n<script>\n  let user = $state({\n    name: 'John',\n    address: {\n      street: '123 Main St',\n      city: 'Anytown'\n    }\n  });\n  \n  function updateCity(newCity) {\n    // This won't trigger reactivity\n    // user.address.city = newCity;\n    \n    // This will work - create a new address object\n    user = {\n      ...user,\n      address: {\n        ...user.address,\n        city: newCity\n      }\n    };\n  }\n</script>\n\n<div>\n  <p>Name: {user.name}</p>\n  <p>Address: {user.address.street}, {user.address.city}</p>\n  <button onclick={() => updateCity('New City')}>Update City</button>\n</div>\n```\n\n### Working with Arrays of Objects\n\n```svelte\n<script>\n  let todos = $state([\n    { id: 1, text: 'Learn Svelte', done: false },\n    { id: 2, text: 'Build an app', done: false }\n  ]);\n  \n  function toggleTodo(id) {\n    // Create a new array with the updated todo\n    todos = todos.map(todo => \n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    );\n  }\n  \n  function addTodo(text) {\n    todos = [...todos, { id: Date.now(), text, done: false }];\n  }\n  \n  function removeTodo(id) {\n    todos = todos.filter(todo => todo.id !== id);\n  }\n  \n  let completedCount = $derived(todos.filter(todo => todo.done).length);\n</script>\n\n<div>\n  <ul>\n    {#each todos as todo}\n      <li>\n        <input \n          type=\"checkbox\" \n          checked={todo.done} \n          onclick={() => toggleTodo(todo.id)} \n        />\n        <span style={todo.done ? 'text-decoration: line-through' : ''}>\n          {todo.text}\n        </span>\n        <button onclick={() => removeTodo(todo.id)}>Delete</button>\n      </li>\n    {/each}\n  </ul>\n  <p>Completed: {completedCount} of {todos.length}</p>\n</div>\n```\n\n### Deeply Nested Structures\n\nFor deeply nested structures, you need to create new objects at each level:\n\n```svelte\n<script>\n  let state = $state({\n    user: {\n      profile: {\n        personal: {\n          name: 'John',\n          age: 30\n        },\n        preferences: {\n          theme: 'dark',\n          notifications: {\n            email: true,\n            push: false\n          }\n        }\n      }\n    }\n  });\n  \n  function togglePushNotifications() {\n    // Deep update requires creating new objects at each level\n    state = {\n      ...state,\n      user: {\n        ...state.user,\n        profile: {\n          ...state.user.profile,\n          preferences: {\n            ...state.user.profile.preferences,\n            notifications: {\n              ...state.user.profile.preferences.notifications,\n              push: !state.user.profile.preferences.notifications.push\n            }\n          }\n        }\n      }\n    };\n  }\n</script>\n```\n\n### Common Patterns for Managing Deep Reactivity\n\n#### 1. Helper Functions for Deep Updates\n\n```svelte\n<script>\n  // Helper function to set a deeply nested property\n  function setDeep(obj, path, value) {\n    const pathArray = path.split('.');\n    const lastKey = pathArray.pop();\n    \n    // Navigate to the parent of the property to update\n    const parent = pathArray.reduce((current, key) => current[key], obj);\n    \n    // Create a new object with the updated property\n    const newParent = { ...parent, [lastKey]: value };\n    \n    // Now work backwards to create new objects up the path\n    return pathArray.reduceRight((result, key, index) => {\n      const parentPath = pathArray.slice(0, index);\n      const currentObj = parentPath.reduce((o, k) => o[k], obj);\n      return {\n        ...currentObj,\n        [key]: result\n      };\n    }, newParent);\n  }\n  \n  let state = $state({\n    user: {\n      profile: {\n        personal: {\n          name: 'John',\n          age: 30\n        }\n      }\n    }\n  });\n  \n  function updateAge(newAge) {\n    state = setDeep(state, 'user.profile.personal.age', newAge);\n  }\n</script>\n```\n\n#### 2. Using Immer-like Patterns\n\n```svelte\n<script>\n  import produce from 'immer';\n  \n  let state = $state({\n    user: {\n      profile: {\n        personal: {\n          name: 'John',\n          age: 30\n        }\n      }\n    }\n  });\n  \n  function updateWithImmer(updater) {\n    state = produce(state, updater);\n  }\n  \n  function updateAge(newAge) {\n    updateWithImmer(draft => {\n      draft.user.profile.personal.age = newAge;\n    });\n  }\n</script>\n```\n\n#### 3. Flattening State Structure\n\nInstead of deeply nesting objects, sometimes it's better to flatten your state:\n\n```svelte\n<script>\n  let userPersonal = $state({\n    name: 'John',\n    age: 30\n  });\n  \n  let userPreferences = $state({\n    theme: 'dark',\n    emailNotifications: true,\n    pushNotifications: false\n  });\n  \n  function updatePushNotifications(value) {\n    userPreferences = {\n      ...userPreferences,\n      pushNotifications: value\n    };\n  }\n</script>\n```\n\n#### 4. Using Classes with Reactive Properties\n\n```svelte\n<script>\n  class UserProfile {\n    name = $state('John');\n    age = $state(30);\n    \n    preferences = $state({\n      theme: 'dark',\n      notifications: {\n        email: true,\n        push: false\n      }\n    });\n    \n    updateName(newName) {\n      this.name = newName;\n    }\n    \n    togglePushNotifications() {\n      this.preferences = {\n        ...this.preferences,\n        notifications: {\n          ...this.preferences.notifications,\n          push: !this.preferences.notifications.push\n        }\n      };\n    }\n  }\n  \n  let profile = $state(new UserProfile());\n</script>\n\n<div>\n  <p>Name: {profile.name}</p>\n  <p>Push notifications: {profile.preferences.notifications.push ? 'On' : 'Off'}</p>\n  <button onclick={() => profile.togglePushNotifications()}>\n    Toggle Push Notifications\n  </button>\n</div>\n```\n\n### Potential Pitfalls and Solutions\n\n#### Pitfall 1: Direct Mutation of Nested Properties\n\n```svelte\n<script>\n  let user = $state({\n    name: 'John',\n    scores: [10, 20, 30]\n  });\n  \n  function brokenUpdate() {\n    // This won't trigger reactivity!\n    user.scores.push(40);\n  }\n  \n  function correctUpdate() {\n    // This will work\n    user = {\n      ...user,\n      scores: [...user.scores, 40]\n    };\n  }\n</script>\n```\n\n#### Pitfall 2: Forgetting to Update the Root Object\n\n```svelte\n<script>\n  let state = $state({\n    count: 0,\n    user: { name: 'John' }\n  });\n  \n  function brokenUpdate() {\n    // This creates a new user object but doesn't assign it back to state\n    const newUser = { ...state.user, name: 'Jane' };\n    // Missing: state = { ...state, user: newUser };\n  }\n  \n  function correctUpdate() {\n    state = {\n      ...state,\n      user: { ...state.user, name: 'Jane' }\n    };\n  }\n</script>\n```\n\n#### Pitfall 3: Circular References\n\n```svelte\n<script>\n  let nodeA = $state({ name: 'A' });\n  let nodeB = $state({ name: 'B' });\n  \n  // Creating circular references can cause issues\n  nodeA = { ...nodeA, next: nodeB };\n  nodeB = { ...nodeB, next: nodeA };\n  \n  // Better approach: use IDs instead of direct references\n  let nodes = $state({\n    A: { name: 'A', nextId: 'B' },\n    B: { name: 'B', nextId: 'A' }\n  });\n  \n  function getNextNode(id) {\n    return nodes[nodes[id].nextId];\n  }\n</script>\n```\n\n#### Pitfall 4: Performance with Large Objects\n\n```svelte\n<script>\n  let hugeState = $state({\n    // Imagine this has hundreds of nested properties\n    users: Array.from({ length: 1000 }, (_, i) => ({\n      id: i,\n      name: `User ${i}`,\n      // ... many more properties\n    }))\n  });\n  \n  function updateOneUser(id, newName) {\n    // This creates many new objects, which can be expensive\n    hugeState = {\n      ...hugeState,\n      users: hugeState.users.map(user => \n        user.id === id ? { ...user, name: newName } : user\n      )\n    };\n  }\n  \n  // Better approach: Split into smaller pieces\n  let users = $state(\n    Array.from({ length: 1000 }, (_, i) => ({\n      id: i,\n      name: `User ${i}`\n    }))\n  );\n  \n  let selectedUserId = $state(null);\n  let selectedUser = $derived(\n    selectedUserId !== null \n      ? users.find(u => u.id === selectedUserId)\n      : null\n  );\n  \n  function updateSelectedUser(newName) {\n    if (selectedUserId === null) return;\n    \n    users = users.map(user => \n      user.id === selectedUserId ? { ...user, name: newName } : user\n    );\n  }\n</script>\n```\n\n#### Pitfall 5: Reactive Updates in Loops\n\n```svelte\n<script>\n  let items = $state([\n    { id: 1, value: 10 },\n    { id: 2, value: 20 },\n    { id: 3, value: 30 }\n  ]);\n  \n  function brokenBatchUpdate() {\n    // This won't work as expected!\n    items.forEach((item, index) => {\n      // Each iteration overwrites the previous update\n      items = items.map((i, idx) => \n        idx === index ? { ...i, value: i.value + 1 } : i\n      );\n    });\n  }\n  \n  function correctBatchUpdate() {\n    // Do all updates in a single operation\n    items = items.map(item => ({ ...item, value: item.value + 1 }));\n  }\n</script>\n```\n\n### Best Practices for Deep Reactivity\n\n1. **Use immutable update patterns**: Always create new objects/arrays rather than mutating existing ones.\n\n2. **Consider state normalization**: For complex data, use a normalized structure (similar to Redux patterns).\n\n3. **Split large states**: Break large nested structures into smaller, more manageable pieces.\n\n4. **Use helper libraries**: Consider using libraries like Immer for complex updates.\n\n5. **Create utility functions**: Build reusable utility functions for common update patterns.\n\n6. **Be mindful of performance**: Deep cloning large objects can impact performance; structure your state to minimize the need for deep updates.\n\nBy understanding these patterns and pitfalls, you can effectively manage deep reactivity in Svelte 5 applications while maintaining clean, maintainable code."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"How can you combine Svelte 5's runes with lifecycle management for tasks like data fetching, cleanup, and external library integration? Provide comprehensive examples.","answer":"# Combining Svelte 5 Runes with Lifecycle Management\n\nSvelte 5's runes can be effectively combined with lifecycle management for tasks like data fetching, cleanup, and integrating with external libraries. This requires understanding how to properly initialize, update, and clean up resources in the component lifecycle.\n\n## Data Fetching Patterns\n\n### Basic Data Fetching on Mount\n\n```svelte\n<script>\n  let data = $state(null);\n  let loading = $state(true);\n  let error = $state(null);\n  \n  // Self-invoking function that runs on component creation\n  (() => {\n    $effect(async () => {\n      try {\n        loading = true;\n        error = null;\n        const response = await fetch('https://api.example.com/data');\n        if (!response.ok) throw new Error('Network response was not ok');\n        data = await response.json();\n      } catch (err) {\n        error = err.message;\n      } finally {\n        loading = false;\n      }\n    });\n  })();\n</script>\n\n<div>\n  {#if loading}\n    <p>Loading...</p>\n  {:else if error}\n    <p>Error: {error}</p>\n  {:else}\n    <pre>{JSON.stringify(data, null, 2)}</pre>\n  {/if}\n</div>\n```\n\n### Dependent Data Fetching\n\n```svelte\n<script>\n  let userId = $state(1);\n  let user = $state(null);\n  let posts = $state(null);\n  let userLoading = $state(false);\n  let postsLoading = $state(false);\n  \n  // Fetch user when userId changes\n  $effect(async () => {\n    userLoading = true;\n    user = null;\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`);\n      user = await response.json();\n    } catch (error) {\n      console.error('Failed to fetch user:', error);\n    } finally {\n      userLoading = false;\n    }\n  });\n  \n  // Fetch posts when user changes\n  $effect(async () => {\n    if (!user) {\n      posts = null;\n      return;\n    }\n    \n    postsLoading = true;\n    try {\n      const response = await fetch(`https://api.example.com/users/${user.id}/posts`);\n      posts = await response.json();\n    } catch (error) {\n      console.error('Failed to fetch posts:', error);\n    } finally {\n      postsLoading = false;\n    }\n  });\n</script>\n\n<div>\n  <select bind:value={userId}>\n    <option value={1}>User 1</option>\n    <option value={2}>User 2</option>\n    <option value={3}>User 3</option>\n  </select>\n  \n  <h2>User Details</h2>\n  {#if userLoading}\n    <p>Loading user...</p>\n  {:else if user}\n    <p>Name: {user.name}</p>\n    <p>Email: {user.email}</p>\n  {:else}\n    <p>No user selected</p>\n  {/if}\n  \n  <h2>User Posts</h2>\n  {#if postsLoading}\n    <p>Loading posts...</p>\n  {:else if posts && posts.length > 0}\n    <ul>\n      {#each posts as post}\n        <li>{post.title}</li>\n      {/each}\n    </ul>\n  {:else}\n    <p>No posts found</p>\n  {/if}\n</div>\n```\n\n### Data Fetching with Abort Controller\n\n```svelte\n<script>\n  let searchTerm = $state('');\n  let results = $state([]);\n  let loading = $state(false);\n  \n  // Search with proper cleanup\n  $effect(() => {\n    // Don't search if term is too short\n    if (searchTerm.length < 2) {\n      results = [];\n      return;\n    }\n    \n    loading = true;\n    \n    // Create an abort controller for this search\n    const controller = new AbortController();\n    const signal = controller.signal;\n    \n    // Start the search\n    fetch(`https://api.example.com/search?q=${searchTerm}`, { signal })\n      .then(response => response.json())\n      .then(data => {\n        results = data;\n        loading = false;\n      })\n      .catch(err => {\n        if (err.name !== 'AbortError') {\n          console.error('Search failed:', err);\n          loading = false;\n        }\n      });\n    \n    // Return cleanup function that aborts the fetch if the effect re-runs\n    return () => controller.abort();\n  });\n</script>\n\n<div>\n  <input \n    type=\"text\" \n    placeholder=\"Search...\" \n    bind:value={searchTerm} \n  />\n  \n  {#if loading}\n    <p>Searching...</p>\n  {:else if results.length > 0}\n    <ul>\n      {#each results as result}\n        <li>{result.title}</li>\n      {/each}\n    </ul>\n  {:else if searchTerm.length >= 2}\n    <p>No results found</p>\n  {/if}\n</div>\n```\n\n## Timer and Interval Management\n\n### Component with Timer Cleanup\n\n```svelte\n<script>\n  let count = $state(0);\n  let isRunning = $state(false);\n  \n  $effect(() => {\n    if (!isRunning) return;\n    \n    console.log('Starting timer');\n    const interval = setInterval(() => {\n      count++;\n    }, 1000);\n    \n    // Return cleanup function that clears the interval\n    return () => {\n      console.log('Cleaning up timer');\n      clearInterval(interval);\n    };\n  });\n  \n  function toggleTimer() {\n    isRunning = !isRunning;\n  }\n  \n  function resetTimer() {\n    count = 0;\n  }\n</script>\n\n<div>\n  <h2>Timer: {count} seconds</h2>\n  <button onclick={toggleTimer}>\n    {isRunning ? 'Pause' : 'Start'}\n  </button>"}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"What are the three main parts of Svelte's control flow block syntax, and how are they used?","answer":"Svelte's control flow blocks use a consistent syntax with three main parts:\n\n1. `{#...}` - Denotes the start of a block (e.g., `{#if}`, `{#each}`, `{#await}`)\n2. `{:...}` - Denotes a different branch part of the block (e.g., `{:else}`, `{:else if}`, `{:then}`, `{:catch}`)\n3. `{/...}` - Denotes the end of a block (e.g., `{/if}`, `{/each}`, `{/await}`)\n\nThis syntax pattern is consistent across all control flow blocks in Svelte, making it easier to learn and recognize. For example, a complete if-else block would look like:\n\n```svelte\n{#if condition}\n  <!-- content to show when condition is true -->\n{:else}\n  <!-- content to show when condition is false -->\n{/if}\n```\n\nThe syntax is designed to be readable and to augment HTML with conditional rendering capabilities while maintaining a clear structure."}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"How do you iterate over a list in Svelte using the each block, and what are the different ways to access item properties and indices?","answer":"In Svelte, you can iterate over lists using the `{#each}` block. The basic syntax is:\n\n```svelte\n{#each expression as name}\n  <!-- content using name -->\n{/each}\n```\n\nThere are several variations and features available:\n\n1. Basic iteration:\n```svelte\n<h1>Shopping list</h1>\n<ul>\n  {#each items as item}\n    <li>{item.name} x {item.qty}</li>\n  {/each}\n</ul>\n```\n\n2. Including the index:\n```svelte\n<ul>\n  {#each items as item, i}\n    <li>{i + 1}: {item.name} x {item.qty}</li>\n  {/each}\n</ul>\n```\n\n3. Using destructuring to access item properties directly:\n```svelte\n{#each items as { id, name, qty }, i}\n  <li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n4. Using rest patterns:\n```svelte\n{#each objects as { id, ...rest }}\n  <li><span>{id}</span><MyComponent {...rest} /></li>\n{/each}\n```\n\n5. Destructuring arrays:\n```svelte\n{#each items as [id, ...rest]}\n  <li><span>{id}</span><MyComponent values={rest} /></li>\n{/each}\n```\n\nThe `{#each}` block can iterate over any array or array-like value (any object with a `length` property), and also supports iterables like `Map` or `Set`, though these are converted to arrays using `Array.from()` which may impact performance."}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"What is the purpose of providing a key in an each block, and what are the best practices for selecting an appropriate key?","answer":"The purpose of providing a key in an `{#each}` block is to help Svelte efficiently update the DOM when the list data changes. When a key is provided, Svelte uses it to diff the list and determine which items have been added, removed, or moved, rather than simply adding or removing items at the end of the list.\n\nSyntax for using keys:\n```svelte\n{#each items as item (item.id)}\n  <li>{item.name} x {item.qty}</li>\n{/each}\n\n// Or with an index\n{#each items as item, i (item.id)}\n  <li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}\n```\n\nBest practices for selecting an appropriate key:\n\n1. The key should uniquely identify each item in the list.\n2. Strings and numbers are recommended as keys since they allow identity to persist when the objects themselves change.\n3. Using object references as keys can lead to unexpected behavior if the objects are recreated with the same values but different identities.\n4. Avoid using the index as a key if the list order might change, as this defeats the purpose of having a key.\n5. If you don't have a natural unique identifier, consider adding one to your data structure (like a UUID).\n\nFor example, using a unique ID is ideal:\n```svelte\n{#each products as product (product.id)}\n  <ProductCard {product} />\n{/each}\n```\n\nUsing a key is particularly important when:\n- The list items contain state (like form inputs)\n- The list will be reordered or filtered\n- You're using animations or transitions on list items"}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"How can you handle empty lists in Svelte's each block, and why is this feature useful?","answer":"In Svelte, you can handle empty lists in an `{#each}` block by using the `{:else}` clause. This clause is rendered when the list being iterated over is empty.\n\n```svelte\n{#each todos as todo}\n  <p>{todo.text}</p>\n{:else}\n  <p>No tasks today!</p>\n{/each}\n```\n\nThis feature is useful for several reasons:\n\n1. **Improved user experience**: Instead of showing nothing when a list is empty, you can display a helpful message or alternative content.\n\n2. **Simplified code**: Without this feature, you would need to use a separate `{#if}` block to check if the list is empty:\n   ```svelte\n   {#if todos.length > 0}\n     {#each todos as todo}\n       <p>{todo.text}</p>\n     {/each}\n   {:else}\n     <p>No tasks today!</p>\n   {/if}\n   ```\n   The `{:else}` clause in the `{#each}` block combines these operations in a more concise way.\n\n3. **Empty state patterns**: It supports implementing \"empty state\" UI patterns, which are important for guiding users when no data is available.\n\n4. **Loading states**: When combined with async data fetching, it can be part of a pattern to show loading states, then either the list or an empty message.\n\nExample with a more complex empty state:\n```svelte\n<div class=\"todo-list\">\n  <h2>Today's Tasks</h2>\n  {#each todos as todo}\n    <div class=\"todo-item\">\n      <input type=\"checkbox\" bind:checked={todo.completed} />\n      <span class={todo.completed ? 'completed' : ''}>{todo.text}</span>\n    </div>\n  {:else}\n    <div class=\"empty-state\">\n      <img src=\"empty-list.svg\" alt=\"Empty list\" />\n      <p>You have no tasks for today!</p>\n      <button on:click={addNewTask}>Add your first task</button>\n    </div>\n  {/each}\n</div>\n```\n\nThis pattern helps create more intuitive and user-friendly interfaces by explicitly handling the empty state case."}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"What types of values can be iterated over with Svelte's each block, and what are the performance considerations when working with different collection types?","answer":"Svelte's `{#each}` block can iterate over several types of collections:\n\n1. **Arrays**: The most common and efficient collection type to iterate over.\n   ```svelte\n   {#each ['apple', 'banana', 'orange'] as fruit}\n     <li>{fruit}</li>\n   {/each}\n   ```\n\n2. **Array-like objects**: Any object with a `length` property.\n   ```svelte\n   {#each { length: 3, 0: 'a', 1: 'b', 2: 'c' } as letter}\n     <li>{letter}</li>\n   {/each}\n   ```\n\n3. **Iterables**: Such as `Map`, `Set`, or custom objects that implement the iterable protocol.\n   ```svelte\n   {#each new Set(['unique', 'values', 'only']) as value}\n     <li>{value}</li>\n   {/each}\n   \n   {#each new Map([['key1', 'value1'], ['key2', 'value2']]) as [key, value]}\n     <li>{key}: {value}</li>\n   {/each}\n   ```\n\nPerformance considerations:\n\n1. **Arrays**: These are the most performant option as they can be directly processed by Svelte.\n\n2. **Iterables**: When using iterables like `Map` or `Set`, Svelte internally converts them to arrays using `Array.from()` before rendering. This conversion happens on each render, which can impact performance in performance-sensitive code.\n\n   As noted in the documentation: \"Iterables need to be finite and static (they shouldn't change while being iterated over). Under the hood, they are transformed to an array using `Array.from` before being passed off to rendering. If you're writing performance-sensitive code, try to avoid iterables and use regular arrays as they are more performant.\"\n\n3. **Dynamic collections**: If your collection changes frequently, consider converting iterables to arrays once and then updating the array as needed, rather than passing the iterable directly to the each block.\n\nExample of optimizing performance with iterables:\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let mySet = new Set(['a', 'b', 'c']);\n  let myArray = [];\n  \n  // Convert once, then work with the array\n  $: myArray = Array.from(mySet);\n  \n  function addItem(item) {\n    mySet.add(item);\n    // Trigger reactivity\n    mySet = mySet;\n  }\n</script>\n\n<!-- More efficient: -->\n{#each myArray as item}\n  <li>{item}</li>\n{/each}\n\n<!-- Less efficient: -->\n{#each mySet as item}\n  <li>{item}</li>\n{/each}\n```\n\nIn summary, while Svelte provides flexibility in what can be iterated over, using regular arrays directly will give the best performance for frequently updating lists."}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"How can you use destructuring patterns within Svelte's each blocks, and what advantages does this provide?","answer":"Svelte allows you to use various destructuring patterns within `{#each}` blocks, which can make your code more concise and readable. This feature is particularly useful when working with complex objects or arrays.\n\nHere are the main ways to use destructuring in each blocks:\n\n1. **Object destructuring**:\n```svelte\n{#each users as { id, name, email }}\n  <div class=\"user-card\">\n    <h3>{name}</h3>\n    <p>{email}</p>\n    <span>ID: {id}</span>\n  </div>\n{/each}\n```\nThis eliminates the need to reference the parent object repeatedly (`user.name`, `user.email`, etc.).\n\n2. **Array destructuring**:\n```svelte\n{#each pairs as [key, value]}\n  <div class=\"key-value\">\n    <strong>{key}:</strong> {value}\n  </div>\n{/each}\n```\nThis is particularly useful when iterating over entries from a Map or similar data structures.\n\n3. **Rest patterns with objects**:\n```svelte\n{#each components as { id, ...props }}\n  <div class=\"component-wrapper\" data-id={id}>\n    <DynamicComponent {...props} />\n  </div>\n{/each}\n```\nThis allows you to extract specific properties while gathering the rest into a single object that can be spread into child components.\n\n4. **Rest patterns with arrays**:\n```svelte\n{#each rows as [id, ...cells]}\n  <tr>\n    <td>Row ID: {id}</td>\n    {#each cells as cell}\n      <td>{cell}</td>\n    {/each}\n  </tr>\n{/each}\n```\nThis lets you handle the first item differently from the rest of the items in an array.\n\n5. **Nested destructuring**:\n```svelte\n{#each users as { id, name, address: { city, country } }}\n  <div class=\"user-location\">\n    <h3>{name}</h3>\n    <p>Lives in {city}, {country}</p>\n  </div>\n{/each}\n```\nThis allows direct access to nested properties.\n\n6. **With index and key**:\n```svelte\n{#each items as { id, name, price }, i (id)}\n  <li class={i % 2 === 0 ? 'even' : 'odd'}>\n    <span>{i + 1}. {name}</span>\n    <span>${price.toFixed(2)}</span>\n  </li>\n{/each}\n```\nYou can combine destructuring with index access and keys.\n\nAdvantages of using destructuring in each blocks:\n\n1. **Cleaner template code**: Reduces repetition and nesting in your templates\n2. **Improved readability**: Makes it clear which properties are being used\n3. **Easier component integration**: Simplifies passing props to child components with the spread operator\n4. **Performance**: Can be slightly more efficient as it avoids repeated property lookups\n5. **Type safety**: When using TypeScript, destructuring can help with type inference\n\nUsing destructuring in Svelte's each blocks is a powerful way to write more maintainable and concise code, especially when working with complex data structures."}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"What other block types does Svelte provide beyond the each block, and what are their primary purposes?","answer":"Beyond the `{#each}` block, Svelte provides several other block types for different control flow scenarios. According to the documentation, these include:\n\n1. **`{#if}` block**: Used for conditional rendering based on a given expression.\n   ```svelte\n   {#if user.isLoggedIn}\n     <p>Welcome back, {user.name}!</p>\n   {:else if user.isGuest}\n     <p>Welcome, guest user!</p>\n   {:else}\n     <p>Please log in to continue</p>\n   {/if}\n   ```\n   The `{#if}` block allows you to conditionally render content based on whether the provided expression evaluates to a truthy value. It can include `{:else if}` and `{:else}` branches.\n\n2. **`{#await}` block**: Used for handling asynchronous data fetching and promises.\n   ```svelte\n   {#await promiseExpression}\n     <!-- Loading state -->\n     <p>Loading data...</p>\n   {:then value}\n     <!-- Success state -->\n     <p>The value is {value}</p>\n   {:catch error}\n     <!-- Error state -->\n     <p>Error: {error.message}</p>\n   {/await}\n   ```\n   The `{#await}` block provides a clean way to handle the three states of a promise: pending, fulfilled, and rejected. This is particularly useful for data fetching operations.\n\n3. **`{#key}` block**: Used for forcing re-rendering when a value changes.\n   ```svelte\n   {#key expression}\n     <!-- This content will be completely re-rendered when the expression changes -->\n     <SomeComponent />\n   {/key}\n   ```\n   The `{#key}` block causes its contents to be completely destroyed and recreated when the specified value changes. This is useful for animations, resetting component state, or forcing DOM elements to refresh.\n\n4. **`{#snippet}` block**: Used for creating reusable template snippets.\n   ```svelte\n   {#snippet greeting(name)}\n     <h1>Hello {name}!</h1>\n   {/snippet}\n   \n   <div>\n     {@render greeting('World')}\n     {@render greeting('Svelte')}\n   </div>\n   ```\n   The `{#snippet}` block allows you to define reusable pieces of markup that can be rendered multiple times with different parameters.\n\nThe documentation mentions that these additional block types are covered in more detail in their respective sections:\n- `{#snippet}` is covered in the \"snippets\" section\n- `{#key}` is covered in the \"transitions-and-animations\" section\n- `{#await}` is covered in the \"data-fetching\" section\n\nEach of these block types serves a specific purpose in Svelte's template syntax:\n- `{#if}` handles conditional rendering\n- `{#each}` handles list rendering\n- `{#await}` handles asynchronous operations\n- `{#key}` handles component recreation and animations\n- `{#snippet}` handles reusable template fragments\n\nTogether, these blocks provide a comprehensive set of tools for controlling the flow of your Svelte application's UI rendering."}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"How does Svelte's each block handle iterating over Maps and Sets, and what are the performance implications?","answer":"Svelte's `{#each}` block can iterate over JavaScript `Map` and `Set` objects, but there are important considerations regarding how this works and the performance implications.\n\n**How it works:**\n\nWhen you pass a `Map` or `Set` to an `{#each}` block, Svelte internally converts it to an array using `Array.from()` before rendering:\n\n```svelte\n<script>\n  const mySet = new Set(['apple', 'banana', 'orange']);\n  const myMap = new Map([\n    ['fruit', 'apple'],\n    ['vegetable', 'carrot'],\n    ['dairy', 'cheese']\n  ]);\n</script>\n\n<!-- Iterating over a Set -->\n<ul>\n  {#each mySet as item}\n    <li>{item}</li>\n  {/each}\n</ul>\n\n<!-- Iterating over a Map -->\n<ul>\n  {#each myMap as [key, value]}\n    <li>{key}: {value}</li>\n  {/each}\n</ul>\n```\n\n**Performance implications:**\n\nThe documentation explicitly warns about performance considerations:\n\n> \"Iterables need to be finite and static (they shouldn't change while being iterated over). Under the hood, they are transformed to an array using `Array.from` before being passed off to rendering. If you're writing performance-sensitive code, try to avoid iterables and use regular arrays as they are more performant.\"\n\nThis has several important implications:\n\n1. **Conversion overhead**: Every time the component updates, Svelte will convert the iterable to an array again using `Array.from()`. This conversion has a performance cost, especially for large collections.\n\n2. **Memory usage**: The conversion creates a new array in memory, which means you're effectively storing the data twice (once in the original iterable and once in the array).\n\n3. **Reactivity concerns**: If the underlying iterable changes frequently, the repeated conversions can impact performance.\n\n**Optimization strategies:**\n\n1. **Pre-convert to arrays**: If you're working with performance-sensitive code, convert your Maps and Sets to arrays once and then work with the arrays:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let mySet = new Set(['apple', 'banana', 'orange']);\n  let setAsArray = [];\n  \n  // Convert once when component mounts\n  onMount(() => {\n    setAsArray = Array.from(mySet);\n  });\n  \n  // Or reactively when the set changes\n  $: setAsArray = Array.from(mySet);\n  \n  function addItem(item) {\n    mySet.add(item);\n    // Trigger reactivity\n    mySet = mySet;\n  }\n</script>\n\n<!-- Use the array version in the each block -->\n{#each setAsArray as item}\n  <li>{item}</li>\n{/each}\n```\n\n2. **Consider update frequency**: If your iterable rarely changes, the conversion cost might be negligible. If it changes frequently, the performance impact will be more significant.\n\n3. **Use appropriate data structures**: Choose the right data structure for your needs. If you primarily need to iterate over the data for display purposes, consider using arrays directly instead of Sets or Maps.\n\n**When to use iterables anyway:**\n\nDespite the performance considerations, there are valid cases for iterating over Maps and Sets:\n\n1. When the unique properties of these collections (like Map's key-value structure or Set's uniqueness guarantee) are essential to your application logic.\n\n2. When the collections are small or don't change frequently.\n\n3. When the performance difference is negligible compared to other operations in your application.\n\nIn summary, while Svelte supports iterating over Maps and Sets, be mindful of the performance implications, especially in performance-critical parts of your application. When possible, convert these iterables to arrays before passing them to the each block."}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"How would you implement a filtered list in Svelte that maintains proper keying and optimizes for performance?","answer":"Implementing a filtered list in Svelte that maintains proper keying and optimizes for performance involves several best practices. Here's a comprehensive approach:\n\n```svelte\n<script>\n  // Sample data\n  let allItems = [\n    { id: 1, name: 'Apple', category: 'fruit', price: 1.2 },\n    { id: 2, name: 'Banana', category: 'fruit', price: 0.8 },\n    { id: 3, name: 'Carrot', category: 'vegetable', price: 0.5 },\n    { id: 4, name: 'Broccoli', category: 'vegetable', price: 1.5 },\n    { id: 5, name: 'Chicken', category: 'meat', price: 5.0 },\n    { id: 6, name: 'Beef', category: 'meat', price: 7.5 }\n  ];\n  \n  // Filter state\n  let selectedCategory = 'all';\n  let minPrice = 0;\n  let maxPrice = 10;\n  let searchTerm = '';\n  \n  // Derived state for filtered items\n  $: filteredItems = allItems.filter(item => {\n    // Category filter\n    if (selectedCategory !== 'all' && item.category !== selectedCategory) return false;\n    \n    // Price range filter\n    if (item.price < minPrice || item.price > maxPrice) return false;\n    \n    // Search term filter\n    if (searchTerm && !item.name.toLowerCase().includes(searchTerm.toLowerCase())) return false;\n    \n    return true;\n  });\n</script>\n\n<div class=\"filters\">\n  <div class=\"filter-group\">\n    <label>\n      Category:\n      <select bind:value={selectedCategory}>\n        <option value=\"all\">All Categories</option>\n        <option value=\"fruit\">Fruit</option>\n        <option value=\"vegetable\">Vegetable</option>\n        <option value=\"meat\">Meat</option>\n      </select>\n    </label>\n  </div>\n  \n  <div class=\"filter-group\">\n    <label>\n      Price Range:\n      <input type=\"range\" bind:value={minPrice} min=\"0\" max=\"10\" step=\"0.1\" />\n      <input type=\"range\" bind:value={maxPrice} min=\"0\" max=\"10\" step=\"0.1\" />\n      ${minPrice.toFixed(2)} - ${maxPrice.toFixed(2)}\n    </label>\n  </div>\n  \n  <div class=\"filter-group\">\n    <label>\n      Search:\n      <input type=\"text\" bind:value={searchTerm} placeholder=\"Search items...\" />\n    </label>\n  </div>\n</div>\n\n<div class=\"results\">\n  <p>Showing {filteredItems.length} of {allItems.length} items</p>\n  \n  <ul class=\"item-list\">\n    {#each filteredItems as item (item.id)}\n      <li class=\"item-card\">\n        <h3>{item.name}</h3>\n        <p>Category: {item.category}</p>\n        <p>Price: ${item.price.toFixed(2)}</p>\n      </li>\n    {:else}\n      <li class=\"empty-state\">No items match your filters</li>\n    {/each}\n  </ul>\n</div>\n```\n\nKey performance optimization techniques used in this example:\n\n1. **Proper keying**: Using `item.id` as the key in the `{#each}` block ensures that Svelte can efficiently update the DOM when the list changes. This is especially important for filtered lists where items may appear and disappear as filters change.\n\n```svelte\n{#each filteredItems as item (item.id)}\n  <!-- content -->\n{/each}\n```\n\n2. **Reactive declarations**: Using Svelte's reactive declarations (`$:`) to compute the filtered list ensures that the filtering only happens when relevant dependencies change.\n\n```svelte\n$: filteredItems = allItems.filter(item => { /* filtering logic */ });\n```\n\n3. **Early returns in filter function**: The filter function uses early returns to avoid unnecessary condition checks, improving performance slightly.\n\n4. **Empty state handling**: Using the `{:else}` clause in the `{#each}` block provides a clean way to handle the case when no items match the filters.\n\n5. **Avoiding iterables**: Using arrays directly rather than Sets or Maps for the filtered list, as recommended in the documentation for performance-sensitive code.\n\nAdditional optimizations you could consider:\n\n1. **Memoization for complex filters**: If the filtering logic is complex, you might want to memoize the filter function to avoid recalculating when inputs haven't changed.\n\n2. **Pagination or virtualization**: For very large lists, implement pagination or virtualization to only render a subset of items at once.\n\n```svelte\n<!-- Pagination example -->\n<script>\n  // ... other code ...\n  let itemsPerPage = 10;\n  let currentPage = 1;\n  \n  $: totalPages = Math.ceil(filteredItems.length / itemsPerPage);\n  $: paginatedItems = filteredItems.slice(\n    (currentPage - 1) * itemsPerPage,\n    currentPage * itemsPerPage\n  );\n  \n  function nextPage() {\n    if (currentPage < totalPages) currentPage++;\n  }\n  \n  function prevPage() {\n    if (currentPage > 1) currentPage--;\n  }\n</script>\n\n<!-- Then use paginatedItems in the each block -->\n{#each paginatedItems as item (item.id)}\n  <!-- content -->\n{/each}\n\n<div class=\"pagination\">\n  <button on:click={prevPage} disabled={currentPage === 1}>Previous</button>\n  <span>{currentPage} of {totalPages}</span>\n  <button on:click={nextPage} disabled={currentPage === totalPages}>Next</button>\n</div>\n```\n\n3. **Debouncing user input**: For search inputs or other frequently changing filters, debounce the input to avoid excessive recalculations.\n\n```svelte\n<script>\n  import { debounce } from './utils';\n  \n  let searchInput = '';\n  let searchTerm = '';\n  \n  const updateSearchTerm = debounce((value) => {\n    searchTerm = value;\n  }, 300);\n  \n  function handleSearchInput(event) {\n    searchInput = event.target.value;\n    updateSearchTerm(searchInput);\n  }\n</script>\n\n<input type=\"text\" value={searchInput} on:input={handleSearchInput} placeholder=\"Search items...\" />\n```\n\nBy combining these techniques, you can create a highly performant filtered list in Svelte that maintains proper reactivity and DOM efficiency through appropriate keying."}
{"source":"docs/svelte/03-template-syntax/xx-control-flow.md","question":"How does Svelte's each block differ from similar constructs in other frameworks like React or Vue, and what are the unique advantages of Svelte's approach?","answer":"Svelte's `{#each}` block has several key differences and advantages compared to similar constructs in React and Vue. Understanding these differences helps developers leverage Svelte's unique approach to building user interfaces.\n\n### Comparison with React\n\n**React's approach:**\n```jsx\n// React\nfunction MyComponent({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n      {items.length === 0 && <li>No items available</li>}\n    </ul>\n  );\n}\n```\n\n**Svelte's approach:**\n```svelte\n<!-- Svelte -->\n<ul>\n  {#each items as item, index (item.id)}\n    <li>{item.name}</li>\n  {:else}\n    <li>No items available</li>\n  {/each}\n</ul>\n```\n\nKey differences:\n1. **Syntax**: Svelte uses a dedicated block syntax (`{#each}`) rather than JavaScript's `.map()` method embedded in JSX.\n2. **Empty state handling**: Svelte has a built-in `{:else}` clause for empty lists, while React requires a separate conditional expression.\n3. **Reactivity**: In Svelte, updates to the array trigger automatic re-rendering without needing immutable update patterns.\n4. **Compilation**: Svelte compiles the each block into efficient JavaScript that updates only what changed, rather than relying on a virtual DOM diffing algorithm.\n\n### Comparison with Vue\n\n**Vue's approach:**\n```vue\n<!-- Vue -->\n<ul>\n  <li v-for=\"(item, index) in items\" :key=\"item.id\">\n    {{ item.name }}\n  </li>\n  <li v-if=\"items.length === 0\">\n    No items available\n  </li>\n</ul>\n```\n\n**Svelte's approach:**\n```svelte\n<!-- Svelte -->\n<ul>\n  {#each items as item, index (item.id)}\n    <li>{item.name}</li>\n  {:else}\n    <li>No items available</li>\n  {/each}\n</ul>\n```\n\nKey differences:\n1. **Directive vs. Block**: Vue uses a directive (`v-for`) attached to the element being repeated, while Svelte uses a block that wraps the repeated content.\n2. **Empty state handling**: Svelte's `{:else}` clause is more integrated than Vue's separate `v-if` condition.\n3. **Scoping**: Svelte's block approach creates a clearer visual scope for the repeated content.\n\n### Unique Advantages of Svelte's Approach\n\n1. **Compiled output efficiency**: \n   Svelte compiles its templates to highly optimized vanilla JavaScript that directly manipulates the DOM, resulting in smaller bundle sizes and faster runtime performance. The `{#each}` block gets transformed into efficient DOM creation and update code.\n\n   ```javascript\n   // Simplified example of compiled output for an each block\n   const each_blocks = [];\n   \n   for (let i = 0; i < items.length; i += 1) {\n     each_blocks[i] = create_each_block(items[i], i);\n   }\n   \n   function update(changed, ctx) {\n     if (changed.items) {\n       // Only update what changed using the keys\n       const each_value = ctx.items;\n       each_blocks = update_keyed_each(/* ... */);\n     }\n   }\n   ```\n\n2. **Block-level syntax advantages**:\n   - Clearer visual nesting and scope\n   - More consistent with other control flow constructs (`{#if}`, `{#await}`)\n   - Easier to wrap multiple elements without needing container elements\n\n3. **Built-in empty state handling**:\n   The `{:else}` clause provides a clean, integrated way to handle empty lists without additional conditional logic.\n\n4. **Advanced destructuring support**:\n   Svelte's `{#each}` block has excellent support for destructuring patterns:\n\n   ```svelte\n   {#each items as { id, name, ...rest }}\n     <Component {id} {name} {...rest} />\n   {/each}\n   \n   {#each pairs as [key, value]}\n     <div>{key}: {value}</div>\n   {/each}\n   ```\n\n5. **No key requirement warnings**:\n   While Svelte encourages using keys for optimal performance (like React and Vue), it doesn't flood your console with warnings when keys are omitted.\n\n6. **True reactivity**:\n   Svelte's reactivity system means you can directly mutate arrays and objects:\n\n   ```svelte\n   <script>\n     let items = [1, 2, 3];\n     \n     function addItem() {\n       items.push(4); // This works in Svelte!\n       items = items; // Trigger reactivity\n     }\n     \n     // Or even better with the reactive assignment\n     function addItemBetter() {\n       items = [...items, 4]; // No need to manually trigger reactivity\n     }\n   </script>\n   ```\n\n7. **Performance with iterables**:\n   While Svelte does convert iterables like `Map` and `Set` to arrays (which has some performance cost), it makes this conversion transparent to the developer and documents the performance implications.\n\n8. **Simpler mental model**:\n   Developers don't need to understand concepts like reconciliation, virtual DOM, or immutability to work effectively with lists in Svelte.\n\nIn summary, Svelte's `{#each}` block provides a more integrated, readable, and efficient approach to list rendering compared to React and Vue. Its block syntax aligns with Svelte's overall philosophy of providing clear, declarative templates that compile to highly optimized JavaScript, resulting in excellent developer experience and runtime performance."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"What is the rule regarding top-level `<style>` elements in Svelte components, and how does this differ from nested style elements?","answer":"In Svelte components, there can only be one top-level `<style>` element per component. This top-level style element is processed by Svelte's compiler, which applies scoping to ensure styles only affect the current component.\n\nIn contrast, nested `<style>` elements (those placed inside other elements or logic blocks) are inserted directly into the DOM without any Svelte-specific processing or scoping. This means that styles defined in nested style elements will affect the entire document, not just the component they're defined in.\n\nFor example:\n\n```svelte\n<script>\n  // Component logic\n</script>\n\n<!-- This is a top-level style element - it will be scoped to the component -->\n<style>\n  div { \n    color: blue; /* Only affects divs in this component */\n  }\n</style>\n\n<div>\n  <!-- This is a nested style element - it will be inserted as-is into the DOM -->\n  <style>\n    div { \n      color: red; /* Affects ALL divs in the entire document */\n    }\n  </style>\n  Some content\n</div>\n```\n\nThis distinction is crucial to understand when managing styles in Svelte applications to avoid unintended global styling effects."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"How would nested `<style>` elements affect your application's styling, and what potential issues might arise from using them?","answer":"Nested `<style>` elements in Svelte are inserted directly into the DOM without any scoping or processing, which can lead to several potential issues:\n\n1. **Global scope contamination**: Styles defined in nested style elements apply globally across the entire application, not just within the component. This can lead to unintended style overrides.\n\n```svelte\n<div>\n  <style>\n    /* This affects ALL paragraphs in the entire application */\n    p { \n      color: red;\n      font-size: 18px;\n    }\n  </style>\n  <p>This paragraph and all other paragraphs in the app will be red</p>\n</div>\n```\n\n2. **Specificity conflicts**: These global styles might conflict with other styles in your application, creating hard-to-debug CSS specificity issues.\n\n3. **Performance concerns**: Dynamically inserting style elements (especially if done frequently or conditionally) can cause browser repaints and layout recalculations.\n\n4. **Maintainability problems**: Having styles scattered throughout components in nested elements makes the styling approach harder to maintain and reason about.\n\n5. **Potential duplicate styles**: If a component with nested styles is used multiple times, those style elements will be duplicated in the DOM.\n\nFor these reasons, it's generally recommended to use the top-level `<style>` element with Svelte's scoping mechanism, or to use external CSS/preprocessors for global styles, rather than relying on nested style elements."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"In what scenarios might nested `<style>` elements be useful in Svelte, despite their limitations?","answer":"While nested `<style>` elements should generally be avoided due to their global nature, there are some specific scenarios where they might be useful:\n\n1. **Dynamic styling based on runtime conditions**: When you need to generate CSS based on data that's only available at runtime:\n\n```svelte\n<script>\n  let dynamicColor = \"blue\";\n  let dynamicSize = \"16px\";\n  \n  // This might be set from an API or user preference\n  function updateTheme(color, size) {\n    dynamicColor = color;\n    dynamicSize = size;\n  }\n</script>\n\n{#if dynamicColor && dynamicSize}\n  <style>\n    :root {\n      --dynamic-color: {dynamicColor};\n      --dynamic-size: {dynamicSize};\n    }\n    \n    /* Note: The above won't actually work as expected because \n       nested styles aren't processed by Svelte. This illustrates \n       the limitation. */\n  </style>\n{/if}\n```\n\n2. **Third-party integration**: When integrating with libraries that expect to inject their own styles:\n\n```svelte\n<div id=\"third-party-container\">\n  <style>\n    /* Styles required by third-party library */\n    .third-party-element {\n      display: flex;\n      position: relative;\n    }\n  </style>\n</div>\n```\n\n3. **Isolated styling environments**: For creating isolated styling environments like iframes or web components where global styles are actually desired within that context.\n\n4. **Critical CSS injection**: For performance optimization where you want to inject critical CSS directly into the page.\n\nHowever, for most of these cases, there are better alternatives in Svelte:\n- For dynamic styling, use style directives or CSS custom properties in the top-level style\n- For third-party integration, consider using svelte:head to add styles\n- For critical CSS, use the top-level style element or external CSS\n\nThe limitations of nested styles (global scope, no preprocessing) make them rarely the best choice in Svelte applications."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"How do Svelte's style scoping mechanisms work with the top-level `<style>` element, and why doesn't this apply to nested style elements?","answer":"Svelte's style scoping mechanism works by transforming the CSS in top-level `<style>` elements to ensure styles only apply to the current component. Here's how it works:\n\nFor top-level `<style>` elements, Svelte:\n1. Generates a unique class identifier for each component\n2. Adds that class to all top-level elements in the component's template\n3. Transforms all selectors in the style block to include that class\n\nFor example, this component:\n\n```svelte\n<style>\n  div { color: blue; }\n  .special { font-weight: bold; }\n</style>\n\n<div>\n  <p class=\"special\">Hello World</p>\n</div>\n```\n\nGets transformed to something like this (simplified):\n\n```html\n<style>\n  div.svelte-xyz123 { color: blue; }\n  .special.svelte-xyz123 { font-weight: bold; }\n</style>\n\n<div class=\"svelte-xyz123\">\n  <p class=\"special svelte-xyz123\">Hello World</p>\n</div>\n```\n\nThis ensures that the styles only apply to elements within this component.\n\nNested style elements don't receive this treatment because:\n1. They're often dynamically created/removed based on component state\n2. Processing would be more complex as they could appear anywhere in the component tree\n3. They might be used specifically for their global nature (e.g., for theming)\n\nWhen you use a nested style element:\n\n```svelte\n<div>\n  <style>\n    p { color: red; }\n  </style>\n  <p>This text will be red</p>\n</div>\n```\n\nIt's inserted directly into the DOM without transformation:\n\n```html\n<div>\n  <style>\n    p { color: red; }\n  </style>\n  <p>This text will be red</p>\n</div>\n```\n\nThe `p` selector will apply to all paragraph elements in the document, not just those in the component.\n\nThis distinction is why it's important to understand when to use top-level styles (for component-specific styling) versus when nested styles might be appropriate (rarely, and with caution)."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"How would you conditionally apply styles in Svelte without using nested `<style>` elements?","answer":"There are several better approaches to conditionally apply styles in Svelte without resorting to nested `<style>` elements:\n\n1. **Using class directives**:\n```svelte\n<script>\n  let isActive = false;\n  let theme = 'light';\n</script>\n\n<style>\n  .button {\n    padding: 8px 16px;\n    border-radius: 4px;\n  }\n  \n  .active {\n    background-color: #4CAF50;\n    color: white;\n  }\n  \n  .inactive {\n    background-color: #f1f1f1;\n    color: #333;\n  }\n  \n  .light-theme {\n    background-color: #ffffff;\n    color: #333333;\n  }\n  \n  .dark-theme {\n    background-color: #222222;\n    color: #ffffff;\n  }\n</style>\n\n<button class=\"button\" \n        class:active={isActive} \n        class:inactive={!isActive}\n        class:light-theme={theme === 'light'}\n        class:dark-theme={theme === 'dark'}>\n  Click me\n</button>\n```\n\n2. **Using inline style directives with variables**:\n```svelte\n<script>\n  let fontSize = '16px';\n  let textColor = '#333';\n  \n  function updateStyles(size, color) {\n    fontSize = size;\n    textColor = color;\n  }\n</script>\n\n<div style:font-size={fontSize} style:color={textColor}>\n  This text has dynamic styling\n</div>\n\n<button on:click={() => updateStyles('20px', 'blue')}>\n  Make text bigger and blue\n</button>\n```\n\n3. **Using CSS custom properties in the top-level style**:\n```svelte\n<script>\n  let primary = '#ff3e00';\n  let secondary = '#40b3ff';\n  let isAlternate = false;\n</script>\n\n<style>\n  div {\n    background-color: var(--background-color);\n    color: var(--text-color);\n    padding: 1rem;\n    border-radius: 4px;\n  }\n</style>\n\n<div style:--background-color={isAlternate ? secondary : primary}\n     style:--text-color={isAlternate ? '#fff' : '#000'}>\n  This div uses CSS custom properties for dynamic styling\n</div>\n\n<button on:click={() => isAlternate = !isAlternate}>\n  Toggle theme\n</button>\n```\n\n4. **Using computed classes**:\n```svelte\n<script>\n  let status = 'warning'; // could be 'success', 'error', 'warning', etc.\n  \n  $: statusClass = `status-${status}`;\n</script>\n\n<style>\n  .status-success { background-color: green; }\n  .status-error { background-color: red; }\n  .status-warning { background-color: orange; }\n</style>\n\n<div class={statusClass}>\n  This is a {status} message\n</div>\n```\n\n5. **Using the svelte:head component for truly global styles**:\n```svelte\n<script>\n  let theme = 'light';\n  \n  $: themeStyles = theme === 'dark' \n    ? `body { background-color: #222; color: #fff; }`\n    : `body { background-color: #fff; color: #222; }`;\n</script>\n\n<svelte:head>\n  <style>\n    {themeStyles}\n  </style>\n</svelte:head>\n\n<button on:click={() => theme = theme === 'light' ? 'dark' : 'light'}>\n  Toggle theme\n</button>\n```\n\nThese approaches provide better scoping, maintainability, and performance compared to using nested `<style>` elements, while still allowing for dynamic and conditional styling."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"What happens when you include a `<style>` element inside a conditional block in Svelte?","answer":"When you include a `<style>` element inside a conditional block in Svelte (like an `{#if}`, `{#each}`, or `{#await}` block), it's treated as a nested style element. This means it will be inserted into or removed from the DOM based on the condition, without any Svelte-specific processing or scoping.\n\nHere's what happens with a style element in a conditional block:\n\n```svelte\n<script>\n  let showStyles = false;\n</script>\n\n<!-- Top-level style - always processed by Svelte, scoped to component -->\n<style>\n  button {\n    padding: 8px 16px;\n    border-radius: 4px;\n    background-color: #4CAF50;\n    color: white;\n  }\n</style>\n\n{#if showStyles}\n  <!-- Nested style - inserted as-is when condition is true -->\n  <style>\n    /* This applies globally to ALL paragraphs in the application */\n    p {\n      color: red;\n      font-size: 18px;\n    }\n  </style>\n{/if}\n\n<p>This paragraph will be red when showStyles is true</p>\n<button on:click={() => showStyles = !showStyles}>\n  Toggle styles\n</button>\n```\n\nThe implications of this approach include:\n\n1. **Dynamic style injection**: When `showStyles` becomes `true`, the browser will parse and apply the nested styles, potentially causing a reflow/repaint.\n\n2. **Global effect**: The styles will apply to all matching elements in the entire document, not just within the component.\n\n3. **Performance considerations**: Frequently toggling styles this way can impact performance as the browser needs to recalculate styles.\n\n4. **Potential style flashing**: Users might see a flash of unstyled content as styles are applied after the condition changes.\n\n5. **Specificity issues**: These dynamically added styles might unexpectedly override other styles due to CSS specificity rules.\n\nA better approach for conditional styling would be to use class directives or CSS custom properties as demonstrated in the previous answer. For example:\n\n```svelte\n<script>\n  let showSpecialStyle = false;\n</script>\n\n<style>\n  p {\n    transition: all 0.3s ease;\n  }\n  \n  .special-style {\n    color: red;\n    font-size: 18px;\n  }\n</style>\n\n<p class:special-style={showSpecialStyle}>\n  This paragraph will be styled conditionally\n</p>\n\n<button on:click={() => showSpecialStyle = !showSpecialStyle}>\n  Toggle special style\n</button>\n```\n\nThis approach maintains proper style scoping while still allowing for conditional styling."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"How does Svelte's approach to CSS differ from other frameworks like React or Vue, particularly regarding style scoping and nested styles?","answer":"Svelte's approach to CSS differs significantly from React and Vue, particularly in how it handles style scoping and nested styles:\n\n### Svelte's Approach\n\n1. **Component-scoped CSS by default**: \n   - Top-level `<style>` tags in Svelte components automatically scope styles to that component\n   - Scoping is done at compile time by adding unique classes to elements\n   - No runtime overhead for style isolation\n   - Only one top-level `<style>` tag is allowed per component\n\n2. **Nested styles behavior**:\n   - Nested `<style>` elements are inserted as-is into the DOM\n   - No scoping or processing is applied to nested styles\n   - They affect the global document\n\n3. **CSS syntax**:\n   - Uses regular CSS syntax without requiring special formats\n   - No need for CSS-in-JS libraries or special attributes\n\n```svelte\n<!-- Svelte Component -->\n<style>\n  /* Automatically scoped to this component */\n  button { \n    background: blue;\n    color: white;\n  }\n</style>\n\n<button>Svelte Button</button>\n```\n\n### React's Approach\n\n1. **No built-in CSS scoping**:\n   - React doesn't provide native CSS scoping\n   - Requires CSS-in-JS libraries (styled-components, Emotion) or CSS Modules\n   - Runtime overhead for many CSS-in-JS solutions\n\n2. **Inline styles**:\n   - Often uses JavaScript objects for inline styles\n   - Camel-cased property names instead of kebab-case\n\n3. **No direct equivalent to nested styles**:\n   - Would typically use dynamic style injection via DOM APIs\n\n```jsx\n// React Component\nimport React from 'react';\nimport './Button.css'; // Global unless using CSS Modules\n\n// Alternative with inline styles\nfunction Button() {\n  return (\n    <button style={{ backgroundColor: 'blue', color: 'white' }}>\n      React Button\n    </button>\n  );\n}\n```\n\n### Vue's Approach\n\n1. **Optional scoped CSS**:\n   - Uses a `scoped` attribute on style tags\n   - Adds data attributes to elements and selectors\n   - Processed at compile time but with different mechanism than Svelte\n\n2. **Multiple style tags allowed**:\n   - Can have multiple `<style>` tags with different processing options\n   - Can mix scoped and global styles\n\n3. **CSS Modules support**:\n   - Built-in support for CSS Modules with `module` attribute\n\n```vue\n<!-- Vue Component -->\n<template>\n  <button class=\"button\">Vue Button</button>\n</template>\n\n<style scoped>\n/* Scoped to this component using data attributes */\n.button {\n  background: blue;\n  color: white;\n}\n</style>\n```\n\n### Key Differences\n\n1. **Compile-time vs Runtime**:\n   - Svelte processes CSS at compile time with zero runtime overhead\n   - React typically handles styles at runtime (except with CSS Modules)\n   - Vue processes some at compile time but with different mechanism\n\n2. **Scoping Implementation**:\n   - Svelte: Uses class-based scoping with generated class names\n   - Vue: Uses data attributes for scoping\n   - React: Relies on third-party solutions with various approaches\n\n3. **Nested Styles**:\n   - Svelte: Inserts nested styles directly into DOM without processing\n   - Vue: No direct equivalent to Svelte's nested styles behavior\n   - React: No direct equivalent; would use dynamic style injection\n\n4. **Developer Experience**:\n   - Svelte: Write standard CSS directly in components\n   - React: Often requires learning CSS-in-JS libraries\n   - Vue: Similar to Svelte but with more configuration options\n\nSvelte's approach generally leads to smaller bundle sizes and better performance, with a developer experience that feels closer to traditional web development while still maintaining component isolation."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"When working with third-party libraries in Svelte, what are the best practices for handling their CSS requirements without using nested `<style>` elements?","answer":"When integrating third-party libraries with Svelte, there are several best practices for handling their CSS requirements without resorting to nested `<style>` elements:\n\n### 1. Using Global Stylesheets\n\nFor libraries that require global styles, import them in your main entry file:\n\n```javascript\n// In your main.js or App.svelte\nimport 'some-library/dist/some-library.css';\n```\n\nThis works well for libraries like Bootstrap, Tailwind, or UI component libraries.\n\n### 2. Using svelte:head for Dynamic Global Styles\n\nFor styles that need to be added conditionally or dynamically:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  let libraryStyles = '';\n  \n  onMount(async () => {\n    // Fetch or import styles dynamically\n    const response = await fetch('some-library/styles.css');\n    libraryStyles = await response.text();\n  });\n</script>\n\n<svelte:head>\n  {#if libraryStyles}\n    <style>\n      /* These styles will be global */\n      {libraryStyles}\n    </style>\n  {/if}\n</svelte:head>\n```\n\n### 3. CSS Custom Properties for Theming\n\nExpose configuration points for third-party libraries using CSS custom properties:\n\n```svelte\n<style>\n  /* Define variables that third-party library will use */\n  :global(:root) {\n    --library-primary-color: #ff3e00;\n    --library-secondary-color: #40b3ff;\n    --library-font-size: 16px;\n  }\n</style>\n```\n\n### 4. Using :global() for Specific Selectors\n\nWhen you need to target specific third-party components from your Svelte component:\n\n```svelte\n<style>\n  /* Scope to your component wrapper but allow targeting library elements */\n  .my-calendar-wrapper :global(.library-calendar-day) {\n    border-radius: 4px;\n  }\n  \n  .my-calendar-wrapper :global(.library-calendar-day.selected) {\n    background-color: var(--theme-color, #ff3e00);\n  }\n</style>\n\n<div class=\"my-calendar-wrapper\">\n  <!-- Third-party calendar component -->\n  <ThirdPartyCalendar />\n</div>\n```\n\n### 5. Style Encapsulation with Shadow DOM\n\nFor complete style isolation, you can use the Shadow DOM (though this is a more advanced approach):\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  import 'third-party-library';\n  \n  let container;\n  \n  onMount(() => {\n    // Create shadow root\n    const shadow = container.attachShadow({ mode: 'open' });\n    \n    // Add styles specific to the shadow DOM\n    const style = document.createElement('style');\n    style.textContent = `\n      .third-party-element { \n        color: blue; \n      }\n    `;\n    shadow.appendChild(style);\n    \n    // Create third-party element in shadow DOM\n    const element = document.createElement('third-party-element');\n    shadow.appendChild(element);\n  });\n</script>\n\n<div bind:this={container}></div>\n```\n\n### 6. Preprocessors and Build Configuration\n\nConfigure your build system to handle third-party CSS:\n\n```javascript\n// svelte.config.js\nimport sveltePreprocess from 'svelte-preprocess';\n\nexport default {\n  preprocess: sveltePreprocess({\n    // Preprocessor options\n    scss: {\n      // Include paths for third-party library styles\n      includePaths: ['node_modules/some-library/scss']\n    }\n  }),\n  // ...other config\n};\n```\n\nThen in your component:\n\n```svelte\n<style lang=\"scss\">\n  /* Import third-party SCSS */\n  @import 'some-library-variables';\n  \n  // Use and override variables\n  $primary-color: $library-primary-color;\n  \n  .my-component {\n    color: $primary-color;\n  }\n</style>\n```\n\n### 7. Component Wrappers\n\nCreate dedicated wrapper components for third-party libraries:\n\n```svelte\n<!-- LibraryWrapper.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  import 'library-css-path';\n  \n  // Component props and initialization\n</script>\n\n<style>\n  /* Component-specific overrides using :global() */\n  :global(.library-component) {\n    font-family: inherit;\n  }\n</style>\n\n<div class=\"library-wrapper\">\n  <slot></slot>\n</div>\n```\n\nThen use this wrapper:\n\n```svelte\n<script>\n  import LibraryWrapper from './LibraryWrapper.svelte';\n  import { ThirdPartyComponent } from 'third-party-library';\n</script>\n\n<LibraryWrapper>\n  <ThirdPartyComponent />\n</LibraryWrapper>\n```\n\n### 8. CSS Reset/Normalization\n\nInclude a CSS reset or normalization before third-party styles to ensure consistent behavior:\n\n```javascript\n// In your main.js\nimport './reset.css';  // First\nimport 'third-party-library/styles.css';  // Then third-party\nimport './app.css';  // Then your app styles\n```\n\nThese approaches provide better maintainability, performance, and style encapsulation compared to using nested `<style>` elements, while still allowing you to effectively integrate third-party libraries into your Svelte application."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"What are the potential performance implications of using nested `<style>` elements in Svelte, particularly in components that might be rendered multiple times?","answer":"Using nested `<style>` elements in Svelte can have several performance implications, especially in components that are rendered multiple times:\n\n### 1. Style Element Duplication\n\nWhen a component with nested `<style>` elements is rendered multiple times, each instance will create its own DOM `<style>` element:\n\n```svelte\n<!-- MyComponent.svelte -->\n<div>\n  <style>\n    .special { color: red; }\n  </style>\n  <p class=\"special\">Styled text</p>\n</div>\n```\n\nIf this component is rendered 10 times:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import MyComponent from './MyComponent.svelte';\n</script>\n\n{#each Array(10) as _}\n  <MyComponent />\n{/each}\n```\n\nThis results in 10 identical `<style>` elements in the DOM, each containing the same CSS rules. In contrast, Svelte's top-level `<style>` elements are extracted and deduplicated during compilation.\n\n### 2. CSSOM Processing Overhead\n\nEach time a new `<style>` element is added to the DOM:\n\n1. The browser must parse the CSS text\n2. Update the CSSOM (CSS Object Model)\n3. Recalculate styles\n4. Potentially trigger layout and paint operations\n\nThis process becomes especially expensive when:\n- Components are frequently mounted/unmounted\n- Styles are complex or target many elements\n- The page already has many style rules\n\n### 3. Render Blocking\n\nStyle processing can block rendering, particularly when:\n\n```svelte\n<script>\n  let items = [];\n  \n  async function loadItems() {\n    items = await fetchData();\n  }\n</script>\n\n{#each items as item}\n  <div>\n    <style>\n      .item { \n        padding: 10px;\n        margin: 5px;\n        border: 1px solid #ccc;\n      }\n    </style>\n    <div class=\"item\">{item.name}</div>\n  </div>\n{/each}\n```\n\nAs each item is rendered, the browser must process a new style element, potentially causing jank during scrolling or animations.\n\n### 4. Memory Usage\n\nMultiple identical style elements consume additional memory. While a single style element might be negligible, in a large application with many components and instances, this can add up:\n\n```svelte\n<!-- Consider a data grid with hundreds of rows -->\n{#each largeDataset as row}\n  <tr>\n    <style>\n      /* Styles for highlighting */\n      .highlight { background-color: yellow; }\n    </style>\n    {#each row as cell, i}\n      <td class:highlight={cell.isHighlighted}>{cell.value}</td>\n    {/each}\n  </tr>\n{/each}\n```\n\nThis could create hundreds of redundant style elements.\n\n### 5. Style Conflict Resolution\n\nWith multiple identical style rules from different instances, the browser must perform more work to resolve which styles apply to which elements, especially with complex selectors or media queries:\n\n```svelte\n<div>\n  <style>\n    @media (max-width: 768px) {\n      .responsive { \n        flex-direction: column;\n      }\n    }\n  </style>\n  <div class=\"responsive\">...</div>\n</div>\n```\n\n### 6. Dynamic Style Changes\n\nWhen nested styles are used with conditionals, each change requires browser recalculation:\n\n```svelte\n<script>\n  let theme = 'light';\n</script>\n\n<div>\n  {#if theme === 'light'}\n    <style>\n      body { background: white; color: black; }\n    </style>\n  {:else}\n    <style>\n      body { background: black; color: white; }\n    </style>\n  {/if}\n</div>\n\n<button on:click={() => theme = theme === 'light' ? 'dark' : 'light'}>\n  Toggle Theme\n</button>\n```\n\nEvery theme toggle removes one style element and adds another, triggering full recalculation.\n\n### Performance-Friendly Alternatives\n\nInstead of nested styles, these alternatives offer better performance:\n\n1. **Top-level styles with class directives**:\n```svelte\n<style>\n  .light-theme { background: white; color: black; }\n  .dark-theme { background: black; color: white; }\n</style>\n\n<div class:light-theme={theme === 'light'} class:dark-theme={theme === 'dark'}>\n  Content\n</div>\n```\n\n2. **CSS custom properties**:\n```svelte\n<style>\n  .themed {\n    background: var(--theme-bg);\n    color: var(--theme-text);\n  }\n</style>\n\n<div class=\"themed\" \n     style:--theme-bg={theme === 'light' ? 'white' : 'black'}\n     style:--theme-text={theme === 'light' ? 'black' : 'white'}>\n  Content\n</div>\n```\n\n3. **For truly global styles, use a single style in svelte:head**:\n```svelte\n<script>\n  $: themeStyles = theme === 'light' \n    ? `body { background: white; color: black; }`\n    : `body { background: black; color: white; }`;\n</script>\n\n<svelte:head>\n  <style>{themeStyles}</style>\n</svelte:head>\n```\n\nThese approaches avoid the performance pitfalls of multiple nested style elements while still providing dynamic styling capabilities."}
{"source":"docs/svelte/04-styling/04-nested-style-elements.md","question":"How can you use Svelte's `:global()` selector in conjunction with top-level styles to achieve global styling when needed, instead of using nested style elements?","answer":"Svelte's `:global()` selector provides a proper way to apply global styles from within a component's top-level `<style>` element, offering a better alternative to nested style elements. Here's how to use it effectively:\n\n### Basic Usage of :global()\n\nThe `:global()` selector allows you to opt out of Svelte's automatic style scoping for specific selectors:\n\n```svelte\n<style>\n  /* Scoped to this component only */\n  div {\n    border: 1px solid #ccc;\n  }\n  \n  /* Applied globally to all h1 elements in the application */\n  :global(h1) {\n    color: #ff3e00;\n    font-size: 2em;\n  }\n  \n  /* You can also combine scoped and global selectors */\n  div :global(a) {\n    /* This targets all <a> elements inside this component's divs */\n    color: blue;\n    text-decoration: none;\n  }\n</style>\n\n<div>\n  <h1>This heading will be Svelte orange</h1>\n  <a href=\"/\">This link will be blue</a>\n</div>\n```\n\n### Targeting Global Elements with Complex Selectors\n\nYou can use more complex selectors with `:global()`:\n\n```svelte\n<style>\n  /* Target specific global classes */\n  :global(.error-message) {\n    color: red;\n    font-weight: bold;\n  }\n  \n  /* Target global elements with specific attributes */\n  :global(input[type=\"text\"]) {\n    border-radius: 4px;\n    padding: 8px;\n  }\n  \n  /* Target global elements with pseudo-classes */\n  :global(button:hover) {\n    background-color: #f0f0f0;\n  }\n  \n  /* Multiple global selectors */\n  :global(h1, h2, h3) {\n    font-family: 'Georgia', serif;\n  }\n</style>\n```\n\n### Defining Global CSS Custom Properties\n\nYou can define CSS custom properties (variables) globally:\n\n```svelte\n<style>\n  :global(:root) {\n    --primary-color: #ff3e00;\n    --secondary-color: #40b3ff;\n    --font-size-base: 16px;\n    --spacing-unit: 8px;\n  }\n  \n  /* Then use these variables in scoped styles */\n  div {\n    color: var(--primary-color);\n    font-size: var(--font-size-base);\n    padding: calc(var(--spacing-unit) * 2);\n  }\n  \n  /* Or in other global styles */\n  :global(button) {\n    background-color: var(--primary-color);\n    color: white;\n    padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);\n  }\n</style>\n```\n\n### Creating Global Utility Classes\n\nDefine utility classes that can be used throughout your application:\n\n```svelte\n<style>\n  /* Flex utilities */\n  :global(.flex) { display: flex; }\n  :global(.flex-col) { flex-direction: column; }\n  :global(.items-center) { align-items: center; }\n  :global(.justify-between) { justify-content: space-between; }\n  \n  /* Spacing utilities */\n  :global(.m-1) { margin: 0.25rem; }\n  :global(.m-2) { margin: 0.5rem; }\n  :global(.p-1) { padding: 0.25rem; }\n  :global(.p-2) { padding: 0.5rem; }\n  \n  /* Text utilities */\n  :global(.text-center) { text-align: center; }\n  :global(.text-lg) { font-size: 1.125rem; }\n</style>\n```\n\n### Theming with :global()\n\nCreate theme styles that affect the entire application:\n\n```svelte\n<script>\n  export let theme = 'light';\n</script>\n\n<style>\n  :global(body) {\n    transition: background-color 0.3s, color 0.3s;\n  }\n  \n  :global(body.light-theme) {\n    background-color: #ffffff;\n    color: #333333;\n  }\n  \n  :global(body.dark-theme) {\n    background-color: #222222;\n    color: #f0f0f0;\n  }\n  \n  :global(.light-theme .card) {\n    background-color: #f5f5f5;\n    border: 1px solid #e0e0e0;\n  }\n  \n  :global(.dark-theme .card) {\n    background-color: #333333;\n    border: 1px solid #444444;\n  }\n</style>\n\n<svelte:body class=\"{theme}-theme\" />\n\n<div>\n  <button on:click={() => theme = theme === 'light' ? 'dark' : 'light'}>\n    Toggle theme\n  </button>\n</div>\n```\n\n### Combining with Media Queries\n\nGlobal styles can be combined with media queries:\n\n```svelte\n<style>\n  /* Global responsive typography */\n  :global(html) {\n    font-size: 16px;\n  }\n  \n  @media (max-width: 768px) {\n    :global(html) {\n      font-size: 14px;\n    }\n  }\n  \n  @media (max-width: 480px) {\n    :global(html) {\n      font-size: 12px;\n    }\n  }\n  \n  /* Global responsive layout */\n  :global(.container) {\n    width: 1200px;\n    margin: 0 auto;\n  }\n  \n  @media (max-width: 1200px) {\n    :global(.container) {\n      width: 100%;\n      padding: 0 1rem;\n    }\n  }\n</style>\n```\n\n### Targeting Third-Party Components\n\nUse `:global()` to style third-party components:\n\n```svelte\n<style>\n  /* Override styles for a third-party datepicker */\n  :global(.datepicker-container) {\n    font-family: inherit;\n  }\n  \n  :global(.datepicker-header) {\n    background-color: var(--primary-color);\n  }\n  \n  :global(.datepicker-day.selected) {\n    background-color: var(--secondary-color);\n  }\n</style>\n\n<div>\n  <ThirdPartyDatepicker />\n</div>\n```\n\n### Creating Global Animations\n\nDefine animations that can be used throughout your application:\n\n```svelte\n<style>\n  @keyframes :global(fadeIn) {\n    from { opacity: 0; }\n    to { opacity: 1; }\n  }\n  \n  @keyframes :global(slideIn) {\n    from { transform: translateY(20px); opacity: 0; }\n    to { transform: translateY(0); opacity: 1; }\n  }\n  \n  :global(.fade-in) {\n    animation: fadeIn 0.3s ease forwards;\n  }\n  \n  :global(.slide-in) {\n    animation: slideIn 0.5s ease forwards;\n  }\n</style>\n```\n\nUsing `:global()` provides a clean, maintainable way to define global styles when needed, while keeping them organized within your component structure. This approach is far superior to using nested `<style>` elements, as it:\n\n1. Keeps all styles in the top-level `<style>` element where they're properly processed by Svelte\n2. Makes global styling intentions explicit with the `:global()` syntax\n3. Avoids the duplication and performance issues of nested style elements\n4. Allows for better organization of global and scoped styles\n5. Works consistently with Svelte's compilation process\n\nRemember that while `:global()` is useful, it should be used judiciously. Overuse can lead to the same maintainability issues as traditional global CSS."}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"What is the purpose of `<svelte:boundary>` in Svelte 5, and when was this feature introduced?","answer":"`<svelte:boundary>` is a special element in Svelte 5 that creates error boundaries in your application. Its primary purpose is to guard against errors in specific parts of your app from breaking the entire application, allowing you to isolate and recover from those errors.\n\nError boundaries work by containing errors that occur during the rendering process or when running `$effect` functions within the boundary. When an error occurs, the contents of the boundary are removed, and you can provide fallback UI or error handling logic.\n\nThis feature was added in Svelte 5.3.0, making it a relatively recent addition to the framework.\n\nIt's important to note that `<svelte:boundary>` only catches errors that occur during the rendering process or in `$effect` functions. Errors that happen outside the rendering process, such as in event handlers, after a `setTimeout`, or in async work, are not caught by error boundaries."}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"How do you implement basic error recovery with `<svelte:boundary>` using the `failed` snippet?","answer":"To implement basic error recovery with `<svelte:boundary>` using the `failed` snippet, you can follow this pattern:\n\n```svelte\n<svelte:boundary>\n  <!-- Your potentially error-prone component or code -->\n  <FlakyComponent />\n\n  {#snippet failed(error, reset)}\n    <!-- Your error UI with recovery option -->\n    <div class=\"error-container\">\n      <p>Something went wrong: {error.message}</p>\n      <button onclick={reset}>Try again</button>\n    </div>\n  {/snippet}\n</svelte:boundary>\n```\n\nThe `failed` snippet receives two arguments:\n1. `error`: The error object that was thrown\n2. `reset`: A function that, when called, will recreate the contents of the boundary\n\nWhen an error occurs during rendering or in an `$effect` function within the boundary, the normal content is removed and the `failed` snippet is rendered instead. The user can then click the \"Try again\" button to reset the boundary and attempt to render the content again.\n\nYou can also pass the `failed` snippet explicitly as a property:\n\n```svelte\n<script>\n  import { snippet } from 'svelte';\n  \n  const failed = snippet((error, reset) => {\n    return `\n      <div class=\"error-container\">\n        <p>Something went wrong: ${error.message}</p>\n        <button onclick=${reset}>Try again</button>\n      </div>\n    `;\n  });\n</script>\n\n<svelte:boundary {failed}>\n  <FlakyComponent />\n</svelte:boundary>\n```\n\nFor the boundary to function properly, you must provide either the `failed` snippet or an `onerror` handler (or both)."}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"How does the `onerror` property work with `<svelte:boundary>`, and how might you use it for error reporting?","answer":"The `onerror` property of `<svelte:boundary>` allows you to provide a function that will be called when an error occurs within the boundary. This function receives two arguments: the error object and a reset function.\n\nHere's how you can use it for error reporting:\n\n```svelte\n<script>\n  // Import your error reporting service\n  import { reportError } from './errorReportingService';\n  \n  function handleError(error, reset) {\n    // Send the error to your reporting service\n    reportError({\n      message: error.message,\n      stack: error.stack,\n      componentName: 'FlakyComponent',\n      timestamp: new Date().toISOString()\n    });\n    \n    // You could also log to console for development\n    console.error('Boundary caught error:', error);\n    \n    // You could automatically try to reset after a delay\n    // setTimeout(reset, 5000);\n  }\n</script>\n\n<svelte:boundary onerror={handleError}>\n  <FlakyComponent />\n  \n  {#snippet failed(error, reset)}\n    <div class=\"error-ui\">\n      <p>An error occurred and has been reported.</p>\n      <button onclick={reset}>Try again</button>\n    </div>\n  {/snippet}\n</svelte:boundary>\n```\n\nIf you want to handle the error and reset logic outside the boundary itself, you can do that too:\n\n```svelte\n<script>\n  let error = $state(null);\n  let reset = $state(() => {});\n  \n  function handleError(e, r) {\n    error = e;\n    reset = r;\n    \n    // Report the error\n    reportError(e);\n  }\n</script>\n\n<svelte:boundary onerror={handleError}>\n  <FlakyComponent />\n</svelte:boundary>\n\n{#if error}\n  <div class=\"external-error-ui\">\n    <p>Error: {error.message}</p>\n    <button onclick={() => {\n      error = null;\n      reset();\n    }}>Retry</button>\n  </div>\n{/if}\n```\n\nIt's important to note that if an error occurs inside the `onerror` function itself (or if you rethrow the error), it will be propagated to a parent boundary if one exists. This allows for hierarchical error handling in your application."}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"What types of errors are NOT caught by `<svelte:boundary>` and how should developers handle those cases?","answer":"`<svelte:boundary>` does not catch all types of errors in your application. Specifically, it only catches errors that occur during:\n\n1. The rendering process of child components\n2. Updates to child components\n3. Execution of `$effect` functions within the boundary\n\nErrors that are NOT caught by `<svelte:boundary>` include:\n\n- Event handler errors (e.g., errors in `onclick`, `onchange`, etc.)\n- Errors in asynchronous operations (e.g., after `setTimeout`, `setInterval`)\n- Errors in Promise callbacks or async/await functions\n- Errors in fetch requests or other API calls\n- Errors in third-party libraries outside the rendering cycle\n\nFor example, this error would NOT be caught:\n\n```svelte\n<button onclick={() => {\n  // This error won't be caught by the surrounding boundary\n  throw new Error(\"Event handler error\");\n}}>Break</button>\n```\n\nTo handle these types of errors, developers should use traditional JavaScript error handling patterns:\n\n1. **Try/catch blocks** for synchronous code:\n```svelte\n<button onclick={() => {\n  try {\n    riskyFunction();\n  } catch (error) {\n    console.error('Caught error in event handler:', error);\n    // Handle the error appropriately\n  }\n}}>Click me</button>\n```\n\n2. **Promise error handling** for asynchronous code:\n```svelte\n<script>\n  async function fetchData() {\n    try {\n      const response = await fetch('/api/data');\n      if (!response.ok) throw new Error('Network response was not ok');\n      return await response.json();\n    } catch (error) {\n      console.error('Fetch error:', error);\n      // Handle the error appropriately\n      return null;\n    }\n  }\n</script>\n```\n\n3. **Global error handlers** for uncaught errors:\n```javascript\n// In your main app entry point\nwindow.addEventListener('error', (event) => {\n  console.error('Global error:', event.error);\n  // Report to error tracking service\n});\n\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('Unhandled promise rejection:', event.reason);\n  // Report to error tracking service\n});\n```\n\nBy combining `<svelte:boundary>` for rendering errors with these traditional error handling approaches for other types of errors, you can create a robust error handling strategy for your Svelte application."}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"How can you nest multiple `<svelte:boundary>` elements to create a hierarchical error handling strategy?","answer":"Nesting multiple `<svelte:boundary>` elements allows you to create a hierarchical error handling strategy where errors can be handled at different levels of your component tree. This approach provides more granular control over error recovery and can help maintain a better user experience.\n\nHere's how you can implement nested boundaries:\n\n```svelte\n<script>\n  function reportCriticalError(error) {\n    console.error('Critical application error:', error);\n    // Send to error reporting service\n  }\n  \n  function reportSectionError(error) {\n    console.warn('Section error:', error);\n    // Log less severe errors\n  }\n</script>\n\n<!-- Outer boundary catches errors that might occur in the entire app section -->\n<svelte:boundary onerror={reportCriticalError}>\n  <h1>My Application</h1>\n  \n  <div class=\"app-container\">\n    <!-- Inner boundary for a specific feature section -->\n    <svelte:boundary onerror={reportSectionError}>\n      <h2>User Dashboard</h2>\n      \n      {#snippet failed(error, reset)}\n        <div class=\"section-error\">\n          <p>The dashboard couldn't be loaded</p>\n          <button onclick={reset}>Reload Dashboard</button>\n        </div>\n      {/snippet}\n      \n      <UserDashboard />\n    </svelte:boundary>\n    \n    <!-- Another inner boundary for a different section -->\n    <svelte:boundary>\n      <h2>Activity Feed</h2>\n      \n      {#snippet failed(error, reset)}\n        <div class=\"section-error\">\n          <p>Couldn't load your activity feed</p>\n          <button onclick={reset}>Try Again</button>\n        </div>\n      {/snippet}\n      \n      <ActivityFeed />\n    </svelte:boundary>\n  </div>\n  \n  {#snippet failed(error, reset)}\n    <div class=\"critical-error\">\n      <h3>Application Error</h3>\n      <p>Something went seriously wrong with the application.</p>\n      <button onclick={reset}>Restart Application</button>\n    </div>\n  {/snippet}\n</svelte:boundary>\n```\n\nIn this example:\n\n1. The outer boundary catches any errors that bubble up from inner boundaries or occur in parts of the application not covered by inner boundaries.\n\n2. Each inner boundary handles errors specific to its section, providing a more targeted error message and recovery option.\n\n3. If an error occurs in `UserDashboard`, the inner boundary will catch it and display the section-specific error UI, while the rest of the application continues to function.\n\n4. If an error occurs in the `onerror` handler of an inner boundary (or if it rethrows the error), the outer boundary will catch it.\n\n5. If a catastrophic error occurs that affects the entire application, the outer boundary provides a fallback UI.\n\nThis hierarchical approach allows for graceful degradation of your application, where errors in one section don't necessarily bring down the entire app. Users can continue to use working parts of the application while specific sections recover from errors.\n\nYou can also create even deeper nesting for more fine-grained control:\n\n```svelte\n<svelte:boundary> <!-- App-level boundary -->\n  <AppShell>\n    <svelte:boundary> <!-- Page-level boundary -->\n      <Page>\n        <svelte:boundary> <!-- Widget-level boundary -->\n          <Widget />\n          \n          {#snippet failed(error, reset)}\n            <p>Widget error: <button onclick={reset}>Reload</button></p>\n          {/snippet}\n        </svelte:boundary>\n      </Page>\n      \n      {#snippet failed(error, reset)}\n        <p>Page error: <button onclick={reset}>Reload Page</button></p>\n      {/snippet}\n    </svelte:boundary>\n  </AppShell>\n  \n  {#snippet failed(error, reset)}\n    <FatalErrorPage {error} {reset} />\n  {/snippet}\n</svelte:boundary>\n```\n\nThis pattern is especially useful in larger applications with many components where you want to isolate potential failures."}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"How can you combine `<svelte:boundary>` with Svelte's state management to create a more sophisticated error handling system?","answer":"Combining `<svelte:boundary>` with Svelte 5's state management capabilities allows you to create a sophisticated error handling system that can track errors, manage recovery attempts, and provide better user experiences. Here's a comprehensive example:\n\n```svelte\n<script>\n  // Import any necessary utilities\n  import { onMount } from 'svelte';\n  \n  // Application error state\n  let errors = $state([]);\n  let errorCount = $state(0);\n  let lastErrorTimestamp = $state(null);\n  let isRecoveryMode = $state(false);\n  let recoveryAttempts = $state(0);\n  \n  // Maximum recovery attempts before suggesting a page refresh\n  const MAX_RECOVERY_ATTEMPTS = 3;\n  \n  // Error handling function for the boundary\n  function handleComponentError(error, reset) {\n    // Add the new error to our error log\n    errors = [...errors, {\n      id: Date.now(),\n      message: error.message,\n      stack: error.stack,\n      timestamp: new Date(),\n      componentName: error.componentName || 'Unknown'\n    }];\n    \n    errorCount++;\n    lastErrorTimestamp = new Date();\n    recoveryAttempts++;\n    isRecoveryMode = true;\n    \n    // Report to error tracking service\n    reportErrorToService(error);\n    \n    // If we've tried to recover too many times, we might want to\n    // stop auto-recovering to prevent infinite error loops\n    if (recoveryAttempts <= MAX_RECOVERY_ATTEMPTS) {\n      // Auto-recovery with exponential backoff\n      const delay = Math.min(1000 * Math.pow(2, recoveryAttempts - 1), 30000);\n      setTimeout(() => {\n        try {\n          reset();\n        } catch (e) {\n          console.error('Error during reset:', e);\n        }\n      }, delay);\n    }\n  }\n  \n  // Reset error state when component is successful\n  function handleSuccessfulRender() {\n    if (isRecoveryMode) {\n      isRecoveryMode = false;\n      recoveryAttempts = 0;\n    }\n  }\n  \n  // Mock function to report errors to a service\n  function reportErrorToService(error) {\n    console.log('Reporting error to service:', error);\n    // Actual implementation would send to your error tracking service\n  }\n  \n  // Effect to track successful renders\n  $effect(() => {\n    // We can use this to detect when the component has successfully rendered\n    if (isRecoveryMode) {\n      handleSuccessfulRender();\n    }\n  });\n  \n  // Clear error history periodically\n  onMount(() => {\n    const interval = setInterval(() => {\n      // Remove errors older than 1 hour\n      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n      errors = errors.filter(e => e.timestamp > oneHourAgo);\n    }, 15 * 60 * 1000); // Check every 15 minutes\n    \n    return () => clearInterval(interval);\n  });\n  \n  // Function to force a manual reset\n  function manualReset(resetFn) {\n    recoveryAttempts = 0;\n    resetFn();\n  }\n</script>\n\n<div class=\"app-container\">\n  {#if errorCount > 0}\n    <div class=\"error-stats\">\n      <small>Errors encountered: {errorCount}</small>\n      {#if lastErrorTimestamp}\n        <small>Last error: {lastErrorTimestamp.toLocaleTimeString()}</small>\n      {/if}\n    </div>\n  {/if}\n  \n  <svelte:boundary onerror={handleComponentError}>\n    <div class=\"content\">\n      <h1>My Application</h1>\n      <FlakyComponent />\n    </div>\n    \n    {#snippet failed(error, reset)}\n      <div class=\"error-boundary-ui\">\n        <h2>Component Error</h2>\n        <p>Message: {error.message}</p>\n        \n        {#if recoveryAttempts > MAX_RECOVERY_ATTEMPTS}\n          <div class=\"recovery-warning\">\n            <p>We've tried to recover multiple times without success.</p>\n            <button onclick={() => manualReset(reset)}>\n              Try one more time\n            </button>\n            <button onclick={() => window.location.reload()}>\n              Refresh the page\n            </button>\n          </div>\n        {:else}\n          <p>Automatically attempting to recover... ({recoveryAttempts}/{MAX_RECOVERY_ATTEMPTS})</p>\n          <button onclick={() => manualReset(reset)}>\n            Retry now\n          </button>\n        {/if}\n      </div>\n    {/snippet}\n  </svelte:boundary>\n  \n  {#if errors.length > 0}\n    <details class=\"error-log\">\n      <summary>Error Log ({errors.length})</summary>\n      <ul>\n        {#each errors as error}\n          <li>\n            <strong>{new Date(error.timestamp).toLocaleString()}</strong>: \n            {error.message} in {error.componentName}\n          </li>\n        {/each}\n      </ul>\n      <button onclick={() => errors = []}>Clear Log</button>\n    </details>\n  {/if}\n</div>\n\n<style>\n  .error-boundary-ui {\n    padding: 1rem;\n    border: 2px solid red;\n    border-radius: 4px;\n    margin: 1rem 0;\n    background-color: #fff8f8;\n  }\n  \n  .error-stats {\n    display: flex;\n    justify-content: space-between;\n    font-size: 0.8rem;\n    color: #666;\n    margin-bottom: 0.5rem;\n  }\n  \n  .error-log {\n    margin-top: 2rem;\n    border-top: 1px solid #eee;\n    padding-top: 1rem;\n  }\n  \n  .recovery-warning {\n    background-color: #fffbe6;\n    padding: 0.5rem;\n    border: 1px solid #ffe58f;\n    border-radius: 4px;\n    margin: 1rem 0;\n  }\n</style>\n```\n\nThis implementation demonstrates several advanced error handling concepts:\n\n1. **Error state tracking**: We maintain a log of errors, count them, and timestamp them.\n\n2. **Recovery attempt limiting**: We track how many times we've tried to recover and provide different UI/behavior after too many failed attempts.\n\n3. **Automatic recovery with exponential backoff**: The system tries to recover automatically with increasing delays between attempts to prevent rapid error loops.\n\n4. **Manual recovery options**: Users can trigger immediate recovery attempts.\n\n5. **Error persistence**: Errors are stored in state and can be reviewed by users or developers.\n\n6. **Cleanup logic**: Old errors are periodically removed to prevent memory issues.\n\n7. **Recovery detection**: We use `$effect` to detect when components have successfully rendered after an error.\n\n8. **Fallback UI progression**: The UI changes based on the error state, showing more options after multiple failures.\n\nThis approach creates a robust error handling system that not only recovers from errors but also provides valuable information for debugging and improves the user experience during error scenarios."}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"How would you implement a loading state within a `<svelte:boundary>` to handle both errors and loading states in asynchronous operations?","answer":"While `<svelte:boundary>` itself doesn't directly handle loading states for asynchronous operations, we can combine it with Svelte's state management to create a comprehensive solution that handles both loading states and errors. Here's how to implement this pattern:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  // State for our data and UI states\n  let data = $state(null);\n  let isLoading = $state(true);\n  let loadError = $state(null);\n  \n  // Function to load data with error handling\n  async function loadData() {\n    isLoading = true;\n    loadError = null;\n    \n    try {\n      // Simulate API call\n      const response = await fetch('/api/data');\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      \n      // Simulate processing time\n      await new Promise(r => setTimeout(r, 1000));\n      \n      data = await response.json();\n    } catch (error) {\n      console.error('Failed to load data:', error);\n      loadError = error;\n      // We don't throw here - we store the error state\n      // This error won't trigger the boundary\n    } finally {\n      isLoading = false;\n    }\n  }\n  \n  // Handle boundary errors (rendering errors, not fetch errors)\n  function handleBoundaryError(error, reset) {\n    console.error('Rendering error:', error);\n    \n    // We could automatically try to reset after a delay\n    setTimeout(() => {\n      // Before resetting, maybe clear problematic data\n      if (error.message.includes('data format')) {\n        data = null;\n      }\n      reset();\n    }, 3000);\n  }\n  \n  // Initial data load\n  onMount(() => {\n    loadData();\n  });\n</script>\n\n<!-- \n  The boundary catches rendering errors, while our state variables\n  handle the loading and API error states\n-->\n<svelte:boundary onerror={handleBoundaryError}>\n  <div class=\"data-container\">\n    {#if isLoading}\n      <div class=\"loading-state\">\n        <p>Loading data...</p>\n        <div class=\"spinner\"></div>\n      </div>\n    {:else if loadError}\n      <div class=\"error-state\">\n        <p>Failed to load data: {loadError.message}</p>\n        <button onclick={loadData}>Try Again</button>\n      </div>\n    {:else if data}\n      <div class=\"data-display\">\n        <h2>Data Loaded Successfully</h2>\n        \n        <!-- \n          If there's an error rendering this component due to malformed data,\n          the boundary will catch it\n        -->\n        <DataVisualizer {data} />\n        \n        <button onclick={loadData}>Refresh Data</button>\n      </div>\n    {:else}\n      <p>No data available</p>\n      <button onclick={loadData}>Load Data</button>\n    {/if}\n  </div>\n  \n  {#snippet failed(error, reset)}\n    <div class=\"rendering-error\">\n      <h3>Display Error</h3>\n      <p>There was a problem showing your data: {error.message}</p>\n      <p>Attempting to recover automatically...</p>\n      <button onclick={reset}>Recover Now</button>\n    </div>\n  {/snippet}\n</svelte:boundary>\n\n<style>\n  .loading-state, .error-state, .rendering-error {\n    padding: 1rem;\n    border-radius: 4px;\n    margin: 1rem 0;\n  }\n  \n  .loading-state {\n    background-color: #f0f8ff;\n    border: 1px solid #bae7ff;\n  }\n  \n  .error-state {\n    background-color: #fff2f0;\n    border: 1px solid #ffccc7;\n  }\n  \n  .rendering-error {\n    background-color: #fffbe6;\n    border: 1px solid #ffe58f;\n  }\n  \n  .spinner {\n    width: 30px;\n    height: 30px;\n    border: 3px solid #f3f3f3;\n    border-top: 3px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n  }\n  \n  @keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n</style>\n```\n\nThis implementation handles three distinct states:\n\n1. **Loading State**: Managed by the `isLoading` state variable, not by the boundary. This shows a spinner while data is being fetched.\n\n2. **API/Fetch Error State**: Managed by the `loadError` state variable, not by the boundary. This handles errors that occur during data fetching.\n\n3. **Rendering Error State**: Managed by the `<svelte:boundary>`. This handles errors that occur when trying to render the data (for example, if the data structure is unexpected and causes a component to throw an error).\n\nThis separation of concerns is important because:\n\n- `<svelte:boundary>` only catches errors during rendering and in `$effect` functions\n- Fetch/API errors typically occur in async functions outside the rendering cycle\n- Loading states are a normal part of the application flow, not error states\n\nFor more complex applications, you could enhance this pattern:\n\n```svelte\n<script>\n  // More sophisticated state management\n  let dataState = $state({\n    data: null,\n    status: 'idle', // 'idle', 'loading', 'success', 'error'\n    error: null,\n    lastLoaded: null,\n    attempts: 0\n  });\n  \n  async function fetchWithRetry(url, options = {}, maxRetries = 3) {\n    let lastError;\n    \n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) throw new Error(`HTTP error ${response.status}`);\n        return await response.json();\n      } catch (error) {\n        console.warn(`Attempt ${attempt + 1} failed:`, error);\n        lastError = error;\n        \n        // Exponential backoff\n        if (attempt < maxRetries - 1) {\n          const delay = Math.pow(2, attempt) * 1000;\n          await new Promise(r => setTimeout(r, delay));\n        }\n      }\n    }\n    \n    throw lastError;\n  }\n  \n  async function loadData() {\n    dataState.status = 'loading';\n    dataState.attempts++;\n    \n    try {\n      const result = await fetchWithRetry('/api/data');\n      dataState.data = result;\n      dataState.status = 'success';\n      dataState.lastLoaded = new Date();\n      dataState.error = null;\n    } catch (error) {\n      dataState.status = 'error';\n      dataState.error = error;\n    }\n  }\n  \n  // Auto-refresh data periodically\n  $effect(() => {\n    if (dataState.status === 'success') {\n      const timer = setTimeout(loadData, 5 * 60 * 1000); // Refresh every 5 minutes\n      return () => clearTimeout(timer);\n    }\n  });\n  \n  // Initial load\n  onMount(loadData);\n</script>\n\n<svelte:boundary>\n  <div class=\"data-section\">\n    <header>\n      <h2>Data Dashboard</h2>\n      {#if dataState.lastLoaded}\n        <small>Last updated: {dataState.lastLoaded.toLocaleTimeString()}</small>\n      {/if}\n      <button \n        onclick={loadData} \n        disabled={dataState.status === 'loading'}\n      >\n        Refresh\n      </button>\n    </header>\n    \n    {#if dataState.status === 'loading'}\n      <LoadingIndicator attempts={dataState.attempts} />\n    {:else if dataState.status === 'error'}\n      <ErrorDisplay \n        error={dataState.error}\n        onRetry={loadData} \n      />\n    {:else if dataState.status === 'success'}\n      <DataDisplay data={dataState.data} />\n    {:else}\n      <p>No data loaded yet</p>\n    {/if}\n  </div>\n  \n  {#snippet failed(error, reset)}\n    <div class=\"boundary-error\">\n      <h3>Rendering Error</h3>\n      <p>{error.message}</p>\n      <div class=\"actions\">\n        <button onclick={() => {\n          // Clear data before resetting to avoid the same error\n          dataState.data = null;\n          reset();\n          // Then reload with fresh data\n          loadData();\n        }}>\n          Reset and Reload\n        </button>\n      </div>\n    </div>\n  {/snippet}\n</svelte:boundary>\n```\n\nThis more advanced implementation includes:\n\n1. A more structured state object\n2. Fetch retry logic with exponential backoff\n3. Automatic periodic data refreshing\n4. A combined reset strategy that clears problematic data before resetting the boundary\n\nBy combining these patterns, you create a robust system that handles loading states, API errors, and rendering errors in a user-friendly way."}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"What's the difference between using the `failed` snippet and the `onerror` handler in `<svelte:boundary>`, and when would you use one over the other?","answer":"The `failed` snippet and the `onerror` handler serve different but complementary purposes in a `<svelte:boundary>`. Understanding their differences and appropriate use cases is key to implementing effective error boundaries in Svelte 5.\n\n## Differences Between `failed` and `onerror`\n\n### `failed` Snippet\n- **Purpose**: Provides fallback UI to display when an error occurs\n- **Return Value**: Returns markup to render in place of the errored content\n- **Context**: Runs in the rendering context of the component\n- **Typical Use**: Displaying user-facing error messages and recovery options\n\n### `onerror` Handler\n- **Purpose**: Executes side effects when an error occurs\n- **Return Value**: Does not return anything that affects the UI\n- **Context**: Runs as a callback function\n- **Typical Use**: Logging, error reporting, state updates, analytics\n\n## When to Use Each Option\n\n### Use the `failed` Snippet When:\n1. You need to provide a user-facing error message or UI\n2. You want to offer recovery options directly in the UI\n3. You need to replace the errored content with alternative content\n4. You want to maintain visual consistency with your application\n\nExample of using just the `failed` snippet:\n\n```svelte\n<svelte:boundary>\n  <UserProfile userId={123} />\n  \n  {#snippet failed(error, reset)}\n    <div class=\"error-card\">\n      <h3>Profile Error</h3>\n      <p>We couldn't load this user profile: {error.message}</p>\n      <button onclick={reset}>Try Again</button>\n    </div>\n  {/snippet}\n</svelte:boundary>\n```\n\n### Use the `onerror` Handler When:\n1. You need to report errors to an error tracking service\n2. You want to update application state outside the boundary\n3. You need to perform side effects like logging\n4. You want to implement programmatic recovery logic\n\nExample of using just the `onerror` handler:\n\n```svelte\n<script>\n  import { reportError } from './errorService';\n  \n  function handleError(error, reset) {\n    // Report to error tracking service\n    reportError(error);\n    \n    // Log for development\n    console.error('Boundary error:', error);\n    \n    // Automatically try to recover after a delay\n    setTimeout(reset, 3000);\n  }\n</script>\n\n<svelte:boundary onerror={handleError}>\n  <PaymentProcessor />\n</svelte:boundary>\n```\n\n### Use Both Together When:\n1. You need both UI feedback and side effects\n2. You want to implement comprehensive error handling\n3. You need to coordinate between error reporting and UI state\n4. You're building a production application where error handling is critical\n\nExample of using both together:\n\n```svelte\n<script>\n  import { reportError } from './errorService';\n  import { toast } from './notificationSystem';\n  \n  let errorCount = $state(0);\n  \n  function handleError(error, reset) {\n    // Increment error counter\n    errorCount++;\n    \n    // Report to error tracking service with context\n    reportError({\n      error,\n      component: 'DataVisualizer',\n      count: errorCount,\n      time: new Date().toISOString()\n    });\n    \n    // Show a toast notification\n    toast.error('An error occurred in the data visualizer');\n    \n    // If we've had too many errors, don't auto-recover\n    if (errorCount <= 3) {\n      setTimeout(reset, 2000);\n    }\n  }\n</script>\n\n<svelte:boundary onerror={handleError}>\n  <DataVisualizer data={complexData} />\n  \n  {#snippet failed(error, reset)}\n    <div class=\"visualizer-error\">\n      <h3>Visualization Error</h3>\n      <p>{error.message}</p>\n      \n      {#if errorCount > 3}\n        <div class=\"persistent-error\">\n          <p>We've tried several times but keep encountering errors.</p>\n          <button onclick={() => {\n            errorCount = 0; // Reset the counter\n            reset();\n          }}>\n            Try Again Anyway\n          </button>\n        </div>\n      {:else}\n        <p>Automatically retrying in 2 seconds...</p>\n        <button onclick={reset}>Retry Now</button>\n      {/if}\n    </div>\n  {/snippet}\n</svelte:boundary>\n```\n\n## Special Considerations\n\n1. **Error Propagation**: If an error occurs in the `onerror` handler itself (or if you rethrow the error), it will be handled by a parent boundary if one exists. This doesn't happen with errors in the `failed` snippet, which would create an infinite loop.\n\n2. **State Coordination**: When using both, be careful about state synchronization. The `failed` snippet has access to component state, while the `onerror` handler might need to update state that the `failed` snippet relies on.\n\n3. **Performance**: The `failed` snippet is part of the rendering cycle, while the `onerror` handler is just a function call. For performance-critical applications, keep the `onerror` handler lightweight.\n\n4. **Testing**: It's generally easier to test the `onerror` handler as a standalone function, while testing the `failed` snippet requires rendering the component.\n\nIn most production applications, using both the `failed` snippet and the `onerror` handler together provides the most comprehensive error handling solution, giving you both user-facing feedback and behind-the-scenes error management."}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"How can you implement progressive error recovery with `<svelte:boundary>` that adapts based on the type of error or number of recovery attempts?","answer":"Implementing progressive error recovery with `<svelte:boundary>` allows your application to adapt its recovery strategy based on factors like error type, frequency, or recovery attempt count. This creates a more resilient application that can handle different error scenarios intelligently.\n\nHere's a comprehensive implementation of progressive error recovery:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  // Error recovery state\n  let recoveryState = $state({\n    attempts: 0,\n    lastErrorType: null,\n    errorHistory: [],\n    recoveryStrategy: 'automatic', // 'automatic', 'manual', 'refresh', 'fallback'\n    isRecovering: false,\n    recoveryStartTime: null\n  });\n  \n  // Function to determine recovery strategy based on error\n  function determineRecoveryStrategy(error) {\n    // Check error type\n    if (error.message.includes('network') || error.message.includes('fetch')) {\n      return 'retry'; // Network errors can often be resolved with retries\n    }\n    \n    if (error.message.includes('permission') || error.message.includes('unauthorized')) {\n      return 'refresh'; // Auth errors often need a page refresh\n    }\n    \n    if (error.message.includes('memory') || error.message.includes('stack')) {\n      return 'fallback'; // Memory issues need fallback mode\n    }\n    \n    // Check error frequency\n    const recentErrors = recoveryState.errorHistory.filter(e => \n      Date.now() - e.timestamp < 60000 // Last minute\n    );\n    \n    if (recentErrors.length >= 3) {\n      return 'manual'; // Too many recent errors, require manual intervention\n    }\n    \n    // Default strategy\n    return 'automatic';\n  }\n  \n  // Handle boundary errors with progressive recovery\n  function handleError(error, reset) {\n    // Record this error\n    const errorRecord = {\n      message: error.message,\n      stack: error.stack,\n      timestamp: Date.now(),\n      type: error.name || 'Error'\n    };\n    \n    recoveryState.errorHistory = [...recoveryState.errorHistory, errorRecord];\n    recoveryState.attempts++;\n    recoveryState.lastErrorType = error.name || 'Error';\n    recoveryState.recoveryStrategy = determineRecoveryStrategy(error);\n    recoveryState.isRecovering = true;\n    recoveryState.recoveryStartTime = Date.now();\n    \n    // Report error\n    console.error('Boundary error:', error);\n    \n    // Implement the determined recovery strategy\n    switch (recoveryState.recoveryStrategy) {\n      case 'automatic':\n        // Calculate backoff time based on attempts (1s, 2s, 4s, 8s, etc.)\n        const backoffTime = Math.min(1000 * Math.pow(2, recoveryState.attempts - 1), 30000);\n        console.log(`Automatic recovery in ${backoffTime}ms (attempt ${recoveryState.attempts})`);\n        \n        setTimeout(() => {\n          attemptRecovery(reset);\n        }, backoffTime);\n        break;\n        \n      case 'retry':\n        // For network errors, try a quick retry then increase delay\n        if (recoveryState.attempts <= 2) {\n          setTimeout(() => attemptRecovery(reset), 1000);\n        } else {\n          // After a few quick retries, switch to exponential backoff\n          const retryTime = Math.min(2000 * Math.pow(2, recoveryState.attempts - 3), 30000);\n          setTimeout(() => attemptRecovery(reset), retryTime);\n        }\n        break;\n        \n      case 'refresh':\n        // Auth errors might need a page refresh, but we'll let the user decide\n        // No automatic reset here\n        break;\n        \n      case 'fallback':\n        // For severe errors, we'll switch to fallback mode\n        // We'll handle this in the failed snippet by showing simplified UI\n        setTimeout(() => attemptRecovery(reset), 5000);\n        break;\n        \n      case 'manual':\n        // Too many errors, require manual intervention\n        // No automatic reset\n        break;\n    }\n  }\n  \n  // Function to attempt recovery and track success/failure\n  function attemptRecovery(reset) {\n    try {\n      // Before resetting, we might want to clear caches or problematic state\n      // depending on the error type\n      if (recoveryState.lastErrorType === 'TypeError' && window.caches) {\n        // Maybe clear relevant caches\n      }\n      \n      reset();\n      \n      // Note: If reset succeeds, the component will re-render\n      // If it fails, it will trigger another error\n    } catch (e) {\n      console.error('Recovery attempt failed:', e);\n      recoveryState.attempts++;\n      // If recovery itself fails, we might want to change strategy\n      recoveryState.recoveryStrategy = 'manual';\n    }\n  }\n  \n  // Clear old error history periodically\n  onMount(() => {\n    const interval = setInterval(() => {\n      // Remove errors older than 1 hour\n      recoveryState.errorHistory = recoveryState.errorHistory.filter(e => \n        Date.now() - e.timestamp < 3600000\n      );\n    }, 15 * 60 * 1000);\n    \n    return () => clearInterval(interval);\n  });\n  \n  // Helper to format time\n  function formatTime(ms) {\n    if (ms < 1000) return `${ms}ms`;\n    return `${(ms / 1000).toFixed(1)}s`;\n  }\n  \n  // Reset recovery state for manual recovery\n  function manualRecovery(reset) {\n    recoveryState.attempts = 0;\n    recoveryState.recoveryStrategy = 'automatic';\n    recoveryState.isRecovering = false;\n    attemptRecovery(reset);\n  }\n</script>\n\n<svelte:boundary onerror={handleError}>\n  <div class=\"app-component\">\n    <h2>Application Component</h2>\n    <ComplexComponent />\n  </div>\n  \n  {#snippet failed(error, reset)}\n    <div class=\"error-recovery-ui\">\n      <h3>Error Recovery</h3>\n      \n      <div class=\"error-details\">\n        <p><strong>Error:</strong> {error.message}</p>\n        <p><strong>Recovery attempts:</strong> {recoveryState.attempts}</p>\n        <p><strong>Strategy:</strong> {recoveryState.recoveryStrategy}</p>\n        \n        {#if recoveryState.recoveryStartTime}\n          <p><strong>Time since error:</strong> \n            {formatTime(Date.now() - recoveryState.recoveryStartTime)}\n          </p>\n        {/if}\n      </div>\n      \n      <!-- Different UI based on recovery strategy -->\n      {#if recoveryState.recoveryStrategy === 'automatic'}\n        <div class=\"automatic-recovery\">\n          <p>Automatically attempting to recover...</p>\n          <div class=\"progress-bar\"></div>\n          <button onclick={() => attemptRecovery(reset)}>\n            Recover Now\n          </button>\n        </div>\n      {:else if recoveryState.recoveryStrategy === 'retry'}\n        <div class=\"retry-recovery\">\n          <p>Network issue detected. Retrying connection...</p>\n          <div class=\"progress-bar\"></div>\n          <button onclick={() => attemptRecovery(reset)}>\n            Retry Now\n          </button>\n        </div>\n      {:else if recoveryState.recoveryStrategy === 'refresh'}\n        <div class=\"refresh-recovery\">\n          <p>This error may require refreshing the page.</p>\n          <div class=\"button-group\">\n            <button onclick={() => attemptRecovery(reset)}>\n              Try Recovery First\n            </button>\n            <button onclick={() => window.location.reload()}>\n              Refresh Page\n            </button>\n          </div>\n        </div>\n      {:else if recoveryState.recoveryStrategy === 'fallback'}\n        <div class=\"fallback-recovery\">\n          <p>Switching to simplified mode due to resource constraints.</p>\n          <button onclick={() => {\n            // Set some global flag for fallback mode\n            window.__FALLBACK_MODE = true;\n            attemptRecovery(reset);\n          }}>\n            Continue in Simplified Mode\n          </button>\n        </div>\n      {:else if recoveryState.recoveryStrategy === 'manual'}\n        <div class=\"manual-recovery\">\n          <p>Multiple errors detected. Manual recovery required.</p>\n          <div class=\"recovery-options\">\n            <button onclick={() => manualRecovery(reset)}>\n              Reset and Recover\n            </button>\n            <button onclick={() => window.location.reload()}>\n              Refresh Page\n            </button>\n            <button onclick={() => {\n              // Clear local storage/session storage\n              localStorage.clear();\n              sessionStorage.clear();\n              window.location.reload();\n            }}>\n              Clear Data and Refresh\n            </button>\n          </div>\n        </div>\n      {/if}\n      \n      <!-- Show error history for debugging -->\n      {#if recoveryState.errorHistory.length > 1}\n        <details class=\"error-history\">\n          <summary>Error History ({recoveryState.errorHistory.length})</summary>\n          <ul>\n            {#each recoveryState.errorHistory.slice().reverse() as error, i}\n              {#if i < 5} <!-- Limit to last 5 errors -->\n                <li>\n                  <strong>{new Date(error.timestamp).toLocaleTimeString()}</strong>: \n                  {error.message} ({error.type})\n                </li>\n              {/if}\n            {/each}\n            {#if recoveryState.errorHistory.length > 5}\n              <li>...and {recoveryState.errorHistory.length - 5} more</li>\n            {/if}\n          </ul>\n        </details>\n      {/if}\n    </div>\n  {/snippet}\n</svelte:boundary>\n\n<style>\n  .error-recovery-ui {\n    padding: 1.5rem;\n    border: 1px solid #ddd;\n    border-radius: 8px;\n    margin: 1rem 0;\n    background-color: #f9f9f9;\n  }\n  \n  .error-details {\n    margin-bottom: 1.5rem;\n    padding: 1rem;\n    background-color: #f0f0f0;\n    border-radius: 4px;\n  }\n  \n  .progress-bar {\n    height: 4px;\n    background-color: #e0e0e0;\n    border-radius: 2px;\n    margin: 0.5rem 0 1rem;\n    overflow: hidden;\n    position: relative;\n  }\n  \n  .progress-bar::after {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 30%;\n    background-color: #2196f3;\n    animation: progress 2s infinite ease-in-out;\n  }\n  \n  @keyframes progress {\n    0% { left: -30%; }\n    100% { left: 100%; }\n  }\n  \n  .button-group {\n    display: flex;\n    gap: 0.5rem;\n  }\n  \n  .error-history {\n    margin-top: 1.5rem;\n    padding-top: 0.5rem;\n    border-top: 1px solid #eee;\n  }\n  \n  .recovery-options {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n    max-width: 300px;\n  }\n</style>\n```\n\nThis implementation demonstrates several advanced progressive recovery techniques:\n\n1. **Contextual Recovery Strategies**:\n   - Different strategies based on error type (network, permission, memory)\n   - Adaptation based on error frequency\n   - Changing strategies if initial recovery fails\n\n2. **Tiered Recovery Approaches**:\n   - Automatic recovery with exponential backoff for general errors\n   - Quick retries for network issues\n   - Page refresh suggestion for authentication problems\n   - Fallback mode for resource constraints\n   - Manual intervention for persistent errors\n\n3. **User Transparency**:\n   - Clear communication about what's happening\n   - Showing recovery attempt count\n   - Displaying time since error\n   - Providing error history\n\n4. **Recovery Options**:\n   - Immediate recovery buttons\n   - Page refresh options\n   - Data clearing options for persistent issues\n   - Simplified mode toggle\n\n5. **Error Tracking**:\n   - Maintaining error history\n   - Tracking error types and timestamps\n   - Limiting history size to prevent memory issues\n\nThis approach creates a highly adaptive error recovery system that:\n\n- Minimizes disruption for users\n- Provides appropriate recovery options based on context\n- Avoids infinite error loops\n- Gives users control when automatic recovery fails\n- Creates transparency about what's happening during errors\n\nFor production applications, you could extend this further with:\n\n- Integration with server-side error reporting\n- User preference settings for error handling\n- A/B testing different recovery strategies\n- Analytics to track recovery success rates\n- Cross-tab coordination for consistent recovery behavior"}
{"source":"docs/svelte/05-special-elements/01-svelte-boundary.md","question":"How can you test the error handling capabilities of `<svelte:boundary>` in a development environment?","answer":"Testing error boundaries is crucial to ensure your application handles errors gracefully in production. Here's a comprehensive guide to testing the error handling capabilities of `<svelte:boundary>` in a development environment:\n\n## 1. Creating Test Components with Deliberate Errors\n\nFirst, let's create components that deliberately throw errors in different scenarios:\n\n```svelte\n<!-- ErrorOnMount.svelte -->\n<script>\n  // This component throws an error during initialization\n  throw new Error(\"Error thrown during component initialization\");\n</script>\n\n<!-- ErrorOnRender.svelte -->\n<script>\n  // This component throws an error during rendering\n  let shouldThrow = true;\n</script>\n\n{#if shouldThrow}\n  {invalidVariable.nonExistentProperty}\n{:else}\n  <p>No error</p>\n{/if}\n\n<!-- ErrorInEffect.svelte -->\n<script>\n  let count = $state(0);\n  \n  // This will throw an error in the effect\n  $effect(() => {\n    if (count > 0) {\n      throw new Error(\"Error thrown in $effect\");\n    }\n  });\n  \n  function incrementCount() {\n    count++;\n  }\n</script>\n\n<button onclick={incrementCount}>Trigger Error</button>\n<p>Count: {count}</p>\n\n<!-- ErrorOnPropChange.svelte -->\n<script>\n  export let data;\n  \n  $effect(() => {\n    // Throws when data is an object without a required property\n    if (data && typeof data === 'object' && !data.requiredProperty) {\n      throw new Error(\"Missing required property\");\n    }\n  });\n</script>\n\n<div>\n  {#if data}\n    <p>Data: {JSON.stringify(data)}</p>\n  {:else}\n    <p>No data</p>\n  {/if}\n</div>\n\n<!-- AsyncError.svelte -->\n<script>\n  let data = $state(null);\n  let error = $state(null);\n  \n  async function fetchData() {\n    try {\n      // Simulate API call that fails\n      await new Promise(r => setTimeout(r, 1000));\n      throw new Error(\"Async operation failed\");\n    } catch (e) {\n      error = e;\n    }\n  }\n  \n  // Automatically fetch on mount\n  fetchData();\n</script>\n\n{#if error}\n  <p>Error: {error.message}</p>\n{:else if data}\n  <p>Data: {data}</p>\n{:else}\n  <p>Loading...</p>\n{/if}\n```\n\n## 2. Creating a Test Harness\n\nNow, let's create a test harness component that allows us to test our error boundaries:\n\n```svelte\n<!-- BoundaryTestHarness.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  import ErrorOnMount from './ErrorOnMount.svelte';\n  import ErrorOnRender from './ErrorOnRender.svelte';\n  import ErrorInEffect from './ErrorInEffect.svelte';\n  import ErrorOnPropChange from './ErrorOnPropChange.svelte';\n  import AsyncError from './AsyncError.svelte';\n  \n  // Test state\n  let activeTest = $state('none');\n  let errorLogs = $state([]);\n  let resetCount = $state(0);\n  let testData = $state({ name: 'test' });\n  \n  // Error handler for our boundary\n  function handleError(error, reset) {\n    const timestamp = new Date().toLocaleTimeString();\n    errorLogs = [...errorLogs, {\n      message: error.message,\n      timestamp,\n      test: activeTest\n    }];\n    \n    console.error(`[${timestamp}] Boundary error in test \"${activeTest}\":`, error);\n    \n    // Store the reset function for manual testing\n    window.__resetBoundary = reset;\n  }\n  \n  // Clear logs\n  function clearLogs() {\n    errorLogs = [];\n  }\n  \n  // Toggle bad data to test prop changes\n  function toggleBadData() {\n    if (testData.requiredProperty) {\n      testData = { name: 'bad data' }; // Missing required property\n    } else {\n      testData = { name: 'good data', requiredProperty: true };\n    }\n  }\n  \n  // For development, expose error logs to console\n  onMount(() => {\n    window.__errorLogs = errorLogs;\n  });\n</script>\n\n<div class=\"test-harness\">\n  <h1>Boundary Test Harness</h1>\n  \n  <div class=\"controls\">\n    <div class=\"test-selector\">\n      <h3>Select Test</h3>\n      <div class=\"radio-group\">\n        <label>\n          <input type=\"radio\" bind:group={activeTest} value=\"none\">\n          None\n        </label>\n        <label>\n          <input type=\"radio\" bind:group={activeTest} value=\"mount\">\n          Error on Mount\n        </label>\n        <label>\n          <input type=\"radio\" bind:group={activeTest} value=\"render\">\n          Error on Render\n        </label>\n        <label>\n          <input type=\"radio\" bind:group={activeTest} value=\"effect\">\n          Error in Effect\n        </label>\n        <label>\n          <input type=\"radio\" bind:group={activeTest} value=\"props\">\n          Error on Prop Change\n        </label>\n        <label>\n          <input type=\"radio\" bind:group={activeTest} value=\"async\">\n          Async Error (not caught by boundary)\n        </label>\n      </div>\n    </div>\n    \n    <div class=\"actions\">\n      <button onclick={clearLogs}>Clear Logs</button>\n      <button onclick={toggleBadData}>Toggle Bad Data</button>\n    </div>\n  </div>\n  \n  <div class=\"test-container\">\n    <h3>Test Component</h3>\n    \n    <svelte:boundary onerror={handleError}>\n      <div class=\"component-container\">\n        {#if activeTest === 'mount'}\n          <ErrorOnMount />\n        {:else if activeTest === 'render'}\n          <ErrorOnRender />\n        {:else if activeTest === 'effect'}\n          <ErrorInEffect />\n        {:else if activeTest === 'props'}\n          <ErrorOnPropChange data={testData} />\n        {:else if activeTest === 'async'}\n          <AsyncError />\n        {:else}\n          <p>Select a test to begin</p>\n        {/if}\n      </div>\n      \n      {#snippet failed(error, reset)}\n        <div class=\"error-ui\">\n          <h4>Error Caught by Boundary!</h4>\n          <p class=\"error-message\">{error.message}</p>\n          <button onclick={() => {\n            reset();\n            resetCount++;\n          }}>\n            Reset Component\n          </button>\n          <p class=\"reset-count\">Reset count: {resetCount}</p>\n        </div>\n      {/snippet}\n    </svelte:boundary>\n  </div>\n  \n  <div class=\"error-log\">\n    <h3>Error Log</h3>\n    {#if errorLogs.length === 0}\n      <p class=\"empty-log\">No errors logged yet.</p>\n    {:else}\n      <ul>\n        {#each errorLogs as log}\n          <li>\n            <span class=\"timestamp\">{log.timestamp}</span>\n            <span class=\"test-name\">[{log.test}]</span>\n            <span class=\"error-text\">{log.message}</span>\n          </li>\n        {/each}\n      </ul>\n    {/if}\n  </div>\n</div>\n\n<style>\n  .test-harness {\n    padding: 2rem;\n    max-width: 800px;\n    margin: 0 auto;\n    font-family: system-ui, sans-serif;\n  }\n  \n  .controls {\n    display: flex;\n    gap: 2rem;\n    margin-bottom: 2rem;\n    padding: 1rem;\n    background-color: #f5f5f5;\n    border-radius: 8px;\n  }\n  \n  .radio-group {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n  }\n  \n  .test-container {\n    border: 1px solid #ddd;\n    border-radius: 8px;\n    padding: 1rem;\n    margin-bottom: 2rem;\n    min-height: 200px;\n  }\n  \n  .component-container {\n    padding: 1rem;\n    background-color: #f9f9f9;\n    border-radius: 4px;\n  }\n  \n  .error-ui {\n    padding: 1rem;\n    background-color: #fff0f0;\n    border: 1px solid #ffcccb;\n    border-radius: 4px;\n  }\n  \n  .error-message {\n    font-family: monospace;\n    background-color: #fff;\n    padding: 0.5rem;\n    border-radius: 4px;\n    overflow-wrap: break-word;\n  }\n  \n  .error-log {\n    background-color: #f0f8ff;\n    border-radius: 8px;\n    padding: 1rem;\n    max-height: 300px;\n    overflow-y: auto;\n  }\n  \n  .error-log ul {\n    list-style-type: none;\n    padding: 0;\n  }\n  \n  .error-log li {\n    padding: 0.5rem;\n    border-bottom: 1px solid #ddd;\n  }\n  \n  .timestamp {\n    color: #666;\n    margin-right: 0.5rem;\n  }\n  \n  .test-name {\n    font-weight: bold;\n    margin-right: 0.5rem;\n  }\n  \n  .reset-count {\n    font-size: 0.8rem;\n    color: #666;\n  }\n  \n  .empty-log {\n    color: #666;\n    font-style: italic;\n  }\n  \n  .actions {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n  }\n</style>\n```\n\n## 3. Testing with Jest or Vitest\n\nFor automated testing, you can use Jest or Vitest with the Svelte testing library:\n\n```javascript\n// boundary.test.js\nimport { render, fireEvent, screen } from '@testing-library/svelte';\nimport { tick } from 'svelte';\nimport BoundaryTest from './BoundaryTest.svelte';\n\n// Component to test boundaries\nimport ErrorBoundaryTest from './ErrorBoundaryTest.svelte';\n\ndescribe('Svelte Boundary Tests', () => {\n  test('renders fallback UI when child component throws', async () => {\n    const { container } = render(ErrorBoundaryTest, {\n      props: { shouldThrow: true }\n    });\n    \n    // Wait for any async rendering\n    await tick();\n    \n    // Check if the error message is displayed\n    expect(screen.getByText(/Error caught by boundary/i)).toBeInTheDocument();\n    expect(screen.getByText(/Try again/i)).toBeInTheDocument();\n  });\n  \n  test('reset function recreates the component', async () => {\n    const { container } = render(ErrorBoundaryTest, {\n      props: { shouldThrow: true }\n    });\n    \n    await tick();\n    \n    // Find and click the reset button\n    const resetButton = screen.getByText(/Try again/i);\n    fireEvent.click(resetButton);\n    \n    await tick();\n    \n    // The component should still show the error UI since shouldThrow is still true\n    expect(screen.getByText(/Error caught by boundary/i)).toBeInTheDocument();\n    \n    // Now let's update the prop to not throw\n    await fireEvent.click(screen.getByText(/Toggle Error/i));\n    await tick();\n    \n    // After toggling, the component should render normally\n    expect(screen.getByText(/Component rendered successfully/i)).toBeInTheDocument();\n  });\n  \n  test('onerror handler is called with error and reset function', async () => {\n    const mockErrorHandler = jest.fn();\n    const { container } = render(ErrorBoundaryTest, {\n      props: { \n        shouldThrow: true,\n        onError: mockErrorHandler\n      }\n    });\n    \n    await tick();\n    \n    // Check if error handler was called\n    expect(mockErrorHandler).toHaveBeenCalled();\n    expect(mockErrorHandler.mock.calls[0][0]).toBeInstanceOf(Error);\n    expect(typeof mockErrorHandler.mock.calls[0][1]).toBe('function');\n  });\n  \n  test('errors in async operations are not caught by boundary', async () => {\n    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();\n    const { container } = render(ErrorBoundaryTest, {\n      props: { throwAsync: true }\n    });\n    \n    // Wait for async operation\n    await new Promise(r => setTimeout(r, 100));\n    await tick();\n    \n    // The boundary should not catch this error\n    expect(screen.queryByText(/Error caught by boundary/i)).not.toBeInTheDocument();\n    \n    // But it should be logged to console\n    expect(consoleErrorSpy).toHaveBeenCalled();\n    \n    consoleErrorSpy.mockRestore();\n  });\n});\n```\n\nHere's the `ErrorBoundaryTest.svelte` component for these tests:\n\n```svelte\n<script>\n  export let shouldThrow = false;\n  export let throwAsync = false;\n  export let onError = () => {};\n  \n  let toggleError = () => {\n    shouldThrow = !shouldThrow;\n  };\n  \n  if (throwAsync) {\n    setTimeout(() => {\n      throw new Error(\"Async error\");\n    }, 50);\n  }\n</script>\n\n<button onclick={toggleError}>Toggle Error</button>\n\n<svelte:boundary onerror={onError}>\n  {#if shouldThrow}\n    {nonExistentVariable.property}\n  {:else}\n    <p>Component rendered successfully</p>\n  {/if}\n  \n  {#snippet failed(error, reset)}\n    <div class=\"error-ui\">\n      <p>Error caught by boundary: {error.message}</p>\n      <button onclick={reset}>Try again</button>\n    </div>\n  {/snippet}\n</svelte:boundary>\n```\n\n## 4. Browser Console Testing Tools\n\nFor manual testing in the browser, you can create console utilities:\n\n```javascript\n// Add this to your main.js or test harness\nwindow.testBoundary = {\n  // Throw an error in a component with a specific ID\n  throwInComponent(id, message = \"Test error\") {\n    const component = document.getElementById(id);\n    if (!component) {\n      console.error(`Component with ID ${id} not found`);\n      return;\n    }\n    \n    // Get the component instance (this is implementation-specific)\n    const instance = component.__svelte_instance__;\n    if (!instance) {\n      console.error(`No Svelte instance found for component ${id}`);\n      return;\n    }\n    \n    // Force an error by setting an invalid property\n    try {\n      instance.$set({ __causeError: undefined.nonExistent });\n    } catch (e) {\n      // The error should be caught by the boundary\n      console.log(`Threw error in component ${id}: ${message}`);\n    }\n  },\n  \n  // Test resetting a boundary\n  resetBoundary() {\n    if (typeof window.__resetBoundary === 'function') {\n      window.__resetBoundary();\n      console.log('Reset boundary');\n      return true;\n    }\n    console.error('No reset function available');\n    return false;\n  },\n  \n  // Get error logs\n  getLogs() {\n    return window.__errorLogs || [];\n  },\n  \n  // Clear error logs\n  clearLogs() {\n    if (Array.isArray(window.__errorLogs)) {\n      window.__errorLogs.length = 0;\n      console.log('Cleared error logs');\n    }\n  }\n};\n\n// Usage in console:\n// testBoundary.throwInComponent('my-component')\n// testBoundary.resetBoundary()\n// testBoundary.getLogs()\n```\n\n## 5. Testing Different Boundary Configurations\n\nTo test different boundary configurations, create a component that allows toggling between configurations:\n\n```svelte\n<!-- BoundaryConfigTest.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  \n  // Configuration options\n  let useOnError = $state(true);\n  let useFailed = $state(true);\n  let autoReset = $state(false);\n  let resetDelay = $state(2000);\n  let throwOnReset = $state(false);\n  \n  // Component state\n  let errorMessage = $state('Default error message');\n  let errorCount = $state(0);\n  let lastReset = $state(null);\n  \n  // Error handler\n  function handleError(error, reset) {\n    errorCount++;\n    console.log('Error handled by onerror:', error);\n    \n    if (autoReset) {\n      setTimeout(() => {\n        console.log('Auto-resetting boundary');\n        if (throwOnReset) {\n          try {\n            throw new Error('Error during reset');\n          } finally {\n            reset();\n          }\n        } else {\n          reset();\n        }\n        lastReset = new Date().toLocaleTimeString();\n      }, resetDelay);\n    }\n  }\n  \n  // Force an error\n  function triggerError() {\n    errorMessage = 'Error triggered at ' + new Date().toLocaleTimeString();\n    // Force a re-render which will trigger the error\n    forceUpdate();\n  }\n  \n  // Force component update\n  let updateCounter = $state(0);\n  function forceUpdate() {\n    updateCounter++;\n  }\n  \n  // This will throw during render\n  $effect(() => {\n    if (updateCounter > 0) {\n      throw new Error"}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"What is the `<svelte:window>` element in Svelte, and why is it useful compared to directly adding event listeners to the window object?","answer":"The `<svelte:window>` element in Svelte is a special element that allows developers to interact with the global `window` object in a declarative way. It serves two primary purposes:\n\n1. It automatically handles cleanup of event listeners when the component is destroyed, preventing memory leaks that could occur if you manually added event listeners to the window and forgot to remove them.\n\n2. It gracefully handles server-side rendering scenarios by checking for the existence of the `window` object, which doesn't exist in server environments.\n\nThis element provides a clean, declarative syntax for window interactions that aligns with Svelte's component-based approach. For example:\n\n```svelte\n<script>\n  function handleKeydown(event) {\n    alert(`pressed the ${event.key} key`);\n  }\n</script>\n\n<svelte:window onkeydown={handleKeydown} />\n```\n\nWithout `<svelte:window>`, you would need to manually add and remove event listeners in lifecycle hooks:\n\n```svelte\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  function handleKeydown(event) {\n    alert(`pressed the ${event.key} key`);\n  }\n  \n  onMount(() => {\n    window.addEventListener('keydown', handleKeydown);\n  });\n  \n  onDestroy(() => {\n    window.removeEventListener('keydown', handleKeydown);\n  });\n</script>\n```\n\nThe `<svelte:window>` approach is more concise and less error-prone, as Svelte handles the lifecycle management automatically."}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"What are the restrictions on where `<svelte:window>` can be placed within a Svelte component?","answer":"The `<svelte:window>` element has specific placement restrictions within a Svelte component. According to the documentation, it may only appear at the top level of your component. This means:\n\n1. It cannot be placed inside a block (such as an `{#if}`, `{#each}`, or `{#await}` block).\n2. It cannot be nested inside other HTML or Svelte elements.\n\nFor example, this is valid:\n\n```svelte\n<script>\n  function handleResize() {\n    console.log('Window was resized');\n  }\n</script>\n\n<h1>My Component</h1>\n<p>Some content</p>\n<svelte:window onresize={handleResize} />\n```\n\nBut these are invalid:\n\n```svelte\n<!-- Invalid: inside an if block -->\n{#if condition}\n  <svelte:window onresize={handleResize} />\n{/if}\n\n<!-- Invalid: inside another element -->\n<div>\n  <svelte:window onresize={handleResize} />\n</div>\n```\n\nThis restriction exists because `<svelte:window>` is meant to represent a global connection to the window object that exists for the entire lifecycle of the component, regardless of conditional rendering logic."}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"What window properties can be bound to using the `<svelte:window>` element, and which ones are read-only?","answer":"The `<svelte:window>` element allows binding to several window properties. According to the documentation, you can bind to the following properties:\n\n- `innerWidth` - The interior width of the window (read-only)\n- `innerHeight` - The interior height of the window (read-only)\n- `outerWidth` - The outer width of the browser window (read-only)\n- `outerHeight` - The outer height of the browser window (read-only)\n- `scrollX` - The number of pixels by which the document is scrolled horizontally (writable)\n- `scrollY` - The number of pixels by which the document is scrolled vertically (writable)\n- `online` - An alias for `window.navigator.onLine`, indicating whether the browser has network access (read-only)\n- `devicePixelRatio` - The ratio of physical pixels to CSS pixels (read-only)\n\nAll of these properties except for `scrollX` and `scrollY` are read-only. This means you can use them to get values from the window object, but you cannot set values to them through the binding.\n\nHere's an example of binding to some of these properties:\n\n```svelte\n<script>\n  let innerWidth;\n  let innerHeight;\n  let scrollY;\n  let online;\n  \n  function scrollToTop() {\n    scrollY = 0; // This works because scrollY is writable\n  }\n  \n  // This would not work because innerWidth is read-only\n  // function setWidth() {\n  //   innerWidth = 1000;\n  // }\n</script>\n\n<svelte:window \n  bind:innerWidth \n  bind:innerHeight \n  bind:scrollY \n  bind:online\n/>\n\n<p>Window dimensions: {innerWidth}px Ã {innerHeight}px</p>\n<p>Scrolled: {scrollY}px from top</p>\n<p>Network status: {online ? 'Online' : 'Offline'}</p>\n<button on:click={scrollToTop}>Scroll to top</button>\n```\n\nIn this example, the component will reactively update whenever any of these window properties change, and you can also programmatically control the `scrollY` position."}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"How can you use `<svelte:window>` to create a component that responds to keyboard shortcuts?","answer":"You can use the `<svelte:window>` element to easily implement keyboard shortcuts in a Svelte component by attaching a handler to the `keydown` or `keyup` events. Here's a comprehensive example of a component that responds to various keyboard shortcuts:\n\n```svelte\n<script>\n  import { createEventDispatcher } from 'svelte';\n  \n  const dispatch = createEventDispatcher();\n  \n  // Track if modifier keys are pressed\n  let ctrlPressed = false;\n  let shiftPressed = false;\n  \n  function handleKeydown(event) {\n    // Update modifier key states\n    if (event.key === 'Control') ctrlPressed = true;\n    if (event.key === 'Shift') shiftPressed = true;\n    \n    // Handle keyboard shortcuts\n    if (ctrlPressed) {\n      switch (event.key) {\n        case 's':\n          event.preventDefault(); // Prevent browser's save dialog\n          dispatch('save');\n          console.log('Save shortcut triggered (Ctrl+S)');\n          break;\n          \n        case 'z':\n          event.preventDefault();\n          if (shiftPressed) {\n            dispatch('redo');\n            console.log('Redo shortcut triggered (Ctrl+Shift+Z)');\n          } else {\n            dispatch('undo');\n            console.log('Undo shortcut triggered (Ctrl+Z)');\n          }\n          break;\n          \n        case 'p':\n          event.preventDefault(); // Prevent browser's print dialog\n          dispatch('print');\n          console.log('Print shortcut triggered (Ctrl+P)');\n          break;\n      }\n    }\n    \n    // Handle navigation keys\n    if (event.key === 'Escape') {\n      dispatch('cancel');\n      console.log('Escape key pressed - canceling current operation');\n    }\n    \n    if (event.key === 'ArrowUp') {\n      dispatch('navigate', { direction: 'up' });\n      console.log('Navigating up');\n    }\n    \n    if (event.key === 'ArrowDown') {\n      dispatch('navigate', { direction: 'down' });\n      console.log('Navigating down');\n    }\n  }\n  \n  function handleKeyup(event) {\n    // Update modifier key states\n    if (event.key === 'Control') ctrlPressed = false;\n    if (event.key === 'Shift') shiftPressed = false;\n  }\n</script>\n\n<svelte:window onkeydown={handleKeydown} onkeyup={handleKeyup} />\n\n<div>\n  <h2>Keyboard Shortcuts</h2>\n  <ul>\n    <li>Ctrl+S: Save</li>\n    <li>Ctrl+Z: Undo</li>\n    <li>Ctrl+Shift+Z: Redo</li>\n    <li>Ctrl+P: Print</li>\n    <li>Escape: Cancel</li>\n    <li>Arrow keys: Navigate</li>\n  </ul>\n  <p>Current modifier keys: \n    {ctrlPressed ? 'Ctrl ' : ''}\n    {shiftPressed ? 'Shift' : ''}\n    {!ctrlPressed && !shiftPressed ? 'None' : ''}\n  </p>\n</div>\n```\n\nThis component:\n1. Tracks the state of modifier keys (Ctrl and Shift)\n2. Handles different keyboard shortcuts with the appropriate combinations\n3. Prevents default browser behaviors for certain key combinations (like Ctrl+S for save)\n4. Dispatches custom events that parent components can listen for\n5. Provides visual feedback about which modifier keys are currently pressed\n\nThe beauty of using `<svelte:window>` for this purpose is that Svelte automatically handles adding and removing the event listeners when the component mounts and unmounts, making the code cleaner and less prone to memory leaks."}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"How can you create a responsive component that adapts to window size changes using `<svelte:window>`?","answer":"You can create a responsive component by binding to the window's `innerWidth` and `innerHeight` properties using `<svelte:window>`. This allows your component to reactively adapt to window size changes without manually setting up resize event listeners. Here's a comprehensive example:\n\n```svelte\n<script>\n  // Bind to window dimensions\n  let innerWidth;\n  let innerHeight;\n  \n  // Define breakpoints for responsive design\n  const breakpoints = {\n    mobile: 480,\n    tablet: 768,\n    desktop: 1024,\n    widescreen: 1440\n  };\n  \n  // Computed properties for current device type\n  $: isMobile = innerWidth <= breakpoints.mobile;\n  $: isTablet = innerWidth > breakpoints.mobile && innerWidth <= breakpoints.tablet;\n  $: isDesktop = innerWidth > breakpoints.tablet && innerWidth <= breakpoints.widescreen;\n  $: isWidescreen = innerWidth > breakpoints.widescreen;\n  \n  // Compute current device type\n  $: deviceType = isMobile ? 'mobile' :\n                  isTablet ? 'tablet' :\n                  isDesktop ? 'desktop' : 'widescreen';\n  \n  // Compute layout properties based on screen size\n  $: columnCount = isMobile ? 1 : isTablet ? 2 : 3;\n  $: fontSize = isMobile ? '14px' : isTablet ? '16px' : '18px';\n  $: padding = isMobile ? '10px' : isTablet ? '15px' : '20px';\n  \n  // Track orientation\n  $: isPortrait = innerHeight > innerWidth;\n  \n  // Debounced resize handler for expensive operations\n  let resizeTimeout;\n  function handleResize() {\n    clearTimeout(resizeTimeout);\n    resizeTimeout = setTimeout(() => {\n      console.log('Window resized to', innerWidth, 'x', innerHeight);\n      // Perform expensive recalculations here\n    }, 250);\n  }\n</script>\n\n<svelte:window \n  bind:innerWidth \n  bind:innerHeight\n  onresize={handleResize}\n/>\n\n<div class=\"container\" style=\"font-size: {fontSize}; padding: {padding};\">\n  <h1>Responsive Component</h1>\n  \n  <div class=\"device-info\">\n    <p>Current viewport: {innerWidth}px Ã {innerHeight}px</p>\n    <p>Device type: {deviceType}</p>\n    <p>Orientation: {isPortrait ? 'Portrait' : 'Landscape'}</p>\n  </div>\n  \n  <div class=\"content\" style=\"grid-template-columns: repeat({columnCount}, 1fr);\">\n    {#each Array(6) as _, i}\n      <div class=\"card\">\n        <h3>Card {i + 1}</h3>\n        <p>This card adapts to the screen size.</p>\n      </div>\n    {/each}\n  </div>\n</div>\n\n<style>\n  .container {\n    max-width: 1200px;\n    margin: 0 auto;\n  }\n  \n  .device-info {\n    background: #f0f0f0;\n    border-radius: 4px;\n    padding: 1rem;\n    margin-bottom: 1rem;\n  }\n  \n  .content {\n    display: grid;\n    gap: 1rem;\n  }\n  \n  .card {\n    background: white;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    padding: 1rem;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  }\n</style>\n```\n\nThis example demonstrates several key responsive design techniques using `<svelte:window>`:\n\n1. **Reactive breakpoints**: The component defines device types based on window width and reactively updates when the window is resized.\n\n2. **Responsive layout adjustments**: It changes the number of columns, font size, and padding based on the current screen size.\n\n3. **Orientation detection**: It determines if the device is in portrait or landscape mode.\n\n4. **Debounced resize handling**: For performance reasons, it includes a debounced resize handler for expensive operations that shouldn't run on every resize event.\n\n5. **CSS Grid with dynamic columns**: The grid layout adapts its column count based on screen size.\n\nThe beauty of this approach is that all these responsive behaviors are handled declaratively and reactively. When the window size changes, Svelte automatically updates the bound properties, which in turn updates all the derived values and causes the component to re-render with the appropriate layout."}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"How can you track and respond to the user's scroll position using `<svelte:window>`?","answer":"You can track and respond to the user's scroll position by binding to the `scrollX` and `scrollY` properties of the window using the `<svelte:window>` element. This allows you to create effects like scroll-triggered animations, infinite scrolling, or scroll-to-top buttons. Here's a comprehensive example:\n\n```svelte\n<script>\n  // Bind to scroll position\n  let scrollY;\n  let scrollX;\n  \n  // Track document dimensions for scroll percentage calculation\n  let innerHeight;\n  let documentHeight;\n  let scrollPercentage = 0;\n  \n  // Calculate scroll percentage whenever scroll position changes\n  $: {\n    documentHeight = document.body.scrollHeight;\n    scrollPercentage = Math.round((scrollY / (documentHeight - innerHeight)) * 100) || 0;\n  }\n  \n  // Determine if we're near the bottom of the page\n  $: isNearBottom = documentHeight - (scrollY + innerHeight) < 200;\n  \n  // Show back-to-top button only when scrolled down\n  $: showBackToTop = scrollY > 300;\n  \n  // Scroll sections for intersection detection\n  let sections = [\n    { id: 'section1', title: 'Introduction', visible: false },\n    { id: 'section2', title: 'Features', visible: false },\n    { id: 'section3', title: 'Pricing', visible: false },\n    { id: 'section4', title: 'Contact', visible: false }\n  ];\n  \n  // Scroll to top function (using the writable scrollY binding)\n  function scrollToTop() {\n    scrollY = 0; // This works because scrollY is writable\n  }\n  \n  // Scroll to specific section\n  function scrollToSection(id) {\n    const element = document.getElementById(id);\n    if (element) {\n      element.scrollIntoView({ behavior: 'smooth' });\n    }\n  }\n  \n  // Check which sections are in viewport\n  function checkVisibleSections() {\n    sections = sections.map(section => {\n      const element = document.getElementById(section.id);\n      if (element) {\n        const rect = element.getBoundingClientRect();\n        // Consider a section visible if its top is in the viewport\n        // or if its bottom is in the viewport\n        // or if it spans the entire viewport\n        const isVisible = \n          (rect.top >= 0 && rect.top <= innerHeight) ||\n          (rect.bottom >= 0 && rect.bottom <= innerHeight) ||\n          (rect.top <= 0 && rect.bottom >= innerHeight);\n        \n        return { ...section, visible: isVisible };\n      }\n      return section;\n    });\n  }\n  \n  // Infinite scroll simulation\n  let items = Array(20).fill().map((_, i) => `Item ${i + 1}`);\n  function loadMoreItems() {\n    if (isNearBottom) {\n      const startIdx = items.length + 1;\n      const newItems = Array(10).fill().map((_, i) => `Item ${startIdx + i}`);\n      items = [...items, ...newItems];\n      console.log('Loaded more items, total:', items.length);\n    }\n  }\n  \n  // Debounce scroll events for performance\n  let scrollTimeout;\n  function handleScroll() {\n    clearTimeout(scrollTimeout);\n    scrollTimeout = setTimeout(() => {\n      checkVisibleSections();\n      loadMoreItems();\n    }, 100);\n  }\n</script>\n\n<svelte:window \n  bind:scrollY \n  bind:scrollX \n  bind:innerHeight \n  onscroll={handleScroll}\n/>\n\n<nav class=\"table-of-contents\" class:fixed={scrollY > 100}>\n  <ul>\n    {#each sections as section}\n      <li class:active={section.visible}>\n        <button on:click={() => scrollToSection(section.id)}>\n          {section.title}\n        </button>\n      </li>\n    {/each}\n  </ul>\n</nav>\n\n<div class=\"scroll-progress-bar\" style=\"width: {scrollPercentage}%\"></div>\n\n<main>\n  <section id=\"section1\">\n    <h2>Introduction</h2>\n    <p>This is the introduction section. Scroll down to see more content.</p>\n  </section>\n  \n  <section id=\"section2\">\n    <h2>Features</h2>\n    <p>This section showcases our amazing features.</p>\n  </section>\n  \n  <section id=\"section3\">\n    <h2>Pricing</h2>\n    <p>Check out our competitive pricing options.</p>\n  </section>\n  \n  <section id=\"section4\">\n    <h2>Contact</h2>\n    <p>Get in touch with our team.</p>\n  </section>\n  \n  <section id=\"infinite-scroll\">\n    <h2>Infinite Scroll Demo</h2>\n    <ul class=\"items-list\">\n      {#each items as item}\n        <li>{item}</li>\n      {/each}\n      {#if isNearBottom}\n        <li class=\"loading\">Loading more items...</li>\n      {/if}\n    </ul>\n  </section>\n</main>\n\n{#if showBackToTop}\n  <button class=\"back-to-top\" on:click={scrollToTop}>\n    â Back to top\n  </button>\n{/if}\n\n<div class=\"scroll-info\">\n  <p>Scroll position: {scrollY}px vertical, {scrollX}px horizontal</p>\n  <p>Scroll percentage: {scrollPercentage}%</p>\n  <p>Document height: {documentHeight}px</p>\n  <p>Viewport height: {innerHeight}px</p>\n  <p>{isNearBottom ? 'Near bottom!' : 'Not near bottom'}</p>\n</div>\n\n<style>\n  section {\n    min-height: 80vh;\n    padding: 2rem;\n    border-bottom: 1px solid #eee;\n  }\n  \n  .scroll-progress-bar {\n    position: fixed;\n    top: 0;\n    left: 0;\n    height: 4px;\n    background: #0066ff;\n    z-index: 1000;\n  }\n  \n  .table-of-contents {\n    background: white;\n    padding: 1rem;\n    border-bottom: 1px solid #eee;\n  }\n  \n  .table-of-contents.fixed {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    z-index: 100;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n  }\n  \n  .table-of-contents ul {\n    display: flex;\n    list-style: none;\n    gap: 1rem;\n    padding: 0;\n    margin: 0;\n  }\n  \n  .table-of-contents li.active button {\n    font-weight: bold;\n    color: #0066ff;\n  }\n  \n  .back-to-top {\n    position: fixed;\n    bottom: 2rem;\n    right: 2rem;\n    background: #0066ff;\n    color: white;\n    border: none;\n    border-radius: 50%;\n    width: 50px;\n    height: 50px;\n    cursor: pointer;\n  }\n  \n  .scroll-info {\n    position: fixed;\n    bottom: 0;\n    left: 0;\n    background: rgba(0,0,0,0.7);\n    color: white;\n    padding: 1rem;\n    font-size: 12px;\n  }\n  \n  .items-list {\n    list-style: none;\n    padding: 0;\n  }\n  \n  .items-list li {\n    padding: 1rem;\n    border-bottom: 1px solid #eee;\n  }\n  \n  .loading {\n    text-align: center;\n    font-style: italic;\n    color: #999;\n  }\n</style>\n```\n\nThis example demonstrates several scroll-related features using `<svelte:window>`:\n\n1. **Scroll position tracking**: Binds to `scrollY` and `scrollX` to monitor the user's scroll position.\n\n2. **Scroll percentage calculation**: Calculates how far the user has scrolled through the document.\n\n3. **Scroll progress bar**: Shows a visual indicator of scroll progress at the top of the page.\n\n4. **Sticky navigation**: Makes the navigation bar sticky after scrolling past a certain point.\n\n5. **Section visibility tracking**: Determines which sections are currently visible in the viewport.\n\n6. **Back-to-top button**: Appears when the user has scrolled down and allows them to instantly return to the top.\n\n7. **Infinite scrolling**: Loads more content when the user approaches the bottom of the page.\n\n8. **Scroll-to-section navigation**: Allows users to jump to specific sections of the page.\n\n9. **Performance optimization**: Uses debouncing to avoid excessive calculations during rapid scrolling.\n\nThe `scrollY` and `scrollX` bindings are particularly powerful because they're two-way bindings, meaning you can not only read the current scroll position but also set it programmatically, enabling features like smooth scrolling to specific sections or returning to the top of the page."}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"How can you detect and respond to online/offline status changes using `<svelte:window>`?","answer":"You can use the `<svelte:window>` element to bind to the `online` property, which is an alias for `window.navigator.onLine`. This allows your Svelte component to reactively respond to changes in the user's network connectivity. Here's a comprehensive example:\n\n```svelte\n<script>\n  // Bind to online status\n  let online;\n  \n  // Track connection information\n  let lastOnlineTime = new Date();\n  let lastOfflineTime = null;\n  let connectionEvents = [];\n  \n  // Connection quality metrics (if available)\n  let connectionType = 'unknown';\n  let connectionSpeed = 'unknown';\n  \n  // Initialize connection info when component mounts\n  import { onMount } from 'svelte';\n  \n  onMount(() => {\n    // Check if the Connection API is available\n    if (navigator.connection) {\n      updateConnectionInfo();\n      navigator.connection.addEventListener('change', updateConnectionInfo);\n    }\n    \n    return () => {\n      if (navigator.connection) {\n        navigator.connection.removeEventListener('change', updateConnectionInfo);\n      }\n    };\n  });\n  \n  function updateConnectionInfo() {\n    if (navigator.connection) {\n      connectionType = navigator.connection.effectiveType || 'unknown';\n      connectionSpeed = navigator.connection.downlink \n        ? `${navigator.connection.downlink} Mbps` \n        : 'unknown';\n    }\n  }\n  \n  // Handle online status changes\n  function handleOnlineChange() {\n    const now = new Date();\n    \n    if (online) {\n      lastOnlineTime = now;\n      connectionEvents = [\n        { status: 'online', time: now, duration: lastOfflineTime ? calculateDuration(lastOfflineTime, now) : null },\n        ...connectionEvents\n      ];\n      showNotification('You are back online!');\n      \n      // Attempt to retry failed operations\n      retryFailedOperations();\n    } else {\n      lastOfflineTime = now;\n      connectionEvents = [\n        { status: 'offline', time: now, duration: null },\n        ...connectionEvents\n      ];\n      showNotification('You are offline. Some features may be unavailable.');\n    }\n  }\n  \n  function calculateDuration(start, end) {\n    const diff = Math.floor((end - start) / 1000);\n    \n    if (diff < 60) return `${diff} seconds`;\n    if (diff < 3600) return `${Math.floor(diff / 60)} minutes`;\n    return `${Math.floor(diff / 3600)} hours`;\n  }\n  \n  function showNotification(message) {\n    // Check if the Notifications API is available and permission is granted\n    if ('Notification' in window && Notification.permission === 'granted') {\n      new Notification('Connection Status', { body: message });\n    } else {\n      console.log(message);\n      // You could show an in-app notification here instead\n    }\n  }\n  \n  let failedOperations = [];\n  \n  function simulateDataOperation() {\n    if (!online) {\n      const operation = {\n        id: Date.now(),\n        type: 'data-update',\n        data: { value: Math.random() },\n        timestamp: new Date()\n      };\n      \n      failedOperations = [...failedOperations, operation];\n      return false;\n    }\n    \n    // Simulate successful operation\n    return true;\n  }\n  \n  function retryFailedOperations() {\n    console.log(`Retrying ${failedOperations.length} failed operations`);\n    \n    // In a real app, you would process these operations\n    // For this example, we'll just clear the queue\n    failedOperations = [];\n  }\n  \n  // Format date for display\n  function formatTime(date) {\n    return date.toLocaleTimeString();\n  }\n</script>\n\n<svelte:window \n  bind:online \n  on:online={handleOnlineChange}\n  on:offline={handleOnlineChange}\n/>\n\n<div class=\"connection-status {online ? 'online' : 'offline'}\">\n  <h1>Network Status: {online ? 'Online' : 'Offline'}</h1>\n  \n  <div class=\"connection-info\">\n    <p>Current status: <strong>{online ? 'Connected' : 'Disconnected'}</strong></p>\n    <p>Connection type: <strong>{connectionType}</strong></p>\n    <p>Connection speed: <strong>{connectionSpeed}</strong></p>\n    \n    {#if online}\n      <p>Online since: <strong>{formatTime(lastOnlineTime)}</strong></p>\n    {:else}\n      <p>Offline since: <strong>{formatTime(lastOfflineTime)}</strong></p>\n      <p>Last online: <strong>{formatTime(lastOnlineTime)}</strong></p>\n    {/if}\n  </div>\n  \n  <div class=\"actions\">\n    <button on:click={simulateDataOperation}>\n      Simulate Data Operation\n    </button>\n    \n    {#if failedOperations.length > 0}\n      <div class=\"pending-operations\">\n        <h3>Pending Operations ({failedOperations.length})</h3>\n        <p>These operations will be processed when you're back online.</p>\n        <ul>\n          {#each failedOperations as op}\n            <li>\n              {op.type} at {formatTime(op.timestamp)}\n            </li>\n          {/each}\n        </ul>\n      </div>\n    {/if}\n  </div>\n  \n  <div class=\"event-log\">\n    <h3>Connection Event Log</h3>\n    <ul>\n      {#each connectionEvents as event}\n        <li class={event.status}>\n          {event.status} at {formatTime(event.time)}\n          {#if event.duration}\n            <span class=\"duration\">(offline for {event.duration})</span>\n          {/if}\n        </li>\n      {/each}\n    </ul>\n  </div>\n</div>\n\n<style>\n  .connection-status {\n    padding: 2rem;\n    border-radius: 8px;\n    margin: 2rem auto;\n    max-width: 600px;\n  }\n  \n  .online {\n    background-color: #e6f7e6;\n    border: 2px solid #4caf50;\n  }\n  \n  .offline {\n    background-color: #f7e6e6;\n    border: 2px solid #f44336;\n  }\n  \n  .connection-info {\n    background: rgba(255, 255, 255, 0.7);\n    padding: 1rem;\n    border-radius: 4px;\n    margin: 1rem 0;\n  }\n  \n  .actions {\n    margin: 1rem 0;\n  }\n  \n  .pending-operations {\n    background: #fff3e0;\n    padding: 1rem;\n    border-radius: 4px;\n    margin-top: 1rem;\n    border-left: 4px solid #ff9800;\n  }\n  \n  .event-log {\n    margin-top: 2rem;\n  }\n  \n  .event-log ul {\n    max-height: 200px;\n    overflow-y: auto;\n    background: white;\n    padding: 0.5rem;\n    border-radius: 4px;\n  }\n  \n  .event-log li {\n    padding: 0.5rem;\n    margin-bottom: 0.5rem;\n    border-radius: 4px;\n  }\n  \n  .event-log li.online {\n    background-color: #e8f5e9;\n    border-left: 3px solid #4caf50;\n  }\n  \n  .event-log li.offline {\n    background-color: #ffebee;\n    border-left: 3px solid #f44336;\n  }\n  \n  .duration {\n    font-style: italic;\n    color: #666;\n  }\n</style>\n```\n\nThis example demonstrates several network connectivity features using `<svelte:window>`:\n\n1. **Online status detection**: Binds to the `online` property to track the user's connection status.\n\n2. **Event handling**: Listens for `online` and `offline` events to respond to changes in connectivity.\n\n3. **Connection quality information**: Uses the Network Information API (where available) to show connection type and speed.\n\n4. **Connection history**: Maintains a log of connectivity changes with timestamps.\n\n5. **Offline duration tracking**: Calculates how long the user was offline when they reconnect.\n\n6. **Offline operation queuing**: Demonstrates a pattern for queuing operations when offline and retrying them when connectivity is restored.\n\n7. **Notifications**: Shows how you might notify users about connectivity changes.\n\n8. **Visual indicators**: Provides clear visual feedback about the current connection state.\n\nThis pattern is particularly useful for progressive web applications (PWAs) that need to function offline and handle intermittent connectivity gracefully. The `<svelte:window>` element makes it easy to implement these features without manually managing event listeners."}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"How does the `<svelte:window>` element handle server-side rendering (SSR) scenarios?","answer":"The `<svelte:window>` element is designed to handle server-side rendering (SSR) scenarios gracefully by checking for the existence of the `window` object, which doesn't exist in server environments. This is one of its key benefits compared to directly accessing the window object in your component code.\n\nWhen a Svelte application is rendered on the server:\n\n1. The `window` object doesn't exist in Node.js or other server environments.\n2. Directly accessing `window` properties or methods would throw errors during SSR.\n3. The `<svelte:window>` element prevents these errors by safely handling the absence of the window object.\n\nHere's an example that demonstrates how `<svelte:window>` handles SSR scenarios and how you might implement a component that works in both server and client environments:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  // These will be undefined during SSR but will be populated on the client\n  let innerWidth;\n  let innerHeight;\n  let scrollY = 0;\n  let online;\n  \n  // Safe default values for SSR\n  let isMobile = false;\n  let isScrolled = false;\n  \n  // Flag to check if we're in the browser\n  let isBrowser = false;\n  \n  onMount(() => {\n    // This code only runs in the browser, not during SSR\n    isBrowser = true;\n    \n    // We could also initialize values here if needed\n    // But the <svelte:window> bindings will handle most cases\n  });\n  \n  // Safely compute derived values\n  $: isMobile = isBrowser && innerWidth ? innerWidth < 768 : false;\n  $: isScrolled = isBrowser && scrollY ? scrollY > 50 : false;\n  \n  // Function that needs window object\n  function scrollToTop() {\n    if (isBrowser) {\n      scrollY = 0;\n      // Alternative if not using bind:scrollY\n      // window.scrollTo({ top: 0, behavior: 'smooth' });\n    }\n  }\n  \n  // Safely handle events that might fire during SSR hydration\n  function handleResize() {\n    if (!isBrowser) return;\n    console.log('Window resized:', innerWidth, 'x', innerHeight);\n  }\n</script>\n\n<!-- This element is essentially a no-op during SSR -->\n<svelte:window \n  bind:innerWidth \n  bind:innerHeight \n  bind:scrollY \n  bind:online\n  onresize={handleResize}\n/>\n\n<div class=\"container\">\n  <header class:scrolled={isScrolled}>\n    <h1>SSR-Compatible Component</h1>\n  </header>\n  \n  <main class:mobile={isMobile}>\n    <h2>This component works in both SSR and browser environments</h2>\n    \n    {#if isBrowser}\n      <div class=\"browser-info\">\n        <p>Window size: {innerWidth}px Ã {innerHeight}px</p>\n        <p>Scroll position: {scrollY}px</p>\n        <p>Network status: {online ? 'Online' : 'Offline'}</p>\n        <p>Device type: {isMobile ? 'Mobile' : 'Desktop'}</p>\n      </div>\n      \n      <button on:click={scrollToTop}>Scroll to top</button>\n    {:else}\n      <div class=\"ssr-message\">\n        <p>This content is being server-side rendered.</p>\n        <p>Window information will be available after hydration.</p>\n      </div>\n    {/if}\n    \n    <!-- Content that renders the same way in both environments -->\n    <div class=\"universal-content\">\n      <p>This content looks the same regardless of rendering environment.</p>\n    </div>\n  </main>\n</div>\n\n<style>\n  header {\n    position: sticky;\n    top: 0;\n    background: white;\n    padding: 1rem;\n    transition: box-shadow 0.3s ease;\n  }\n  \n  header.scrolled {\n    box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n  }\n  \n  main {\n    padding: 2rem;\n  }\n  \n  main.mobile {\n    padding: 1rem;\n  }\n  \n  .browser-info {\n    background: #f0f0f0;\n    padding: 1rem;\n    border-radius: 4px;\n    margin: 1rem 0;\n  }\n  \n  .ssr-message {\n    background: #fff3e0;\n    padding: 1rem;\n    border-radius: 4px;\n    border-left: 4px solid #ff9800;\n    margin: 1rem 0;\n  }\n  \n  .universal-content {\n    margin-top: 2rem;\n    padding: 1rem;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n  }\n</style>\n```\n\nKey aspects of SSR handling with `<svelte:window>`:\n\n1. **No errors during SSR**: The `<svelte:window>` element doesn't cause errors when the window object doesn't exist.\n\n2. **Hydration-friendly**: After the server-rendered HTML is sent to the browser, Svelte \"hydrates\" it by attaching event listeners and establishing reactivity. The `<svelte:window>` element seamlessly transitions from SSR to client-side during this process.\n\n3. **Safe defaults**: The example uses safe default values for properties that would be undefined during SSR.\n\n4. **Environment detection**: The `onMount` lifecycle function only runs in the browser, allowing you to detect when you're in a browser environment.\n\n5. **Conditional rendering**: The component can render different content based on whether it's in the browser or on the server.\n\n6. **Defensive programming**: All browser-specific code is guarded with checks to ensure it only runs in the appropriate environment.\n\nThis approach ensures your components work correctly regardless of where they're rendered, which is essential for applications that use SSR for performance, SEO, or other reasons."}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"What's the difference between using `<svelte:window>` for scroll position tracking and using the Intersection Observer API? When would you choose one over the other?","answer":"Both `<svelte:window>` with scroll position tracking and the Intersection Observer API can be used to detect elements' visibility in the viewport, but they serve different purposes and have different performance characteristics. Understanding these differences helps you choose the right approach for your specific use case.\n\n### Using `<svelte:window>` for Scroll Position Tracking\n\n```svelte\n<script>\n  let scrollY;\n  let innerHeight;\n  \n  // Elements to track\n  let section1Element;\n  let section2Element;\n  let section3Element;\n  \n  // Visibility state\n  let section1Visible = false;\n  let section2Visible = false;\n  let section3Visible = false;\n  \n  // Check visibility on scroll\n  $: {\n    if (section1Element) {\n      const rect = section1Element.getBoundingClientRect();\n      section1Visible = rect.top < innerHeight && rect.bottom > 0;\n    }\n    \n    if (section2Element) {\n      const rect = section2Element.getBoundingClientRect();\n      section2Visible = rect.top < innerHeight && rect.bottom > 0;\n    }\n    \n    if (section3Element) {\n      const rect = section3Element.getBoundingClientRect();\n      section3Visible = rect.top < innerHeight && rect.bottom > 0;\n    }\n  }\n</script>\n\n<svelte:window bind:scrollY bind:innerHeight />\n\n<section bind:this={section1Element} class:visible={section1Visible}>\n  <h2>Section 1</h2>\n  <p>This section is {section1Visible ? 'visible' : 'not visible'}</p>\n</section>\n\n<section bind:this={section2Element} class:visible={section2Visible}>\n  <h2>Section 2</h2>\n  <p>This section is {section2Visible ? 'visible' : 'not visible'}</p>\n</section>\n\n<section bind:this={section3Element} class:visible={section3Visible}>\n  <h2>Section 3</h2>\n  <p>This section is {section3Visible ? 'visible' : 'not visible'}</p>\n</section>\n\n<style>\n  section {\n    min-height: 100vh;\n    opacity: 0.3;\n    transition: opacity 0.5s;\n  }\n  \n  section.visible {\n    opacity: 1;\n  }\n</style>\n```\n\n### Using Intersection Observer API\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  // Elements to track\n  let section1Element;\n  let section2Element;\n  let section3Element;\n  \n  // Visibility state\n  let section1Visible = false;\n  let section2Visible = false;\n  let section3Visible = false;\n  \n  onMount(() => {\n    // Create an observer\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach(entry => {\n        // Determine which element was observed\n        if (entry.target === section1Element) {\n          section1Visible = entry.isIntersecting;\n        } else if (entry.target === section2Element) {\n          section2Visible = entry.isIntersecting;\n        } else if (entry.target === section3Element) {\n          section3Visible = entry.isIntersecting;\n        }\n      });\n    }, {\n      // Options\n      threshold: 0.1, // Consider visible when 10% is in view\n      rootMargin: '0px' // No margin\n    });\n    \n    // Observe all sections\n    observer.observe(section1Element);\n    observer.observe(section2Element);\n    observer.observe(section3Element);\n    \n    return () => {\n      // Clean up on component destruction\n      observer.disconnect();\n    };\n  });\n</script>\n\n<section bind:this={section1Element} class:visible={section1Visible}>\n  <h2>Section 1</h2>\n  <p>This section is {section1Visible ? 'visible' : 'not visible'}</p>\n</section>\n\n<section bind:this={section2Element} class:visible={section2Visible}>\n  <h2>Section 2</h2>\n  <p>This section is {section2Visible ? 'visible' : 'not visible'}</p>\n</section>\n\n<section bind:this={section3Element} class:visible={section3Visible}>\n  <h2>Section 3</h2>\n  <p>This section is {section3Visible ? 'visible' : 'not visible'}</p>\n</section>\n\n<style>\n  section {\n    min-height: 100vh;\n    opacity: 0.3;\n    transition: opacity 0.5s;\n  }\n  \n  section.visible {\n    opacity: 1;\n  }\n</style>\n```\n\n### Key Differences and When to Use Each Approach\n\n1. **Performance**:\n   - **`<svelte:window>` with scroll tracking**: Fires on every scroll event, which can be very frequent (potentially hundreds of times during a single scroll action). Even with debouncing, this can be less efficient.\n   - **Intersection Observer**: Operates asynchronously and is optimized by the browser. It doesn't fire on every scroll pixel but only when the observed element crosses the specified threshold.\n\n2. **Precision**:\n   - **`<svelte:window>`**: Gives you the exact scroll position at all times, allowing for pixel-perfect calculations.\n   - **Intersection Observer**: Tells you when an element enters or exits the viewport (or a specified container), but doesn't continuously report position.\n\n3. **Use Cases**:\n   - **Use `<svelte:window>` when**:\n     - You need the exact scroll position for effects like parallax scrolling\n     - You're creating a scroll-linked animation that depends on precise scroll values\n     - You need to track the overall scroll progress of the page\n     - You need to implement custom scrolling behavior\n     - You need to support older browsers without polyfills\n\n   - **Use Intersection Observer when**:\n     - You just need to know if an element is visible in the viewport\n     - You're implementing lazy loading of images or content\n     - You want to trigger animations when elements come into view\n     - You're implementing infinite scrolling\n     - Performance is a priority\n     - You need to observe many elements simultaneously\n\n4. **Code Complexity**:\n   - **`<svelte:window>`**: Simpler for basic scroll tracking but requires more manual calculation for element visibility.\n   - **Intersection Observer**: Requires slightly more setup code but handles the visibility calculations for you.\n\n5. **Browser Support**:\n   - **`<svelte:window>`**: Works in all browsers.\n   - **Intersection Observer**: Good modern browser support, but may require a polyfill for older browsers.\n\n### Hybrid Approach Example\n\nSometimes, a hybrid approach can be beneficial:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  // For precise scroll tracking\n  let scrollY;\n  let scrollPercentage = 0;\n  let documentHeight;\n  let innerHeight;\n  \n  // For element visibility\n  let sections = [\n    { id: 'section1', element: null, visible: false, title: 'Introduction' },\n    { id: 'section2', element: null, visible: false, title: 'Features' },\n    { id: 'section3', element: null, visible: false, title: 'Pricing' }\n  ];\n  \n  // Calculate scroll percentage\n  $: {\n    documentHeight = document.body?.scrollHeight || 0;\n    scrollPercentage = documentHeight \n      ? Math.round((scrollY / (documentHeight - innerHeight)) * 100) \n      : 0;\n  }\n  \n  onMount(() => {\n    // Set up Intersection Observer for element visibility\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach(entry => {\n        // Find the section that was observed\n        const sectionIndex = sections.findIndex(s => s.element === entry.target);\n        if (sectionIndex !== -1) {\n          // Update its visibility\n          sections[sectionIndex].visible = entry.isIntersecting;\n          sections = [...sections]; // Trigger reactivity\n        }\n      });\n    }, {\n      threshold: 0.2,\n      rootMargin: '0px'\n    });\n    \n    // Observe all sections\n    sections.forEach(section => {\n      if (section.element) {\n        observer.observe(section.element);\n      }\n    });\n    \n    return () => observer.disconnect();\n  });\n  \n  function scrollToSection(id) {\n    const section = sections.find(s => s.id === id);\n    if (section && section.element) {\n      section.element.scrollIntoView({ behavior: 'smooth' });\n    }\n  }\n</script>\n\n<svelte:window bind:scrollY bind:innerHeight />\n\n<nav>\n  <div class=\"scroll-progress\" style=\"width: {scrollPercentage}%\"></div>\n  <ul>\n    {#each sections as section}\n      <li class:active={section.visible}>\n        <button on:click={() => scrollToSection(section.id)}>\n          {section.title}\n        </button>\n      </li>\n    {/each}\n  </ul>\n</nav>\n\n{#each sections as section}\n  <section \n    id={section.id} \n    bind:this={section.element} \n    class:visible={section.visible}\n  >\n    <h2>{section.title}</h2>\n    <p>Scroll position: {scrollY}px</p>\n    <p>This section is {section.visible ? 'visible' : 'not visible'}</p>\n  </section>\n{/each}\n\n<style>\n  /* Styles similar to previous examples */\n  nav {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    background: white;\n    z-index: 100;\n  }\n  \n  .scroll-progress {\n    height: 4px;\n    background: #0066ff;\n  }\n  \n  section {\n    min-height: 100vh;\n    opacity: 0.3;\n    transition: opacity 0.5s;\n  }\n  \n  section.visible {\n    opacity: 1;\n  }\n  \n  nav ul {\n    display: flex;\n    list-style: none;\n    padding: 0.5rem;\n  }\n  \n  li.active button {\n    font-weight: bold;\n    color: #0066ff;\n  }\n</style>\n```\n\nIn this hybrid approach:\n- Intersection Observer handles element visibility detection efficiently\n- `<svelte:window>` provides precise scroll position for the progress bar\n- Each technique is used for what it does best\n\nChoose the approach that best fits your specific requirements, considering performance implications, browser support needs, and the level of precision required for your UI effects."}
{"source":"docs/svelte/05-special-elements/02-svelte-window.md","question":"How can you use `<svelte:window>` to implement responsive design techniques that go beyond CSS media queries?","answer":"While CSS media queries are powerful for responsive design, using `<svelte:window>` to bind to window properties like `innerWidth` and `innerHeight` enables more dynamic and JavaScript-driven responsive behaviors. This approach allows for responsive techniques that CSS alone cannot achieve. Here's a comprehensive exploration of these techniques:\n\n```svelte\n<script>\n  // Bind to window dimensions\n  let innerWidth;\n  let innerHeight;\n  let devicePixelRatio;\n  \n  // Orientation and aspect ratio\n  $: orientation = innerWidth > innerHeight ? 'landscape' : 'portrait';\n  $: aspectRatio = innerWidth / innerHeight;\n  $: isUltrawide = aspectRatio > 2.1;\n  \n  // Custom breakpoints\n  const breakpoints = {\n    sm: 640,\n    md: 768,\n    lg: 1024,\n    xl: 1280,\n    '2xl': 1536\n  };\n  \n  // Responsive state based on current width\n  $: size = \n    innerWidth < breakpoints.sm ? 'xs' :\n    innerWidth < breakpoints.md ? 'sm' :\n    innerWidth < breakpoints.lg ? 'md' :\n    innerWidth < breakpoints.xl ? 'lg' :\n    innerWidth < breakpoints['2xl'] ? 'xl' : '2xl';\n  \n  // Dynamic component selection based on screen size\n  import MobileNav from './components/MobileNav.svelte';\n  import TabletNav from './components/TabletNav.svelte';\n  import DesktopNav from './components/DesktopNav.svelte';\n  \n  $: NavComponent = \n    size === 'xs' || size === 'sm' ? MobileNav :\n    size === 'md' ? TabletNav : DesktopNav;\n  \n  // Dynamic layout configuration\n  $: columns = \n    size === 'xs' ? 1 :\n    size === 'sm' ? 2 :\n    size === 'md' ? 3 :\n    size === 'lg' ? 4 : 6;\n  \n  $: itemsPerPage = \n    size === 'xs' ? 5 :\n    size === 'sm' ? 10 :\n    size === 'md' ? 15 : 20;\n  \n  // Conditional feature flags based on screen size\n  $: features = {\n    animations: size !== 'xs', // Disable animations on smallest screens\n    sidePanel: size !== 'xs' && size !== 'sm', // Only show side panel on larger screens\n    detailedView: size !== 'xs', // Show simplified view on mobile\n    advancedFilters: size !== 'xs' && size !== 'sm', // Only show advanced filters on larger screens\n    hoverEffects: innerWidth > 1024, // Only enable hover effects on larger screens (likely not touch)\n    highResImages: devicePixelRatio > 1 // Use high-res images on high DPI screens\n  };\n  \n  // Viewport-aware component loading\n  import { onMount } from 'svelte';\n  let heavyComponentsLoaded = false;\n  \n  onMount(() => {\n    // Only load heavy components if we're on a larger screen\n    if (innerWidth >= breakpoints.lg) {\n      loadHeavyComponents();\n    }\n  });\n  \n  function loadHeavyComponents() {\n    // In a real app, this might dynamically import large components\n    console.log('Loading heavy components for large screens');\n    heavyComponentsLoaded = true;\n  }\n  \n  // Window size change handler\n  let debounceTimeout;\n  function handleResize() {\n    clearTimeout(debounceTimeout);\n    debounceTimeout = setTimeout(() => {\n      console.log(`Window resized to ${innerWidth}x${innerHeight}, size: ${size}`);\n      \n      // Conditionally load heavy components if window gets bigger\n      if (innerWidth >= breakpoints.lg && !heavyComponentsLoaded) {\n        loadHeavyComponents();\n      }\n      \n      // You could also recalculate layouts or adjust UI here\n    }, 250);\n  }\n  \n  // Sample data for the grid\n  let items = Array(24).fill().map((_, i) => ({\n    id: i + 1,\n    title: `Item ${i + 1}`,\n    content: `This is the content for item ${i + 1}`\n  }));\n</script>\n\n<svelte:window \n  bind:innerWidth \n  bind:innerHeight\n  bind:devicePixelRatio\n  onresize={handleResize}\n/>\n\n<div class=\"app-container\" class:ultrawide={isUltrawide}>\n  <header>\n    <h1>Responsive App ({size} / {orientation})</h1>\n    <p>Window: {innerWidth}x{innerHeight}px, Pixel Ratio: {devicePixelRatio}</p>\n    \n    <!-- Dynamic component selection -->\n    <svelte:component this={NavComponent} />\n  </header>\n  \n  <main class:with-sidebar={features.sidePanel}>\n    <!-- Conditional layout based on screen size -->\n    {#if features.sidePanel}\n      <aside>\n        <h2>Side Panel</h2>\n        <p>This panel is only visible on screens larger than {breakpoints.md}px.</p>\n        \n        {#if features.advancedFilters}\n          <div class=\"filters\">\n            <h3>Advanced Filters</h3>\n            <p>These filters are only available on larger screens.</p>\n            <!-- Filter controls would go here -->\n          </div>\n        {/if}\n      </aside>\n    {/if}\n    \n    <div class=\"content\">\n      <!-- Dynamic grid layout -->\n      <div \n        class=\"grid\" \n        style=\"grid-template-columns: repeat({columns}, 1fr);\"\n      >\n        {#each items.slice(0, itemsPerPage) as item}\n          <div \n            class=\"card\" \n            class:with-hover={features.hoverEffects}\n            class:detailed={features.detailedView}\n          >\n            <h3>{item.title}</h3>\n            \n            {#if features.highResImages}\n              <img src=\"high-res-image.jpg\" alt=\"High resolution\" />\n            {:else}\n              <img src=\"standard-image.jpg\" alt=\"Standard resolution\" />\n            {/if}\n            \n            {#if features.detailedView}\n              <p>{item.content}</p>\n              <div class=\"actions\">\n                <button>View</button>\n                <button>Edit</button>\n              </div>\n            {:else}\n              <!-- Simplified view for small screens -->\n              <button>View</button>\n            {/if}\n          </div>\n        {/each}\n      </div>\n      \n      <div class=\"pagination\">\n        <p>Showing {itemsPerPage} items per page</p>\n      </div>\n    </div>\n  </main>\n  \n  <footer>\n    <p>Current breakpoint: {size} ({innerWidth}px)</p>\n    <p>Aspect ratio: {aspectRatio.toFixed(2)}</p>\n    <p>Orientation: {orientation}</p>\n    \n    <div class=\"feature-list\">\n      <h3>Enabled Features:</h3>\n      <ul>\n        {#each Object.entries(features) as [feature, enabled]}\n          <li class:enabled>{feature}: {enabled ? 'â' : 'â'}</li>\n        {/each}\n      </ul>\n    </div>\n  </footer>\n</div>\n\n<style>\n  .app-container {\n    max-width: 1400px;\n    margin: 0 auto;\n    padding: 1rem;\n  }\n  \n  .app-container.ultrawide {\n    max-width: 2000px; /* Wider layout for ultrawide screens */\n  }\n  \n  main {\n    display: flex;\n    gap: 1rem;\n    margin: 1rem 0;\n  }\n  \n  main:not(.with-sidebar) .content {\n    width: 100%;\n  }\n  \n  .with-sidebar .content {\n    width: 75%;\n  }\n  \n  aside {\n    width: 25%;\n    background: #f0f0f0;\n    padding: 1rem;\n    border-radius: 4px;\n  }\n  \n  .grid {\n    display: grid;\n    gap: 1rem;\n  }\n  \n  .card {\n    background: white;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    padding: 1rem;\n    transition: all 0.3s ease;\n  }\n  \n  .card.with-hover:hover {\n    transform: translateY(-4px);\n    box-shadow: 0 10px 20px rgba(0,0,0,0.1);\n  }\n  \n  .card.detailed {\n    padding: 1.5rem;\n  }\n  \n  .actions {\n    display: flex;\n    gap: 0.5rem;\n    margin-top: 1rem;\n  }\n  \n  .feature-list li.enabled {\n    color: green;\n  }\n  \n  footer {\n    margin-top: 2rem;\n    padding-top: 1rem;\n    border-top: 1px solid #ddd;\n  }\n</style>\n```\n\n### Key Responsive Design Techniques Using `<svelte:window>`\n\n1. **Dynamic Component Selection**:\n   - Choose different component implementations based on screen size\n   - This goes beyond just hiding/showing elements with CSS\n   - Components can have completely different UX patterns for different devices\n\n2. **Adaptive Layout Logic**:\n   - Dynamically adjust the number of columns, items per page, or layout configuration\n   - Respond to both width and height changes for truly responsive layouts\n   - Handle orientation changes explicitly\n\n3. **Feature Toggling**:\n   - Enable/disable features based on screen size and device capabilities\n   - Simplify the UI on smaller screens by removing advanced features\n   - Optimize performance by disabling animations or effects on less powerful devices\n\n4. **Resolution-Aware Media**:\n   - Use `devicePixelRatio` to serve appropriate image resolutions\n   - Avoid downloading high-resolution assets on low-DPI displays\n   - Implement responsive images beyond what `srcset` can provide\n\n5. **Aspect Ratio-Based Layouts**:\n   - Detect ultrawide monitors or unusual aspect ratios\n   - Optimize layouts for different screen shapes, not just sizes\n   - Provide different experiences for portrait vs. landscape orientations\n\n6. **Performance Optimization**:\n   - Conditionally load heavy components only on capable devices\n   - Implement different rendering strategies based on device capabilities\n   - Adjust animation complexity based on screen size and performance metrics\n\n7. **Custom Breakpoints System**:\n   - Define and use breakpoints in JavaScript that match your CSS system\n   - Create a unified approach to responsive design across both domains\n   - Make breakpoints available to component logic, not just styles\n\n8. **Viewport-Aware Initialization**:\n   - Initialize components differently based on initial viewport size\n   - Avoid unnecessary work on smaller devices\n   - Enhance the experience on larger screens with additional features\n\n9. **Responsive State Management**:\n   - Track the current responsive \"size\" as application state\n   - Allow components to react to size changes without each implementing their own logic\n   - Centralize responsive decision-making for consistency\n\n10. **Interaction Adaption**:\n    - Detect likely input methods (touch vs. mouse) based on screen size\n    - Adjust interaction patterns accordingly (e.g., hover effects only on non-touch devices)\n    - Provide different navigation patterns for different device types\n\nThese JavaScript-driven responsive techniques complement CSS media queries rather than replacing them. Use CSS for styling changes and layout adjustments that don't require JavaScript logic, and use `<svelte:window>` bindings for more complex responsive behaviors that need to influence component logic, rendering decisions, or application state."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"What is the `<svelte:document>` element in Svelte 5, and how does it differ from `<svelte:window>`?","answer":"The `<svelte:document>` element in Svelte 5 is a special element that allows you to add event listeners and apply actions to the global `document` object. It differs from `<svelte:window>` in that it specifically targets the `document` object rather than the `window` object, enabling you to listen for events that fire on `document` but not on `window`, such as `visibilitychange`.\n\nThe syntax for using `<svelte:document>` is similar to `<svelte:window>`:\n\n```svelte\n<svelte:document onevent={handler} />\n```\n\nOr for binding to properties:\n\n```svelte\n<svelte:document bind:prop={value} />\n```\n\nFor example, to listen for the `visibilitychange` event and apply an action to the document:\n\n```svelte\n<script>\n  import { someAction } from './actions';\n  \n  function handleVisibilityChange(event) {\n    console.log('Document visibility changed:', document.visibilityState);\n    // Handle visibility change\n  }\n</script>\n\n<svelte:document \n  onvisibilitychange={handleVisibilityChange} \n  use:someAction \n/>\n```\n\nLike `<svelte:window>`, the `<svelte:document>` element must only appear at the top level of your component and cannot be placed inside a block or element."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"What are the properties you can bind to with `<svelte:document>`, and what does it mean that they are \"readonly\"?","answer":"With the `<svelte:document>` element, you can bind to the following properties:\n\n1. `activeElement` - References the currently focused element\n2. `fullscreenElement` - References the element that's currently displayed in fullscreen mode\n3. `pointerLockElement` - References the element that's currently locking the pointer\n4. `visibilityState` - Indicates the visibility state of the document (e.g., \"visible\", \"hidden\")\n\nThe documentation specifies that all of these bindings are \"readonly,\" which means you can bind to them to read their values, but you cannot set their values through the binding. In other words, the data flow is one-way: from the document properties to your component state, but not the other way around.\n\nHere's an example of how you might use these readonly bindings:\n\n```svelte\n<script>\n  let currentActiveElement = null;\n  let isFullscreen = false;\n  let isPointerLocked = false;\n  let docVisibilityState = 'visible';\n  \n  function handleActiveElementChange() {\n    console.log('Active element changed to:', currentActiveElement);\n  }\n  \n  function handleFullscreenChange() {\n    isFullscreen = !!currentFullscreenElement;\n    console.log('Fullscreen state:', isFullscreen ? 'active' : 'inactive');\n  }\n  \n  function handleVisibilityChange() {\n    console.log('Document visibility:', docVisibilityState);\n    if (docVisibilityState === 'hidden') {\n      // Pause animations or background tasks\n    } else if (docVisibilityState === 'visible') {\n      // Resume animations or background tasks\n    }\n  }\n  \n  $: if (currentActiveElement) handleActiveElementChange();\n  $: handleFullscreenChange();\n  $: handleVisibilityChange();\n</script>\n\n<svelte:document \n  bind:activeElement={currentActiveElement}\n  bind:fullscreenElement={currentFullscreenElement}\n  bind:pointerLockElement={currentPointerLockElement}\n  bind:visibilityState={docVisibilityState}\n/>\n\n<button on:click={() => document.documentElement.requestFullscreen()}>\n  Enter Fullscreen\n</button>\n\n<div>Current visibility state: {docVisibilityState}</div>\n<div>Is fullscreen: {isFullscreen ? 'Yes' : 'No'}</div>\n<div>Active element tag: {currentActiveElement?.tagName || 'None'}</div>\n```\n\nSince these bindings are readonly, attempting to set their values directly won't work. For example, this won't work:\n\n```svelte\n<!-- This won't work because the binding is readonly -->\n<button on:click={() => docVisibilityState = 'hidden'}>Hide document</button>\n```\n\nInstead, you would need to use the appropriate DOM APIs to change these properties, and the bindings will reflect those changes."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"How would you use `<svelte:document>` to detect when a user switches tabs or minimizes the browser window?","answer":"You can use the `<svelte:document>` element with the `visibilitychange` event and the `visibilityState` property to detect when a user switches tabs or minimizes the browser window. The `visibilityState` property will change to \"hidden\" when the document is not visible to the user, and back to \"visible\" when it is.\n\nHere's a comprehensive example of how to implement this:\n\n```svelte\n<script>\n  let isDocumentVisible = true;\n  let lastVisibilityChange = new Date();\n  let timeHidden = 0;\n  let timeVisible = 0;\n  let startTime = new Date();\n  \n  function handleVisibilityChange(event) {\n    const now = new Date();\n    const timeSinceLastChange = now - lastVisibilityChange;\n    \n    if (document.visibilityState === 'hidden') {\n      isDocumentVisible = false;\n      timeVisible += timeSinceLastChange;\n      console.log('User switched away from tab or minimized window');\n      // Pause any animations, videos, or resource-intensive operations\n      pauseOperations();\n    } else if (document.visibilityState === 'visible') {\n      isDocumentVisible = true;\n      timeHidden += timeSinceLastChange;\n      console.log('User returned to tab or restored window');\n      // Resume operations that were paused\n      resumeOperations();\n    }\n    \n    lastVisibilityChange = now;\n  }\n  \n  function pauseOperations() {\n    // Implementation to pause operations\n    console.log('Pausing operations to save resources');\n  }\n  \n  function resumeOperations() {\n    // Implementation to resume operations\n    console.log('Resuming operations');\n  }\n  \n  // Reactive declarations to track time metrics\n  $: totalSessionTime = new Date() - startTime;\n  $: visibilityPercentage = Math.round((timeVisible / totalSessionTime) * 100);\n</script>\n\n<svelte:document \n  onvisibilitychange={handleVisibilityChange}\n  bind:visibilityState\n/>\n\n<div class=\"status-indicator\" class:visible={isDocumentVisible} class:hidden={!isDocumentVisible}>\n  Document is currently {isDocumentVisible ? 'visible' : 'hidden'}\n</div>\n\n<div class=\"metrics\">\n  <h3>Session Metrics</h3>\n  <p>Total session time: {Math.round(totalSessionTime / 1000)} seconds</p>\n  <p>Time visible: {Math.round(timeVisible / 1000)} seconds ({visibilityPercentage}%)</p>\n  <p>Time hidden: {Math.round(timeHidden / 1000)} seconds ({100 - visibilityPercentage}%)</p>\n</div>\n\n<style>\n  .status-indicator {\n    padding: 10px;\n    border-radius: 4px;\n    margin-bottom: 20px;\n  }\n  \n  .visible {\n    background-color: #d4edda;\n    color: #155724;\n  }\n  \n  .hidden {\n    background-color: #f8d7da;\n    color: #721c24;\n  }\n  \n  .metrics {\n    background-color: #f8f9fa;\n    padding: 15px;\n    border-radius: 4px;\n  }\n</style>\n```\n\nThis example not only detects when the document visibility changes but also keeps track of how long the document has been visible or hidden during the current session. This can be useful for analytics, optimizing resource usage, or providing a better user experience by pausing and resuming operations as needed."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"Can you explain how to use actions with `<svelte:document>` and provide an example of a practical use case?","answer":"In Svelte, actions are functions that are called when an element is created, allowing you to run code that interacts directly with a DOM element. The `<svelte:document>` element supports actions through the `use:` directive, just like regular DOM elements.\n\nActions with `<svelte:document>` are particularly useful when you need to set up and tear down global document-level event listeners or behaviors that aren't covered by the standard event handlers.\n\nHere's how to define and use an action with `<svelte:document>`:\n\n```svelte\n<script>\n  // Define an action function\n  function keyboardShortcuts(node, options = {}) {\n    const shortcuts = options.shortcuts || {};\n    \n    // Event handler function\n    const handleKeyDown = (event) => {\n      // Check if Alt, Ctrl, or Shift keys are required and pressed\n      const alt = !!options.alt === event.altKey;\n      const ctrl = !!options.ctrl === event.ctrlKey;\n      const shift = !!options.shift === event.shiftKey;\n      \n      // If modifiers match and the key is in our shortcuts\n      if (alt && ctrl && shift && shortcuts[event.key]) {\n        event.preventDefault(); // Prevent default browser behavior\n        shortcuts[event.key](event); // Call the shortcut handler\n      }\n    };\n    \n    // Add the event listener\n    node.addEventListener('keydown', handleKeyDown);\n    \n    // Return the destroy function to clean up when component is unmounted\n    return {\n      destroy() {\n        node.removeEventListener('keydown', handleKeyDown);\n      },\n      // Optional update method if action parameters change\n      update(newOptions) {\n        options = newOptions;\n      }\n    };\n  }\n  \n  // Define some shortcut handlers\n  function handleSave() {\n    console.log('Save shortcut activated');\n    saveData();\n  }\n  \n  function handleUndo() {\n    console.log('Undo shortcut activated');\n    undoLastAction();\n  }\n  \n  function handleRedo() {\n    console.log('Redo shortcut activated');\n    redoLastAction();\n  }\n  \n  // Placeholder functions for the actual operations\n  function saveData() { /* Implementation */ }\n  function undoLastAction() { /* Implementation */ }\n  function redoLastAction() { /* Implementation */ }\n</script>\n\n<svelte:document\n  use:keyboardShortcuts={{\n    ctrl: true,\n    shortcuts: {\n      's': handleSave,\n      'z': handleUndo,\n      'y': handleRedo\n    }\n  }}\n/>\n\n<div class=\"app\">\n  <h1>Document with Keyboard Shortcuts</h1>\n  <p>Try the following shortcuts:</p>\n  <ul>\n    <li><kbd>Ctrl</kbd> + <kbd>S</kbd>: Save</li>\n    <li><kbd>Ctrl</kbd> + <kbd>Z</kbd>: Undo</li>\n    <li><kbd>Ctrl</kbd> + <kbd>Y</kbd>: Redo</li>\n  </ul>\n</div>\n```\n\nAnother practical example could be an action that detects when the user is inactive:\n\n```svelte\n<script>\n  let isUserActive = true;\n  let lastActivity = new Date();\n  let inactivityTimeout = 60000; // 1 minute\n  let inactivityTimer;\n  \n  function trackUserActivity(node, options = { timeout: 60000 }) {\n    inactivityTimeout = options.timeout;\n    \n    const resetTimer = () => {\n      isUserActive = true;\n      lastActivity = new Date();\n      clearTimeout(inactivityTimer);\n      \n      inactivityTimer = setTimeout(() => {\n        isUserActive = false;\n        if (options.onInactive) options.onInactive();\n      }, inactivityTimeout);\n    };\n    \n    // List of events to track for activity\n    const activityEvents = [\n      'mousedown', 'mousemove', 'keypress', \n      'scroll', 'touchstart', 'click', 'keydown'\n    ];\n    \n    // Add all event listeners\n    activityEvents.forEach(eventName => {\n      node.addEventListener(eventName, resetTimer, { passive: true });\n    });\n    \n    // Initial setup\n    resetTimer();\n    \n    return {\n      destroy() {\n        // Clean up all event listeners\n        activityEvents.forEach(eventName => {\n          node.removeEventListener(eventName, resetTimer);\n        });\n        clearTimeout(inactivityTimer);\n      },\n      update(newOptions) {\n        inactivityTimeout = newOptions.timeout;\n        // Reset the timer with new timeout\n        resetTimer();\n      }\n    };\n  }\n  \n  function handleUserInactive() {\n    console.log('User has been inactive for', inactivityTimeout / 1000, 'seconds');\n    // Maybe show a session timeout warning or log the user out\n    showInactivityWarning();\n  }\n  \n  function showInactivityWarning() {\n    // Implementation\n  }\n  \n  // Calculate time since last activity\n  $: timeSinceLastActivity = new Date() - lastActivity;\n</script>\n\n<svelte:document\n  use:trackUserActivity={{\n    timeout: 60000, // 1 minute\n    onInactive: handleUserInactive\n  }}\n/>\n\n<div class=\"status\">\n  <p>User is currently {isUserActive ? 'active' : 'inactive'}</p>\n  <p>Time since last activity: {Math.round(timeSinceLastActivity / 1000)} seconds</p>\n  <p>Inactivity timeout: {inactivityTimeout / 1000} seconds</p>\n</div>\n\n{#if !isUserActive}\n  <div class=\"warning\">\n    <h2>Are you still there?</h2>\n    <p>You've been inactive for a while. Your session will expire soon.</p>\n    <button on:click={() => isUserActive = true}>I'm still here</button>\n  </div>\n{/if}\n```\n\nThese examples demonstrate how actions with `<svelte:document>` can be used to implement global behaviors like keyboard shortcuts or user inactivity tracking, which need to work across the entire document regardless of which element has focus."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"What placement restrictions apply to the `<svelte:document>` element and why do these restrictions exist?","answer":"According to the documentation, the `<svelte:document>` element has two important placement restrictions:\n\n1. It may only appear at the top level of your component\n2. It must never be inside a block or element\n\nThese restrictions exist for several important reasons:\n\n1. **Conceptual clarity**: The `document` object is a singleton that exists at the global level in the browser. By restricting `<svelte:document>` to the top level of a component, Svelte enforces a clearer mental model where global objects are handled at the top level.\n\n2. **Lifecycle management**: Placing `<svelte:document>` at the top level ensures that event listeners and bindings are set up when the component is mounted and cleaned up when the component is destroyed. If it were allowed inside conditional blocks, Svelte would need to handle attaching and detaching listeners as the DOM updates, which could lead to performance issues and bugs.\n\n3. **Preventing duplicate listeners**: If `<svelte:document>` could be used inside loops or repeated blocks, it could inadvertently create multiple listeners for the same events on the same document object, leading to performance issues and unexpected behavior.\n\n4. **Avoiding reactivity complications**: Keeping `<svelte:document>` at the top level simplifies the reactivity system's job, as it doesn't need to track the element through conditionals, loops, or nested component hierarchies.\n\nHere's an example of correct usage:\n\n```svelte\n<script>\n  function handleVisibilityChange() {\n    // Handle the event\n  }\n</script>\n\n<!-- Correct: at the top level of the component -->\n<svelte:document onvisibilitychange={handleVisibilityChange} />\n\n<div>\n  <!-- Component content here -->\n</div>\n```\n\nExamples of incorrect usage:\n\n```svelte\n<script>\n  let showDocumentListener = true;\n  function handleVisibilityChange() {\n    // Handle the event\n  }\n</script>\n\n<!-- Incorrect: inside a conditional block -->\n{#if showDocumentListener}\n  <svelte:document onvisibilitychange={handleVisibilityChange} />\n{/if}\n\n<!-- Incorrect: inside an element -->\n<div>\n  <svelte:document onvisibilitychange={handleVisibilityChange} />\n</div>\n\n<!-- Incorrect: inside a loop -->\n{#each items as item}\n  <svelte:document onvisibilitychange={handleVisibilityChange} />\n{/each}\n```\n\nIf you need to conditionally add or remove document event listeners, you should do so using reactive statements in your script section:\n\n```svelte\n<script>\n  let shouldListen = false;\n  \n  function handleVisibilityChange() {\n    // Handle the event\n  }\n  \n  $: if (shouldListen) {\n    // Add listener manually when condition is true\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    // Return a cleanup function\n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }\n</script>\n\n<button on:click={() => shouldListen = !shouldListen}>\n  {shouldListen ? 'Stop' : 'Start'} listening\n</button>\n```\n\nBy enforcing these placement restrictions, Svelte helps developers avoid common pitfalls and ensures that document-level event handling is predictable and efficient."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"How would you implement a fullscreen toggle feature in Svelte using the `<svelte:document>` element?","answer":"To implement a fullscreen toggle feature in Svelte using the `<svelte:document>` element, we can leverage the `fullscreenElement` binding to track the fullscreen state and use the Fullscreen API to toggle fullscreen mode. Here's a comprehensive example:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let currentFullscreenElement = null;\n  let isFullscreen = false;\n  let targetElement;\n  let fullscreenSupported = false;\n  let fullscreenError = null;\n  \n  // Check if fullscreen is supported\n  onMount(() => {\n    fullscreenSupported = document.documentElement.requestFullscreen ||\n                          document.documentElement.webkitRequestFullscreen ||\n                          document.documentElement.mozRequestFullScreen ||\n                          document.documentElement.msRequestFullscreen;\n  });\n  \n  // Update isFullscreen whenever fullscreenElement changes\n  $: isFullscreen = !!currentFullscreenElement;\n  \n  // Function to toggle fullscreen\n  async function toggleFullscreen() {\n    try {\n      fullscreenError = null;\n      \n      if (!isFullscreen) {\n        // Enter fullscreen mode\n        if (targetElement.requestFullscreen) {\n          await targetElement.requestFullscreen();\n        } else if (targetElement.webkitRequestFullscreen) { /* Safari */\n          await targetElement.webkitRequestFullscreen();\n        } else if (targetElement.msRequestFullscreen) { /* IE11 */\n          await targetElement.msRequestFullscreen();\n        }\n      } else {\n        // Exit fullscreen mode\n        if (document.exitFullscreen) {\n          await document.exitFullscreen();\n        } else if (document.webkitExitFullscreen) { /* Safari */\n          await document.webkitExitFullscreen();\n        } else if (document.msExitFullscreen) { /* IE11 */\n          await document.msExitFullscreen();\n        }\n      }\n    } catch (error) {\n      console.error('Fullscreen error:', error);\n      fullscreenError = error.message;\n    }\n  }\n  \n  // Function to handle fullscreen change event\n  function handleFullscreenChange() {\n    console.log('Fullscreen state changed:', isFullscreen ? 'enabled' : 'disabled');\n  }\n</script>\n\n<svelte:document \n  bind:fullscreenElement={currentFullscreenElement}\n  onfullscreenchange={handleFullscreenChange}\n  onfullscreenerror={(e) => fullscreenError = e.message}\n/>\n\n<div class=\"fullscreen-container\" bind:this={targetElement}>\n  <div class=\"content\">\n    <h1>Fullscreen Demo</h1>\n    \n    {#if !fullscreenSupported}\n      <div class=\"error\">\n        Fullscreen is not supported in your browser.\n      </div>\n    {:else}\n      <button \n        on:click={toggleFullscreen}\n        disabled={!fullscreenSupported}\n        class=\"fullscreen-button\"\n      >\n        {isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}\n      </button>\n      \n      {#if fullscreenError}\n        <div class=\"error\">\n          Error: {fullscreenError}\n        </div>\n      {/if}\n      \n      <div class=\"status\">\n        Current status: {isFullscreen ? 'Fullscreen' : 'Normal'}\n      </div>\n      \n      <div class=\"info\">\n        <p>Fullscreen element: {currentFullscreenElement ? currentFullscreenElement.tagName : 'None'}</p>\n      </div>\n    {/if}\n    \n    <div class=\"demo-content\">\n      <p>This content will be displayed in fullscreen mode when you click the button.</p>\n      <!-- Add more content here -->\n    </div>\n  </div>\n</div>\n\n<style>\n  .fullscreen-container {\n    border: 2px solid #ccc;\n    padding: 20px;\n    border-radius: 8px;\n    background-color: #f9f9f9;\n    min-height: 300px;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n  }\n  \n  /* When in fullscreen mode */\n  :global(:-webkit-full-screen) .fullscreen-container,\n  :global(:fullscreen) .fullscreen-container {\n    background-color: white;\n    width: 100vw;\n    height: 100vh;\n    padding: 40px;\n    border: none;\n  }\n  \n  .content {\n    max-width: 800px;\n    margin: 0 auto;\n    text-align: center;\n  }\n  \n  .fullscreen-button {\n    background-color: #4CAF50;\n    color: white;\n    border: none;\n    padding: 12px 24px;\n    border-radius: 4px;\n    font-size: 16px;\n    cursor: pointer;\n    margin: 20px 0;\n    transition: background-color 0.3s;\n  }\n  \n  .fullscreen-button:hover {\n    background-color: #45a049;\n  }\n  \n  .fullscreen-button:disabled {\n    background-color: #cccccc;\n    cursor: not-allowed;\n  }\n  \n  .status {\n    margin: 20px 0;\n    font-weight: bold;\n  }\n  \n  .error {\n    color: #d32f2f;\n    margin: 20px 0;\n    padding: 10px;\n    background-color: #ffebee;\n    border-radius: 4px;\n  }\n  \n  .info {\n    margin: 20px 0;\n    font-style: italic;\n    color: #666;\n  }\n  \n  .demo-content {\n    margin-top: 40px;\n    padding: 20px;\n    background-color: #e8f5e9;\n    border-radius: 8px;\n  }\n</style>\n```\n\nKey aspects of this implementation:\n\n1. **Fullscreen Element Binding**: We use `bind:fullscreenElement={currentFullscreenElement}` to keep track of which element is currently in fullscreen mode. This is a readonly binding that Svelte will update automatically.\n\n2. **Fullscreen Events**: We listen for the `fullscreenchange` and `fullscreenerror` events to handle state changes and errors.\n\n3. **Browser Compatibility**: The implementation includes checks for different browser prefixes (`webkit`, `moz`, `ms`) to ensure cross-browser compatibility.\n\n4. **Reactive Declarations**: We use `$: isFullscreen = !!currentFullscreenElement` to reactively update our UI based on the fullscreen state.\n\n5. **Target Element**: We use `bind:this={targetElement}` to get a reference to the DOM element we want to make fullscreen.\n\n6. **Error Handling**: We catch and display any errors that might occur when entering or exiting fullscreen mode.\n\n7. **Styling**: We use global selectors (`:global(:fullscreen)`) to style the element differently when it's in fullscreen mode.\n\nThis implementation provides a complete solution for toggling fullscreen mode with proper error handling and browser compatibility. The `<svelte:document>` element makes it easy to bind to the `fullscreenElement` property and listen for fullscreen-related events."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"How can you use `<svelte:document>` to implement a feature that tracks which element has focus in your application?","answer":"You can use the `<svelte:document>` element with the `activeElement` binding to track which element currently has focus in your application. This can be useful for accessibility features, keyboard navigation, or analytics tracking. Here's a comprehensive implementation:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let currentActiveElement = null;\n  let focusHistory = [];\n  let maxHistoryLength = 10;\n  let elementDetails = {\n    tagName: null,\n    id: null,\n    className: null,\n    type: null,\n    value: null,\n    textContent: null,\n    placeholder: null,\n    name: null,\n    ariaLabel: null\n  };\n  \n  // Function to get element details safely\n  function getElementDetails(element) {\n    if (!element) return { ...elementDetails };\n    \n    try {\n      return {\n        tagName: element.tagName || null,\n        id: element.id || null,\n        className: element.className || null,\n        type: element.type || null,\n        value: element instanceof HTMLInputElement ? element.value : null,\n        textContent: element.textContent?.trim().substring(0, 50) || null,\n        placeholder: element.placeholder || null,\n        name: element.name || null,\n        ariaLabel: element.getAttribute('aria-label') || null\n      };\n    } catch (error) {\n      console.error('Error getting element details:', error);\n      return { ...elementDetails };\n    }\n  }\n  \n  // Update element details when active element changes\n  function updateElementDetails() {\n    if (!currentActiveElement) {\n      elementDetails = getElementDetails(null);\n      return;\n    }\n    \n    elementDetails = getElementDetails(currentActiveElement);\n    \n    // Add to focus history if it's a new element\n    const lastElement = focusHistory[0];\n    if (!lastElement || lastElement.element !== currentActiveElement) {\n      focusHistory.unshift({\n        element: currentActiveElement,\n        details: { ...elementDetails },\n        timestamp: new Date()\n      });\n      \n      // Trim history to max length\n      if (focusHistory.length > maxHistoryLength) {\n        focusHistory = focusHistory.slice(0, maxHistoryLength);\n      }\n    }\n  }\n  \n  // Function to handle focus change\n  function handleFocusChange() {\n    updateElementDetails();\n    console.log('Focus changed to:', elementDetails.tagName);\n    \n    // You could trigger analytics events here\n    if (elementDetails.tagName === 'BUTTON') {\n      console.log('Button focused:', elementDetails.textContent);\n    } else if (elementDetails.tagName === 'INPUT') {\n      console.log('Input focused:', elementDetails.type, elementDetails.id || elementDetails.name);\n    }\n  }\n  \n  // Set up a mutation observer to detect dynamically added elements\n  onMount(() => {\n    // Initial update\n    updateElementDetails();\n    \n    // Create a button for testing focus\n    const createTestElements = () => {\n      const container = document.createElement('div');\n      container.id = 'test-focus-elements';\n      container.style.position = 'fixed';\n      container.style.bottom = '10px';\n      container.style.right = '10px';\n      container.style.backgroundColor = '#f0f0f0';\n      container.style.padding = '10px';\n      container.style.borderRadius = '5px';\n      container.style.zIndex = '1000';\n      \n      const button = document.createElement('button');\n      button.textContent = 'Test Button';\n      button.id = 'test-focus-button';\n      \n      const input = document.createElement('input');\n      input.type = 'text';\n      input.placeholder = 'Test Input';\n      input.id = 'test-focus-input';\n      \n      container.appendChild(button);\n      container.appendChild(document.createElement('br'));\n      container.appendChild(input);\n      \n      document.body.appendChild(container);\n    };\n    \n    // Uncomment to add test elements\n    // createTestElements();\n    \n    return () => {\n      // Cleanup if needed\n      const testContainer = document.getElementById('test-focus-elements');\n      if (testContainer) {\n        document.body.removeChild(testContainer);\n      }\n    };\n  });\n  \n  // React to active element changes\n  $: if (currentActiveElement) handleFocusChange();\n</script>\n\n<svelte:document bind:activeElement={currentActiveElement} />\n\n<div class=\"focus-tracker\">\n  <h2>Focus Tracker</h2>\n  \n  <div class=\"current-focus\">\n    <h3>Currently Focused Element</h3>\n    {#if elementDetails.tagName}\n      <table>\n        <tr>\n          <th>Property</th>\n          <th>Value</th>\n        </tr>\n        {#each Object.entries(elementDetails) as [property, value]}\n          {#if value !== null}\n            <tr>\n              <td>{property}</td>\n              <td>{value}</td>\n            </tr>\n          {/if}\n        {/each}\n      </table>\n    {:else}\n      <p>No element currently focused</p>\n    {/if}\n  </div>\n  \n  <div class=\"focus-history\">\n    <h3>Focus History</h3>\n    {#if focusHistory.length > 0}\n      <table>\n        <tr>\n          <th>Time</th>\n          <th>Element</th>\n          <th>Details</th>\n        </tr>\n        {#each focusHistory as { details, timestamp }, i}\n          <tr>\n            <td>{timestamp.toLocaleTimeString()}</td>\n            <td>{details.tagName}</td>\n            <td>\n              {#if details.id}ID: {details.id}{/if}\n              {#if details.type}Type: {details.type}{/if}\n              {#if details.textContent}Text: {details.textContent}{/if}\n            </td>\n          </tr>\n        {/each}\n      </table>\n    {:else}\n      <p>No focus history recorded yet</p>\n    {/if}\n  </div>\n  \n  <div class=\"test-area\">\n    <h3>Test Focus</h3>\n    <div class=\"focus-test-elements\">\n      <button>Focus me</button>\n      <input type=\"text\" placeholder=\"Type something here\" />\n      <select>\n        <option>Option 1</option>\n        <option>Option 2</option>\n      </select>\n      <a href=\"#\" tabindex=\"0\">Focusable link</a>\n    </div>\n  </div>\n</div>\n\n<style>\n  .focus-tracker {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 20px;\n    background-color: #f9f9f9;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  }\n  \n  h2 {\n    color: #333;\n    border-bottom: 2px solid #ddd;\n    padding-bottom: 10px;\n  }\n  \n  h3 {\n    color: #555;\n    margin-top: 20px;\n  }\n  \n  .current-focus, .focus-history, .test-area {\n    margin-top: 20px;\n    padding: 15px;\n    background-color: white;\n    border-radius: 5px;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n  }\n  \n  table {\n    width: 100%;\n    border-collapse: collapse;\n    margin-top: 10px;\n  }\n  \n  th, td {\n    padding: 8px;\n    text-align: left;\n    border-bottom: 1px solid #ddd;\n  }\n  \n  th {\n    background-color: #f2f2f2;\n  }\n  \n  .focus-test-elements {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 10px;\n    margin-top: 10px;\n  }\n  \n  button, input, select, a {\n    padding: 8px 16px;\n    border-radius: 4px;\n  }\n  \n  button {\n    background-color: #4CAF50;\n    color: white;\n    border: none;\n    cursor: pointer;\n  }\n  \n  input, select {\n    border: 1px solid #ddd;\n  }\n  \n  a {\n    text-decoration: none;\n    color: #2196F3;\n    padding: 8px 0;\n  }\n  \n  a:focus, button:focus, input:focus, select:focus {\n    outline: 2px solid #2196F3;\n    outline-offset: 2px;\n  }\n</style>\n```\n\nThis implementation provides several useful features:\n\n1. **Current Focus Tracking**: It binds to `document.activeElement` to keep track of which element currently has focus.\n\n2. **Element Details**: It extracts and displays various properties of the focused element, such as tag name, ID, class, value, etc.\n\n3. **Focus History**: It maintains a history of recently focused elements, which can be useful for debugging or analytics.\n\n4. **Test Area**: It includes a set of focusable elements to test the focus tracking functionality.\n\n5. **Event Handling**: It logs focus changes to the console and could be extended to send analytics events or trigger other actions.\n\nPractical applications for this focus tracking include:\n\n1. **Accessibility Testing**: Monitoring focus order to ensure keyboard navigation works correctly.\n\n2. **User Behavior Analysis**: Tracking which form fields users interact with and in what order.\n\n3. **Debugging**: Helping identify focus-related issues in complex applications.\n\n4. **Custom Focus Management**: Building more sophisticated focus management systems for complex UIs.\n\n5. **Auto-saving Forms**: Triggering save operations when users move focus away from input fields.\n\nThe `<svelte:document>` element with the `activeElement` binding makes implementing this functionality much cleaner than manually setting up and tearing down event listeners."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"How can the `<svelte:document>` element be used to implement a pointer lock feature for a canvas-based game or application?","answer":"The `<svelte:document>` element can be used to implement a pointer lock feature for canvas-based games or applications by binding to the `pointerLockElement` property and handling related events. Pointer lock (also called mouse capture) allows you to access mouse movement data even when the cursor reaches the edge of the browser window, which is essential for first-person games and other applications requiring unlimited mouse movement.\n\nHere's a comprehensive implementation of a pointer lock feature using `<svelte:document>`:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let canvas;\n  let ctx;\n  let currentPointerLockElement = null;\n  let isPointerLocked = false;\n  let canRequestPointerLock = false;\n  let pointerLockError = null;\n  \n  // Mouse position tracking\n  let mouseX = 0;\n  let mouseY = 0;\n  let mouseDeltaX = 0;\n  let mouseDeltaY = 0;\n  \n  // Game state\n  let playerX = 250;\n  let playerY = 250;\n  let playerSize = 20;\n  let playerSpeed = 0.5;\n  let score = 0;\n  let gameActive = false;\n  \n  // Check if pointer lock is supported\n  onMount(() => {\n    if (canvas) {\n      ctx = canvas.getContext('2d');\n      \n      // Check if pointer lock is supported\n      canRequestPointerLock = 'pointerLockElement' in document || \n                             'mozPointerLockElement' in document || \n                             'webkitPointerLockElement' in document;\n      \n      if (canRequestPointerLock) {\n        // Set up canvas and initial drawing\n        canvas.width = 500;\n        canvas.height = 500;\n        drawGame();\n      }\n    }\n    \n    return () => {\n      // Make sure to exit pointer lock when component is destroyed\n      if (document.exitPointerLock) {\n        document.exitPointerLock();\n      }\n    };\n  });\n  \n  // Update isPointerLocked when the pointerLockElement changes\n  $: isPointerLocked = !!currentPointerLockElement;\n  $: if (isPointerLocked) {\n    if (!gameActive) startGame();\n  } else {\n    if (gameActive) pauseGame();\n  }\n  \n  // Request pointer lock on the canvas\n  function requestPointerLock() {\n    pointerLockError = null;\n    \n    try {\n      if (canvas.requestPointerLock) {\n        canvas.requestPointerLock();\n      } else if (canvas.mozRequestPointerLock) {\n        canvas.mozRequestPointerLock();\n      } else if (canvas.webkitRequestPointerLock) {\n        canvas.webkitRequestPointerLock();\n      }\n    } catch (error) {\n      console.error('Pointer lock error:', error);\n      pointerLockError = error.message;\n    }\n  }\n  \n  // Exit pointer lock\n  function exitPointerLock() {\n    if (document.exitPointerLock) {\n      document.exitPointerLock();\n    } else if (document.mozExitPointerLock) {\n      document.mozExitPointerLock();\n    } else if (document.webkitExitPointerLock) {\n      document.webkitExitPointerLock();\n    }\n  }\n  \n  // Handle pointer lock change\n  function handlePointerLockChange() {\n    console.log('Pointer lock state changed:', isPointerLocked ? 'locked' : 'unlocked');\n    \n    if (isPointerLocked) {\n      console.log('Pointer is now locked to', currentPointerLockElement.tagName);\n    } else {\n      console.log('Pointer is now unlocked');\n    }\n  }\n  \n  // Handle pointer lock error\n  function handlePointerLockError(event) {\n    console.error('Pointer lock error:', event);\n    pointerLockError = 'Failed to lock the pointer. This may be due to permissions or the feature being disabled.';\n  }\n  \n  // Handle mouse movement when pointer is locked\n  function handleMouseMove(event) {\n    if (isPointerLocked) {\n      // Use movementX/Y for smoother tracking (works better than clientX/Y with pointer lock)\n      mouseDeltaX = event.movementX || \n                  event.mozMovementX || \n                  event.webkitMovementX || \n                  0;\n      \n      mouseDeltaY = event.movementY || \n                  event.mozMovementY || \n                  event.webkitMovementY || \n                  0;\n      \n      // Update player position based on mouse movement\n      playerX += mouseDeltaX * playerSpeed;\n      playerY += mouseDeltaY * playerSpeed;\n      \n      // Keep player within bounds\n      playerX = Math.max(playerSize, Math.min(canvas.width - playerSize, playerX));\n      playerY = Math.max(playerSize, Math.min(canvas.height - playerSize, playerY));\n      \n      // Update score based on movement\n      score += Math.abs(mouseDeltaX) + Math.abs(mouseDeltaY);\n      \n      // Redraw the game\n      drawGame();\n    }\n  }\n  \n  // Start the game\n  function startGame() {\n    gameActive = true;\n    console.log('Game started');\n    drawGame();\n  }\n  \n  // Pause the game\n  function pauseGame() {\n    gameActive = false;\n    console.log('Game paused');\n    drawPausedState();\n  }\n  \n  // Draw the game\n  function drawGame() {\n    if (!ctx) return;\n    \n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw background\n    ctx.fillStyle = '#f0f0f0';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw border\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw player\n    ctx.fillStyle = '#4CAF50';\n    ctx.beginPath();\n    ctx.arc(playerX, playerY, playerSize, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw score\n    ctx.fillStyle = '#333';\n    ctx.font = '16px Arial';\n    ctx.fillText(`Score: ${Math.floor(score)}`, 10, 25);\n    \n    // Draw instructions if not pointer locked\n    if (!isPointerLocked) {\n      drawInstructions();\n    }\n  }\n  \n  // Draw paused state\n  function drawPausedState() {\n    if (!ctx) return;\n    \n    // Draw semi-transparent overlay\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw paused text\n    ctx.fillStyle = 'white';\n    ctx.font = '24px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);\n    ctx.font = '16px Arial';\n    ctx.fillText('Click to resume', canvas.width / 2, canvas.height / 2 + 30);\n    \n    // Reset text alignment\n    ctx.textAlign = 'left';\n  }\n  \n  // Draw instructions\n  function drawInstructions() {\n    if (!ctx) return;\n    \n    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    ctx.fillStyle = 'white';\n    ctx.font = '24px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('Pointer Lock Demo', canvas.width / 2, canvas.height / 2 - 50);\n    ctx.font = '16px Arial';\n    ctx.fillText('Click to start', canvas.width / 2, canvas.height / 2);\n    ctx.fillText('Move your mouse to control the green circle', canvas.width / 2, canvas.height / 2 + 30);\n    ctx.fillText('Press ESC to exit pointer lock', canvas.width / 2, canvas.height / 2 + 60);\n    \n    // Reset text alignment\n    ctx.textAlign = 'left';\n  }\n</script>\n\n<svelte:document \n  bind:pointerLockElement={currentPointerLockElement}\n  onpointerlockchange={handlePointerLockChange}\n  onpointerlockerror={handlePointerLockError}\n  onmousemove={handleMouseMove}\n/>\n\n<div class=\"game-container\">\n  <h1>Pointer Lock Demo</h1>\n  \n  <div class=\"canvas-container\">\n    <canvas \n      bind:this={canvas} \n      on:click={isPointerLocked ? null : requestPointerLock}\n    ></canvas>\n    \n    {#if !canRequestPointerLock}\n      <div class=\"error-overlay\">\n        <p>Pointer Lock is not supported in your browser.</p>\n      </div>\n    {/if}\n  </div>\n  \n  <div class=\"controls\">\n    <div class=\"status\">\n      Pointer Lock: <span class={isPointerLocked ? 'locked' : 'unlocked'}>\n        {isPointerLocked ? 'LOCKED' : 'UNLOCKED'}\n      </span>\n    </div>\n    \n    {#if pointerLockError}\n      <div class=\"error\">\n        Error: {pointerLockError}\n      </div>\n    {/if}\n    \n    <div class=\"buttons\">\n      {#if isPointerLocked}\n        <button on:click={exitPointerLock}>Exit Pointer Lock</button>\n      {:else}\n        <button on:click={requestPointerLock} disabled={!canRequestPointerLock}>\n          Lock Pointer\n        </button>\n      {/if}\n    </div>\n    \n    <div class=\"info\">\n      <p>Mouse Delta: X: {mouseDeltaX.toFixed(2)}, Y: {mouseDeltaY.toFixed(2)}</p>\n      <p>Player Position: X: {playerX.toFixed(2)}, Y: {playerY.toFixed(2)}</p>\n      <p>Score: {Math.floor(score)}</p>\n    </div>\n    \n    <div class=\"instructions\">\n      <h3>Instructions:</h3>\n      <ol>\n        <li>Click the canvas to lock the pointer</li>\n        <li>Move your mouse to control the green circle</li>\n        <li>Press ESC or click the button below to exit pointer lock</li>\n      </ol>\n    </div>\n  </div>\n</div>\n\n<style>\n  .game-container {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 20px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n  }\n  \n  h1 {\n    text-align: center;\n    color: #333;\n  }\n  \n  .canvas-container {\n    position: relative;\n    width: 500px;\n    height: 500px;\n    margin: 0 auto;\n    border: 2px solid #333;\n    border-radius: 4px;\n    overflow: hidden;\n  }\n  \n  canvas {\n    display: block;\n    background-color: #f0f0f0;\n    cursor: pointer;\n  }\n  \n  .error-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: white;\n    text-align: center;\n    padding: 20px;\n  }\n  \n  .controls {\n    margin-top: 20px;\n    padding: 15px;\n    background-color: #f9f9f9;\n    border-radius: 4px;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n  }\n  \n  .status {\n    text-align: center;\n    font-size: 18px;\n    font-weight: bold;\n    margin-bottom: 15px;\n  }\n  \n  .locked {\n    color: #4CAF50;\n  }\n  \n  .unlocked {\n    color: #F44336;\n  }\n  \n  .error {\n    color: #F44336;\n    background-color: #FFEBEE;\n    padding: 10px;\n    border-radius: 4px;\n    margin-bottom: 15px;\n  }\n  \n  .buttons {\n    text-align: center;\n    margin-bottom: 15px;\n  }\n  \n  button {\n    background-color: #2196F3;\n    color: white;\n    border: none;\n    padding: 10px 20px;\n    border-radius: 4px;\n    font-size: 16px;\n    cursor: pointer;\n    transition: background-color 0.3s;\n  }\n  \n  button:hover {\n    background-color: #0b7dda;\n  }\n  \n  button:disabled {\n    background-color: #cccccc;\n    cursor: not-allowed;\n  }\n  \n  .info {\n    background-color: #E3F2FD;\n    padding: 10px;\n    border-radius: 4px;\n    margin-bottom: 15px;\n  }\n  \n  .info p {\n    margin: 5px 0;\n  }\n  \n  .instructions {\n    background-color: #FFFDE7;\n    padding: 10px;\n    border-radius: 4px;\n  }\n  \n  .instructions h3 {\n    margin-top: 0;\n    color: #333;\n  }\n  \n  .instructions ol {\n    padding-left: 20px;\n  }\n  \n  .instructions li {\n    margin-bottom: 5px;\n  }\n</style>\n```\n\nThis implementation demonstrates several important aspects of using the pointer lock API with Svelte:\n\n1. **Pointer Lock Element Binding**: We use `bind:pointerLockElement={currentPointerLockElement}` to track which element (if any) has the pointer locked. This is a readonly binding that Svelte will update automatically.\n\n2. **Event Handling**: We listen for `pointerlockchange` and `pointerlockerror` events to handle state changes and errors.\n\n3. **Mouse Movement**: When the pointer is locked, we use the `mousemove` event with `event.movementX` and `event.movementY` to track relative mouse movement.\n\n4. **Browser Compatibility**: The implementation includes checks for different browser prefixes and fallbacks.\n\n5. **Game Mechanics**: We implement a simple game where the player controls a circle with mouse movements, demonstrating a practical use case for pointer lock.\n\n6. **UI Feedback**: We provide clear visual feedback about the pointer lock state and instructions for the user.\n\n7. **Error Handling**: We catch and display any errors that might occur when requesting pointer lock.\n\nKey benefits of using `<svelte:document>` for this feature:\n\n1. **Centralized Event Handling**: All document-level events are handled in one place.\n\n2. **Automatic Cleanup**: Svelte automatically removes event listeners when the component is destroyed.\n\n3. **Reactivity**: The `isPointerLocked` state is derived reactively from the `currentPointerLockElement` binding, making it easy to update the UI based on the pointer lock state.\n\n4. **Clean Code**: The implementation is more readable and maintainable than manually adding and removing event listeners.\n\nThis implementation provides a solid foundation for building canvas-based games or applications that require pointer lock functionality in Svelte."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"What are the limitations of the `<svelte:document>` element compared to directly accessing the `document` object, and when might you choose one approach over the other?","answer":"The `<svelte:document>` element provides a declarative way to interact with the global `document` object in Svelte, but it does have some limitations compared to directly accessing the `document` object. Understanding these limitations helps in deciding which approach to use in different scenarios.\n\n### Limitations of `<svelte:document>`\n\n1. **Limited Property Bindings**: You can only bind to a predefined set of properties:\n   - `activeElement`\n   - `fullscreenElement`\n   - `pointerLockElement`\n   - `visibilityState`\n\n2. **Readonly Bindings**: All bindings are readonly, meaning you can only read values from the document, not set them.\n\n3. **Placement Restrictions**: The element can only be used at the top level of a component and cannot be placed inside blocks or other elements.\n\n4. **Event Handling Limitations**: While you can handle document events, you don't have as much control over event options (like `capture`, `once`, or `passive`) as you would with the direct `addEventListener` method.\n\n5. **No Direct Method Access**: You can't directly call document methods like `document.querySelector()` or `document.createElement()` through the `<svelte:document>` element.\n\n### Direct `document` Access Advantages\n\nUsing the `document` object directly:\n\n```svelte\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  let isVisible = true;\n  \n  function handleVisibilityChange() {\n    isVisible = document.visibilityState === 'visible';\n  }\n  \n  onMount(() => {\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n  });\n  \n  onDestroy(() => {\n    document.removeEventListener('visibilitychange', handleVisibilityChange);\n  });\n</script>\n```\n\nThis approach offers:\n\n1. **Full API Access**: Access to all document properties, methods, and events.\n2. **Event Options**: More control over event listener options.\n3. **Dynamic Listeners**: Add and remove listeners conditionally.\n4. **No Placement Restrictions**: Use anywhere in your component logic.\n\n### When to Use `<svelte:document>`\n\nUse `<svelte:document>` when:\n\n1. **Simple Event Handling**: You need to listen for document events in a declarative way.\n\n```svelte\n<svelte:document onvisibilitychange={handleVisibilityChange} />\n```\n\n2. **Tracking Document Properties**: You want to reactively track one of the supported document properties.\n\n```svelte\n<script>\n  let currentActiveElement;\n  $: if (currentActiveElement) {\n    console.log('Active element changed:', currentActiveElement.tagName);\n  }\n</script>\n\n<svelte:document bind:activeElement={currentActiveElement} />\n```\n\n3. **Using Actions on Document**: You want to apply Svelte actions to the document.\n\n```svelte\n<script>\n  function documentLogger(node) {\n    console.log('Action applied to document');\n    \n    return {\n      destroy() {\n        console.log('Cleaning up document action');\n      }\n    };\n  }\n</script>\n\n<svelte:document use:documentLogger />\n```\n\n4. **Clean Component API**: You want a clean, declarative API that automatically handles setup and teardown.\n\n### When to Use Direct `document` Access\n\nUse direct `document` access when:\n\n1. **Complex Conditional Logic**: You need to add/remove listeners based on complex conditions.\n\n```svelte\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  let shouldListen = false;\n  let cleanup = null;\n  \n  $: {\n    if (shouldListen && !cleanup) {\n      document.addEventListener('visibilitychange', handleVisibilityChange);\n      cleanup = () => {\n        document.removeEventListener('visibilitychange', handleVisibilityChange);\n      };\n    } else if (!shouldListen && cleanup) {\n      cleanup();\n      cleanup = null;\n    }\n  }\n  \n  onDestroy(() => {\n    if (cleanup) cleanup();\n  });\n</script>\n```\n\n2. **Advanced Event Options**: You need to specify event listener options.\n\n```svelte\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  onMount(() => {\n    document.addEventListener('click', handleCapturingClick, { capture: true });\n    document.addEventListener('touchstart', handleTouch, { passive: true });\n    \n    return () => {\n      document.removeEventListener('click', handleCapturingClick, { capture: true });\n      document.removeEventListener('touchstart', handleTouch, { passive: true });\n    };\n  });\n</script>\n```\n\n3. **Using Document Methods**: You need to call document methods.\n\n```svelte\n<script>\n  function findElements() {\n    const elements = document.querySelectorAll('.my-class');\n    // Process elements...\n  }\n  \n  function createAndAppend() {\n    const newElement = document.createElement('div');\n    newElement.textContent = 'Dynamically created';\n    document.body.appendChild(newElement);\n  }\n</script>\n```\n\n4. **Working with Unsupported Properties**: You need to access or monitor document properties not supported by `<svelte:document>`.\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let docTitle = document.title;\n  \n  onMount(() => {\n    // Set up a MutationObserver to watch for title changes\n    const observer = new MutationObserver(() => {\n      docTitle = document.title;\n    });\n    \n    observer.observe(document.querySelector('title'), { \n      subtree: true, \n      characterData: true, \n      childList: true \n    });\n    \n    return () => observer.disconnect();\n  });\n</script>\n```\n\n### Practical Example Combining Both Approaches\n\nSometimes, the best solution is to combine both approaches:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let visibilityState;\n  let documentHasFocus = document.hasFocus();\n  let customEventCount = 0;\n  \n  // Use direct document access for things not supported by <svelte:document>\n  onMount(() => {\n    // Check focus periodically\n    const focusInterval = setInterval(() => {\n      documentHasFocus = document.hasFocus();\n    }, 1000);\n    \n    // Listen for custom events\n    const handleCustomEvent = () => {\n      customEventCount++;\n    };\n    \n    document.addEventListener('my-custom-event', handleCustomEvent);\n    \n    // Create a custom method on document for demo purposes\n    document.triggerCustomEvent = () => {\n      document.dispatchEvent(new CustomEvent('my-custom-event'));\n    };\n    \n    return () => {\n      clearInterval(focusInterval);\n      document.removeEventListener('my-custom-event', handleCustomEvent);\n      delete document.triggerCustomEvent;\n    };\n  });\n  \n  function handleVisibilityChange() {\n    console.log('Visibility changed to:', visibilityState);\n    // Additional handling...\n  }\n</script>\n\n<!-- Use <svelte:document> for the supported features -->\n<svelte:document \n  bind:visibilityState\n  onvisibilitychange={handleVisibilityChange}\n/>\n\n<div>\n  <h2>Document State</h2>\n  <p>Visibility: {visibilityState}</p>\n  <p>Has focus: {documentHasFocus ? 'Yes' : 'No'}</p>\n  <p>Custom events received: {customEventCount}</p>\n  \n  <button on:click={() => document.triggerCustomEvent()}>\n    Trigger Custom Event\n  </button>\n</div>\n```\n\nIn conclusion, `<svelte:document>` provides a clean, declarative way to interact with the document when your needs align with its capabilities. For more complex scenarios or when you need access to features not supported by `<svelte:document>`, direct document access is the way to go. Often, a combination of both approaches provides the best solution."}
{"source":"docs/svelte/05-special-elements/03-svelte-document.md","question":"How can you use the `visibilityState` binding with `<svelte:document>` to optimize resource usage in a web application, and what are some practical examples of this optimization?","answer":"The `visibilityState` binding with `<svelte:document>` provides a powerful way to optimize resource usage in web applications by allowing you to react to changes in document visibility. When a user switches tabs, minimizes the browser, or navigates away from your page, the `visibilityState` changes to \"hidden\", giving you an opportunity to pause or reduce resource-intensive operations.\n\nHere's a comprehensive look at how to implement this optimization with practical examples:\n\n### Basic Implementation\n\n```svelte\n<script>\n  let visibilityState = 'visible';\n  let isVisible = true;\n  \n  $: isVisible = visibilityState === 'visible';\n  \n  function handleVisibilityChange() {\n    console.log('Document visibility changed to:', visibilityState);\n    \n    if (isVisible) {\n      resumeOperations();\n    } else {\n      pauseOperations();\n    }\n  }\n  \n  function pauseOperations() {\n    console.log('Pausing resource-intensive operations');\n    // Implementation details below\n  }\n  \n  function resumeOperations() {\n    console.log('Resuming operations');\n    // Implementation details below\n  }\n</script>\n\n<svelte:document \n  bind:visibilityState\n  onvisibilitychange={handleVisibilityChange}\n/>\n```\n\n### Practical Examples of Resource Optimization\n\n#### 1. Pausing Animation Loops\n\nAnimation loops using `requestAnimationFrame` can consume significant CPU resources. Pausing them when the document is hidden can save battery life and CPU cycles:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let visibilityState;\n  let isVisible = true;\n  let animationFrameId = null;\n  let canvas;\n  let ctx;\n  let particleSystem = [];\n  let fps = 0;\n  let frameCount = 0;\n  let lastFpsUpdate = 0;\n  \n  $: isVisible = visibilityState === 'visible';\n  \n  onMount(() => {\n    if (canvas) {\n      ctx = canvas.getContext('2d');\n      canvas.width = 400;\n      canvas.height = 300;\n      \n      // Initialize particle system\n      for (let i = 0; i < 100; i++) {\n        particleSystem.push({\n          x: Math.random() * canvas.width,\n          y: Math.random() * canvas.height,\n          vx: (Math.random() - 0.5) * 2,\n          vy: (Math.random() - 0.5) * 2,\n          size: Math.random() * 5 + 2,\n          color: `hsl(${Math.random() * 360}, 70%, 60%)`\n        });\n      }\n      \n      // Start animation if document is visible\n      if (isVisible) {\n        startAnimation();\n      }\n    }\n    \n    return () => {\n      if (animationFrameId) {\n        cancelAnimationFrame(animationFrameId);\n      }\n    };\n  });\n  \n  function handleVisibilityChange() {\n    if (isVisible) {\n      startAnimation();\n    } else {\n      stopAnimation();\n    }\n  }\n  \n  function startAnimation() {\n    if (!animationFrameId) {\n      console.log('Starting animation loop');\n      lastFpsUpdate = performance.now();\n      frameCount = 0;\n      animationLoop();\n    }\n  }\n  \n  function stopAnimation() {\n    if (animationFrameId) {\n      console.log('Stopping animation loop');\n      cancelAnimationFrame(animationFrameId);\n      animationFrameId = null;\n    }\n  }\n  \n  function animationLoop(timestamp) {\n    // Calculate FPS\n    frameCount++;\n    if (timestamp - lastFpsUpdate >= 1000) {\n      fps = Math.round((frameCount * 1000) / (timestamp - lastFpsUpdate));\n      frameCount = 0;\n      lastFpsUpdate = timestamp;\n    }\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Update and draw particles\n    ctx.globalAlpha = 0.7;\n    particleSystem.forEach(particle => {\n      // Update position\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n      \n      // Bounce off walls\n      if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;\n      if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;\n      \n      // Draw particle\n      ctx.fillStyle = particle.color;\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, particle."}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"What is the `<svelte:body>` element in Svelte, and how does it differ from using event listeners on the `<svelte:window>` element?","answer":"The `<svelte:body>` element in Svelte is a special element that allows you to add event listeners and actions directly to the `document.body` element. \n\nIt differs from `<svelte:window>` in that it targets the `body` element specifically, allowing you to listen for events that don't bubble up to the window object. Some events like `mouseenter` and `mouseleave` only fire on DOM elements (including the body) but not on the window object.\n\nHere's an example of how to use `<svelte:body>`:\n\n```svelte\n<script>\n  function handleMouseenter() {\n    console.log('Mouse entered the body');\n  }\n  \n  function handleMouseleave() {\n    console.log('Mouse left the body');\n  }\n  \n  function fadeBodyAction(node) {\n    // Example action that could fade the body in/out\n    return {\n      destroy() {\n        // Cleanup when component is destroyed\n      }\n    };\n  }\n</script>\n\n<svelte:body \n  onmouseenter={handleMouseenter} \n  onmouseleave={handleMouseleave}\n  use:fadeBodyAction\n/>\n\n<main>\n  <!-- Your component content -->\n</main>\n```\n\nThis allows you to react to mouse movements in and out of the viewport, which wouldn't be possible with just `<svelte:window>`."}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"What are the placement restrictions for the `<svelte:body>` element in a Svelte component, and why do these restrictions exist?","answer":"The `<svelte:body>` element has specific placement restrictions in a Svelte component:\n\n1. It must only appear at the top level of your component\n2. It must never be inside a block (like `{#if}`, `{#each}`, etc.) or inside another element\n\nFor example, this is valid:\n\n```svelte\n<script>\n  function handleMouseenter() {\n    console.log('Mouse entered the body');\n  }\n</script>\n\n<svelte:body onmouseenter={handleMouseenter} />\n\n<div>Component content</div>\n```\n\nBut these are invalid:\n\n```svelte\n<!-- Invalid: inside a block -->\n{#if condition}\n  <svelte:body onmouseenter={handleMouseenter} />\n{/if}\n\n<!-- Invalid: inside another element -->\n<div>\n  <svelte:body onmouseenter={handleMouseenter} />\n</div>\n```\n\nThese restrictions exist because `<svelte:body>` is not meant to represent an actual DOM element in your component's hierarchy. Instead, it's a declarative way to attach listeners to the existing `document.body` element. Since there's only one body element in a document, it wouldn't make sense to conditionally attach these listeners or to try to place the body element inside another element.\n\nThe compiler enforces these restrictions to prevent logical errors and to maintain a clear separation between your component's DOM structure and these special global element bindings."}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"How can you use actions with the `<svelte:body>` element, and what are some practical use cases for this feature?","answer":"You can use actions with the `<svelte:body>` element by applying the `use:` directive, just as you would with any other DOM element in Svelte. This is a powerful feature that allows you to encapsulate and reuse DOM manipulation logic that needs to target the body element.\n\nHere's how to apply an action to `<svelte:body>`:\n\n```svelte\n<script>\n  function bodyScrollLock(node, enabled = true) {\n    const originalStyle = window.getComputedStyle(node).overflow;\n    \n    function setLocked(isLocked) {\n      node.style.overflow = isLocked ? 'hidden' : originalStyle;\n    }\n    \n    // Set initial state\n    setLocked(enabled);\n    \n    return {\n      update(newEnabled) {\n        setLocked(newEnabled);\n      },\n      destroy() {\n        setLocked(false);\n      }\n    };\n  }\n  \n  let isModalOpen = false;\n</script>\n\n<svelte:body use:bodyScrollLock={isModalOpen} />\n\n<button on:click={() => isModalOpen = !isModalOpen}>\n  {isModalOpen ? 'Close' : 'Open'} Modal\n</button>\n\n{#if isModalOpen}\n  <div class=\"modal\">\n    <!-- Modal content -->\n    <p>This is a modal. The body scrolling is now disabled.</p>\n  </div>\n{/if}\n```\n\nSome practical use cases for using actions with `<svelte:body>` include:\n\n1. **Scroll locking**: As shown above, preventing body scrolling when modals or drawers are open\n2. **Theme management**: Applying dark/light mode classes to the body\n3. **Touch gesture handling**: Adding touch event listeners for mobile-specific interactions\n4. **Global keyboard shortcuts**: Implementing app-wide keyboard navigation\n5. **Body class management**: Adding/removing classes based on application state\n6. **Analytics tracking**: Monitoring user engagement with the page\n\nFor example, here's a more complex theme manager action:\n\n```svelte\n<script>\n  function themeManager(node, { theme = 'light', saveToLocalStorage = true } = {}) {\n    // Load theme from localStorage if available\n    if (saveToLocalStorage) {\n      const savedTheme = localStorage.getItem('theme');\n      if (savedTheme) theme = savedTheme;\n    }\n    \n    function applyTheme(newTheme) {\n      // Remove all theme classes\n      node.classList.remove('theme-light', 'theme-dark', 'theme-custom');\n      // Add the new theme class\n      node.classList.add(`theme-${newTheme}`);\n      // Save to localStorage if enabled\n      if (saveToLocalStorage) {\n        localStorage.setItem('theme', newTheme);\n      }\n    }\n    \n    // Apply initial theme\n    applyTheme(theme);\n    \n    return {\n      update({ theme: newTheme }) {\n        applyTheme(newTheme);\n      }\n    };\n  }\n  \n  let currentTheme = 'light';\n</script>\n\n<svelte:body use:themeManager={{ theme: currentTheme }} />\n\n<div class=\"theme-controls\">\n  <button on:click={() => currentTheme = 'light'}>Light Theme</button>\n  <button on:click={() => currentTheme = 'dark'}>Dark Theme</button>\n</div>\n```"}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"Can you use multiple event listeners on the `<svelte:body>` element? If so, provide an example of a component that tracks both mouse position and touch events on the body.","answer":"Yes, you can use multiple event listeners on the `<svelte:body>` element. This is useful for tracking various interactions with the document body simultaneously.\n\nHere's an example of a component that tracks both mouse position and touch events on the body:\n\n```svelte\n<script>\n  // Track mouse position\n  let mouseX = 0;\n  let mouseY = 0;\n  \n  // Track touch information\n  let touchActive = false;\n  let touchCount = 0;\n  let lastTouchX = 0;\n  let lastTouchY = 0;\n  \n  // Mouse event handlers\n  function handleMousemove(event) {\n    mouseX = event.clientX;\n    mouseY = event.clientY;\n  }\n  \n  // Touch event handlers\n  function handleTouchstart(event) {\n    touchActive = true;\n    touchCount = event.touches.length;\n    \n    if (touchCount > 0) {\n      const touch = event.touches[0];\n      lastTouchX = touch.clientX;\n      lastTouchY = touch.clientY;\n    }\n  }\n  \n  function handleTouchmove(event) {\n    if (touchCount > 0) {\n      const touch = event.touches[0];\n      lastTouchX = touch.clientX;\n      lastTouchY = touch.clientY;\n    }\n  }\n  \n  function handleTouchend(event) {\n    touchCount = event.touches.length;\n    if (touchCount === 0) {\n      touchActive = false;\n    }\n  }\n</script>\n\n<svelte:body \n  onmousemove={handleMousemove}\n  ontouchstart={handleTouchstart}\n  ontouchmove={handleTouchmove}\n  ontouchend={handleTouchend}\n/>\n\n<div class=\"tracker-display\">\n  <div class=\"mouse-position\">\n    <h2>Mouse Position</h2>\n    <p>X: {mouseX}, Y: {mouseY}</p>\n  </div>\n  \n  <div class=\"touch-info\">\n    <h2>Touch Information</h2>\n    <p>Active: {touchActive ? 'Yes' : 'No'}</p>\n    <p>Number of touches: {touchCount}</p>\n    {#if touchActive}\n      <p>Last touch position: X: {lastTouchX}, Y: {lastTouchY}</p>\n    {/if}\n  </div>\n</div>\n\n<style>\n  .tracker-display {\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    background: rgba(0, 0, 0, 0.7);\n    color: white;\n    padding: 15px;\n    border-radius: 8px;\n    font-family: monospace;\n  }\n</style>\n```\n\nThis component:\n1. Tracks mouse position using the `mousemove` event\n2. Monitors touch interactions using `touchstart`, `touchmove`, and `touchend` events\n3. Displays the current state of both input types\n4. Works on both desktop and mobile devices\n\nYou can add as many event listeners as needed to the `<svelte:body>` element, making it a powerful tool for global interaction tracking."}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"How does event handling on `<svelte:body>` work with event modifiers in Svelte? Provide examples of using event modifiers like `preventDefault` and `once` with body events.","answer":"In Svelte, event handling on `<svelte:body>` supports the same event modifiers that are available for regular DOM elements. These modifiers provide a convenient way to control event behavior without having to manually handle it in your event functions.\n\nThe syntax for using event modifiers with `<svelte:body>` follows the standard Svelte pattern:\n\n```svelte\n<svelte:body on:event|modifier={handler} />\n```\n\nHere are the available event modifiers in Svelte:\n\n- `preventDefault` - calls `event.preventDefault()` before running the handler\n- `stopPropagation` - calls `event.stopPropagation()`, preventing the event from bubbling up\n- `passive` - improves scrolling performance with touch/wheel events (Svelte will add it automatically where safe)\n- `nonpassive` - explicitly sets `passive: false`\n- `capture` - fires the handler during the capture phase instead of the bubbling phase\n- `once` - removes the handler after the first time it runs\n- `self` - only trigger handler if event.target is the element itself\n- `trusted` - only trigger handler if event.isTrusted is true (i.e., if the event was triggered by a user action)\n\nHere's an example component demonstrating several event modifiers with `<svelte:body>`:\n\n```svelte\n<script>\n  let clickCount = 0;\n  let rightClickCount = 0;\n  let keyPressCount = 0;\n  let lastKey = '';\n  let touchStarted = false;\n  \n  function handleClick() {\n    clickCount++;\n  }\n  \n  function handleRightClick() {\n    rightClickCount++;\n    console.log('Right click handled and prevented default context menu');\n  }\n  \n  function handleKeydown(event) {\n    keyPressCount++;\n    lastKey = event.key;\n  }\n  \n  function handleOneTimeTouch() {\n    touchStarted = true;\n    console.log('Touch event handled once - further touches will not trigger this');\n  }\n  \n  function resetCounters() {\n    clickCount = 0;\n    rightClickCount = 0;\n    keyPressCount = 0;\n    lastKey = '';\n  }\n</script>\n\n<!-- Using event modifiers with svelte:body -->\n<svelte:body \n  on:click={handleClick}\n  on:contextmenu|preventDefault={handleRightClick}\n  on:keydown|passive={handleKeydown}\n  on:touchstart|once={handleOneTimeTouch}\n/>\n\n<div class=\"event-demo\">\n  <h1>Event Modifier Demo</h1>\n  \n  <div class=\"counters\">\n    <p>Body clicks: {clickCount}</p>\n    <p>Right clicks (prevented): {rightClickCount}</p>\n    <p>Key presses: {keyPressCount}</p>\n    <p>Last key pressed: {lastKey || 'None'}</p>\n    <p>One-time touch triggered: {touchStarted ? 'Yes' : 'No'}</p>\n  </div>\n  \n  <button on:click={resetCounters}>Reset Counters</button>\n  \n  <div class=\"instructions\">\n    <h2>Try these actions:</h2>\n    <ul>\n      <li>Click anywhere on the page to increment the click counter</li>\n      <li>Right-click anywhere (context menu will be prevented)</li>\n      <li>Press any key to see it recorded</li>\n      <li>On touch devices, touch the screen once to trigger the one-time event</li>\n    </ul>\n  </div>\n</div>\n\n<style>\n  .event-demo {\n    max-width: 600px;\n    margin: 0 auto;\n    padding: 20px;\n    font-family: sans-serif;\n  }\n  \n  .counters {\n    background: #f0f0f0;\n    padding: 15px;\n    border-radius: 5px;\n    margin: 20px 0;\n  }\n  \n  button {\n    padding: 10px 15px;\n    background: #0066cc;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  \n  .instructions {\n    margin-top: 30px;\n    padding: 15px;\n    background: #fffde7;\n    border-left: 4px solid #ffd600;\n  }\n</style>\n```\n\nIn this example:\n\n1. `on:contextmenu|preventDefault` prevents the default browser context menu from appearing when right-clicking\n2. `on:keydown|passive` improves performance by telling the browser that the handler won't call `preventDefault()`\n3. `on:touchstart|once` ensures the touch handler only runs the first time the user touches the screen\n\nThese modifiers help create more efficient and cleaner code by handling common event patterns declaratively rather than imperatively in your handler functions."}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"Can the `<svelte:body>` element be used in conjunction with other special elements like `<svelte:window>` and `<svelte:document>`? If so, provide an example of a component that uses multiple special elements to create a comprehensive event monitoring system.","answer":"Yes, the `<svelte:body>` element can be used in conjunction with other special elements like `<svelte:window>` and `<svelte:document>`. Each of these special elements targets a different part of the browser's object model, allowing you to create comprehensive event monitoring systems.\n\nHere's an example of a component that uses multiple special elements to monitor various events throughout the application:\n\n```svelte\n<script>\n  // State for tracking different events\n  let windowEvents = [];\n  let documentEvents = [];\n  let bodyEvents = [];\n  \n  // Maximum number of events to keep in history\n  const MAX_EVENTS = 10;\n  \n  // Helper to add event to history with timestamp\n  function addEvent(store, eventName, details = {}) {\n    const timestamp = new Date().toLocaleTimeString();\n    const newEvent = {\n      timestamp,\n      name: eventName,\n      details\n    };\n    \n    // Add to beginning of array and limit size\n    store.unshift(newEvent);\n    if (store.length > MAX_EVENTS) {\n      store.pop();\n    }\n    \n    // Trigger reactivity\n    windowEvents = windowEvents;\n    documentEvents = documentEvents;\n    bodyEvents = bodyEvents;\n  }\n  \n  // Window event handlers\n  function handleResize(event) {\n    addEvent(windowEvents, 'resize', {\n      width: window.innerWidth,\n      height: window.innerHeight\n    });\n  }\n  \n  function handleScroll(event) {\n    addEvent(windowEvents, 'scroll', {\n      scrollX: window.scrollX,\n      scrollY: window.scrollY\n    });\n  }\n  \n  function handleOnline(event) {\n    addEvent(windowEvents, 'online');\n  }\n  \n  function handleOffline(event) {\n    addEvent(windowEvents, 'offline');\n  }\n  \n  // Document event handlers\n  function handleVisibilityChange(event) {\n    addEvent(documentEvents, 'visibilitychange', {\n      hidden: document.hidden,\n      visibilityState: document.visibilityState\n    });\n  }\n  \n  function handleSelectionChange(event) {\n    const selection = document.getSelection();\n    addEvent(documentEvents, 'selectionchange', {\n      text: selection ? selection.toString() : ''\n    });\n  }\n  \n  function handleClick(event) {\n    addEvent(documentEvents, 'click', {\n      target: event.target.tagName,\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  \n  // Body event handlers\n  function handleMouseEnter(event) {\n    addEvent(bodyEvents, 'mouseenter');\n  }\n  \n  function handleMouseLeave(event) {\n    addEvent(bodyEvents, 'mouseleave');\n  }\n  \n  function handleTouchStart(event) {\n    addEvent(bodyEvents, 'touchstart', {\n      touches: event.touches.length\n    });\n  }\n  \n  // Clear all logs\n  function clearLogs() {\n    windowEvents = [];\n    documentEvents = [];\n    bodyEvents = [];\n  }\n</script>\n\n<!-- Special elements for global event monitoring -->\n<svelte:window \n  on:resize={handleResize}\n  on:scroll={handleScroll}\n  on:online={handleOnline}\n  on:offline={handleOffline}\n/>\n\n<svelte:document\n  on:visibilitychange={handleVisibilityChange}\n  on:selectionchange={handleSelectionChange}\n  on:click={handleClick}\n/>\n\n<svelte:body\n  on:mouseenter={handleMouseEnter}\n  on:mouseleave={handleMouseLeave}\n  on:touchstart={handleTouchStart}\n/>\n\n<div class=\"event-monitor\">\n  <h1>Global Event Monitor</h1>\n  <button on:click={clearLogs}>Clear All Logs</button>\n  \n  <div class=\"event-panels\">\n    <div class=\"event-panel\">\n      <h2>Window Events</h2>\n      {#if windowEvents.length === 0}\n        <p class=\"empty-state\">No window events recorded yet</p>\n      {:else}\n        <ul>\n          {#each windowEvents as event}\n            <li>\n              <span class=\"timestamp\">{event.timestamp}</span>\n              <span class=\"event-name\">{event.name}</span>\n              <span class=\"event-details\">{JSON.stringify(event.details)}</span>\n            </li>\n          {/each}\n        </ul>\n      {/if}\n    </div>\n    \n    <div class=\"event-panel\">\n      <h2>Document Events</h2>\n      {#if documentEvents.length === 0}\n        <p class=\"empty-state\">No document events recorded yet</p>\n      {:else}\n        <ul>\n          {#each documentEvents as event}\n            <li>\n              <span class=\"timestamp\">{event.timestamp}</span>\n              <span class=\"event-name\">{event.name}</span>\n              <span class=\"event-details\">{JSON.stringify(event.details)}</span>\n            </li>\n          {/each}\n        </ul>\n      {/if}\n    </div>\n    \n    <div class=\"event-panel\">\n      <h2>Body Events</h2>\n      {#if bodyEvents.length === 0}\n        <p class=\"empty-state\">No body events recorded yet</p>\n      {:else}\n        <ul>\n          {#each bodyEvents as event}\n            <li>\n              <span class=\"timestamp\">{event.timestamp}</span>\n              <span class=\"event-name\">{event.name}</span>\n              <span class=\"event-details\">{JSON.stringify(event.details)}</span>\n            </li>\n          {/each}\n        </ul>\n      {/if}\n    </div>\n  </div>\n</div>\n\n<style>\n  .event-monitor {\n    font-family: system-ui, sans-serif;\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 20px;\n  }\n  \n  button {\n    background: #4a5568;\n    color: white;\n    border: none;\n    padding: 8px 16px;\n    border-radius: 4px;\n    margin-bottom: 20px;\n    cursor: pointer;\n  }\n  \n  .event-panels {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 20px;\n  }\n  \n  .event-panel {\n    background: #f7fafc;\n    border-radius: 8px;\n    padding: 16px;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.12);\n  }\n  \n  h2 {\n    margin-top: 0;\n    font-size: 1.2rem;\n    color: #2d3748;\n    border-bottom: 1px solid #e2e8f0;\n    padding-bottom: 8px;\n  }\n  \n  ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n  }\n  \n  li {\n    padding: 8px 0;\n    border-bottom: 1px solid #edf2f7;\n    font-size: 0.9rem;\n  }\n  \n  .timestamp {\n    color: #718096;\n    display: block;\n  }\n  \n  .event-name {\n    font-weight: bold;\n    color: #4299e1;\n    margin-right: 8px;\n  }\n  \n  .event-details {\n    color: #4a5568;\n    font-family: monospace;\n    font-size: 0.8rem;\n  }\n  \n  .empty-state {\n    color: #a0aec0;\n    font-style: italic;\n  }\n</style>\n```\n\nThis component demonstrates:\n\n1. Using `<svelte:window>` to monitor global window events like resizing, scrolling, and online/offline status\n2. Using `<svelte:document>` to track document-level events like visibility changes and selection changes\n3. Using `<svelte:body>` to detect when the mouse enters or leaves the page and touch interactions\n\nEach special element serves a distinct purpose:\n- `<svelte:window>` is for window-specific events and properties\n- `<svelte:document>` is for document-level events that don't bubble up to window\n- `<svelte:body>` is for events specific to the body element, like mouseenter/mouseleave\n\nBy combining these special elements, you can create a comprehensive monitoring system that tracks user interactions at various levels of the DOM hierarchy."}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"How can you dynamically add or remove event listeners on the `<svelte:body>` element based on component state? Provide an example of conditionally attaching body event listeners.","answer":"In Svelte, you can dynamically add or remove event listeners on the `<svelte:body>` element based on component state in two main ways:\n\n1. Using conditional event handler assignment\n2. Using reactive statements to add/remove listeners programmatically\n\nHere's an example using the first approach - conditional event handler assignment:\n\n```svelte\n<script>\n  // State to control whether listeners are active\n  let trackMouse = false;\n  let trackTouch = false;\n  \n  // State to store tracking data\n  let mouseX = 0;\n  let mouseY = 0;\n  let touchX = 0;\n  let touchY = 0;\n  \n  // Event handlers\n  function handleMousemove(event) {\n    mouseX = event.clientX;\n    mouseY = event.clientY;\n  }\n  \n  function handleTouchmove(event) {\n    if (event.touches.length > 0) {\n      touchX = event.touches[0].clientX;\n      touchY = event.touches[0].clientY;\n    }\n  }\n  \n  // Toggle tracking functions\n  function toggleMouseTracking() {\n    trackMouse = !trackMouse;\n  }\n  \n  function toggleTouchTracking() {\n    trackTouch = !trackTouch;\n  }\n</script>\n\n<!-- Conditionally assign handlers based on state -->\n<svelte:body \n  on:mousemove={trackMouse ? handleMousemove : null}\n  on:touchmove={trackTouch ? handleTouchmove : null}\n/>\n\n<div class=\"tracking-control\">\n  <h1>Dynamic Event Listener Demo</h1>\n  \n  <div class=\"controls\">\n    <div class=\"control-section\">\n      <h2>Mouse Tracking</h2>\n      <button on:click={toggleMouseTracking}>\n        {trackMouse ? 'Disable' : 'Enable'} Mouse Tracking\n      </button>\n      \n      {#if trackMouse}\n        <div class=\"tracking-data\">\n          <p>Mouse position: X: {mouseX}, Y: {mouseY}</p>\n        </div>\n      {:else}\n        <p class=\"inactive\">Mouse tracking inactive</p>\n      {/if}\n    </div>\n    \n    <div class=\"control-section\">\n      <h2>Touch Tracking</h2>\n      <button on:click={toggleTouchTracking}>\n        {trackTouch ? 'Disable' : 'Enable'} Touch Tracking\n      </button>\n      \n      {#if trackTouch}\n        <div class=\"tracking-data\">\n          <p>Touch position: X: {touchX}, Y: {touchY}</p>\n        </div>\n      {:else}\n        <p class=\"inactive\">Touch tracking inactive</p>\n      {/if}\n    </div>\n  </div>\n  \n  <div class=\"performance-note\">\n    <h3>Performance Note:</h3>\n    <p>When disabled, the event listeners are effectively removed, improving performance.</p>\n  </div>\n</div>\n\n<style>\n  .tracking-control {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 20px;\n    font-family: system-ui, sans-serif;\n  }\n  \n  .controls {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 20px;\n    margin: 20px 0;\n  }\n  \n  .control-section {\n    background: #f8f9fa;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  }\n  \n  button {\n    background: #4361ee;\n    color: white;\n    border: none;\n    padding: 10px 15px;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    transition: background 0.2s;\n  }\n  \n  button:hover {\n    background: #3a56d4;\n  }\n  \n  .tracking-data {\n    background: #e6f7ff;\n    padding: 15px;\n    border-radius: 4px;\n    margin-top: 15px;\n    border-left: 4px solid #1890ff;\n  }\n  \n  .inactive {\n    color: #8c8c8c;\n    font-style: italic;\n  }\n  \n  .performance-note {\n    background: #fff7e6;\n    padding: 15px;\n    border-radius: 4px;\n    margin-top: 30px;\n    border-left: 4px solid #ffa940;\n  }\n  \n  h3 {\n    margin-top: 0;\n  }\n</style>\n```\n\nIn this example:\n\n1. We use two boolean state variables (`trackMouse` and `trackTouch`) to control whether event listeners are active\n2. We conditionally assign the event handlers using the ternary operator: `on:mousemove={trackMouse ? handleMousemove : null}`\n3. When the handler is `null`, Svelte effectively removes the event listener from the body element\n4. Toggle buttons allow the user to enable/disable each type of tracking independently\n\nThis approach is clean and declarative, making it easy to understand when listeners are active.\n\nFor more complex scenarios where you need to add multiple listeners dynamically or use more complex logic, you could use the second approach with reactive statements:\n\n```svelte\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  \n  let trackingMode = 'none'; // 'none', 'mouse', 'touch', or 'both'\n  \n  // State to store tracking data\n  let positionX = 0;\n  let positionY = 0;\n  \n  // Event handlers\n  function handleMousemove(event) {\n    positionX = event.clientX;\n    positionY = event.clientY;\n  }\n  \n  function handleTouchmove(event) {\n    if (event.touches.length > 0) {\n      positionX = event.touches[0].clientX;\n      positionY = event.touches[0].clientY;\n    }\n  }\n  \n  // Use reactive statement to update event listeners when trackingMode changes\n  $: {\n    // Clean up existing listeners first\n    if (typeof document !== 'undefined') {\n      document.body.removeEventListener('mousemove', handleMousemove);\n      document.body.removeEventListener('touchmove', handleTouchmove);\n      \n      // Add listeners based on current tracking mode\n      if (trackingMode === 'mouse' || trackingMode === 'both') {\n        document.body.addEventListener('mousemove', handleMousemove);\n      }\n      \n      if (trackingMode === 'touch' || trackingMode === 'both') {\n        document.body.addEventListener('touchmove', handleTouchmove);\n      }\n    }\n  }\n  \n  // Clean up on component destruction\n  onDestroy(() => {\n    if (typeof document !== 'undefined') {\n      document.body.removeEventListener('mousemove', handleMousemove);\n      document.body.removeEventListener('touchmove', handleTouchmove);\n    }\n  });\n</script>\n\n<!-- No svelte:body element needed here since we're managing listeners manually -->\n\n<div class=\"tracking-control\">\n  <h1>Advanced Dynamic Event Listeners</h1>\n  \n  <div class=\"mode-selector\">\n    <label>\n      <input type=\"radio\" bind:group={trackingMode} value=\"none\">\n      No Tracking\n    </label>\n    \n    <label>\n      <input type=\"radio\" bind:group={trackingMode} value=\"mouse\">\n      Mouse Only\n    </label>\n    \n    <label>\n      <input type=\"radio\" bind:group={trackingMode} value=\"touch\">\n      Touch Only\n    </label>\n    \n    <label>\n      <input type=\"radio\" bind:group={trackingMode} value=\"both\">\n      Both Mouse and Touch\n    </label>\n  </div>\n  \n  <div class=\"tracking-display\">\n    <h2>Position: X: {positionX}, Y: {positionY}</h2>\n    <p>Current tracking mode: {trackingMode}</p>\n  </div>\n</div>\n```\n\nThis second approach gives you more programmatic control but is generally more verbose and requires manual cleanup. In most cases, the first approach using conditional assignment is preferred for its simplicity and because Svelte handles the listener lifecycle automatically."}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"What are the limitations of the `<svelte:body>` element compared to directly manipulating the document body in JavaScript? When would you choose one approach over the other?","answer":"The `<svelte:body>` element provides a declarative way to interact with the document body, but it has certain limitations compared to directly manipulating the body with JavaScript. Understanding these limitations helps determine when to use each approach.\n\n### Limitations of `<svelte:body>`\n\n1. **Limited to event listeners and actions**: `<svelte:body>` primarily allows you to add event listeners and actions to the body element. It doesn't provide direct access to manipulate body attributes, styles, or content.\n\n2. **Cannot add content to the body**: Unlike direct DOM manipulation, you cannot use `<svelte:body>` to add HTML content outside your component's mount point.\n\n3. **Placement restrictions**: `<svelte:body>` must be at the top level of your component and cannot be inside blocks or other elements, limiting dynamic usage.\n\n4. **Component lifecycle bound**: Event listeners added via `<svelte:body>` are automatically bound to the component's lifecycle - they're removed when the component is destroyed, which might not always be desired for truly global handlers.\n\n5. **Limited to one instance per component**: You can only have one `<svelte:body>` element per component, whereas with direct JavaScript you can organize multiple body manipulations however you want.\n\n### When to use `<svelte:body>`\n\n`<svelte:body>` is preferable when:\n\n1. **Adding simple event listeners**: When you just need to listen for events like `mouseenter`, `mouseleave`, etc.\n\n2. **Using Svelte actions on the body**: When you want to use Svelte's action system to encapsulate body-related functionality.\n\n3. **Keeping things declarative**: When you want your event handling to be visible in the component markup rather than hidden in JavaScript functions.\n\n4. **Automatic cleanup needed**: When you want listeners to be automatically cleaned up when the component is destroyed.\n\n### When to use direct JavaScript manipulation\n\nDirect manipulation is better when:\n\n1. **Complex body modifications**: When you need to add classes, modify styles, or change attributes on the body element.\n\n2. **Adding content outside component**: When you need to add modal containers, overlay elements, or other content directly to the body.\n\n3. **Truly global handlers**: When you need event listeners that persist beyond the component's lifecycle.\n\n4. **Dynamic manipulation with complex logic**: When the manipulation logic is too complex to express declaratively.\n\n### Comparison Example\n\nHere's a comparison showing both approaches for implementing a \"disable scroll\" feature when a modal is open:\n\n```svelte\n<script>\n  let isModalOpen = false;\n  \n  // Approach 1: Using <svelte:body> with an action\n  function preventScrollAction(node, enabled) {\n    if (!enabled) return {};\n    \n    const originalStyle = window.getComputedStyle(document.body).overflow;\n    \n    // Set body to prevent scrolling\n    document.body.style.overflow = 'hidden';\n    \n    return {\n      update(newEnabled) {\n        document.body.style.overflow = newEnabled ? 'hidden' : originalStyle;\n      },\n      destroy() {\n        document.body.style.overflow = originalStyle;\n      }\n    };\n  }\n  \n  // Approach 2: Direct JavaScript manipulation\n  $: {\n    if (typeof document !== 'undefined') {\n      if (isModalOpen) {\n        // Store original for restoration\n        if (!document.body.dataset.originalOverflow) {\n          document.body.dataset.originalOverflow = document.body.style.overflow || '';\n        }\n        document.body.style.overflow = 'hidden';\n      } else if (document.body.dataset.originalOverflow !== undefined) {\n        // Restore original overflow\n        document.body.style.overflow = document.body.dataset.originalOverflow;\n      }\n    }\n  }\n  \n  // Choose which approach to use\n  const useDirectManipulation = false;\n</script>\n\n{#if !useDirectManipulation}\n  <!-- Approach 1: Using svelte:body with an action -->\n  <svelte:body use:preventScrollAction={isModalOpen} />\n{/if}\n\n<button on:click={() => isModalOpen = !isModalOpen}>\n  {isModalOpen ? 'Close' : 'Open'} Modal\n</button>\n\n{#if isModalOpen}\n  <div class=\"modal\">\n    <div class=\"modal-content\">\n      <h2>Modal Content</h2>\n      <p>This is a modal that prevents body scrolling while open.</p>\n      <p>We're using the {useDirectManipulation ? 'direct JavaScript' : 'svelte:body action'} approach.</p>\n      <button on:click={() => isModalOpen = false}>Close</button>\n    </div>\n  </div>\n{/if}\n\n<style>\n  .modal {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.5);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n  \n  .modal-content {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    max-width: 500px;\n  }\n  \n  /* Add a lot of content to demonstrate scrolling */\n  :global(body::after) {\n    content: '';\n    display: block;\n    height: 200vh;\n  }\n</style>\n```\n\nIn this example:\n- Approach 1 uses `<svelte:body>` with an action, which is cleaner and more \"Svelte-like\"\n- Approach 2 uses direct JavaScript manipulation, which gives more control but requires more manual management\n\nFor this specific use case (disabling body scroll), the `<svelte:body>` approach is probably cleaner. However, if you needed to also add a class to the body, change multiple style properties, or manipulate other attributes, direct JavaScript would be more appropriate."}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"How does the `<svelte:body>` element work in server-side rendering (SSR) contexts, and what considerations should developers keep in mind when using it in SSR applications?","answer":"The `<svelte:body>` element requires special consideration in server-side rendering (SSR) contexts because the DOM, including the `document.body` element, doesn't exist on the server. Understanding how Svelte handles this and implementing appropriate safeguards is important for developers building SSR applications.\n\n### How `<svelte:body>` Works in SSR\n\nWhen Svelte compiles a component containing `<svelte:body>` for SSR:\n\n1. **Event listeners are not attached during SSR**: Since there's no actual DOM on the server, event listeners specified on `<svelte:body>` are not attached during server rendering.\n\n2. **Hydration handling**: Svelte's hydration process will attach the event listeners once the client-side JavaScript takes over in the browser.\n\n3. **Actions are handled specially**: Actions on `<svelte:body>` are not executed during SSR but are set up during hydration on the client.\n\n### Considerations for Developers\n\nHere are important considerations when using `<svelte:body>` in SSR applications:\n\n#### 1. Guard Against Server-Side Execution\n\nAlways ensure that any code that directly accesses the DOM is guarded against server execution:\n\n```svelte\n<script>\n  import { browser } from '$app/environment'; // SvelteKit example\n  \n  function handleBodyClick() {\n    // Safe to access DOM APIs here\n    console.log('Body clicked');\n  }\n  \n  let bodyAction = (node) => {\n    // This won't run on the server\n    console.log('Body action initialized');\n    \n    return {\n      destroy() {\n        console.log('Body action destroyed');\n      }\n    };\n  };\n  \n  // For any manual DOM manipulation, guard it\n  $: {\n    if (browser) {\n      // Safe to access document.body here\n    }\n  }\n</script>\n\n<svelte:body \n  on:click={handleBodyClick}\n  use:bodyAction\n/>\n```\n\n#### 2. Handle Hydration Mismatches\n\nBe aware that differences between server-rendered HTML and client expectations can cause hydration mismatches:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let isClient = false;\n  \n  onMount(() => {\n    isClient = true;\n  });\n  \n  function bodyAction(node) {\n    // Only runs on client\n    if (isClient) {\n      node.classList.add('js-enabled');\n    }\n    \n    return {\n      destroy() {\n        if (isClient) {\n          node.classList.remove('js-enabled');\n        }\n      }\n    };\n  }\n</script>\n\n<svelte:body use:bodyAction />\n```\n\n#### 3. Use `onMount` for Client-Only Code\n\nAny initialization code that depends on the body element should be placed in `onMount`:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  let bodyScrollPosition = 0;\n  \n  onMount(() => {\n    // Safe to access document.body here\n    const handleScroll = () => {\n      bodyScrollPosition = window.scrollY;\n    };\n    \n    document.body.addEventListener('scroll', handleScroll);\n    \n    return () => {\n      document.body.removeEventListener('scroll', handleScroll);\n    };\n  });\n</script>\n\n<svelte:body on:mouseenter={() => console.log('Mouse entered body')} />\n\n<div>Scroll position: {bodyScrollPosition}px</div>\n```\n\n#### 4. Be Cautious with Body Modifications\n\nWhen modifying the body element's attributes or classes, consider both SSR and client rendering:\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  export let theme = 'light';\n  \n  // This action handles applying the theme to the body\n  function themeAction(node, currentTheme) {\n    // Apply theme class\n    node.classList.add(`theme-${currentTheme}`);\n    \n    return {\n      update(newTheme) {\n        // Remove old theme\n        node.classList.remove(`theme-${currentTheme}`);\n        // Add new theme\n        node.classList.add(`theme-${newTheme}`);\n        // Update reference\n        currentTheme = newTheme;\n      },\n      destroy() {\n        // Clean up\n        node.classList.remove(`theme-${currentTheme}`);\n      }\n    };\n  }\n  \n  // For server rendered pages, we need to ensure the initial\n  // HTML includes the right class on the body\n  onMount(() => {\n    // This runs only on the client after hydration\n    console.log('Theme hydrated on client');\n  });\n</script>\n\n<svelte:body use:themeAction={theme} />\n\n<!-- Theme switcher -->\n<div class=\"theme-controls\">\n  <button on:click={() => theme = 'light'}>Light Theme</button>\n  <button on:click={() => theme = 'dark'}>Dark Theme</button>\n</div>\n```\n\n#### 5. Complete SSR Example with SvelteKit\n\nHere's a more complete example showing how to properly handle `<svelte:body>` in a SvelteKit application:\n\n```svelte\n<script>\n  import { browser } from '$app/environment';\n  import { onMount } from 'svelte';\n  \n  // Props\n  export let initialTheme = 'light';\n  \n  // State\n  let theme = initialTheme;\n  let mounted = false;\n  \n  // Initialize client-side\n  onMount(() => {\n    mounted = true;\n    \n    // Maybe load theme from localStorage on client\n    if (browser) {\n      const savedTheme = localStorage.getItem('theme');\n      if (savedTheme) {\n        theme = savedTheme;\n      }\n    }\n  });\n  \n  // Save theme changes to localStorage\n  $: {\n    if (browser && mounted) {\n      localStorage.setItem('theme', theme);\n    }\n  }\n  \n  // Body theme action\n  function applyTheme(node, currentTheme) {\n    // Apply initial theme\n    node.classList.add(`theme-${currentTheme}`);\n    \n    return {\n      update(newTheme) {\n        node.classList.remove(`theme-${currentTheme}`);\n        node.classList.add(`theme-${newTheme}`);\n        currentTheme = newTheme;\n      },\n      destroy() {\n        node.classList.remove(`theme-${currentTheme}`);\n      }\n    };\n  }\n  \n  // Handle body class for SSR\n  // This ensures the server-rendered HTML includes the theme class\n  export const ssr = true;\n  \n  // In a real app, you might handle this in your app.html template\n  // or with hooks.server.js to set the class on the initial HTML\n</script>\n\n<!-- Only attach the action when in the browser -->\n{#if browser}\n  <svelte:body use:applyTheme={theme} />\n{/if}\n\n<div class=\"theme-app theme-{theme}\">\n  <h1>Theme Switcher</h1>\n  \n  <div class=\"theme-controls\">\n    <button \n      class:active={theme === 'light'} \n      on:click={() => theme = 'light'}\n    >\n      Light Theme\n    </button>\n    \n    <button \n      class:active={theme === 'dark'} \n      on:click={() => theme = 'dark'}\n    >\n      Dark Theme\n    </button>\n  </div>\n  \n  <div class=\"info-box\">\n    <p>Current theme: {theme}</p>\n    <p>Client-side hydrated: {mounted ? 'Yes' : 'No'}</p>\n  </div>\n</div>\n\n<style>\n  /* Component styles */\n  .theme-app {\n    padding: 2rem;\n    max-width: 600px;\n    margin: 0 auto;\n  }\n  \n  .theme-controls {\n    display: flex;\n    gap: 1rem;\n    margin: 1rem 0;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    border: 1px solid #ccc;\n    background: #f0f0f0;\n    cursor: pointer;\n  }\n  \n  button.active {\n    background: #0066cc;\n    color: white;\n  }\n  \n  .info-box {\n    padding: 1rem;\n    background: #f5f5f5;\n    border-radius: 4px;\n    margin-top: 1rem;\n  }\n  \n  /* Theme specific styles for the component */\n  .theme-dark {\n    background: #222;\n    color: #fff;\n  }\n  \n  .theme-dark .info-box {\n    background: #333;\n    color: #eee;\n  }\n  \n  /* The global theme styles would typically be in app.css */\n  :global(.theme-light) {\n    /* Light theme variables */\n  }\n  \n  :global(.theme-dark) {\n    /* Dark theme variables */\n  }\n</style>\n```\n\n### Summary of SSR Considerations\n\n1. **Guard DOM access**: Always ensure DOM access only happens in the browser\n2. **Use lifecycle hooks**: Leverage `onMount` for client-side initialization\n3. **Handle hydration properly**: Be aware of potential hydration mismatches\n4. **Consider initial HTML**: For body classes needed during SSR, handle them in your HTML template\n5. **Use environment checks**: Use environment variables like `browser` to conditionally execute code\n6. **Prefer actions**: For body manipulations, use actions which are automatically handled during hydration\n\nBy following these guidelines, you can effectively use `<svelte:body>` in SSR applications while avoiding common pitfalls."}
{"source":"docs/svelte/05-special-elements/04-svelte-body.md","question":"How does `<svelte:body>` compare to similar special elements in other frameworks, and what unique advantages does Svelte's implementation offer for handling body events and actions?","answer":"Svelte's `<svelte:body>` element provides a unique approach to interacting with the document body compared to similar mechanisms in other frameworks. This comparison highlights the distinctive advantages of Svelte's implementation and how it fits into Svelte's overall philosophy.\n\n### Comparison with Other Frameworks\n\n#### React\n\nReact doesn't have a direct equivalent to `<svelte:body>`. To interact with the body element in React, developers typically:\n\n1. Use effects to manually add/remove event listeners:\n\n```jsx\nimport { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    const handleMouseEnter = () => console.log('Mouse entered body');\n    \n    document.body.addEventListener('mouseenter', handleMouseEnter);\n    \n    return () => {\n      document.body.removeEventListener('mouseenter', handleMouseEnter);\n    };\n  }, []);\n  \n  return <div>My Component</div>;\n}\n```\n\n2. Use portals for rendering content into the body:\n\n```jsx\nimport { createPortal } from 'react-dom';\n\nfunction Modal({ isOpen, children }) {\n  if (!isOpen) return null;\n  \n  return createPortal(\n    <div className=\"modal\">{children}</div>,\n    document.body\n  );\n}\n```\n\n#### Vue\n\nVue has a more similar approach with its `v-on` directives that can be attached to the `window` or `document`, but not directly to the `body`:\n\n```vue\n<script setup>\nimport { onMounted, onUnmounted } from 'vue';\n\nfunction handleBodyClick(e) {\n  console.log('Body clicked');\n}\n\nonMounted(() => {\n  document.body.addEventListener('click', handleBodyClick);\n});\n\nonUnmounted(() => {\n  document.body.removeEventListener('click', handleBodyClick);\n});\n</script>\n\n<template>\n  <div>My Component</div>\n</template>\n```\n\nVue 3 also has a `Teleport` component for rendering to different DOM locations, similar to React's portals.\n\n#### Angular\n\nAngular provides the `@HostListener` decorator to listen for events on the window, document, or body:\n\n```typescript\nimport { Component, HostListener } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  template: '<div>My Component</div>'\n})\nexport class MyComponent {\n  @HostListener('body:click')\n  onBodyClick() {\n    console.log('Body clicked');\n  }\n  \n  @HostListener('body:mouseenter')\n  onBodyMouseEnter() {\n    console.log('Mouse entered body');\n  }\n}\n```\n\n### Unique Advantages of Svelte's Implementation\n\nSvelte's `<svelte:body>` offers several advantages compared to these approaches:\n\n#### 1. Declarative Syntax\n\nSvelte's approach is fully declarative, making the intent clear directly in the component template:\n\n```svelte\n<script>\n  function handleMouseenter() {\n    console.log('Mouse entered body');\n  }\n</script>\n\n<svelte:body onmouseenter={handleMouseenter} />\n```\n\nThis is more readable and maintainable than imperative approaches that require manually adding and removing event listeners.\n\n#### 2. Automatic Lifecycle Management\n\nSvelte automatically handles adding event listeners when the component is mounted and removing them when the component is destroyed. This eliminates a common source of memory leaks that can occur when developers forget to clean up event listeners.\n\n#### 3. Action System Integration\n\nSvelte's unique action system works seamlessly with `<svelte:body>`, allowing for powerful, reusable DOM interactions:\n\n```svelte\n<script>\n  function bodyClassAction(node, className) {\n    node.classList.add(className);\n    \n    return {\n      update(newClassName) {\n        node.classList.remove(className);\n        node.classList.add(newClassName);\n        className = newClassName;\n      },\n      destroy() {\n        node.classList.remove(className);\n      }\n    };\n  }\n</script>\n\n<svelte:body use:bodyClassAction={'dark-theme'} />\n```\n\nThis action system is more powerful and flexible than the manual approaches required in other frameworks.\n\n#### 4. Event Modifier Support\n\nSvelte's event modifiers work with `<svelte:body>`, providing a concise way to control event behavior:\n\n```svelte\n<svelte:body \n  on:click|preventDefault|stopPropagation={handleClick}\n  on:keydown|once={handleFirstKeypress}\n/>\n```\n\nThis is much cleaner than the equivalent manual event handling in other frameworks.\n\n#### 5. Consistent with Svelte's Philosophy\n\nThe `<svelte:body>` element is consistent with Svelte's overall philosophy of providing clear, declarative abstractions that compile away to efficient vanilla JavaScript. It fits naturally with other special elements like `<svelte:window>`, `<svelte:document>`, and `<svelte:head>`.\n\n#### 6. Optimized Compilation\n\nSvelte's compiler can optimize the event handling code based on static analysis, potentially resulting in better performance than manual DOM manipulation.\n\n### Practical Comparison Example\n\nHere's a practical comparison showing how to implement the same functionality across frameworks:\n\n**Task**: Add a global keyboard shortcut handler that listens for Escape key presses on the body element and toggle a dark theme class on the body.\n\n**Svelte Solution**:\n\n```svelte\n<script>\n  let isDarkTheme = false;\n  \n  function handleKeydown(event) {\n    if (event.key === 'Escape') {\n      isDarkTheme = !isDarkTheme;\n    }\n  }\n  \n  function themeAction(node, isDark) {\n    const applyTheme = (dark) => {\n      if (dark) {\n        node.classList.add('dark-theme');\n      } else {\n        node.classList.remove('dark-theme');\n      }\n    };\n    \n    applyTheme(isDark);\n    \n    return {\n      update(newIsDark) {\n        applyTheme(newIsDark);\n      }\n    };\n  }\n</script>\n\n<svelte:body \n  on:keydown={handleKeydown}\n  use:themeAction={isDarkTheme}\n/>\n\n<div class=\"app\">\n  <h1>Press ESC to toggle theme</h1>\n  <p>Current theme: {isDarkTheme ? 'Dark' : 'Light'}</p>\n</div>\n```\n\n**React Solution**:\n\n```jsx\nimport { useState, useEffect } from 'react';\n\nfunction App() {\n  const [isDarkTheme, setIsDarkTheme] = useState(false);\n  \n  useEffect(() => {\n    const handleKeydown = (event) => {\n      if (event.key === 'Escape') {\n        setIsDarkTheme(prev => !prev);\n      }\n    };\n    \n    document.body.addEventListener('keydown', handleKeydown);\n    \n    return () => {\n      document.body.removeEventListener('keydown', handleKeydown);\n    };\n  }, []);\n  \n  useEffect(() => {\n    if (isDarkTheme) {\n      document.body.classList.add('dark-theme');\n    } else {\n      document.body.classList.remove('dark-theme');\n    }\n  }, [isDarkTheme]);\n  \n  return (\n    <div className=\"app\">\n      <h1>Press ESC to toggle theme</h1>\n      <p>Current theme: {isDarkTheme ? 'Dark' : 'Light'}</p>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n**Vue Solution**:\n\n```vue\n<script setup>\nimport { ref, onMounted, onUnmounted, watch } from 'vue';\n\nconst isDarkTheme = ref(false);\n\nfunction handleKeydown(event) {\n  if (event.key === 'Escape') {\n    isDarkTheme.value = !isDarkTheme.value;\n  }\n}\n\nonMounted(() => {\n  document.body.addEventListener('keydown', handleKeydown);\n});\n\nonUnmounted(() => {\n  document.body.removeEventListener('keydown', handleKeydown);\n});\n\nwatch(isDarkTheme, (newValue) => {\n  if (newValue) {\n    document.body.classList.add('dark-theme');\n  } else {\n    document.body.classList.remove('dark-theme');\n  }\n});\n</script>\n\n<template>\n  <div class=\"app\">\n    <h1>Press ESC to toggle theme</h1>\n    <p>Current theme: {{ isDarkTheme ? 'Dark' : 'Light' }}</p>\n  </div>\n</template>\n```\n\n### Summary of Advantages\n\n1. **Declarative Syntax**: Svelte's approach is more readable and maintainable\n2. **Automatic Cleanup**: No need to manually manage event listener lifecycles\n3. **Action System**: Powerful, reusable DOM interactions\n4. **Event Modifiers**: Concise control over event behavior\n5. **Consistent API**: Fits naturally with Svelte's other special elements\n6. **Compiler Optimizations**: Potential performance benefits from static analysis\n\nThese advantages make `<svelte:body>` a more elegant and developer-friendly solution for interacting with the document body compared to the approaches available in other frameworks."}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"What is the `<svelte:head>` element in Svelte and what problem does it solve?","answer":"The `<svelte:head>` element is a special Svelte element that allows you to insert content directly into the document's `<head>` section from anywhere in your component hierarchy. This solves a critical problem in single-page applications (SPAs) where modifying the document head (for setting page titles, meta tags, styles, etc.) would otherwise require direct DOM manipulation or complex state management.\n\nWithout `<svelte:head>`, developers would need to use imperative JavaScript to modify the document head, which is less declarative and harder to maintain. The `<svelte:head>` element provides a clean, declarative way to control document head content that aligns with Svelte's component-based approach.\n\n```svelte\n<script>\n  // Component state can drive head content\n  let pageTitle = \"Welcome to my app\";\n  let description = \"This is my amazing Svelte application\";\n</script>\n\n<svelte:head>\n  <title>{pageTitle}</title>\n  <meta name=\"description\" content={description} />\n  <link rel=\"canonical\" href=\"https://mysite.com/current-page\" />\n</svelte:head>\n```\n\nThis pattern is especially important for SEO, accessibility, and social media sharing, as it allows components to define their own metadata."}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"How does `<svelte:head>` behave during server-side rendering (SSR) and why is this important?","answer":"During server-side rendering, `<svelte:head>` content is handled specially - it's exposed separately from the main `body` content. This separation is crucial because it allows the server to properly construct a complete HTML document with both `<head>` and `<body>` sections.\n\nWhen Svelte renders your application on the server, it collects all the `<svelte:head>` content from across your component tree and makes it available to be inserted into the document's `<head>` section. This means that even deeply nested components can contribute to the document head in the server-rendered HTML.\n\nThis behavior is particularly important for:\n\n1. **SEO**: Search engines can immediately see metadata like titles, descriptions, and Open Graph tags without executing JavaScript.\n2. **Initial page load**: Users see the correct page title and favicon immediately.\n3. **Social media sharing**: Platforms like Twitter, Facebook, etc. can extract proper sharing metadata from your pages.\n\nFor example, in a SvelteKit application (which uses SSR by default), a page component might look like:\n\n```svelte\n<script>\n  export let data; // Page data from a load function\n</script>\n\n<svelte:head>\n  <title>{data.article.title} | My Blog</title>\n  <meta name=\"description\" content={data.article.excerpt} />\n  <meta property=\"og:image\" content={data.article.featuredImage} />\n  <meta property=\"og:title\" content={data.article.title} />\n  <meta property=\"og:description\" content={data.article.excerpt} />\n  <meta name=\"twitter:card\" content=\"summary_large_image\" />\n</svelte:head>\n\n<article>\n  <h1>{data.article.title}</h1>\n  <!-- Article content -->\n</article>\n```\n\nWhen this page is server-rendered, all these meta tags will be properly included in the initial HTML sent to the browser, ensuring optimal SEO and social sharing capabilities."}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"What are the placement restrictions for the `<svelte:head>` element and why do these restrictions exist?","answer":"The `<svelte:head>` element has specific placement restrictions within Svelte components:\n\n1. It must only appear at the top level of your component\n2. It must never be inside a block (like `{#if}`, `{#each}`, etc.) or another element\n\nThese restrictions exist because the `<svelte:head>` element is not a regular DOM element - it's a special Svelte construct that needs to be handled differently from normal elements. Svelte needs to be able to reliably track and manage the content that should be inserted into the document head.\n\nIf `<svelte:head>` were allowed inside conditional blocks or nested elements, it would create ambiguity about when and how the head content should be applied, especially during server-side rendering. The current restrictions make the behavior predictable and easier to reason about.\n\nHere are examples of correct and incorrect usage:\n\nâ Correct usage - at the top level of a component:\n```svelte\n<script>\n  let title = \"My Page\";\n</script>\n\n<svelte:head>\n  <title>{title}</title>\n</svelte:head>\n\n<main>\n  <h1>{title}</h1>\n</main>\n```\n\nâ Incorrect usage - inside a block:\n```svelte\n<script>\n  let showTitle = true;\n  let title = \"My Page\";\n</script>\n\n{#if showTitle}\n  <svelte:head>\n    <title>{title}</title>\n  </svelte:head>\n{/if}\n\n<main>\n  <h1>{title}</h1>\n</main>\n```\n\nâ Incorrect usage - inside another element:\n```svelte\n<script>\n  let title = \"My Page\";\n</script>\n\n<div>\n  <svelte:head>\n    <title>{title}</title>\n  </svelte:head>\n</div>\n```\n\nInstead, you can use reactive declarations to control what appears in the head:\n\n```svelte\n<script>\n  let showTitle = true;\n  let title = \"My Page\";\n  \n  $: headTitle = showTitle ? title : \"Untitled Page\";\n</script>\n\n<svelte:head>\n  <title>{headTitle}</title>\n</svelte:head>\n```"}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"How can you dynamically update the content in `<svelte:head>` based on component state?","answer":"One of the powerful features of `<svelte:head>` is that like any other part of a Svelte component, it can reactively update based on component state. You can use all of Svelte's reactivity features to dynamically change what appears in the document head.\n\nHere's a comprehensive example showing different ways to update head content based on component state:\n\n```svelte\n<script>\n  // Basic state\n  let pageTitle = \"Product Listing\";\n  let currentProduct = null;\n  let isLoading = true;\n  let searchQuery = \"\";\n  let colorScheme = \"light\";\n  \n  // Reactive declarations for derived values\n  $: documentTitle = isLoading \n    ? \"Loading...\" \n    : currentProduct \n      ? `${currentProduct.name} - Product Details` \n      : searchQuery \n        ? `Search results for \"${searchQuery}\"` \n        : pageTitle;\n        \n  $: metaDescription = currentProduct \n    ? currentProduct.description.substring(0, 160) \n    : \"Browse our collection of premium products\";\n    \n  $: themeColor = colorScheme === \"dark\" ? \"#121212\" : \"#ffffff\";\n  \n  // Simulating a product selection\n  function selectProduct(product) {\n    currentProduct = product;\n  }\n  \n  // Simulating theme switching\n  function toggleColorScheme() {\n    colorScheme = colorScheme === \"light\" ? \"dark\" : \"light\";\n  }\n</script>\n\n<svelte:head>\n  <title>{documentTitle}</title>\n  <meta name=\"description\" content={metaDescription} />\n  <meta name=\"theme-color\" content={themeColor} />\n  \n  {#if currentProduct}\n    <!-- Product-specific meta tags -->\n    <meta property=\"og:type\" content=\"product\" />\n    <meta property=\"og:title\" content={currentProduct.name} />\n    <meta property=\"og:description\" content={currentProduct.description} />\n    <meta property=\"og:image\" content={currentProduct.imageUrl} />\n    <meta property=\"product:price:amount\" content={currentProduct.price} />\n    <meta property=\"product:price:currency\" content=\"USD\" />\n  {:else}\n    <!-- Default meta tags -->\n    <meta property=\"og:type\" content=\"website\" />\n    <meta property=\"og:title\" content={pageTitle} />\n    <meta property=\"og:description\" content=\"Browse our collection of premium products\" />\n    <meta property=\"og:image\" content=\"/default-share-image.jpg\" />\n  {/if}\n  \n  <!-- Dynamically load CSS based on color scheme -->\n  <link rel=\"stylesheet\" href={`/styles/${colorScheme}-theme.css`} />\n</svelte:head>\n\n<!-- Rest of the component -->\n<main class={colorScheme}>\n  {#if isLoading}\n    <p>Loading products...</p>\n  {:else if currentProduct}\n    <h1>{currentProduct.name}</h1>\n    <!-- Product details -->\n  {:else}\n    <h1>{pageTitle}</h1>\n    <!-- Product listing -->\n  {/if}\n  \n  <button on:click={toggleColorScheme}>\n    Switch to {colorScheme === 'light' ? 'dark' : 'light'} mode\n  </button>\n</main>\n```\n\nIn this example:\n1. The page title changes based on loading state, current product, or search query\n2. Different meta tags are shown based on whether a product is selected\n3. The theme color and stylesheet change based on the color scheme preference\n4. All of these changes happen reactively as the component state changes\n\nThis approach ensures that the document head always reflects the current state of your application, which is important for SEO, accessibility, and user experience."}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"Can multiple components in a Svelte application use `<svelte:head>` simultaneously? How does Svelte handle this situation?","answer":"Yes, multiple components in a Svelte application can use `<svelte:head>` simultaneously. Svelte intelligently merges the content from all active `<svelte:head>` elements in the component tree.\n\nWhen multiple components include `<svelte:head>` elements, Svelte combines their content in the document's head. This allows components at different levels of your application to contribute to the document head without conflicts.\n\nHere's how Svelte handles different scenarios:\n\n### Non-conflicting elements\n\nWhen components add different types of elements to the head, they simply co-exist:\n\n```svelte\n<!-- Layout.svelte -->\n<svelte:head>\n  <link rel=\"stylesheet\" href=\"/global.css\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n</svelte:head>\n\n<!-- Page.svelte -->\n<svelte:head>\n  <title>My Page</title>\n  <meta name=\"description\" content=\"Page description\">\n</svelte:head>\n\n<!-- ResultingHead in the browser -->\n<head>\n  <link rel=\"stylesheet\" href=\"/global.css\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <title>My Page</title>\n  <meta name=\"description\" content=\"Page description\">\n</head>\n```\n\n### Conflicting elements\n\nWhen components add the same type of unique elements (like `<title>`), the more deeply nested component's elements take precedence:\n\n```svelte\n<!-- Layout.svelte -->\n<svelte:head>\n  <title>My Site</title>\n  <meta name=\"description\" content=\"Default site description\">\n</svelte:head>\n\n<slot />\n\n<!-- Page.svelte (used inside Layout) -->\n<svelte:head>\n  <title>Product Page</title>\n  <meta name=\"description\" content=\"Product-specific description\">\n</svelte:head>\n\n<!-- ResultingHead in the browser -->\n<head>\n  <title>Product Page</title>\n  <meta name=\"description\" content=\"Product-specific description\">\n</head>\n```\n\n### Dynamic updates\n\nWhen component state changes or routes change in an SPA, Svelte automatically updates the document head to reflect the current component tree:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import { Router, Route } from 'svelte-routing';\n  import Home from './Home.svelte';\n  import About from './About.svelte';\n  import Product from './Product.svelte';\n</script>\n\n<svelte:head>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"icon\" href=\"/favicon.ico\">\n</svelte:head>\n\n<Router>\n  <Route path=\"/\" component={Home} />\n  <Route path=\"/about\" component={About} />\n  <Route path=\"/product/:id\" component={Product} />\n</Router>\n```\n\nAs the user navigates between routes, each page component can define its own head content, which Svelte will seamlessly update.\n\nThis approach allows for a clean separation of concerns, where:\n- Layout components can handle global head elements like stylesheets and viewport settings\n- Page components can set page-specific elements like titles and descriptions\n- Feature components can add specialized meta tags when needed\n\nSvelte handles all the DOM manipulation needed to keep the document head in sync with your component tree."}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"How can you use `<svelte:head>` to implement proper SEO practices in a Svelte application?","answer":"The `<svelte:head>` element is a powerful tool for implementing SEO best practices in Svelte applications. It allows you to programmatically control important SEO elements directly from your components. Here's a comprehensive guide on using `<svelte:head>` for SEO:\n\n### Essential SEO Meta Tags\n\n```svelte\n<script>\n  export let article = {\n    title: 'Understanding Svelte's Reactivity',\n    description: 'A deep dive into how Svelte's reactive system works under the hood',\n    publishDate: '2023-05-15T09:00:00Z',\n    modifiedDate: '2023-05-20T14:30:00Z',\n    category: 'Web Development',\n    featuredImage: '/images/svelte-reactivity.jpg',\n    canonicalUrl: 'https://mysite.com/blog/understanding-svelte-reactivity'\n  };\n</script>\n\n<svelte:head>\n  <!-- Essential Meta Tags -->\n  <title>{article.title} | My Tech Blog</title>\n  <meta name=\"description\" content={article.description} />\n  \n  <!-- Canonical URL (important for content that might exist at multiple URLs) -->\n  <link rel=\"canonical\" href={article.canonicalUrl} />\n  \n  <!-- Open Graph / Facebook -->\n  <meta property=\"og:type\" content=\"article\" />\n  <meta property=\"og:url\" content={article.canonicalUrl} />\n  <meta property=\"og:title\" content={article.title} />\n  <meta property=\"og:description\" content={article.description} />\n  <meta property=\"og:image\" content={`https://mysite.com${article.featuredImage}`} />\n  \n  <!-- Twitter -->\n  <meta property=\"twitter:card\" content=\"summary_large_image\" />\n  <meta property=\"twitter:url\" content={article.canonicalUrl} />\n  <meta property=\"twitter:title\" content={article.title} />\n  <meta property=\"twitter:description\" content={article.description} />\n  <meta property=\"twitter:image\" content={`https://mysite.com${article.featuredImage}`} />\n  \n  <!-- Article-specific metadata -->\n  <meta property=\"article:published_time\" content={article.publishDate} />\n  <meta property=\"article:modified_time\" content={article.modifiedDate} />\n  <meta property=\"article:section\" content={article.category} />\n  \n  <!-- Structured Data / JSON-LD for Rich Results -->\n  <script type=\"application/ld+json\">\n  {JSON.stringify({\n    \"@context\": \"https://schema.org\",\n    \"@type\": \"BlogPosting\",\n    \"headline\": article.title,\n    \"image\": `https://mysite.com${article.featuredImage}`,\n    \"datePublished\": article.publishDate,\n    \"dateModified\": article.modifiedDate,\n    \"author\": {\n      \"@type\": \"Person\",\n      \"name\": \"Your Name\"\n    },\n    \"publisher\": {\n      \"@type\": \"Organization\",\n      \"name\": \"My Tech Blog\",\n      \"logo\": {\n        \"@type\": \"ImageObject\",\n        \"url\": \"https://mysite.com/logo.png\"\n      }\n    },\n    \"description\": article.description\n  })}\n  </script>\n</svelte:head>\n\n<article>\n  <h1>{article.title}</h1>\n  <!-- Article content -->\n</article>\n```\n\n### Dynamic SEO for Different Page Types\n\nDifferent types of pages need different SEO approaches. Here's how to handle various page types:\n\n```svelte\n<script>\n  export let pageType; // 'home', 'product', 'category', 'article', etc.\n  export let pageData; // Data specific to the page\n  \n  // Compute SEO data based on page type\n  $: seoData = getSeoData(pageType, pageData);\n  \n  function getSeoData(type, data) {\n    switch(type) {\n      case 'home':\n        return {\n          title: 'My E-commerce Store | Quality Products Online',\n          description: 'Shop our selection of premium products with fast shipping and excellent customer service.',\n          type: 'website',\n          schema: {\n            \"@context\": \"https://schema.org\",\n            \"@type\": \"WebSite\",\n            \"name\": \"My E-commerce Store\",\n            \"url\": \"https://mystore.com\"\n          }\n        };\n      \n      case 'product':\n        return {\n          title: `${data.name} | My E-commerce Store`,\n          description: data.description.substring(0, 160),\n          type: 'product',\n          schema: {\n            \"@context\": \"https://schema.org\",\n            \"@type\": \"Product\",\n            \"name\": data.name,\n            \"image\": data.images[0],\n            \"description\": data.description,\n            \"offers\": {\n              \"@type\": \"Offer\",\n              \"price\": data.price,\n              \"priceCurrency\": \"USD\",\n              \"availability\": data.inStock ? \"https://schema.org/InStock\" : \"https://schema.org/OutOfStock\"\n            }\n          }\n        };\n        \n      case 'category':\n        return {\n          title: `${data.name} | Categories | My E-commerce Store`,\n          description: `Shop our selection of ${data.name}. ${data.productCount} products available.`,\n          type: 'website',\n          schema: {\n            \"@context\": \"https://schema.org\",\n            \"@type\": \"CollectionPage\",\n            \"name\": data.name,\n            \"description\": `Shop our selection of ${data.name}`\n          }\n        };\n        \n      // Add more page types as needed\n      \n      default:\n        return {\n          title: 'My E-commerce Store',\n          description: 'Shop our products online',\n          type: 'website',\n          schema: null\n        };\n    }\n  }\n</script>\n\n<svelte:head>\n  <title>{seoData.title}</title>\n  <meta name=\"description\" content={seoData.description} />\n  \n  <meta property=\"og:title\" content={seoData.title} />\n  <meta property=\"og:description\" content={seoData.description} />\n  <meta property=\"og:type\" content={seoData.type} />\n  \n  {#if seoData.schema}\n    <script type=\"application/ld+json\">\n      {JSON.stringify(seoData.schema)}\n    </script>\n  {/if}\n</svelte:head>\n```\n\n### Handling Multilingual SEO\n\nFor multilingual sites, you can add language-specific meta tags:\n\n```svelte\n<script>\n  export let currentLanguage = 'en';\n  export let availableTranslations = {\n    en: '/en/blog/article-slug',\n    es: '/es/blog/article-slug',\n    fr: '/fr/blog/article-slug'\n  };\n  \n  export let localizedContent = {\n    title: 'Article Title in Current Language',\n    description: 'Article description in current language'\n  };\n</script>\n\n<svelte:head>\n  <title>{localizedContent.title}</title>\n  <meta name=\"description\" content={localizedContent.description} />\n  \n  <!-- Language meta tag -->\n  <meta http-equiv=\"content-language\" content={currentLanguage} />\n  \n  <!-- Canonical URL for current language -->\n  <link rel=\"canonical\" href={`https://mysite.com${availableTranslations[currentLanguage]}`} />\n  \n  <!-- Alternate language versions -->\n  {#each Object.entries(availableTranslations) as [lang, url]}\n    <link rel=\"alternate\" hreflang={lang} href={`https://mysite.com${url}`} />\n  {/each}\n  \n  <!-- Default hreflang -->\n  <link rel=\"alternate\" hreflang=\"x-default\" href={`https://mysite.com${availableTranslations.en}`} />\n</svelte:head>\n```\n\n### SEO for Single Page Applications\n\nSPAs can have SEO challenges. Using `<svelte:head>` with server-side rendering (like in SvelteKit) addresses most issues, but you can also add:\n\n```svelte\n<svelte:head>\n  <!-- Preconnect to important domains -->\n  <link rel=\"preconnect\" href=\"https://api.mysite.com\">\n  <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n  \n  <!-- Preload critical resources -->\n  <link rel=\"preload\" href=\"/fonts/main-font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin>\n  \n  <!-- Meta tags for web crawlers -->\n  <meta name=\"robots\" content=\"index, follow\" />\n  \n  <!-- For SPA crawling -->\n  <meta name=\"fragment\" content=\"!\">\n</svelte:head>\n```\n\nBy leveraging `<svelte:head>` in these ways, you can implement comprehensive SEO practices in your Svelte application, ensuring that search engines properly index and display your content."}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"How can you use `<svelte:head>` to dynamically load CSS or JavaScript resources based on component needs?","answer":"The `<svelte:head>` element provides an elegant way to dynamically load CSS or JavaScript resources based on your component's specific needs. This allows for more efficient resource loading, loading dependencies only when necessary.\n\nHere's how you can use `<svelte:head>` for dynamic resource loading:\n\n### Dynamically Loading CSS\n\n```svelte\n<script>\n  // Component props/state\n  export let theme = 'light'; // 'light' or 'dark'\n  export let features = []; // Features that need specific stylesheets\n  \n  // Computed properties for resource paths\n  $: themeStylesheet = `/styles/${theme}-theme.css`;\n  \n  // Track if specific features are enabled\n  $: hasDataGrid = features.includes('data-grid');\n  $: hasCharts = features.includes('charts');\n  $: hasPrintLayout = features.includes('print-layout');\n  \n  // Preloading state\n  let preloadCharts = false;\n  \n  // Function to prepare charts before they're needed\n  function prepareCharts() {\n    preloadCharts = true;\n  }\n</script>\n\n<svelte:head>\n  <!-- Core stylesheets that are always needed -->\n  <link rel=\"stylesheet\" href=\"/styles/base.css\">\n  \n  <!-- Dynamic theme stylesheet -->\n  <link rel=\"stylesheet\" href={themeStylesheet}>\n  \n  <!-- Feature-specific stylesheets, only loaded when needed -->\n  {#if hasDataGrid}\n    <link rel=\"stylesheet\" href=\"/styles/data-grid.css\">\n  {/if}\n  \n  {#if hasCharts}\n    <link rel=\"stylesheet\" href=\"/styles/charts.css\">\n  {:else if preloadCharts}\n    <!-- Preload chart styles but don't apply them yet -->\n    <link rel=\"preload\" href=\"/styles/charts.css\" as=\"style\">\n  {/if}\n  \n  {#if hasPrintLayout}\n    <!-- Print-specific stylesheet -->\n    <link rel=\"stylesheet\" href=\"/styles/print.css\" media=\"print\">\n  {/if}\n  \n  <!-- Responsive stylesheets -->\n  <link rel=\"stylesheet\" href=\"/styles/mobile.css\" media=\"(max-width: 600px)\">\n  <link rel=\"stylesheet\" href=\"/styles/tablet.css\" media=\"(min-width: 601px) and (max-width: 1024px)\">\n  <link rel=\"stylesheet\" href=\"/styles/desktop.css\" media=\"(min-width: 1025px)\">\n</svelte:head>\n\n<div class=\"component\">\n  <!-- Component content -->\n  \n  {#if !hasCharts}\n    <button on:click={prepareCharts}>Prepare charts</button>\n  {/if}\n</div>\n```\n\n### Dynamically Loading JavaScript\n\n```svelte\n<script>\n  import { onMount } from 'svelte';\n  \n  // Component state\n  let mapActive = false;\n  let analyticsEnabled = false;\n  let editorLoaded = false;\n  \n  // Track script loading status\n  let mapScriptLoaded = false;\n  let editorScriptLoading = false;\n  \n  // Function to initialize map\n  function initializeMap() {\n    mapActive = true;\n  }\n  \n  // Function to load rich text editor when needed\n  function loadEditor() {\n    if (!editorLoaded && !editorScriptLoading) {\n      editorScriptLoading = true;\n    }\n  }\n  \n  // Handle editor script load completion\n  function onEditorLoaded() {\n    editorLoaded = true;\n    editorScriptLoading = false;\n    // Initialize editor\n    window.RichEditor.init('#editor');\n  }\n  \n  onMount(() => {\n    // Check if analytics should be enabled based on user preferences\n    analyticsEnabled = localStorage.getItem('analytics-consent') === 'true';\n  });\n</script>\n\n<svelte:head>\n  <!-- Dynamically load map script -->\n  {#if mapActive && !mapScriptLoaded}\n    <script \n      src=\"https://maps.example.com/api.js?key=YOUR_API_KEY\" \n      on:load={() => { mapScriptLoaded = true; }}\n    ></script>\n  {/if}\n  \n  <!-- Dynamically load analytics only if user has consented -->\n  {#if analyticsEnabled}\n    <script async src=\"https://analytics.example.com/tracker.js\"></script>\n  {/if}\n  \n  <!-- Load rich text editor when needed -->\n  {#if editorScriptLoading}\n    <script \n      src=\"/scripts/rich-editor.js\" \n      on:load={onEditorLoaded}\n    ></script>\n    <link rel=\"stylesheet\" href=\"/styles/rich-editor.css\">\n  {/if}\n  \n  <!-- Preconnect to domains we'll need resources from -->\n  <link rel=\"preconnect\" href=\"https://maps.example.com\">\n  <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n</svelte:head>\n\n<div class=\"component\">\n  {#if !mapActive}\n    <button on:click={initializeMap}>Show Map</button>\n  {:else if !mapScriptLoaded}\n    <p>Loading map...</p>\n  {:else}\n    <div id=\"map\"></div>\n  {/if}\n  \n  <div class=\"editor-container\">\n    {#if !editorLoaded}\n      <button on:click={loadEditor}>Load Rich Text Editor</button>\n    {:else}\n      <div id=\"editor\"></div>\n    {/if}\n  </div>\n</div>\n```\n\n### Advanced Use Case: Lazy Loading Third-Party Components\n\n```svelte\n<script>\n  // State to track component visibility and loading\n  let commentsVisible = false;\n  let commentsNearViewport = false;\n  let commentsLoaded = false;\n  \n  // Options for intersection observer\n  const observerOptions = {\n    rootMargin: '200px', // Start loading when within 200px of viewport\n  };\n  \n  // Track comment section element\n  let commentSectionElement;\n  \n  // Set up intersection observer to detect when comments are near viewport\n  onMount(() => {\n    if (typeof IntersectionObserver !== 'undefined' && commentSectionElement) {\n      const observer = new IntersectionObserver((entries) => {\n        if (entries[0].isIntersecting) {\n          commentsNearViewport = true;\n          observer.disconnect();\n        }\n      }, observerOptions);\n      \n      observer.observe(commentSectionElement);\n      \n      return () => observer.disconnect();\n    }\n  });\n  \n  // Function to show comments section\n  function showComments() {\n    commentsVisible = true;\n  }\n  \n  // Handle disqus load completion\n  function onDisqusLoaded() {\n    commentsLoaded = true;\n    // Initialize Disqus\n    window.DISQUS.reset({\n      reload: true,\n      config: function () {\n        this.page.identifier = 'article-123';\n        this.page.url = window.location.href;\n      }\n    });\n  }\n</script>\n\n<svelte:head>\n  <!-- Preload Disqus when near viewport but before user clicks -->\n  {#if commentsNearViewport && !commentsLoaded && !commentsVisible}\n    <link rel=\"preconnect\" href=\"https://yoursite.disqus.com\">\n    <link rel=\"dns-prefetch\" href=\"https://yoursite.disqus.com\">\n  {/if}\n  \n  <!-- Load Disqus script when comments are shown -->\n  {#if commentsVisible && !commentsLoaded}\n    <script>\n      window.disqus_config = function() {\n        this.page.identifier = 'article-123';\n        this.page.url = window.location.href;\n      };\n    </script>\n    <script \n      src=\"https://yoursite.disqus.com/embed.js\" \n      id=\"disqus-script\"\n      on:load={onDisqusLoaded}\n    ></script>\n  {/if}\n</svelte:head>\n\n<article>\n  <!-- Article content -->\n</article>\n\n<div bind:this={commentSectionElement} class=\"comments-section\">\n  {#if !commentsVisible}\n    <button on:click={showComments}>Show Comments</button>\n  {:else if !commentsLoaded}\n    <p>Loading comments...</p>\n  {:else}\n    <div id=\"disqus_thread\"></div>\n  {/if}\n</div>\n```\n\nThese examples demonstrate how `<svelte:head>` can be used to:\n\n1. Dynamically load theme-specific stylesheets\n2. Load feature-specific CSS only when those features are used\n3. Apply responsive stylesheets based on media queries\n4. Load JavaScript libraries on demand\n5. Respect user preferences for things like analytics\n6. Optimize performance with preloading and preconnecting\n7. Implement sophisticated lazy loading for third-party components\n\nThis approach improves performance by reducing the initial page load size and only loading resources when they're needed, while keeping the resource management logic cleanly encapsulated within your components."}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"How does `<svelte:head>` interact with client-side routing in a Svelte SPA, and what considerations should be made for managing head content during route transitions?","answer":"In a Svelte Single Page Application (SPA) with client-side routing, `<svelte:head>` plays a crucial role in updating the document head as users navigate between routes. However, there are important considerations to ensure head content is properly managed during route transitions.\n\n### Basic Interaction with Client-Side Routing\n\nWhen using client-side routing (with libraries like svelte-routing, svelte-navigator, or SvelteKit's routing), each route component can define its own `<svelte:head>` content. Svelte will automatically update the document head when routes change:\n\n```svelte\n<!-- Home.svelte -->\n<svelte:head>\n  <title>Home | My SPA</title>\n  <meta name=\"description\" content=\"Welcome to my application\" />\n</svelte:head>\n\n<!-- About.svelte -->\n<svelte:head>\n  <title>About Us | My SPA</title>\n  <meta name=\"description\" content=\"Learn about our team and mission\" />\n</svelte:head>\n\n<!-- App.svelte (with routing) -->\n<script>\n  import { Router, Route } from 'svelte-routing';\n  import Home from './Home.svelte';\n  import About from './About.svelte';\n</script>\n\n<Router>\n  <Route path=\"/\" component={Home} />\n  <Route path=\"/about\" component={About} />\n</Router>\n```\n\nWhen the user navigates from the home page to the about page, Svelte will automatically update the document title and meta description.\n\n### Considerations for Route Transitions\n\n#### 1. Handling Transition Timing\n\nDuring route transitions, there might be a brief moment when neither the old nor new route component is mounted. This can cause flickering of the document title or meta tags. To prevent this, consider using a persistent layout component:\n\n```svelte\n<!-- Layout.svelte -->\n<script>\n  export let title = 'My SPA';\n  export let description = 'Default description';\n</script>\n\n<svelte:head>\n  <title>{title}</title>\n  <meta name=\"description\" content={description} />\n</svelte:head>\n\n<slot />\n\n<!-- App.svelte -->\n<script>\n  import { Router, Route } from 'svelte-routing';\n  import Layout from './Layout.svelte';\n  import Home from './Home.svelte';\n  import About from './About.svelte';\n</script>\n\n<Router>\n  <Layout>\n    <Route path=\"/\" component={Home} />\n    <Route path=\"/about\" component={About} />\n  </Layout>\n</Router>\n\n<!-- Home.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  \n  onMount(() => {\n    document.title = 'Home | My SPA';\n    document.querySelector('meta[name=\"description\"]').setAttribute('content', 'Welcome to my application');\n  });\n</script>\n\n<!-- Content -->\n```\n\nThis approach ensures the document head always has content, even during transitions.\n\n#### 2. Using a Store for Head Content\n\nA more sophisticated approach is to use a Svelte store to manage head content:\n\n```svelte\n<!-- stores/head.js -->\n<script context=\"module\">\n  import { writable } from 'svelte/store';\n  \n  export const title = writable('My SPA');\n  export const description = writable('Default description');\n  export const canonicalUrl = writable('');\n  export const metaTags = writable([]);\n</script>\n\n<!-- HeadManager.svelte -->\n<script>\n  import { title, description, canonicalUrl, metaTags } from './stores/head';\n</script>\n\n<svelte:head>\n  <title>{$title}</title>\n  <meta name=\"description\" content={$description} />\n  \n  {#if $canonicalUrl}\n    <link rel=\"canonical\" href={$canonicalUrl} />\n  {/if}\n  \n  {#each $metaTags as tag}\n    <meta {...tag} />\n  {/each}\n</svelte:head>\n\n<!-- App.svelte -->\n<script>\n  import { Router, Route } from 'svelte-routing';\n  import HeadManager from './HeadManager.svelte';\n  import Home from './Home.svelte';\n  import About from './About.svelte';\n</script>\n\n<HeadManager />\n\n<Router>\n  <Route path=\"/\" component={Home} />\n  <Route path=\"/about\" component={About} />\n</Router>\n\n<!-- Home.svelte -->\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  import { title, description, canonicalUrl, metaTags } from './stores/head';\n  \n  onMount(() => {\n    title.set('Home | My SPA');\n    description.set('Welcome to my application');\n    canonicalUrl.set('https://myapp.com/');\n    metaTags.set([\n      { property: 'og:title', content: 'Home | My SPA' },\n      { property: 'og:description', content: 'Welcome to my application' }\n    ]);\n  });\n</script>\n\n<!-- Content -->\n```\n\nThis approach provides fine-grained control over head content during transitions.\n\n#### 3. Handling Async Route Data\n\nFor routes that load data asynchronously, you need to handle the transition between loading and loaded states:\n\n```svelte\n<!-- ProductPage.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  \n  export let id; // Product ID from route params\n  \n  let product = null;\n  let loading = true;\n  let error = null;\n  \n  onMount(async () => {\n    try {\n      loading = true;\n      product = await fetchProduct(id);\n    } catch (e) {\n      error = e;\n    } finally {\n      loading = false;\n    }\n  });\n  \n  $: documentTitle = loading \n    ? 'Loading Product... | My Store' \n    : error \n      ? 'Product Not Found | My Store' \n      : `${product.name} | My Store`;\n      \n  $: metaDescription = loading \n    ? 'Loading product information' \n    : error \n      ? 'Sorry, this product could not be found' \n      : product.description.substring(0, 160);\n</script>\n\n<svelte:head>\n  <title>{documentTitle}</title>\n  <meta name=\"description\" content={metaDescription} />\n  \n  {#if !loading && !error}\n    <meta property=\"og:title\" content={product.name} />\n    <meta property=\"og:description\" content={product.description} />\n    <meta property=\"og:image\" content={product.imageUrl} />\n    <meta property=\"og:url\" content={`https://mystore.com/products/${id}`} />\n    <meta property=\"og:type\" content=\"product\" />\n  {/if}\n</svelte:head>\n\n{#if loading}\n  <p>Loading product...</p>\n{:else if error}\n  <p>Error: {error.message}</p>\n{:else}\n  <h1>{product.name}</h1>\n  <!-- Product details -->\n{/if}\n```\n\n#### 4. Analytics and Route Tracking\n\nWhen using client-side routing, you need to manually track page views for analytics:\n\n```svelte\n<!-- AnalyticsManager.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  import { location } from 'svelte-routing';\n  \n  // Track page views when route changes\n  $: if (typeof window !== 'undefined' && $location) {\n    trackPageView($location.pathname);\n  }\n  \n  function trackPageView(path) {\n    if (typeof gtag !== 'undefined') {\n      gtag('config', 'GA-TRACKING-ID', {\n        page_path: path\n      });\n    }\n  }\n  \n  onMount(() => {\n    // Initial page load tracking\n    trackPageView(window.location.pathname);\n  });\n</script>\n\n<svelte:head>\n  <!-- Google Analytics -->\n  <script async src=\"https://www.googletagmanager.com/gtag/js?id=GA-TRACKING-ID\"></script>\n  <script>\n    window.dataLayer = window.dataLayer || [];\n    function gtag(){dataLayer.push(arguments);}\n    gtag('js', new Date());\n    gtag('config', 'GA-TRACKING-ID', { send_page_view: false });\n  </script>\n</svelte:head>\n```\n\n#### 5. History State and Page Titles\n\nBrowser history entries should include the correct page title:\n\n```svelte\n<script>\n  import { onMount, afterUpdate } from 'svelte';\n  import { router } from 'svelte-routing';\n  \n  export let pageTitle;\n  \n  // Update history state with page title\n  afterUpdate(() => {\n    if (typeof history !== 'undefined' && history.replaceState && pageTitle) {\n      const state = history.state;\n      history.replaceState(state, pageTitle, window.location.href);\n    }\n  });\n</script>\n\n<svelte:head>\n  <title>{pageTitle}</title>\n</svelte:head>\n```\n\n#### 6. Scroll Restoration\n\nAfter route changes, consider how scroll position affects the user experience:\n\n```svelte\n<script>\n  import { onMount, beforeUpdate, afterUpdate } from 'svelte';\n  import { location } from 'svelte-routing';\n  \n  let scrollPositions = {};\n  let isBack = false;\n  \n  // Store scroll positions for each route\n  beforeUpdate(() => {\n    if (typeof window !== 'undefined') {\n      scrollPositions[$location.pathname] = window.scrollY;\n    }\n  });\n  \n  // Detect back/forward navigation\n  onMount(() => {\n    window.addEventListener('popstate', () => {\n      isBack = true;\n    });\n  });\n  \n  // Restore scroll position or scroll to top\n  afterUpdate(() => {\n    if (typeof window !== 'undefined') {\n      if (isBack && scrollPositions[$location.pathname]) {\n        window.scrollTo(0, scrollPositions[$location.pathname]);\n        isBack = false;\n      } else {\n        window.scrollTo(0, 0);\n      }\n    }\n  });\n</script>\n```\n\nBy carefully considering these aspects of client-side routing with `<svelte:head>`, you can create a seamless user experience with proper document head management during route transitions in your Svelte SPA."}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"What are the limitations of `<svelte:head>` and how can they be overcome in complex applications?","answer":"While `<svelte:head>` is a powerful feature in Svelte, it does have some limitations that developers should be aware of, especially in complex applications. Here's a comprehensive look at these limitations and strategies to overcome them:\n\n### Limitation 1: Placement Restrictions\n\nAs mentioned in the documentation, `<svelte:head>` can only appear at the top level of a component and cannot be placed inside blocks or other elements.\n\n**Problems:**\n- Cannot conditionally render head content using `{#if}` blocks directly around `<svelte:head>`\n- Cannot place `<svelte:head>` inside layout components or slots\n\n**Solutions:**\n\n1. **Use reactive variables for conditional content:**\n```svelte\n<script>\n  let showMetaTags = true;\n  let isProductPage = true;\n  \n  // Reactive declarations for conditional content\n  $: metaTags = showMetaTags \n    ? [\n        { name: 'robots', content: 'index, follow' },\n        { name: 'author', content: 'Your Name' }\n      ] \n    : [];\n    \n  $: schemaData = isProductPage \n    ? {\n        \"@context\": \"https://schema.org\",\n        \"@type\": \"Product\",\n        \"name\": \"Product Name\"\n      } \n    : null;\n</script>\n\n<svelte:head>\n  <!-- Always included -->\n  <title>My Page</title>\n  \n  <!-- Conditionally included based on reactive variables -->\n  {#each metaTags as tag}\n    <meta name={tag.name} content={tag.content}>\n  {/each}\n  \n  {#if schemaData}\n    <script type=\"application/ld+json\">\n      {JSON.stringify(schemaData)}\n    </script>\n  {/if}\n</svelte:head>\n```\n\n2. **Create specialized head components:**\n```svelte\n<!-- SEOHead.svelte -->\n<script>\n  export let title;\n  export let description;\n  export let canonical;\n  export let ogImage;\n</script>\n\n<svelte:head>\n  <title>{title}</title>\n  <meta name=\"description\" content={description}>\n  <link rel=\"canonical\" href={canonical}>\n  <meta property=\"og:image\" content={ogImage}>\n</svelte:head>\n\n<!-- Usage in parent component -->\n<script>\n  import SEOHead from './SEOHead.svelte';\n  let showSEO = true;\n</script>\n\n{#if showSEO}\n  <SEOHead \n    title=\"My Page\" \n    description=\"Page description\" \n    canonical=\"https://mysite.com/page\" \n    ogImage=\"/images/share.jpg\" \n  />\n{/if}\n```\n\n### Limitation 2: No Direct Access to Head Outside Components\n\nIn some cases, you might need to modify the document head from outside the component lifecycle, such as in utility functions or stores.\n\n**Problems:**\n- Cannot directly use `<svelte:head>` in JavaScript modules or utilities\n- Difficult to manage head content from global state management\n\n**Solutions:**\n\n1. **Create a head store:**\n```svelte\n<!-- stores/head.js -->\nimport { writable } from 'svelte/store';\n\n// Create stores for different head elements\nexport const title = writable('Default Title');\nexport const meta = writable([]);\nexport const links = writable([]);\nexport const scripts = writable([]);\n\n// Helper functions\nexport function setTitle(newTitle) {\n  title.set(newTitle);\n}\n\nexport function addMeta(newMeta) {\n  meta.update(m => [...m, newMeta]);\n}\n\nexport function clearMeta() {\n  meta.set([]);\n}\n\n// Similar functions for links and scripts\n\n<!-- HeadManager.svelte -->\n<script>\n  import { title, meta, links, scripts } from './stores/head';\n</script>\n\n<svelte:head>\n  <title>{$title}</title>\n  \n  {#each $meta as m}\n    <meta {...m} />\n  {/each}\n  \n  {#each $links as l}\n    <link {...l} />\n  {/each}\n  \n  {#each $scripts as s}\n    <script {...s.attrs}>{s.content || ''}</script>\n  {/each}\n</svelte:head>\n\n<!-- Usage in App.svelte -->\n<script>\n  import HeadManager from './HeadManager.svelte';\n</script>\n\n<HeadManager />\n<!-- Rest of app -->\n\n<!-- Usage in any component or JavaScript module -->\n<script>\n  import { setTitle, addMeta, clearMeta } from './stores/head';\n  \n  function navigateToProduct(product) {\n    clearMeta();\n    setTitle(`${product.name} | My Store`);\n    addMeta({ name: 'description', content: product.description });\n    addMeta({ property: 'og:title', content: product.name });\n    // Navigate to product page\n  }\n</script>\n```\n\n2. **Use Context API for component hierarchies:**\n```svelte\n<!-- HeadContext.svelte -->\n<script context=\"module\">\n  import { setContext, getContext } from 'svelte';\n  \n  const HEAD_CONTEXT_KEY = Symbol('head');\n  \n  export function setHeadContext() {\n    const head = {\n      title: '',\n      meta: [],\n      setTitle: (title) => { head.title = title; },\n      addMeta: (meta) => { head.meta = [...head.meta, meta]; }\n    };\n    \n    setContext(HEAD_CONTEXT_KEY, head);\n    return head;\n  }\n  \n  export function getHeadContext() {\n    return getContext(HEAD_CONTEXT_KEY);\n  }\n</script>\n\n<!-- Layout.svelte -->\n<script>\n  import { setHeadContext } from './HeadContext.svelte';\n  \n  const head = setHeadContext();\n</script>\n\n<svelte:head>\n  <title>{head.title}</title>\n  {#each head.meta as m}\n    <meta {...m} />\n  {/each}\n</svelte:head>\n\n<slot />\n\n<!-- ChildComponent.svelte -->\n<script>\n  import { getHeadContext } from './HeadContext.svelte';\n  import { onMount } from 'svelte';\n  \n  const head = getHeadContext();\n  \n  onMount(() => {\n    head.setTitle('Child Page');\n    head.addMeta({ name: 'description', content: 'Child page description' });\n  });\n</script>\n```\n\n### Limitation 3: Server/Client Synchronization in SSR\n\nWhen using server-side rendering, there can be challenges with keeping the head content synchronized between server and client.\n\n**Problems:**\n- Initial server-rendered head might not match what the client renders after hydration\n- Dynamic content based on client-side data might cause flickering\n\n**Solutions:**\n\n1. **Ensure consistent initial state:**\n```svelte\n<script>\n  export let serverData; // Data passed from server\n  \n  // Use server data for initial render to ensure consistency\n  let pageTitle = serverData.title;\n  let pageDescription = serverData.description;\n</script>\n\n<svelte:head>\n  <title>{pageTitle}</title>\n  <meta name=\"description\" content={pageDescription}>\n</svelte:head>\n```\n\n2. **Prevent flickering with preloaded data:**\n```svelte\n<!-- In SvelteKit -->\n<script>\n  // Load function ensures data is available during SSR\n  export async function load({ fetch }) {\n    const response = await fetch('/api/page-data');\n    const pageData = await response.json();\n    \n    return {\n      pageData\n    };\n  }\n</script>\n\n<script>\n  export let data; // Contains pageData from load function\n  \n  // Head content is consistent between server and client\n  $: pageTitle = data.pageData.title;\n</script>\n\n<svelte:head>\n  <title>{pageTitle}</title>\n</svelte:head>\n```\n\n### Limitation 4: Managing Multiple Instances\n\nWhen multiple components use `<svelte:head>`, it can be challenging to manage priorities and conflicts.\n\n**Problems:**\n- Conflicting meta tags from different components\n- Duplicate tags causing warnings or unexpected behavior\n- Unclear which component's head content takes precedence\n\n**Solutions:**\n\n1. **Implement a priority system:**\n```svelte\n<!-- stores/head.js -->\nimport { writable } from 'svelte/store';\n\n// Store with priority tracking\nexport const headElements = writable([]);\n\nexport function addHeadElement(element, priority = 0) {\n  headElements.update(elements => {\n    // Remove any existing elements with the same key\n    const filtered = elements.filter(e => e.key !== element.key);\n    // Add new element with priority\n    return [...filtered, { ...element, priority }].sort((a, b) => b.priority - a.priority);\n  });\n}\n\nexport function removeHeadElement(key) {\n  headElements.update(elements => elements.filter(e => e.key !== key));\n}\n\n<!-- HeadManager.svelte -->\n<script>\n  import { headElements } from './stores/head';\n  \n  // Get unique elements, with highest priority winning\n  $: uniqueElements = $headElements.reduce((acc, curr) => {\n    // For elements like title where only one can exist, use the highest priority\n    if (curr.type === 'title') {\n      const existing = acc.find(e => e.type === 'title');\n      if (!existing || existing.priority < curr.priority) {\n        return [...acc.filter(e => e.type !== 'title'), curr];\n      }\n      return acc;\n    }\n    \n    // For meta tags, use the name/property as unique key\n    if (curr.type === 'meta') {\n      const key = curr.props.name || curr.props.property;\n      const existing = acc.find(e => \n        e.type === 'meta' && \n        (e.props.name === key || e.props.property === key)\n      );\n      if (!existing || existing.priority < curr.priority) {\n        return [...acc.filter(e => \n          !(e.type === 'meta' && (e.props.name === key || e.props.property === key))\n        ), curr];\n      }\n      return acc;\n    }\n    \n    // For other elements\n    return [...acc, curr];\n  }, []);\n</script>\n\n<svelte:head>\n  {#each uniqueElements as element (element.key)}\n    {#if element.type === 'title'}\n      <title>{element.content}</title>\n    {:else if element.type === 'meta'}\n      <meta {...element.props} />\n    {:else if element.type === 'link'}\n      <link {...element.props} />\n    {:else if element.type === 'script'}\n      <script {...element.props}>{element.content || ''}</script>\n    {/if}\n  {/each}\n</svelte:head>\n\n<!-- Usage in a component -->\n<script>\n  import { onMount, onDestroy } from 'svelte';\n  import { addHeadElement, removeHeadElement } from './stores/head';\n  \n  const PAGE_PRIORITY = 10; // Higher than default\n  \n  onMount(() => {\n    addHeadElement({\n      key: 'page-title',\n      type: 'title',\n      content: 'Product Page',\n      priority: PAGE_PRIORITY\n    });\n    \n    addHeadElement({\n      key: 'page-description',\n      type: 'meta',\n      props: { name: 'description', content: 'Product description' },\n      priority: PAGE_PRIORITY\n    });\n  });\n  \n  onDestroy(() => {\n    removeHeadElement('page-title');\n    removeHeadElement('page-description');\n  });\n</script>\n```\n\n2. **Use component hierarchy for natural precedence:**\n\nIn Svelte, when multiple components use `<svelte:head>`, the more deeply nested component's elements take precedence for unique elements like `<title>`. You can leverage this natural behavior by structuring your component hierarchy to reflect the desired precedence.\n\n```svelte\n<!-- Layout.svelte (parent) -->\n<svelte:head>\n  <title>Site Name</title>\n  <meta name=\"description\" content=\"Default site description\">\n</svelte:head>\n\n<slot />\n\n<!-- Page.svelte (child used inside Layout) -->\n<svelte:head>\n  <title>Page Name | Site Name</title>\n  <meta name=\"description\" content=\"Page-specific description\">\n</svelte:head>\n\n<!-- Feature.svelte (grandchild used inside Page) -->\n<svelte:head>\n  <title>Feature Detail | Page Name | Site Name</title>\n</svelte:head>\n```\n\nBy understanding these limitations and implementing appropriate solutions, you can effectively use `<svelte:head>` even in complex Svelte applications with sophisticated head management requirements."}
{"source":"docs/svelte/05-special-elements/05-svelte-head.md","question":"How can `<svelte:head>` be used to implement advanced features like theme switching, language localization, and social media previews?","answer":"The `<svelte:head>` element can be leveraged to implement advanced web features that enhance user experience and platform integration. Let's explore how to implement theme switching, language localization, and social media previews using `<svelte:head>`.\n\n## Theme Switching\n\nYou can use `<svelte:head>` to dynamically change the appearance of your application by switching CSS themes:\n\n```svelte\n<script>\n  import { writable } from 'svelte/store';\n  import { onMount } from 'svelte';\n  \n  // Create a store for the current theme\n  const theme = writable('light'); // Default theme\n  \n  // Optional: Persist theme preference\n  onMount(() => {\n    // Load theme preference from localStorage\n    const savedTheme = localStorage.getItem('theme-preference');\n    if (savedTheme) {\n      theme.set(savedTheme);\n    } else {\n      // Check for system preference\n      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n      if (prefersDark) {\n        theme.set('dark');\n      }\n    }\n    \n    // Listen for system theme changes\n    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {\n      if (!localStorage.getItem('theme-preference')) {\n        theme.set(e.matches ? 'dark' : 'light');\n      }\n    });\n  });\n  \n  // Function to toggle theme\n  function toggleTheme() {\n    theme.update(current => {\n      const newTheme = current === 'light' ? 'dark' : 'light';\n      localStorage.setItem('theme-preference', newTheme);\n      return newTheme;\n    });\n  }\n  \n  // Reactive variables for theme-specific settings\n  $: themeColor = $theme === 'dark' ? '#121212' : '#ffffff';\n  $: themeClass = $theme;\n</script>\n\n<svelte:head>\n  <!-- Theme color for browser UI -->\n  <meta name=\"theme-color\" content={themeColor}>\n  \n  <!-- Conditional CSS loading -->\n  {#if $theme === 'dark'}\n    <link rel=\"stylesheet\" href=\"/themes/dark.css\">\n  {:else}\n    <link rel=\"stylesheet\" href=\"/themes/light.css\">\n  {/if}\n  \n  <!-- CSS variables approach (alternative) -->\n  <style>\n    :root {\n      --background-color: {$theme === 'dark' ? '#121212' : '#ffffff'};\n      --text-color: {$theme === 'dark' ? '#ffffff' : '#121212'};\n      --primary-color: {$theme === 'dark' ? '#bb86fc' : '#6200ee'};\n      --secondary-color: {$theme === 'dark' ? '#03dac6' : '#03dac6'};\n      --error-color: {$theme === 'dark' ? '#cf6679' : '#b00020'};\n    }\n  </style>\n  \n  <!-- Prevent flash of wrong theme -->\n  <script>\n    // Immediately set the theme class on document before React hydrates\n    document.documentElement.classList.add(\n      localStorage.getItem('theme-preference') || \n      (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')\n    );\n  </script>\n</svelte:head>\n\n<!-- Apply theme class to html element -->\n<svelte:body class={themeClass} />\n\n<button on:click={toggleTheme}>\n  Switch to {$theme === 'light' ? 'dark' : 'light'} mode\n</button>\n```\n\n### Advanced Theme Switching with Prefers-Color-Scheme\n\n```svelte\n<script>\n  import { writable, derived } from 'svelte/store';\n  \n  // Theme preferences\n  const themePreference = writable('system'); // 'light', 'dark', or 'system'\n  const systemDarkMode = writable(false);\n  \n  // Derived store that determines the actual theme\n  const activeTheme = derived(\n    [themePreference, systemDarkMode],\n    ([$pref, $sysDark]) => {\n      if ($pref === 'system') {\n        return $sysDark ? 'dark' : 'light';\n      }\n      return $pref;\n    }\n  );\n  \n  // Initialize on mount\n  onMount(() => {\n    // Load saved preference\n    const saved = localStorage.getItem('theme-preference');\n    if (saved) {\n      themePreference.set(saved);\n    }\n    \n    // Check system preference\n    const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    systemDarkMode.set(darkModeMediaQuery.matches);\n    \n    // Listen for system changes\n    const handleChange = (e) => systemDarkMode.set(e.matches);\n    darkModeMediaQuery.addEventListener('change', handleChange);\n    \n    return () => {\n      darkModeMediaQuery.removeEventListener('change', handleChange);\n    };\n  });\n  \n  // Save preference when it changes\n  $: {\n    if (typeof localStorage !== 'undefined') {\n      localStorage.setItem('theme-preference', $themePreference);\n    }\n  }\n  \n  function setTheme(theme) {\n    themePreference.set(theme);\n  }\n</script>\n\n<svelte:head>\n  <!-- Theme-specific meta tags -->\n  <meta name=\"theme-color\" content={$activeTheme === 'dark' ? '#121212' : '#ffffff'}>\n  <meta name=\"color-scheme\" content={$activeTheme}>\n  \n  <!-- Preload both themes to prevent flash when switching -->\n  <link rel=\"preload\" href=\"/themes/light.css\" as=\"style\">\n  <link rel=\"preload\" href=\"/themes/dark.css\" as=\"style\">\n  \n  <!-- Active theme stylesheet -->\n  <link rel=\"stylesheet\" href={`/themes/${$activeTheme}.css`}>\n  \n  <!-- Prevent flash of wrong theme with inline script -->\n  <script>\n    (function() {\n      function getTheme() {\n        const saved = localStorage.getItem('theme-preference');\n        if (saved === 'light' || saved === 'dark') return saved;\n        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n      }\n      document.documentElement.setAttribute('data-theme', getTheme());\n    })();\n  </script>\n</svelte:head>\n\n<div class=\"theme-controls\">\n  <button class:active={$themePreference === 'light'} on:click={() => setTheme('light')}>\n    Light\n  </button>\n  <button class:active={$themePreference === 'system'} on:click={() => setTheme('system')}>\n    System\n  </button>\n  <button class:active={$themePreference === 'dark'} on:click={() => setTheme('dark')}>\n    Dark\n  </button>\n</div>\n```\n\n## Language Localization\n\nYou can use `<svelte:head>` to implement language localization for your application:\n\n```svelte\n<script>\n  import { writable } from 'svelte/store';\n  import { onMount } from 'svelte';\n  import translations from './translations';\n  \n  // Available languages\n  const languages = [\n    { code: 'en', name: 'English', dir: 'ltr' },\n    { code: 'ar', name: 'Ø§ÙØ¹Ø±Ø¨ÙØ©', dir: 'rtl' },\n    { code: 'es', name: 'EspaÃ±ol', dir: 'ltr' },\n    { code: 'ja', name: 'æ¥æ¬èª', dir: 'ltr' }\n  ];\n  \n  // Current language store\n  const language = writable('en');\n  \n  // Current translations\n  $: currentTranslations = translations[$language] || translations.en;\n  \n  // Current language metadata\n  $: currentLang = languages.find(l => l.code === $language) || languages[0];\n  \n  // Detect browser language on mount\n  onMount(() => {\n    // Check for saved preference\n    const savedLang = localStorage.getItem('language-preference');\n    if (savedLang && languages.some(l => l.code === savedLang)) {\n      language.set(savedLang);\n      return;\n    }\n    \n    // Detect browser language\n    const browserLang = navigator.language.split('-')[0];\n    if (languages.some(l => l.code === browserLang)) {\n      language.set(browserLang);\n    }\n  });\n  \n  // Save language preference when it changes\n  $: {\n    if (typeof localStorage !== 'undefined') {\n      localStorage.setItem('language-preference', $language);\n    }\n  }\n  \n  function setLanguage(langCode) {\n    language.set(langCode);\n  }\n</script>\n\n<svelte:head>\n  <!-- Language attributes -->\n  <html lang={$language} dir={currentLang.dir} />\n  \n  <!-- Localized meta information -->\n  <title>{currentTranslations.pageTitle}</title>\n  <meta name=\"description\" content={currentTranslations.pageDescription} />\n  \n  <!-- Alternate language versions -->\n  {#each languages as lang}\n    <link \n      rel=\"alternate\" \n      hreflang={lang.code} \n      href={`https://mysite.com/${lang.code}${window.location.pathname}`} \n    />\n  {/each}\n  \n  <!-- Default hreflang -->\n  <link rel=\"alternate\" hreflang=\"x-default\" href={`https://mysite.com/en${window.location.pathname}`} />\n  \n  <!-- Language-specific fonts -->\n  {#if $language === 'ar'}\n    <link href=\"https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap\" rel=\"stylesheet\">\n  {:else if $language === 'ja'}\n    <link href=\"https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap\" rel=\"stylesheet\">\n  {:else}\n    <link href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap\" rel=\"stylesheet\">\n  {/if}\n  \n  <!-- Language-specific styles -->\n  <link rel=\"stylesheet\" href={`/styles/lang/${$language}.css`}>\n  \n  <!-- RTL support -->\n  {#if currentLang.dir === 'rtl'}\n    <link rel=\"stylesheet\" href=\"/styles/rtl.css\">\n  {/if}\n</svelte:head>\n\n<div class=\"language-selector\">\n  {#each languages as lang}\n    <button \n      class:active={$language === lang.code}\n      on:click={() => setLanguage("}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"What is the purpose of the `<svelte:element>` component in Svelte, and when would you use it instead of a regular HTML element?","answer":"The `<svelte:element>` component in Svelte allows you to dynamically render an element whose tag name is unknown at author time. It's particularly useful when the element type needs to be determined at runtime, such as when rendering content from a CMS or when implementing a component that needs to adapt its root element based on props or state.\n\nThe basic syntax is:\n```svelte\n<svelte:element this={expression} />\n```\n\nWhere `expression` evaluates to a string representing a valid HTML tag name.\n\nYou would use `<svelte:element>` instead of a regular HTML element when:\n1. The element type comes from an external source (API, CMS, etc.)\n2. You want to create a flexible component where the root element can change\n3. You're building a component library where consumers can specify which element to render\n\nFor example, if you're building a text component that could be a paragraph, heading, or span depending on context:\n\n```svelte\n<script>\n  let tag = $state('p');\n  \n  function changeTag(newTag) {\n    tag = newTag;\n  }\n</script>\n\n<div>\n  <button on:click={() => changeTag('h1')}>Heading 1</button>\n  <button on:click={() => changeTag('h2')}>Heading 2</button>\n  <button on:click={() => changeTag('p')}>Paragraph</button>\n  <button on:click={() => changeTag('span')}>Span</button>\n  \n  <svelte:element this={tag}>\n    This content will render as whatever element is selected\n  </svelte:element>\n</div>\n```\n\nThis approach gives you dynamic control over the rendered element while maintaining all the reactivity and event handling that Svelte provides."}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"What happens if the `this` attribute in `<svelte:element>` has a nullish value? How can this behavior be useful?","answer":"When the `this` attribute in `<svelte:element>` has a nullish value (null or undefined), the element and all of its children will not be rendered at all. This creates a clean way to conditionally render elements without additional wrapper elements or control flow.\n\nFor example:\n\n```svelte\n<script>\n  let elementType = $state('div');\n  \n  function toggleElement() {\n    elementType = elementType ? null : 'div';\n  }\n</script>\n\n<button on:click={toggleElement}>\n  {elementType ? 'Hide Element' : 'Show Element'}\n</button>\n\n<svelte:element this={elementType}>\n  This content will only appear when elementType is not null or undefined.\n</svelte:element>\n```\n\nThis behavior is useful in several scenarios:\n1. Conditional rendering without extra markup\n2. Progressive enhancement where elements might not be available in certain environments\n3. When implementing components that need to wait for data before rendering\n4. For accessibility patterns where elements should be completely removed rather than just hidden\n\nYou can also use this pattern with async data:\n\n```svelte\n<script>\n  let data = $state(null);\n  let elementType = $derived(data ? 'article' : null);\n  \n  // Fetch data from an API\n  async function fetchData() {\n    const response = await fetch('/api/content');\n    data = await response.json();\n  }\n  \n  fetchData();\n</script>\n\n<svelte:element this={elementType}>\n  {#if data}\n    <h1>{data.title}</h1>\n    <p>{data.content}</p>\n  {/if}\n</svelte:element>\n```\n\nIn this example, nothing will render until the data is loaded, and then it will appear as an article element."}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"What limitations exist when using `<svelte:element>` with void elements like `<hr>` or `<br>`?","answer":"When using `<svelte:element>` with void elements (self-closing elements like `<hr>`, `<br>`, `<img>`, etc.), you need to be careful about adding child content. Void elements cannot contain children by definition, and Svelte will throw a runtime error in development mode if you attempt to place content inside a `<svelte:element>` that resolves to a void element.\n\nFor example, this code will cause a runtime error:\n\n```svelte\n<script>\n  let tag = $state('hr');\n</script>\n\n<svelte:element this={tag}>\n  This text cannot appear inside an hr element\n</svelte:element>\n```\n\nThe error occurs because `<hr>` is a void element and cannot contain child nodes, but the `<svelte:element>` has text content.\n\nTo handle this situation properly, you have several options:\n\n1. Ensure void elements don't have children:\n\n```svelte\n<script>\n  let tag = $state('div');\n  let content = $state('Some content');\n  \n  // List of void elements to check against\n  const voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', \n                       'link', 'meta', 'param', 'source', 'track', 'wbr'];\n</script>\n\n{#if voidElements.includes(tag)}\n  <svelte:element this={tag} />\n{:else}\n  <svelte:element this={tag}>\n    {content}\n  </svelte:element>\n{/if}\n```\n\n2. Conditionally render content based on the element type:\n\n```svelte\n<script>\n  let tag = $state('div');\n  let content = $state('Some content');\n  \n  const isVoidElement = $derived(['area', 'base', 'br', 'col', 'embed', 'hr', \n                                'img', 'input', 'link', 'meta', 'param', \n                                'source', 'track', 'wbr'].includes(tag));\n</script>\n\n<svelte:element this={tag}>\n  {#if !isVoidElement}\n    {content}\n  {/if}\n</svelte:element>\n```\n\nThis limitation exists because Svelte tries to maintain proper HTML semantics even when using dynamic elements. Being aware of this constraint helps you build more robust components that won't break when the element type changes."}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"Which binding is supported with `<svelte:element>` and why are other Svelte bindings not available?","answer":"With `<svelte:element>`, the only supported binding is `bind:this`. This binding allows you to get a reference to the actual DOM element that gets created. Other Svelte bindings (like `bind:value`, `bind:checked`, etc.) are not available when using `<svelte:element>`.\n\nThe reason other bindings aren't supported is that Svelte's built-in bindings are designed to work with specific element types. For example, `bind:value` works with `<input>`, `<select>`, and `<textarea>` elements, but has different behaviors depending on the element type and its attributes. Since `<svelte:element>` can render any element, Svelte cannot determine at compile time which bindings would be appropriate or how they should behave.\n\nHere's an example of using the supported `bind:this` binding:\n\n```svelte\n<script>\n  let tag = $state('div');\n  let elementRef = $state(null);\n  \n  function focusElement() {\n    if (elementRef && typeof elementRef.focus === 'function') {\n      elementRef.focus();\n    }\n  }\n  \n  function changeTag() {\n    tag = tag === 'div' ? 'input' : 'div';\n  }\n</script>\n\n<button on:click={changeTag}>Change to {tag === 'div' ? 'input' : 'div'}</button>\n<button on:click={focusElement}>Focus element</button>\n\n<svelte:element this={tag} bind:this={elementRef} tabindex=\"0\">\n  {#if tag !== 'input'}\n    This is a {tag} element\n  {/if}\n</svelte:element>\n```\n\nIf you need to work with element-specific properties, you'll need to handle them manually using the element reference or through event handlers:\n\n```svelte\n<script>\n  let tag = $state('input');\n  let elementRef = $state(null);\n  let value = $state('');\n  \n  function handleInput(event) {\n    value = event.target.value;\n  }\n</script>\n\n<svelte:element \n  this={tag} \n  bind:this={elementRef}\n  value={value}\n  on:input={handleInput}\n  type=\"text\"\n  placeholder=\"Type something...\"\n/>\n\n<p>Current value: {value}</p>\n```\n\nIn this example, we're manually tracking the input value through an event handler rather than using `bind:value`, which would work with a regular `<input>` element but isn't available with `<svelte:element>`."}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"How does Svelte handle namespaces with `<svelte:element>`, and when would you need to explicitly set the namespace?","answer":"Svelte tries to infer the correct namespace for elements rendered with `<svelte:element>` based on their context in the document. However, there are situations where Svelte cannot automatically determine the appropriate namespace, especially when dynamically rendering SVG or MathML elements.\n\nIn these cases, you can explicitly set the namespace using the `xmlns` attribute:\n\n```svelte\n<svelte:element this={tag} xmlns=\"http://www.w3.org/2000/svg\" />\n```\n\nYou would need to explicitly set the namespace in the following scenarios:\n\n1. When rendering SVG elements outside an `<svg>` context:\n\n```svelte\n<script>\n  let svgElement = $state('circle');\n  let htmlElement = $state('div');\n</script>\n\n<!-- Inside SVG, namespace is inferred -->\n<svg>\n  <svelte:element this={svgElement} cx=\"50\" cy=\"50\" r=\"40\" fill=\"red\" />\n</svg>\n\n<!-- Outside SVG, namespace must be explicit -->\n<svelte:element \n  this={svgElement} \n  xmlns=\"http://www.w3.org/2000/svg\"\n  cx=\"50\" \n  cy=\"50\" \n  r=\"40\" \n  fill=\"blue\" \n/>\n\n<!-- HTML elements use the default HTML namespace -->\n<svelte:element this={htmlElement}>\n  This is in the HTML namespace\n</svelte:element>\n```\n\n2. When dynamically switching between HTML and SVG elements:\n\n```svelte\n<script>\n  let elementType = $state('div');\n  \n  function toggleElementType() {\n    elementType = elementType === 'div' ? 'circle' : 'div';\n  }\n  \n  $effect(() => {\n    console.log(`Element type is now: ${elementType}`);\n  });\n  \n  const isSvgElement = $derived(['circle', 'rect', 'path', 'svg', 'g'].includes(elementType));\n</script>\n\n<button on:click={toggleElementType}>\n  Toggle to {elementType === 'div' ? 'circle' : 'div'}\n</button>\n\n<svelte:element \n  this={elementType}\n  xmlns={isSvgElement ? \"http://www.w3.org/2000/svg\" : undefined}\n  cx={isSvgElement ? \"50\" : undefined}\n  cy={isSvgElement ? \"50\" : undefined}\n  r={isSvgElement ? \"40\" : undefined}\n  fill={isSvgElement ? \"purple\" : undefined}\n  style={!isSvgElement ? \"padding: 20px; border: 1px solid black;\" : undefined}\n>\n  {#if !isSvgElement}\n    This is an HTML element\n  {/if}\n</svelte:element>\n```\n\n3. For MathML elements (less common):\n\n```svelte\n<script>\n  let mathElement = $state('math');\n</script>\n\n<svelte:element this={mathElement} xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>x</mi>\n  <mo>+</mo>\n  <mn>1</mn>\n</svelte:element>\n```\n\nBy explicitly setting the namespace, you ensure that the browser correctly interprets and renders the element with the appropriate rules and behaviors for that namespace."}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"What are the restrictions on what values can be used for the `this` attribute in `<svelte:element>`?","answer":"The `this` attribute in `<svelte:element>` has several important restrictions on what values can be used:\n\n1. It must be a valid DOM element tag name (a string representing an HTML, SVG, or MathML element).\n2. It cannot be special values like `#text` that represent non-element DOM nodes.\n3. It cannot be Svelte-specific elements like `svelte:head`, `svelte:component`, etc.\n4. It cannot be component names (you should use `<svelte:component>` for that purpose).\n\nThese restrictions exist because `<svelte:element>` is specifically designed to render standard DOM elements with dynamic tag names, not to render arbitrary DOM nodes or components.\n\nHere are examples of valid and invalid uses:\n\n```svelte\n<script>\n  // Valid tag names\n  let validTag1 = $state('div');\n  let validTag2 = $state('span');\n  let validTag3 = $state('custom-element'); // Custom elements are valid\n  let validTag4 = $state('circle'); // SVG elements are valid\n  \n  // Invalid values\n  let invalidTag1 = $state('#text');\n  let invalidTag2 = $state('svelte:head');\n  let invalidTag3 = $state('MyComponent');\n  let invalidTag4 = $state({}); // Non-string values are invalid\n</script>\n\n<!-- These will work -->\n<svelte:element this={validTag1}>Valid div</svelte:element>\n<svelte:element this={validTag2}>Valid span</svelte:element>\n<svelte:element this={validTag3}>Valid custom element</svelte:element>\n<svg>\n  <svelte:element this={validTag4} cx=\"50\" cy=\"50\" r=\"40\" />\n</svg>\n\n<!-- These will cause errors -->\n<!-- Cannot render text nodes directly -->\n<svelte:element this={invalidTag1}>Won't work</svelte:element>\n\n<!-- Cannot render Svelte special elements -->\n<svelte:element this={invalidTag2}>Won't work</svelte:element>\n\n<!-- Cannot render components -->\n<svelte:element this={invalidTag3}>Won't work</svelte:element>\n\n<!-- Non-string values are invalid -->\n<svelte:element this={invalidTag4}>Won't work</svelte:element>\n```\n\nIf you need to dynamically render components rather than DOM elements, you should use `<svelte:component>` instead:\n\n```svelte\n<script>\n  import MyComponent from './MyComponent.svelte';\n  import OtherComponent from './OtherComponent.svelte';\n  \n  let currentComponent = $state(MyComponent);\n  \n  function toggleComponent() {\n    currentComponent = currentComponent === MyComponent ? OtherComponent : MyComponent;\n  }\n</script>\n\n<button on:click={toggleComponent}>Toggle Component</button>\n\n<!-- Use svelte:component for components -->\n<svelte:component this={currentComponent} />\n\n<!-- Use svelte:element for DOM elements -->\n<svelte:element this=\"div\">This is a div</svelte:element>\n```\n\nUnderstanding these restrictions helps you choose the right Svelte special element for your specific use case."}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"How can you use `<svelte:element>` to create a flexible component that adapts its root element based on props?","answer":"You can use `<svelte:element>` to create flexible, adaptable components by allowing consumers to specify which root element to render through props. This pattern is commonly known as \"polymorphic components\" and is especially useful for UI component libraries.\n\nHere's a complete example of how to implement a flexible Box component that can render as any HTML element:\n\n```svelte\n<!-- Box.svelte -->\n<script>\n  // Allow consumers to specify which element to render\n  export let as = $state('div');\n  \n  // Common props that might be used regardless of element type\n  export let id = $state(undefined);\n  export let className = $state('');\n  export let style = $state('');\n  \n  // Pass all other props to the element\n  export let props = $state({});\n</script>\n\n<svelte:element \n  this={as}\n  id={id}\n  class={className}\n  {style}\n  {...props}\n>\n  <slot></slot>\n</svelte:element>\n```\n\nNow you can use this component in various ways:\n\n```svelte\n<!-- App.svelte -->\n<script>\n  import Box from './Box.svelte';\n</script>\n\n<!-- As a div (default) -->\n<Box className=\"container\">\n  This is a div box\n</Box>\n\n<!-- As a section with ID -->\n<Box as=\"section\" id=\"main-section\" className=\"section-box\">\n  This is a section box\n</Box>\n\n<!-- As a button with event handlers -->\n<Box \n  as=\"button\"\n  className=\"button primary\"\n  props={{\n    onClick: () => alert('Button clicked!'),\n    type: 'button',\n    disabled: false\n  }}\n>\n  Click Me\n</Box>\n\n<!-- As a link -->\n<Box \n  as=\"a\"\n  props={{\n    href: \"https://svelte.dev\",\n    target: \"_blank\",\n    rel: \"noopener noreferrer\"\n  }}\n>\n  Go to Svelte\n</Box>\n```\n\nYou can extend this pattern to create more specific components. For example, a Text component that adapts its semantic meaning:\n\n```svelte\n<!-- Text.svelte -->\n<script>\n  export let as = $state('p');\n  export let size = $state('medium'); // 'small', 'medium', 'large'\n  export let weight = $state('normal'); // 'normal', 'bold'\n  export let color = $state('inherit');\n  \n  // Map size values to actual CSS classes\n  const sizeClasses = {\n    small: 'text-sm',\n    medium: 'text-md',\n    large: 'text-lg'\n  };\n  \n  // Compute the final className\n  const computedClass = $derived([\n    sizeClasses[size] || '',\n    weight === 'bold' ? 'font-bold' : '',\n    'text-component'\n  ].filter(Boolean).join(' '));\n  \n  // Compute the style\n  const computedStyle = $derived(`color: ${color};`);\n</script>\n\n<svelte:element\n  this={as}\n  class={computedClass}\n  style={computedStyle}\n>\n  <slot></slot>\n</svelte:element>\n\n<style>\n  .text-sm { font-size: 0.875rem; line-height: 1.25rem; }\n  .text-md { font-size: 1rem; line-height: 1.5rem; }\n  .text-lg { font-size: 1.125rem; line-height: 1.75rem; }\n  .font-bold { font-weight: 700; }\n  .text-component { margin: 0; }\n</style>\n```\n\nUsage:\n\n```svelte\n<script>\n  import Text from './Text.svelte';\n</script>\n\n<Text>Default paragraph</Text>\n\n<Text as=\"h1\" size=\"large\" weight=\"bold\" color=\"#333\">\n  This is a heading\n</Text>\n\n<Text as=\"span\" size=\"small\" color=\"#666\">\n  This is small inline text\n</Text>\n\n<Text as=\"blockquote\" style=\"border-left: 3px solid #ccc; padding-left: 1rem;\">\n  This is a blockquote with custom styling\n</Text>\n```\n\nThis approach provides several benefits:\n1. Semantic HTML - components can adapt to the proper semantic element\n2. Flexibility - one component can serve multiple purposes\n3. Consistency - styling and behavior remain consistent regardless of the rendered element\n4. Developer experience - intuitive API that mirrors HTML but with enhanced capabilities\n\nThe key is to carefully manage which props are applied directly to the element and which ones are processed by your component logic."}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"How can you handle event listeners and attributes dynamically with `<svelte:element>`?","answer":"The `<svelte:element>` component allows you to pass event listeners and attributes dynamically, just like with regular HTML elements. This is particularly useful when building flexible components where both the element type and its properties might change at runtime.\n\nHere's how to handle event listeners and attributes dynamically:\n\n```svelte\n<script>\n  let elementType = $state('button');\n  let attributes = $state({\n    id: 'dynamic-element',\n    class: 'primary',\n    style: 'padding: 10px; border-radius: 4px;',\n    'data-testid': 'test-element'\n  });\n  \n  // Update attributes dynamically\n  function updateAttributes() {\n    attributes = {\n      ...attributes,\n      class: attributes.class === 'primary' ? 'secondary' : 'primary',\n      style: attributes.class === 'primary' \n        ? 'padding: 10px; border-radius: 4px; background: blue; color: white;' \n        : 'padding: 10px; border-radius: 4px; background: green; color: white;'\n    };\n  }\n  \n  // Event handlers\n  function handleClick(event) {\n    console.log('Element clicked:', event);\n    updateAttributes();\n  }\n  \n  function handleMouseOver(event) {\n    console.log('Mouse over element:', event);\n  }\n  \n  function changeElementType() {\n    elementType = elementType === 'button' ? 'div' : 'button';\n  }\n</script>\n\n<div>\n  <button on:click={changeElementType}>\n    Change to {elementType === 'button' ? 'div' : 'button'}\n  </button>\n  \n  <svelte:element \n    this={elementType}\n    {...attributes}\n    on:click={handleClick}\n    on:mouseover={handleMouseOver}\n    disabled={elementType === 'button' ? false : undefined}\n  >\n    I am a {elementType} with dynamic attributes and events\n  </svelte:element>\n</div>\n```\n\nFor more complex scenarios, you might want to conditionally apply certain attributes or event listeners based on the element type:\n\n```svelte\n<script>\n  let elementType = $state('input');\n  let value = $state('');\n  \n  // Different attributes for different elements\n  const elementAttributes = $derived(() => {\n    switch (elementType) {\n      case 'input':\n        return {\n          type: 'text',\n          placeholder: 'Type something...',\n          value\n        };\n      case 'button':\n        return {\n          type: 'button'\n        };\n      case 'a':\n        return {\n          href: 'https://svelte.dev',\n          target: '_blank',\n          rel: 'noopener noreferrer'\n        };\n      default:\n        return {};\n    }\n  });\n  \n  // Different event handlers for different elements\n  function handleInputChange(event) {\n    value = event.target.value;\n  }\n  \n  function handleButtonClick() {\n    alert('Button clicked! Current value: ' + value);\n  }\n  \n  function handleLinkClick(event) {\n    if (!confirm('Navigate to external site?')) {\n      event.preventDefault();\n    }\n  }\n</script>\n\n<div>\n  <div>\n    <button on:click={() => elementType = 'input'}>Input</button>\n    <button on:click={() => elementType = 'button'}>Button</button>\n    <button on:click={() => elementType = 'a'}>Link</button>\n    <button on:click={() => elementType = 'div'}>Div</button>\n  </div>\n  \n  <svelte:element \n    this={elementType}\n    {...elementAttributes}\n    on:input={elementType === 'input' ? handleInputChange : undefined}\n    on:click={elementType === 'button' ? handleButtonClick : undefined}\n    on:click={elementType === 'a' ? handleLinkClick : undefined}\n  >\n    {elementType !== 'input' ? `I am a ${elementType} element` : ''}\n  </svelte:element>\n  \n  {#if value}\n    <p>Current value: {value}</p>\n  {/if}\n</div>\n```\n\nYou can also create a more generic approach using a helper function:\n\n```svelte\n<script>\n  let elementType = $state('div');\n  \n  // Helper function to get appropriate props based on element type\n  function getElementProps(type) {\n    const baseProps = {\n      class: 'base-element',\n      'data-element-type': type\n    };\n    \n    const typeSpecificProps = {\n      'a': {\n        href: '#',\n        class: 'link-element'\n      },\n      'button': {\n        type: 'button',\n        class: 'button-element'\n      },\n      'input': {\n        type: 'text',\n        placeholder: 'Enter text...',\n        class: 'input-element'\n      }\n    };\n    \n    return {\n      ...baseProps,\n      ...(typeSpecificProps[type] || {})\n    };\n  }\n  \n  // Dynamic event handler that adapts to element type\n  function handleInteraction(event) {\n    console.log(`Interaction with ${elementType}:`, event);\n    \n    if (elementType === 'input') {\n      console.log('Input value:', event.target.value);\n    }\n  }\n</script>\n\n<div>\n  <select bind:value={elementType}>\n    <option value=\"div\">Div</option>\n    <option value=\"span\">Span</option>\n    <option value=\"a\">Link</option>\n    <option value=\"button\">Button</option>\n    <option value=\"input\">Input</option>\n  </select>\n  \n  <svelte:element \n    this={elementType}\n    {...getElementProps(elementType)}\n    on:click={handleInteraction}\n    on:input={elementType === 'input' ? handleInteraction : undefined}\n  >\n    {elementType !== 'input' ? `This is a ${elementType} element` : ''}\n  </svelte:element>\n</div>\n\n<style>\n  .base-element {\n    margin: 10px 0;\n    padding: 8px;\n  }\n  \n  .link-element {\n    color: blue;\n    text-decoration: underline;\n  }\n  \n  .button-element {\n    background: #4CAF50;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n  \n  .input-element {\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    padding: 8px;\n  }\n</style>\n```\n\nThis approach allows you to build highly adaptable components that can change not just their appearance but their entire behavior based on the current context or user preferences."}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"What are some practical use cases for `<svelte:element>` in a real-world application?","answer":"The `<svelte:element>` component offers significant flexibility in Svelte applications. Here are some practical real-world use cases where it shines:\n\n### 1. Rendering CMS Content\n\nWhen working with content from a headless CMS that includes HTML structure information:\n\n```svelte\n<script>\n  let cmsContent = $state([\n    { type: 'h1', content: 'Welcome to our site' },\n    { type: 'p', content: 'This is a paragraph from the CMS.' },\n    { type: 'blockquote', content: 'An important quote here.', attributes: { class: 'highlight' } },\n    { type: 'ul', content: [\n      { type: 'li', content: 'First item' },\n      { type: 'li', content: 'Second item' }\n    ]}\n  ]);\n  \n  // Recursive component to render nested content\n  function renderContent(item) {\n    if (Array.isArray(item.content)) {\n      return item.content.map(child => renderContent(child)).join('');\n    }\n    return item.content;\n  }\n</script>\n\n<div class=\"cms-content\">\n  {#each cmsContent as item}\n    {#if Array.isArray(item.content)}\n      <svelte:element this={item.type} {...(item.attributes || {})}>\n        {#each item.content as child}\n          <svelte:element this={child.type} {...(child.attributes || {})}>\n            {renderContent(child)}\n          </svelte:element>\n        {/each}\n      </svelte:element>\n    {:else}\n      <svelte:element this={item.type} {...(item.attributes || {})}>\n        {item.content}\n      </svelte:element>\n    {/if}\n  {/each}\n</div>\n```\n\n### 2. Accessible Component Library\n\nCreating components that adapt their semantic meaning based on context:\n\n```svelte\n<!-- Button.svelte -->\n<script>\n  // Button can render as different elements while maintaining styling\n  export let as = $state('button');\n  export let variant = $state('primary');\n  export let size = $state('medium');\n  export let disabled = $state(false);\n  export let href = $state(undefined);\n  \n  // Determine the correct element based on props\n  const element = $derived(() => {\n    // If href is provided, it should be a link\n    if (href && !disabled) return 'a';\n    // Otherwise use the specified element or default to button\n    return as || 'button';\n  });\n  \n  // Compute classes based on props\n  const classes = $derived([\n    'btn',\n    `btn-${variant}`,\n    `btn-${size}`,\n    disabled ? 'btn-disabled' : ''\n  ].filter(Boolean).join(' '));\n  \n  // Compute element-specific attributes\n  const elementAttrs = $derived(() => {\n    if (element === 'a') {\n      return href ? { href, role: 'button' } : {};\n    }\n    \n    if (element === 'button') {\n      return { type: 'button', disabled };\n    }\n    \n    // For other elements, add aria attributes for accessibility\n    return { \n      role: 'button',\n      tabindex: disabled ? undefined : '0',\n      'aria-disabled': disabled ? 'true' : undefined\n    };\n  });\n  \n  // Handle keyboard interactions for non-button/link elements\n  function handleKeyDown(event) {\n    if (disabled) return;\n    if (element !== 'button' && element !== 'a' && (event.key === 'Enter' || event.key === ' ')) {\n      event.preventDefault();\n      event.target.click();\n    }\n  }\n</script>\n\n<svelte:element \n  this={element}\n  class={classes}\n  {...elementAttrs}\n  on:click\n  on:keydown={handleKeyDown}\n>\n  <slot></slot>\n</svelte:element>\n\n<style>\n  .btn {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: 4px;\n    font-weight: 500;\n    cursor: pointer;\n    text-decoration: none;\n  }\n  \n  .btn-primary {\n    background-color: #0066cc;\n    color: white;\n    border: none;\n  }\n  \n  .btn-secondary {\n    background-color: transparent;\n    color: #0066cc;\n    border: 1px solid #0066cc;\n  }\n  \n  .btn-small { padding: 6px 12px; font-size: 14px; }\n  .btn-medium { padding: 8px 16px; font-size: 16px; }\n  .btn-large { padding: 12px 24px; font-size: 18px; }\n  \n  .btn-disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n</style>\n```\n\nUsage:\n\n```svelte\n<script>\n  import Button from './Button.svelte';\n</script>\n\n<!-- Regular button -->\n<Button on:click={() => alert('Clicked!')}>Click Me</Button>\n\n<!-- Link that looks like a button -->\n<Button href=\"/dashboard\" variant=\"secondary\">Go to Dashboard</Button>\n\n<!-- Span that acts like a button (for special layout needs) -->\n<Button as=\"span\" size=\"large\">Span Button</Button>\n\n<!-- Disabled state -->\n<Button disabled>Cannot Click</Button>\n```\n\n### 3. Dynamic Form Elements\n\nCreating a flexible form field component:\n\n```svelte\n<!-- FormField.svelte -->\n<script>\n  export let type = $state('text'); // text, textarea, select, etc.\n  export let label = $state('');\n  export let name = $state('');\n  export let value = $state('');\n  export let options = $state([]);\n  export let required = $state(false);\n  export let error = $state('');\n  \n  // Map field types to actual elements\n  const elementMap = {\n    'text': 'input',\n    'email': 'input',\n    'password': 'input',\n    'number': 'input',\n    'date': 'input',\n    'checkbox': 'input',\n    'radio': 'input',\n    'textarea': 'textarea',\n    'select': 'select'\n  };\n  \n  const element = $derived(elementMap[type] || 'input');\n  \n  function handleInput(event) {\n    if (type === 'checkbox') {\n      value = event.target.checked;\n    } else {\n      value = event.target.value;\n    }\n  }\n</script>\n\n<div class=\"form-field {error ? 'has-error' : ''}\">\n  {#if label}\n    <label for={name}>{label} {required ? '*' : ''}</label>\n  {/if}\n  \n  {#if element === 'select'}\n    <select \n      {name}\n      id={name}\n      bind:value\n      required={required}\n      aria-invalid={error ? 'true' : 'false'}\n    >\n      {#each options as option}\n        <option value={option.value}>{option.label}</option>\n      {/each}\n    </select>\n  {:else if element === 'textarea'}\n    <textarea\n      {name}\n      id={name}\n      bind:value\n      required={required}\n      aria-invalid={error ? 'true' : 'false'}\n    ></textarea>\n  {:else}\n    <svelte:element\n      this={element}\n      type={type}\n      {name}\n      id={name}\n      value={type !== 'checkbox' ? value : undefined}\n      checked={type === 'checkbox' ? value : undefined}\n      on:input={handleInput}\n      required={required}\n      aria-invalid={error ? 'true' : 'false'}\n    />\n  {/if}\n  \n  {#if error}\n    <div class=\"error-message\">{error}</div>\n  {/if}\n</div>\n\n<style>\n  .form-field {\n    margin-bottom: 16px;\n  }\n  \n  label {\n    display: block;\n    margin-bottom: 4px;\n    font-weight: 500;\n  }\n  \n  input, select, textarea {\n    width: 100%;\n    padding: 8px;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n  \n  .has-error input, \n  .has-error select, \n  .has-error textarea {\n    border-color: #dc3545;\n  }\n  \n  .error-message {\n    color: #dc3545;\n    font-size: 14px;\n    margin-top: 4px;\n  }\n</style>\n```\n\nUsage:\n\n```svelte\n<script>\n  import FormField from './FormField.svelte';\n  \n  let formData = $state({\n    name: '',\n    email: '',\n    message: '',\n    preference: '',\n    subscribe: false\n  });\n  \n  let errors = $state({});\n  \n  function validateForm() {\n    let valid = true;\n    let newErrors = {};\n    \n    if (!formData.name) {\n      newErrors.name = 'Name is required';\n      valid = false;\n    }\n    \n    if (!formData.email) {\n      newErrors.email = 'Email is required';\n      valid = false;\n    } else if (!/\\S+@\\S+\\.\\S+/.test(formData.email)) {\n      newErrors.email = 'Email is invalid';\n      valid = false;\n    }\n    \n    errors = newErrors;\n    return valid;\n  }\n  \n  function handleSubmit() {\n    if (validateForm()) {\n      alert('Form submitted successfully!');\n      console.log(formData);\n    }\n  }\n</script>\n\n<form on:submit|preventDefault={handleSubmit}>\n  <FormField\n    type=\"text\"\n    label=\"Name\"\n    name=\"name\"\n    bind:value={formData.name}\n    required={true}\n    error={errors.name}\n  />\n  \n  <FormField\n    type=\"email\"\n    label=\"Email\"\n    name=\"email\"\n    bind:value={formData.email}\n    required={true}\n    error={errors.email}\n  />\n  \n  <FormField\n    type=\"textarea\"\n    label=\"Message\"\n    name=\"message\"\n    bind:value={formData.message}\n  />\n  \n  <FormField\n    type=\"select\"\n    label=\"Preference\"\n    name=\"preference\"\n    bind:value={formData.preference}\n    options={[\n      { value: '', label: 'Select an option' },\n      { value: 'option1', label: 'Option 1' },\n      { value: 'option2', label: 'Option 2' }\n    ]}\n  />\n  \n  <FormField\n    type=\"checkbox\"\n    label=\"Subscribe to newsletter\"\n    name=\"subscribe\"\n    bind:value={formData.subscribe}\n  />\n  \n  <button type=\"submit\">Submit</button>\n</form>\n```\n\n### 4. Markdown/Rich Text Renderer\n\nRendering markdown or rich text content with proper HTML elements:\n\n```svelte\n<script>\n  import { marked } from 'marked';\n  \n  export let markdown = $state('# Hello\\n\\nThis is a **markdown** paragraph.');\n  \n  // Parse markdown to HTML nodes\n  const tokens = $derived(marked.lexer(markdown));\n  \n  // Process tokens to a renderable format\n  const elements = $derived(tokens.map(token => {\n    switch (token.type) {\n      case 'heading':\n        return {\n          tag: `h${token.depth}`,\n          content: token.text,\n          attrs: { id: token.text.toLowerCase().replace(/\\s+/g, '-') }\n        };\n      case 'paragraph':\n        return { tag: 'p', content: token.text };\n      case 'list':\n        return { \n          tag: token.ordered ? 'ol' : 'ul',\n          items: token.items.map(item => item.text)\n        };\n      case 'code':\n        return { \n          tag: 'pre',\n          content: token.text,\n          attrs: { class: `language-${token.lang || 'text'}` }\n        };\n      case 'blockquote':\n        return { tag: 'blockquote', content: token.text };\n      case 'hr':\n        return { tag: 'hr' };\n      default:\n        return { tag: 'div', content: token.raw };\n    }\n  }));\n</script>\n\n<div class=\"markdown-content\">\n  {#each elements as element}\n    {#if element.tag === 'hr'}\n      <hr>\n    {:else if element.items}\n      <svelte:element this={element.tag}>\n        {#each element.items as item}\n          <li>{item}</li>\n        {/each}\n      </svelte:element>\n    {:else}\n      <svelte:element this={element.tag} {...(element.attrs || {})}>\n        {element.content}\n      </svelte:element>\n    {/if}\n  {/each}\n</div>\n\n<style>\n  .markdown-content {\n    line-height: 1.6;\n  }\n  \n  .markdown-content :global(h1),\n  .markdown-content :global(h2),\n  .markdown-content :global(h3),\n  .markdown-content :global(h4),\n  .markdown-content :global(h5),\n  .markdown-content :global(h6) {\n    margin-top: 1.5em;\n    margin-bottom: 0.5em;\n  }\n  \n  .markdown-content :global(p) {\n    margin-bottom: 1em;\n  }\n  \n  .markdown-content :global(pre) {\n    background: #f4f4f4;\n    padding: 1em;\n    border-radius: 4px;\n    overflow-x: auto;\n  }\n  \n  .markdown-content :global(blockquote) {\n    border-left: 3px solid #ccc;\n    padding-left: 1em;\n    font-style: italic;\n  }\n</style>\n```\n\nThese examples demonstrate how `<svelte:element>` can be used to create flexible, maintainable, and accessible components in real-world applications."}
{"source":"docs/svelte/05-special-elements/06-svelte-element.md","question":"How does `<svelte:element>` differ from `<svelte:component>`, and when should you use one over the other?","answer":"`<svelte:element>` and `<svelte:component>` are both special Svelte elements that enable dynamic rendering, but they serve different purposes and have distinct use cases. Understanding their differences is crucial for using them correctly in your Svelte applications.\n\n### Key Differences\n\n| Feature | `<svelte:element>` | `<svelte:component>` |\n|---------|-------------------|----------------------|\n| Purpose | Renders a DOM element with a dynamic tag name | Renders a Svelte component dynamically |\n| Value of `this` | String representing a valid HTML/SVG tag name | A Svelte component constructor |\n| Bindings | Only supports `bind:this` | Supports all bindings that the component exposes |\n| Props | Attributes are passed to the DOM element | Props are passed to the component |\n| Events | DOM events from the element | Events dispatched by the component |\n| Slots | Can contain children like regular elements | Can pass slot content to the component |\n\n### When to Use `<svelte:element>`\n\nUse `<svelte:element>` when:\n\n1. You need to render a standard HTML or SVG element whose tag name is determined at runtime\n2. You're building flexible UI components that adapt their semantic meaning\n3. You're rendering content from a CMS that specifies HTML structure\n4. You want to create polymorphic components that can render as different elements while maintaining consistent styling\n\nExample of `<svelte:element>`:\n\n```svelte\n<script>\n  let tagName = $state('div');\n  \n  function changeElement() {\n    // Cycle through different HTML elements\n    const elements = ['div', 'section', 'article', 'aside'];\n    const currentIndex = elements.indexOf(tagName);\n    tagName = elements[(currentIndex + 1) % elements.length];\n  }\n</script>\n\n<button on:click={changeElement}>\n  Change to {tagName === 'div' ? 'section' : tagName === 'section' ? 'article' : tagName === 'article' ? 'aside' : 'div'}\n</button>\n\n<svelte:element this={tagName} class=\"container\">\n  I am a {tagName} element\n</svelte:element>\n```\n\n### When to Use `<svelte:component>`\n\nUse `<svelte:component>` when:\n\n1. You need to render different Svelte components based on some condition\n2. You're implementing a component registry or factory pattern\n3. You want to lazy-load components\n4. You're building a plugin system where components can be registered dynamically\n\nExample of `<svelte:component>`:\n\n```svelte\n<script>\n  import ComponentA from './ComponentA.svelte';\n  import ComponentB from './ComponentB.svelte';\n  import ComponentC from './ComponentC.svelte';\n  \n  let activeComponent = $state(ComponentA);\n  \n  const components = [\n    { name: 'Component A', component: ComponentA },\n    { name: 'Component B', component: ComponentB },\n    { name: 'Component C', component: ComponentC }\n  ];\n</script>\n\n<div>\n  <div class=\"component-selector\">\n    {#each components as { name, component }}\n      <button \n        on:click={() => activeComponent = component}\n        class:active={activeComponent === component}\n      >\n        {name}\n      </button>\n    {/each}\n  </div>\n  \n  <div class=\"component-container\">\n    <svelte:component this={activeComponent} />\n  </div>\n</div>\n```\n\n### Practical Comparison\n\nHere's a practical comparison showing when to use each:\n\n```svelte\n<script>\n  import Button from './Button.svelte';\n  import Card from './Card.svelte';\n  import Alert from './Alert.svelte';\n  \n  // For svelte:component - different component types\n  let componentType = $state('button');\n  let componentMap = {\n    'button': Button,\n    'card': Card,\n    'alert': Alert\n  };\n  \n  // For svelte:element - different HTML elements\n  let elementType = $state('div');\n  \n  // Component props\n  let buttonProps = $state({\n    variant: 'primary',\n    size: 'medium',\n    disabled: false\n  });\n  \n  // Element attributes\n  let elementAttrs = $state({\n    class: 'custom-element',\n    'data-testid': 'test-element'\n  });\n</script>\n\n<div class=\"demo\">\n  <div class=\"controls\">\n    <div>\n      <h3>Component Type</h3>\n      <select bind:value={componentType}>\n        <option value=\"button\">Button</option>\n        <option value=\"card\">Card</option>\n        <option value=\"alert\">Alert</option>\n      </select>\n    </div>\n    \n    <div>\n      <h3>Element Type</h3>\n      <select bind:value={elementType}>\n        <option value=\"div\">div</option>\n        <option value=\"section\">section</option>\n        <option value=\"article\">article</option>\n        <option value=\"span\">span</option>\n      </select>\n    </div>\n  </div>\n  \n  <div class=\"examples\">\n    <div class=\"example\">\n      <h2>svelte:component Example</h2>\n      <!-- Using svelte:component for dynamic components -->\n      <svelte:component \n        this={componentMap[componentType]} \n        {...(componentType === 'button' ? buttonProps : {})}\n        on:click={() => alert(`${componentType} clicked!`)}\n      >\n        {#if componentType === 'button'}\n          Click Me\n        {:else if componentType === 'card'}\n          <h3 slot=\"header\">Card Title</h3>\n          <p>This is card content rendered with svelte:component</p>\n          <div slot=\"footer\">Card Footer</div>\n        {:else if componentType === 'alert'}\n          This is an alert message!\n        {/if}\n      </svelte:component>\n    </div>\n    \n    <div class=\"example\">\n      <h2>svelte:element Example</h2>\n      <!-- Using svelte:element for dynamic HTML elements -->\n      <svelte:element \n        this={elementType} \n        {...elementAttrs}\n        on:click={() => alert(`${elementType} element clicked!`)}\n      >\n        This is a {elementType} element rendered with svelte:element\n      </svelte:element>\n    </div>\n  </div>\n</div>\n\n<style>\n  .demo {\n    padding: 20px;\n    border: 1px solid #ccc;\n    border-radius: 8px;\n  }\n  \n  .controls {\n    display: flex;\n    gap: 20px;\n    margin-bottom: 20px;\n  }\n  \n  .examples {\n    display: flex;\n    gap: 20px;\n  }\n  \n  .example {\n    flex: 1;\n    padding: 15px;\n    border: 1px dashed #ccc;\n    border-radius: 4px;\n  }\n  \n  h2 {\n    margin-top: 0;\n    font-size: 18px;\n  }\n  \n  select {\n    padding: 5px;\n    width: 100%;\n  }\n</style>\n```\n\n### Common Mistakes to Avoid\n\n1. **Using `<svelte:element>` for components**\n   ```svelte\n   <!-- â Wrong - won't work -->\n   <svelte:element this={MyComponent} />\n   \n   <!-- â Correct -->\n   <svelte:component this={MyComponent} />\n   ```\n\n2. **Using `<svelte:component>` for HTML elements**\n   ```svelte\n   <!-- â Wrong - won't work as expected -->\n   <svelte:component this=\"div\" />\n   \n   <!-- â Correct -->\n   <svelte:element this=\"div\" />\n   ```\n\n3. **Trying to use component bindings with `<svelte:element>`**\n   ```svelte\n   <!-- â Wrong - only bind:this works -->\n   <svelte:element this=\"input\" bind:value={inputValue} />\n   \n   <!-- â Correct - use event handlers instead -->\n   <svelte:element \n     this=\"input\" \n     value={inputValue}\n     on:input={(e) => inputValue = e.target.value} \n   />\n   ```\n\nIn summary, use `<svelte:element>` when you need to render different HTML/SVG elements dynamically, and use `<svelte:component>` when you need to render different Svelte components dynamically. Understanding this distinction will help you write more flexible and maintainable Svelte applications."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"What is the purpose of the `<svelte:options>` element in Svelte 5, and where should it be placed in a component file?","answer":"The `<svelte:options>` element provides a way to specify per-component compiler options in Svelte 5. It allows developers to configure how Svelte compiles an individual component without affecting other components in the application.\n\nThe `<svelte:options>` element should typically be placed at the top of your component file, before any markup, script, or style tags. This placement makes it clear that these options apply to the entire component.\n\nExample usage:\n```svelte\n<svelte:options namespace=\"svg\" runes={true} />\n\n<script>\n  // Component logic here\n</script>\n\n<!-- Component markup here -->\n```\n\nThe options specified in `<svelte:options>` will only affect the current component and won't cascade to child components or the rest of your application."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"How can you use `<svelte:options>` to force a component to use runes mode or legacy mode in Svelte 5?","answer":"In Svelte 5, you can explicitly specify whether a component should use runes mode or legacy mode using the `runes` option in the `<svelte:options>` element.\n\nTo force a component into runes mode:\n```svelte\n<svelte:options runes={true} />\n\n<script>\n  let $count = 0;\n  \n  function increment() {\n    $count++;\n  }\n</script>\n\n<button on:click={increment}>Count: {$count}</button>\n```\n\nTo force a component into legacy mode:\n```svelte\n<svelte:options runes={false} />\n\n<script>\n  import { onMount } from 'svelte';\n  \n  let count = 0;\n  \n  function increment() {\n    count += 1;\n  }\n  \n  onMount(() => {\n    console.log('Component mounted in legacy mode');\n  });\n</script>\n\n<button on:click={increment}>Count: {count}</button>\n```\n\nThis option is particularly useful during the transition period when migrating from Svelte 4 to Svelte 5, allowing you to gradually adopt runes in your codebase by explicitly opting components in or out of runes mode."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"What is the `namespace` option in `<svelte:options>` and when would you use it?","answer":"The `namespace` option in `<svelte:options>` specifies the XML namespace where the component will be used. This affects how the component is compiled and rendered. In Svelte 5, there are three possible values:\n\n1. `\"html\"` - The default namespace, used for standard HTML components\n2. `\"svg\"` - Used when creating SVG components\n3. `\"mathml\"` - Used when creating MathML components\n\nYou would use the `namespace` option when creating components that need to be rendered within a specific namespace context, particularly for SVG or MathML content.\n\nExample for an SVG component:\n```svelte\n<svelte:options namespace=\"svg\" />\n\n<script>\n  export let width = 100;\n  export let height = 100;\n  export let fill = 'red';\n</script>\n\n<!-- This component will be compiled as SVG content -->\n<circle cx={width/2} cy={height/2} r={Math.min(width, height)/2} {fill} />\n```\n\nThis component can then be used within an SVG context:\n\n```svelte\n<svg width=\"200\" height=\"200\">\n  <MyCircle fill=\"blue\" />\n</svg>\n```\n\nWithout setting the correct namespace, SVG or MathML elements might not render correctly as the compiler needs to know which DOM API to use for creating elements."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"How can you use `<svelte:options>` to configure a Svelte component as a custom element (web component)?","answer":"The `customElement` option in `<svelte:options>` allows you to configure a Svelte component to be compiled as a custom element (web component). You can either pass a string to specify just the tag name or an object with more detailed configuration options.\n\nBasic usage with just a tag name:\n```svelte\n<svelte:options customElement=\"my-counter\" />\n\n<script>\n  let $count = 0;\n  \n  function increment() {\n    $count++;\n  }\n</script>\n\n<button on:click={increment}>Count: {$count}</button>\n```\n\nMore advanced configuration with an object:\n```svelte\n<svelte:options customElement={{\n  tag: \"my-counter\",\n  shadow: \"open\", // Use open shadow DOM\n  props: {\n    // Define properties and their types\n    initialCount: { type: \"Number\", reflect: true },\n    label: { type: \"String\" }\n  },\n  // Optionally define which events should be forwarded outside the component\n  events: [\"change\", \"update\"]\n}} />\n\n<script>\n  export let initialCount = 0;\n  export let label = \"Count\";\n  \n  let $count = initialCount;\n  \n  function increment() {\n    $count++;\n    dispatchEvent(new CustomEvent('update', { detail: $count }));\n  }\n</script>\n\n<button on:click={increment}>{label}: {$count}</button>\n```\n\nAfter compiling, you can use this component in any HTML file like a standard HTML element:\n```html\n<my-counter initial-count=\"5\" label=\"Current Value\"></my-counter>\n```\n\nThe `customElement` option is powerful for creating reusable web components that can be used in any web application, even those not using Svelte."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"What does the `css=\"injected\"` option do in Svelte 5, and how does it affect server-side rendering versus client-side rendering?","answer":"The `css=\"injected\"` option in `<svelte:options>` controls how a component's styles are handled. When this option is set, the component will inject its styles inline rather than bundling them with other styles.\n\n```svelte\n<svelte:options css=\"injected\" />\n\n<script>\n  // Component logic\n</script>\n\n<div class=\"container\">\n  <h1>Hello World</h1>\n</div>\n\n<style>\n  .container {\n    background-color: #f0f0f0;\n    padding: 20px;\n  }\n  \n  h1 {\n    color: #333;\n  }\n</style>\n```\n\nThe behavior differs between server-side rendering (SSR) and client-side rendering:\n\n1. During server-side rendering:\n   - With `css=\"injected\"`, the styles are injected as a `<style>` tag in the `<head>` of the document.\n   - This ensures that the styles are immediately available when the HTML is rendered, preventing flash of unstyled content (FOUC).\n\n2. During client-side rendering:\n   - With `css=\"injected\"`, the styles are loaded via JavaScript when the component is mounted.\n   - The styles are scoped to the component as usual, but they're injected dynamically rather than being part of a separate CSS bundle.\n\nThis option can be useful when:\n- You need to ensure styles are immediately available for specific components during SSR\n- You're creating a library component that needs to manage its own styles\n- You want to dynamically load styles only when a component is actually used\n\nHowever, using this option may lead to duplicate styles if the same component is used multiple times, so it should be used judiciously."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"Which `<svelte:options>` features from Svelte 4 are deprecated in Svelte 5, and why might they have been deprecated?","answer":"According to the documentation, several `<svelte:options>` features from Svelte 4 have been deprecated in Svelte 5. These deprecated options are:\n\n1. `immutable={true|false}` - This option allowed developers to tell Svelte whether they were using immutable data patterns, enabling optimization in change detection.\n   - When `true`, Svelte would perform simple referential equality checks to determine if values had changed.\n   - When `false` (the default), Svelte would be more conservative about whether mutable objects had changed.\n\n2. `accessors={true|false}` - This option controlled whether Svelte would add getters and setters for the component's props.\n   - When `true`, Svelte would generate getter and setter methods for props, allowing external code to access and modify them.\n   - When `false` (the default), these accessors would not be generated.\n\nThe documentation specifically notes that these options are \"deprecated in Svelte 5 and non-functional in runes mode.\"\n\nThese options were likely deprecated because:\n\n1. The runes system in Svelte 5 fundamentally changes how reactivity works, making the `immutable` option unnecessary. Runes provide a more explicit and consistent way to handle reactivity.\n\n2. With the component model changes in Svelte 5, the component API has been streamlined, and the need for accessors has been reduced or eliminated. The component architecture in Svelte 5 focuses more on explicit state management through runes.\n\nExample of these options in Svelte 4 (now deprecated):\n```svelte\n<!-- Svelte 4 code using deprecated options -->\n<svelte:options immutable={true} accessors={true} />\n\n<script>\n  export let name;\n  export let items = [];\n  \n  // With immutable=true, you'd need to replace the array rather than mutate it\n  function addItem(item) {\n    items = [...items, item]; // Create new array rather than using items.push(item)\n  }\n</script>\n```\n\nIn Svelte 5 with runes, you would instead write:\n```svelte\n<script>\n  let $name = $props.name;\n  let $items = $state([]);\n  \n  function addItem(item) {\n    $items = [...$items, item];\n  }\n</script>\n```\n\nThe runes approach makes the reactivity pattern more explicit and consistent, removing the need for the compiler options."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"How would you create an SVG component in Svelte 5 using the appropriate namespace option, and what issues might occur if you don't specify the correct namespace?","answer":"To create an SVG component in Svelte 5, you should use the `namespace=\"svg\"` option in the `<svelte:options>` element. This tells the Svelte compiler that the component will be rendered as SVG content, ensuring that the correct DOM APIs are used.\n\nHere's an example of a reusable SVG icon component:\n\n```svelte\n<svelte:options namespace=\"svg\" />\n\n<script>\n  export let size = 24;\n  export let color = \"currentColor\";\n  export let viewBox = \"0 0 24 24\";\n  export let strokeWidth = 2;\n</script>\n\n<!-- This is an SVG \"check\" icon -->\n<svg width={size} height={size} {viewBox} fill=\"none\" stroke={color} stroke-width={strokeWidth} stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path d=\"M20 6L9 17l-5-5\" />\n</svg>\n```\n\nYou can then use this component within an SVG context in another component:\n\n```svelte\n<svg>\n  <CheckIcon color=\"green\" size={32} />\n</svg>\n```\n\nIssues that might occur if you don't specify the correct namespace:\n\n1. **Element creation problems**: Without the SVG namespace, the browser might create HTML elements instead of SVG elements, leading to rendering failures.\n\n2. **Attribute handling differences**: SVG has different attribute handling than HTML. For example, in SVG, attributes like `viewBox` are case-sensitive, while HTML is case-insensitive.\n\n3. **DOM API differences**: The DOM APIs for creating SVG elements are different from those for HTML elements. Without the correct namespace, Svelte might use the wrong APIs.\n\n4. **Style application issues**: CSS might be applied differently between HTML and SVG contexts.\n\nExample of what might go wrong:\n\n```svelte\n<!-- Missing namespace, will likely cause problems -->\n<script>\n  export let size = 24;\n</script>\n\n<!-- This might not render correctly without the SVG namespace -->\n<circle cx={size/2} cy={size/2} r={size/3} fill=\"red\" />\n```\n\nWhen using this component in an SVG context, the circle might not appear at all or might render incorrectly because the DOM elements weren't created with the appropriate namespace.\n\nUsing the correct namespace ensures that Svelte generates the appropriate code for the context in which the component will be used."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"Can you use multiple options in a single `<svelte:options>` element? Provide an example of a component that uses several options together.","answer":"Yes, you can specify multiple options in a single `<svelte:options>` element by listing them as separate attributes. This allows you to configure various aspects of how Svelte compiles your component all in one place.\n\nHere's an example of a component that uses several options together:\n\n```svelte\n<svelte:options \n  runes={true}\n  namespace=\"svg\"\n  customElement=\"custom-chart\"\n  css=\"injected\"\n/>\n\n<script>\n  // Use runes for reactivity\n  let $width = $props.width ?? 300;\n  let $height = $props.height ?? 200;\n  let $data = $props.data ?? [];\n  let $color = $props.color ?? \"steelblue\";\n  \n  // Calculate the visualization based on data\n  $effect(() => {\n    console.log(`Rendering chart with ${$data.length} data points`);\n  });\n  \n  // Helper function to scale data to fit the chart\n  function scalePoint(value, min, max) {\n    const dataMin = Math.min(...$data);\n    const dataMax = Math.max(...$data);\n    return min + (value - dataMin) * (max - min) / (dataMax - dataMin || 1);\n  }\n</script>\n\n<!-- SVG chart component with points from the data -->\n<svg width={$width} height={$height}>\n  <rect width={$width} height={$height} fill=\"#f9f9f9\" stroke=\"#ccc\" />\n  \n  {#each $data as point, i}\n    <circle \n      cx={scalePoint(i, 20, $width - 20)} \n      cy={scalePoint(point, $height - 20, 20)} \n      r=\"5\" \n      fill={$color} \n    />\n  {/each}\n</svg>\n\n<style>\n  svg {\n    border-radius: 4px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n  }\n  \n  circle {\n    transition: r 0.2s ease-out;\n  }\n  \n  circle:hover {\n    r: 8;\n  }\n</style>\n```\n\nIn this example:\n\n1. `runes={true}` - Enables runes mode for the component, allowing the use of reactive primitives like `$state`, `$props`, and `$effect`.\n\n2. `namespace=\"svg\"` - Specifies that this component will render SVG content, ensuring the correct DOM APIs are used.\n\n3. `customElement=\"custom-chart\"` - Configures the component to be compiled as a custom element with the tag name \"custom-chart\", allowing it to be used in non-Svelte applications.\n\n4. `css=\"injected\"` - Makes the component inject its styles inline, ensuring they're available immediately during server-side rendering and loaded via JavaScript during client-side rendering.\n\nThis component can now be used in various contexts:\n- As a standard Svelte component within other Svelte components\n- As a custom element in any HTML page: `<custom-chart width=\"500\" height=\"300\" data=\"[10,45,32,87,23]\" color=\"tomato\"></custom-chart>`\n- Within SVG contexts because it specifies the SVG namespace\n\nThe combination of these options makes the component highly versatile and reusable across different environments."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"How does the `customElement` option in `<svelte:options>` differ when you pass a string versus an object? What additional configurations can you specify when using an object?","answer":"When using the `customElement` option in `<svelte:options>`, you can provide either a string or an object, with each approach offering different levels of configuration:\n\n**When passing a string:**\n```svelte\n<svelte:options customElement=\"my-element\" />\n```\n\nThis simple approach only specifies the tag name for the custom element. The string value is used as the `tag` option, and all other settings use default values.\n\n**When passing an object:**\n```svelte\n<svelte:options customElement={{\n  tag: \"my-element\",\n  // Additional configuration options here\n}} />\n```\n\nWith an object, you can specify much more detailed configuration. According to the documentation, the object is passed as the \"options\" when compiling the component as a custom element.\n\nThe additional configurations you can specify include:\n\n1. **`tag`**: (Required) The name of the custom element tag (must include a hyphen as per custom element specs)\n\n2. **`shadow`**: Controls the shadow DOM encapsulation mode\n   - `\"open\"` - Creates an open shadow root (accessible via JavaScript from outside)\n   - `\"closed\"` - Creates a closed shadow root (not accessible from outside)\n   - `\"none\"` - No shadow DOM (styles won't be encapsulated)\n\n3. **`props`**: Defines property descriptors for the custom element, allowing you to specify:\n   - Type information for each property\n   - Whether properties should reflect to attributes\n   - Default values\n   - Custom converters\n\n4. **`events`**: Specifies which events dispatched by the component should be forwarded outside the shadow DOM\n\nHere's a comprehensive example showing these configurations:\n\n```svelte\n<svelte:options customElement={{\n  tag: \"data-table\",\n  shadow: \"open\",\n  props: {\n    // Define type and reflection for each property\n    data: { \n      type: \"Array\", \n      reflect: false,\n      default: [] \n    },\n    sortable: { \n      type: \"Boolean\", \n      reflect: true,\n      default: false \n    },\n    pageSize: { \n      type: \"Number\", \n      reflect: true,\n      default: 10,\n      // Custom converter to ensure pageSize is always a positive number\n      converter: (value) => Math.max(1, parseInt(value) || 10)\n    },\n    theme: {\n      type: \"String\",\n      reflect: true,\n      default: \"light\"\n    }\n  },\n  // Events that should be forwarded outside the shadow DOM\n  events: [\"sort\", \"page\", \"select\", \"filter\"]\n}} />\n\n<script>\n  // Component using runes\n  let $data = $props.data ?? [];\n  let $sortable = $props.sortable ?? false;\n  let $pageSize = $props.pageSize ?? 10;\n  let $theme = $props.theme ?? \"light\";\n  \n  let $currentPage = $state(1);\n  \n  function changePage(page) {\n    $currentPage = page;\n    dispatchEvent(new CustomEvent('page', { \n      detail: { page, pageSize: $pageSize }\n    }));\n  }\n  \n  function sortData(column) {\n    if (!$sortable) return;\n    \n    // Sort logic here\n    dispatchEvent(new CustomEvent('sort', { \n      detail: { column }\n    }));\n  }\n</script>\n\n<div class=\"data-table {$theme}\">\n  <!-- Table implementation here -->\n</div>\n\n<style>\n  .data-table {\n    width: 100%;\n    border-collapse: collapse;\n  }\n  \n  .data-table.dark {\n    background: #333;\n    color: white;\n  }\n  \n  .data-table.light {\n    background: white;\n    color: #333;\n  }\n</style>\n```\n\nWhen this component is compiled, it becomes a custom element that can be used in any HTML with rich configuration:\n\n```html\n<data-table \n  data='[{\"id\":1,\"name\":\"Item 1\"},{\"id\":2,\"name\":\"Item 2\"}]'\n  sortable\n  page-size=\"20\"\n  theme=\"dark\">\n</data-table>\n\n<script>\n  // Listen for events from the custom element\n  document.querySelector('data-table').addEventListener('sort', (event) => {\n    console.log('Sorted by', event.detail.column);\n  });\n</script>\n```\n\nThe object approach provides much finer control over how the custom element behaves when used outside of Svelte, making it more robust for use in diverse environments."}
{"source":"docs/svelte/05-special-elements/07-svelte-options.md","question":"In the context of a Svelte 5 project that's migrating from Svelte 4, how would you strategically use `<svelte:options>` to manage the transition between legacy mode and runes mode? What considerations should developers keep in mind?","answer":"Migrating from Svelte 4 to Svelte 5 requires careful planning, especially when transitioning from legacy reactivity to runes. The `<svelte:options>` element can be a powerful tool to manage this transition strategically. Here's how you might approach it:\n\n### Strategic Migration Approach\n\n1. **Start with a Default Mode**\n\nFirst, decide on a default mode for your project. You might choose to set all components to legacy mode initially and then incrementally migrate to runes:\n\n```js\n// svelte.config.js\nexport default {\n  compilerOptions: {\n    runes: false // Default to legacy mode project-wide\n  }\n  // other config options\n};\n```\n\n2. **Selectively Opt-in Components to Runes Mode**\n\nAs you're ready to migrate specific components, use `<svelte:options>` to explicitly opt them into runes mode:\n\n```svelte\n<!-- NewFeature.svelte - a component you're ready to migrate -->\n<svelte:options runes={true} />\n\n<script>\n  // Using runes syntax\n  let $count = $state(0);\n  let $doubled = $derived($count * 2);\n  \n  function increment() {\n    $count++;\n  }\n</script>\n\n<button on:click={increment}>Count: {$count} (Doubled: {$doubled})</button>\n```\n\n3. **Keep Complex Legacy Components in Legacy Mode**\n\nFor complex components that would require significant refactoring, explicitly keep them in legacy mode:\n\n```svelte\n<!-- ComplexLegacyComponent.svelte -->\n<svelte:options runes={false} />\n\n<script>\n  import { onMount, beforeUpdate, afterUpdate } from 'svelte';\n  \n  export let data;\n  let processedData = [];\n  \n  $: if (data) {\n    processedData = processData(data);\n  }\n  \n  function processData(input) {\n    // Complex data processing\n    return input.map(item => ({ ...item, processed: true }));\n  }\n  \n  onMount(() => {\n    // Legacy lifecycle hooks\n  });\n</script>\n\n<!-- Complex component markup -->\n```\n\n### Considerations for Developers\n\n1. **Component Dependencies**\n\nWhen migrating, consider the dependencies between components. It's often easier to start migrating leaf components (those with no child components) first and then work your way up the component tree.\n\n```\nParentComponent (legacy)\nâââ ChildComponent1 (migrate to runes first)\nâââ ChildComponent2 (migrate to runes first)\nâââ ChildComponent3 (migrate to runes first)\n```\n\n2. **Prop Passing Between Legacy and Runes Components**\n\nWhen passing props between legacy and runes components, be aware of how reactivity works in each mode:\n\n```svelte\n<!-- ParentComponent.svelte (legacy mode) -->\n<svelte:options runes={false} />\n\n<script>\n  let count = 0;\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n\n<button on:click={increment}>Increment</button>\n<ChildComponent value={count} />\n```\n\n```svelte\n<!-- ChildComponent.svelte (runes mode) -->\n<svelte:options runes={true} />\n\n<script>\n  // In runes mode, access props using $props\n  const value = $props.value;\n  \n  // Create a derived value\n  const $doubled = $derived(value * 2);\n</script>\n\n<div>Value: {value}, Doubled: {$doubled}</div>\n```\n\n3. **Store Usage**\n\nSvelte stores work differently in runes mode vs. legacy mode. In a mixed environment:\n\n```svelte\n<!-- Legacy component using stores -->\n<svelte:options runes={false} />\n\n<script>\n  import { writable } from 'svelte/store';\n  \n  const count = writable(0);\n  \n  function increment() {\n    count.update(n => n + 1);\n  }\n</script>\n\n<button on:click={increment}>Count: {$count}</button>\n```\n\n```svelte\n<!-- Runes component using the same store -->\n<svelte:options runes={true} />\n\n<script>\n  import { writable } from 'svelte/store';\n  \n  const count = writable(0);\n  \n  // In runes mode, you can still use $ to subscribe to stores\n  function increment() {\n    count.update(n => n + 1);\n  }\n</script>\n\n<button on:click={increment}>Count: {$count}</button>\n```\n\n4. **Testing Strategy**\n\nImplement a robust testing strategy that covers components in both modes to ensure behavior remains consistent during migration:\n\n```js\n// Example test for a component that works in both modes\ntest('Counter increments in both legacy and runes mode', async () => {\n  // Test legacy mode\n  const legacyCounter = render(Counter, { runes: false });\n  await fireEvent.click(legacyCounter.getByText('Increment'));\n  expect(legacyCounter.getByText('Count: 1')).toBeInTheDocument();\n  \n  // Test runes mode\n  const runesCounter = render(Counter, { runes: true });\n  await fireEvent.click(runesCounter.getByText('Increment'));\n  expect(runesCounter.getByText('Count: 1')).toBeInTheDocument();\n});\n```\n\n5. **Documentation and Team Communication**\n\nMaintain clear documentation about which components use which mode and establish team conventions:\n\n```md\n# Component Migration Status\n\n## Runes Mode Components\n- UserProfile.svelte\n- Dashboard.svelte\n- Navigation.svelte\n\n## Legacy Mode Components\n- ComplexDataTable.svelte\n- LegacyChart.svelte\n- ThirdPartyIntegration.svelte\n\n## Migration Planned\n- ShoppingCart.svelte (Sprint 4)\n- CheckoutFlow.svelte (Sprint 5)\n```\n\n### Example Migration Plan Implementation\n\nHere's a more complete example showing how you might implement a phased migration plan:\n\n1. **Phase 1: Infrastructure Setup**\n\n```js\n// svelte.config.js\nexport default {\n  compilerOptions: {\n    runes: false // Start with legacy mode as default\n  }\n};\n```\n\n2. **Phase 2: Migrate Simple Components**\n\n```svelte\n<!-- Button.svelte -->\n<svelte:options runes={true} />\n\n<script>\n  const type = $props.type ?? 'button';\n  const label = $props.label ?? 'Button';\n  \n  let $hovered = $state(false);\n  \n  function handleMouseEnter() {\n    $hovered = true;\n  }\n  \n  function handleMouseLeave() {\n    $hovered = false;\n  }\n</script>\n\n<button \n  {type} \n  class:hovered={$hovered}\n  on:mouseenter={handleMouseEnter}\n  on:mouseleave={handleMouseLeave}\n  on:click\n>\n  {label}\n</button>\n\n<style>\n  button {\n    padding: 8px 16px;\n    border-radius: 4px;\n    transition: all 0.2s;\n  }\n  \n  .hovered {\n    transform: scale(1.05);\n  }\n</style>\n```\n\n3. **Phase 3: Create Hybrid Components When Needed**\n\n```svelte\n<!-- DataDisplay.svelte - Wrapper that works with both legacy and runes components -->\n<svelte:options runes={true} />\n\n<script>\n  const data = $props.data ?? [];\n  \n  let $displayMode = $state('table');\n</script>\n\n<div class=\"display-container\">\n  <div class=\"controls\">\n    <Button \n      label=\"Table View\" \n      on:click={() => $displayMode = 'table'} \n    />\n    <Button \n      label=\"Chart View\" \n      on:click={() => $displayMode = 'chart'} \n    />\n  </div>\n  \n  <div class=\"content\">\n    {#if $displayMode === 'table'}\n      <!-- Legacy component with explicit mode -->\n      <LegacyDataTable data={data} />\n    {:else}\n      <!-- New runes component -->\n      <DataChart data={data} />\n    {/if}\n  </div>\n</div>\n```\n\n4. **Phase 4: Update Global Project Config When Mostly Migrated**\n\n```js\n// svelte.config.js (updated for phase 4)\nexport default {\n  compilerOptions: {\n    runes: true // Switch default to runes mode\n  }\n};\n```\n\n5. **Phase 5: Explicitly Mark Remaining Legacy Components**\n\n```svelte\n<!-- ComplexLegacyWidget.svelte -->\n<svelte:options runes={false} />\n\n<script>\n  // This component will be migrated later\n  // Complex legacy code that would be time-consuming to migrate\n</script>\n```\n\nBy using `<svelte:options>` strategically, you can manage a gradual, controlled migration from Svelte 4's legacy mode to Svelte 5's runes mode, minimizing disruption while modernizing your codebase."}