{"source":"docs/svelte/01-introduction/01-overview.md","question":"What are the three main building blocks of a Svelte component, and how are they structured in a single file component?","answer":"A Svelte component consists of three main building blocks, all contained within a single .svelte file:\n1. `<script>` - Contains JavaScript logic and component state\n2. Template - The HTML markup (written directly in the file, no wrapper needed)\n3. `<style>` - Component-scoped CSS\n\nHere's an example showing all three parts:\n```svelte\n<script>\n    // JavaScript logic goes here\n    let count = 0;\n    function increment() {\n        count++;\n    }\n</script>\n\n<!-- Template HTML goes here -->\n<button on:click={increment}>\n    Clicked {count} times\n</button>\n\n<style>\n    /* Scoped CSS goes here */\n    button {\n        font-size: 2em;\n    }\n</style>\n```"}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"How does Svelte differ from traditional JavaScript frameworks in terms of its approach to building user interfaces?","answer":"Svelte takes a unique compiler-based approach to building user interfaces, unlike traditional frameworks that do most of their work in the browser at runtime. The key difference is that Svelte processes and converts your components into optimized JavaScript during the build step, rather than shipping the framework code to the browser.\n\nWhen you write a Svelte component, it gets compiled into efficient, standalone JavaScript that precisely updates the DOM when your data changes. This results in:\n- Smaller bundle sizes\n- Better performance\n- No virtual DOM overhead\n- No framework runtime code needed in the browser\n\nThis is different from frameworks like React or Vue, which need to ship their runtime libraries to the browser and perform reconciliation at runtime."}
{"source":"docs/svelte/01-introduction/01-overview.md","question":"What are the different ways to get started with Svelte development, and what are the pros and cons of each approach?","answer":"The documentation outlines several ways to start developing with Svelte:\n\n1. Interactive Tutorial (/tutorial)\n- Pros: Best for beginners, hands-on learning\n- Cons: Not suitable for real project development\n- Recommended for: New developers learning Svelte basics\n\n2. Online Playground (/playground)\n- Pros: Quick experimentation, no setup required\n- Cons: Limited features, not for production development\n- Recommended for: Testing small code snippets or concepts\n\n3. StackBlitz (sveltekit.new)\n- Pros: Full development environment, includes SvelteKit\n- Cons: Dependent on internet connection, some limitations compared to local setup\n- Recommended for: More complex prototyping or learning SvelteKit\n\n4. Local Development with SvelteKit\n- Pros: Full featured, best for real applications\n- Cons: Requires local setup and configuration\n- Recommended for: Production applications and serious development\n\nThe best choice depends on your needs: use the tutorial for learning, playground for quick tests, and local setup with SvelteKit for real project development."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"What are the main differences between starting a new project with SvelteKit versus using Svelte directly with Vite, and when would you choose one over the other?","answer":"SvelteKit and direct Svelte with Vite serve different purposes:\n\nSvelteKit:\n- Official application framework with built-in routing and other features\n- Best for full applications\n- Setup: `npx sv create myapp`\n- Includes additional features like server-side rendering out of the box\n\nSvelte + Vite directly:\n- More minimal setup\n- Setup: `npm create vite@latest` (select svelte option)\n- Outputs static files to `dist` directory\n- Requires manual selection of routing library\n- Better for simpler projects or when you need more control over the setup\n\nChoose SvelteKit for full applications where you'll benefit from its built-in features. Choose Svelte + Vite directly for simpler projects, learning Svelte basics, or when you need more control over the tooling."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"A developer mentions they're getting TypeScript errors in their Svelte code but their VS Code doesn't show any helpful hints. What tools and configurations would you recommend to improve their development experience?","answer":"There are several tools available to improve the Svelte development experience:\n\n1. Install the official VS Code extension:\n```bash\n# Install from VS Code marketplace\nsvelte.svelte-vscode\n```\n\n2. Use the command line checker:\n```bash\n# Install globally\nnpm install -g svelte-cli\n# Check your code\nsv check\n```\n\n3. Additional recommendations:\n- Ensure your project has proper TypeScript configuration\n- Consider using the Vite plugin (`vite-plugin-svelte`) which includes TypeScript support\n- Check the [Svelte Society resources](https://sveltesociety.dev/resources#editor-support) for additional editor integrations\n\nThese tools provide features like syntax highlighting, IntelliSense, error checking, and TypeScript support specifically for Svelte files."}
{"source":"docs/svelte/01-introduction/02-getting-started.md","question":"Your team needs to migrate a legacy Webpack-based Svelte application to a modern build system. Based on the documentation, what would be the recommended approach and what potential challenges should you consider?","answer":"Based on the documentation, here's the recommended migration approach:\n\n1. Primary recommendation: Migrate to Vite\n- The docs explicitly state \"we recommend Vite\"\n- Use `vite-plugin-svelte` for Svelte integration\n- Benefits include faster build times and better developer experience\n\nMigration steps:\n```bash\n# For a basic Vite setup\nnpm create vite@latest\n# Select Svelte option\n\n# For a more full-featured setup\nnpx sv create newapp\n# Migrate code from old project\n```\n\nConsiderations:\n- If using SvelteKit, you'll get additional features but may need to restructure your application\n- If staying with just Vite, you'll need to choose and implement a routing solution\n- Check for Webpack-specific configurations that need to be translated to Vite\n- While Rollup and other build tools are supported, they're not the recommended path\n\nAlternative options exist through plugins for Rollup and Webpack, but these aren't recommended unless there are specific requirements preventing a move to Vite."}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"What are the main sections of a .svelte file and what is the purpose of each? How are they different from regular HTML files?","answer":"A .svelte file consists of three optional sections:\n1. `<script>` - Contains component instance-level JavaScript/TypeScript logic that runs when a component instance is created\n2. `<style>` - Contains CSS that is automatically scoped to the component\n3. Markup - Contains the HTML template for the component\n\nUnlike regular HTML files, .svelte files are a superset of HTML that allow for component-based architecture. Here's an example structure:\n\n```svelte\n<script>\n    // Component logic here\n    let count = 0;\n</script>\n\n<style>\n    /* Styles are automatically scoped to this component */\n    button { color: blue; }\n</style>\n\n<!-- Markup here -->\n<button>{count}</button>\n```"}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"What is the difference between `<script>` and `<script module>` in a Svelte component, and when would you use each?","answer":"The key differences are:\n\n- `<script>` runs for each component instance and contains instance-specific logic\n- `<script module>` runs once when the module first evaluates and is shared across all instances\n\nUse `<script module>` when you need to:\n- Define shared state or logic across all instances of a component\n- Export values that should be accessible when importing the component\n- Initialize module-level variables\n\nExample:\n```svelte\n<script module>\n    let instanceCount = 0;\n    export const getInstanceCount = () => instanceCount;\n</script>\n\n<script>\n    instanceCount += 1;\n    console.log(`I am instance number ${instanceCount}`);\n</script>\n```"}
{"source":"docs/svelte/01-introduction/03-svelte-files.md","question":"How does style scoping work in Svelte components and what are its implications for component-based CSS?","answer":"In Svelte, CSS declared within a `<style>` block is automatically scoped to that component, meaning the styles only affect elements within that component. This is achieved through a unique implementation that:\n\n1. Adds unique identifiers to component styles\n2. Prevents style leakage between components\n3. Allows for component-specific styling without naming conflicts\n\nExample:\n```svelte\n<style>\n    /* This p selector only affects <p> elements in this component */\n    p {\n        color: burlywood;\n    }\n</style>\n\n<p>This paragraph will be burlywood</p>\n```\n\nEven if another component has `p` styles, they won't conflict with this one. This scoping mechanism helps maintain style isolation and makes components more maintainable and reusable.\n\nThese styles are processed at compile time, making it more efficient than runtime CSS-in-JS solutions."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"What is the main difference between regular .js/.ts files and .svelte.js/.svelte.ts files in Svelte 5, and why would you use the latter?","answer":"The main difference is that .svelte.js and .svelte.ts files allow you to use Svelte runes while still behaving like regular JavaScript/TypeScript modules. This is particularly useful in two scenarios:\n1. Creating reusable reactive logic that can be shared across components\n2. Sharing reactive state across your application\nRegular .js/.ts files cannot use runes, making these special file extensions necessary when you need reactivity outside of .svelte components."}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"How would you create a shared reactive counter state that can be used across multiple components using a .svelte.ts file?","answer":"Here's how you could implement a shared counter using a .svelte.ts file:\n\n```typescript\n// counter.svelte.ts\nimport { $state } from 'svelte';\n\nexport const count = $state(0);\nexport const increment = () => count++;\nexport const decrement = () => count--;\n```\n\nYou can then import and use this in any component:\n```svelte\n<script>\n  import { count, increment, decrement } from './counter.svelte.ts';\n</script>\n\n<button on:click={decrement}>-</button>\n<span>{$count}</span>\n<button on:click={increment}>+</button>\n```"}
{"source":"docs/svelte/01-introduction/04-svelte-js-files.md","question":"In Svelte 5, if you want to create a custom reactive hook that manages a timer, would you use a .svelte.js file or a regular .js file, and why?","answer":"You should use a .svelte.js file because you need to use runes to create reactive logic. Here's an example:\n\n```javascript\n// useTimer.svelte.js\nimport { $state, $effect } from 'svelte';\n\nexport function useTimer(initialSeconds) {\n  const time = $state(initialSeconds);\n  let intervalId;\n\n  $effect(() => {\n    intervalId = setInterval(() => {\n      time--;\n      if (time <= 0) {\n        clearInterval(intervalId);\n      }\n    }, 1000);\n\n    return () => clearInterval(intervalId); // cleanup\n  });\n\n  return time;\n}\n```\n\nA regular .js file wouldn't work here because it doesn't support runes ($state and $effect), which are essential for creating reactive logic. The .svelte.js extension is specifically designed for this use case in Svelte 5."}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How do you declare props in Svelte 5, and what are the different ways to handle default values and TypeScript typing for these props?","answer":"In Svelte 5, props are declared using the `$props` rune. Here are the key ways to work with props:\n\nBasic prop declaration:\n```svelte\n<script>\n  let { foo, bar } = $props();\n</script>\n```\n\nWith default values:\n```svelte\n<script>\n  let { foo = 'default value' } = $props();\n</script>\n```\n\nWith TypeScript typing:\n```svelte\n<script lang=\"ts\">\n  interface Props {\n    required: string;\n    optional?: number;\n    [key: string]: unknown;\n  }\n  \n  let { required, optional, ...rest }: Props = $props();\n</script>\n```\n\nYou can also use JSDoc for typing in JavaScript:\n```svelte\n<script>\n  /** @type {{ x: string }} */\n  let { x } = $props();\n</script>\n```"}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"Explain how reactivity works in Svelte 5 with respect to props and state. What's the difference between using regular variable assignment and the $derived rune?","answer":"In Svelte 5, reactivity works differently for props and state variables:\n\nFor local state, you use the `$state` rune to create reactive variables:\n```svelte\n<script>\n  let count = $state(0);\n  \n  function increment() {\n    count = count + 1; // This triggers a re-render\n  }\n</script>\n```\n\nFor derived values based on props or state, you use the `$derived` rune:\n```svelte\n<script>\n  let count = $state(0);\n  let double = $derived(count * 2);\n</script>\n```\n\nImportant distinctions:\n1. Regular variable assignments in `<script>` blocks only run once during component creation\n2. Props updates don't automatically update destructured variables\n3. To react to prop changes, you must use `$derived` or `$effect` runes\n\nExample of prop reactivity issue:\n```svelte\n<script>\n  let { person } = $props();\n  let { name } = person; // Won't update when person changes!\n  \n  // Instead, use:\n  let name = $derived(person.name);\n</script>\n```"}
{"source":"docs/svelte/01-introduction/xx-props.md","question":"How can you create readonly properties in a Svelte 5 component, and what are the limitations when working with reserved words as prop names?","answer":"In Svelte 5, there are two key aspects to handling readonly properties and reserved words:\n\n1. Creating readonly properties:\n```svelte\n<script>\n  // These exports are readonly from outside the component\n  export const CONSTANT = 'unchangeable';\n  export function helper() {\n    return 'can be called but not reassigned';\n  }\n  export class MyClass {\n    // class is readonly\n  }\n</script>\n```\n\n2. Using reserved words as prop names:\n```svelte\n<script>\n  // Use destructuring with renaming for reserved words\n  let { class: className } = $props();\n  \n  // Now use className instead of class in your component\n</script>\n```\n\nKey points:\n- Readonly properties can be accessed using `bind:this` syntax on the component\n- Reserved words can be used as prop names through aliasing\n- The export keyword creates readonly properties that cannot be modified from outside\n- This is useful for creating stable public APIs for your components"}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"How does reactivity in Svelte 5 differ from Svelte 4, and how would you convert a basic reactive counter component from Svelte 4 to Svelte 5?","answer":"In Svelte 5, reactivity is explicitly declared using runes, whereas Svelte 4 used implicit reactivity for top-level variables. The key difference is the introduction of the `$state` rune. Here's a comparison:\n\nSvelte 4:\n```svelte\n<script>\n  let count = 0; // Implicitly reactive\n</script>\n\n<button on:click={() => count++}>\n  Count: {count}\n</button>\n```\n\nSvelte 5:\n```svelte\n<script>\n  let count = $state(0); // Explicitly reactive using $state rune\n</script>\n\n<button onclick={() => count++}>\n  Count: {count}\n</button>\n```\n\nThe new approach with runes is more explicit and can be used anywhere, including class fields, not just at the top level of components."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"Explain how you would implement a shopping cart total calculator in Svelte 5 that automatically updates when items are added or prices change, using both `$state` and `$derived`.","answer":"Here's how to implement a reactive shopping cart total using Svelte 5's reactivity system:\n\n```svelte\n<script>\n  let items = $state([\n    { name: 'Apple', price: 0.50, quantity: 1 },\n    { name: 'Banana', price: 0.30, quantity: 2 }\n  ]);\n  \n  let subtotal = $derived(\n    items.reduce((sum, item) => sum + (item.price * item.quantity), 0)\n  );\n  \n  let total = $derived(subtotal * 1.2); // with 20% tax\n  \n  function addItem(name, price) {\n    items = [...items, { name, price, quantity: 1 }];\n  }\n</script>\n\n<div>\n  {#each items as item}\n    <div>{item.name}: ${item.price} x {item.quantity}</div>\n  {/each}\n  \n  <div>Subtotal: ${subtotal}</div>\n  <div>Total (with tax): ${total}</div>\n</div>\n```\n\nThe `$derived` values automatically update whenever the items array changes. The expression inside `$derived` must be side-effect free, focusing purely on calculating the derived value."}
{"source":"docs/svelte/01-introduction/xx-reactivity-fundamentals.md","question":"How would you use `$effect` to create a component that saves user preferences to localStorage whenever they change, and what are the key considerations when using side effects in Svelte 5?","answer":"Here's how to implement persistent user preferences using `$effect`:\n\n```svelte\n<script>\n  let theme = $state(\n    localStorage.getItem('theme') || 'light'\n  );\n  \n  let fontSize = $state(\n    parseInt(localStorage.getItem('fontSize')) || 16\n  );\n  \n  $effect(() => {\n    // This runs on mount and whenever theme or fontSize change\n    localStorage.setItem('theme', theme);\n    localStorage.setItem('fontSize', fontSize.toString());\n    \n    // Apply the preferences\n    document.body.className = theme;\n    document.body.style.fontSize = `${fontSize}px`;\n  });\n</script>\n\n<div>\n  <select bind:value={theme}>\n    <option value=\"light\">Light</option>\n    <option value=\"dark\">Dark</option>\n  </select>\n  \n  <input \n    type=\"range\" \n    bind:value={fontSize} \n    min=\"12\" \n    max=\"24\"\n  />\n</div>\n```\n\nKey considerations when using `$effect`:\n1. Effects run after DOM updates have been applied\n2. Multiple reactive changes are batched together into a single effect run\n3. Effects should be used for side effects only, not for deriving values (use `$derived` for that)\n4. Effects run on component mount and whenever their dependencies change\n5. You can access DOM elements safely within effects since they run after the DOM is updated"}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"What are Svelte 5 runes and how do they differ from regular JavaScript functions?","answer":"Svelte 5 runes are special compiler-controlled symbols that are part of Svelte's syntax, marked with a `$` prefix. They have three key differences from regular JavaScript functions:\n1. They don't require imports as they're built into the language\n2. They can't be assigned to variables or passed as function arguments\n3. They can only be used in specific positions (similar to JavaScript keywords)\n\nFor example, this is valid rune usage:\n```js\nlet message = $state('hello');\n```\nBut this would be invalid:\n```js\nconst myRune = $state; // Error: Runes cannot be assigned to variables\nsomeFunction($state); // Error: Runes cannot be passed as arguments\n```"}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"In which file types can Svelte runes be used, and what is their primary purpose in the Svelte ecosystem?","answer":"Svelte runes can be used in two types of files:\n1. `.svelte` files (component files)\n2. `.svelte.js` or `.svelte.ts` files (Svelte-specific JavaScript/TypeScript files)\n\nTheir primary purpose is to control the Svelte compiler and provide special functionality within the Svelte ecosystem. They act as keywords in the Svelte language, allowing developers to tap into Svelte's reactive system and other compiler features. This makes them fundamental building blocks for creating reactive and dynamic Svelte applications."}
{"source":"docs/svelte/02-runes/01-what-are-runes.md","question":"How does the transition to runes in Svelte 5 impact existing Svelte applications, and what should developers be aware of regarding backward compatibility?","answer":"The introduction of runes in Svelte 5 represents a significant change in how reactivity and state management are handled. The documentation explicitly notes that \"Runes didn't exist prior to Svelte 5,\" which means:\n\n1. Applications built with earlier versions of Svelte won't use runes\n2. When upgrading to Svelte 5, developers need to be aware that this is a new syntax\n3. Code examples and tutorials from pre-Svelte 5 might need to be adapted to use the new runes system\n\nDevelopers should plan for a careful migration process when upgrading existing applications to Svelte 5, as the introduction of runes represents a fundamental change in how Svelte code is written and structured."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"\"What is the difference between using $state and $state.raw in Svelte 5, and when would you choose one over the other?\"","answer":"The main difference is in how they handle objects and arrays:\n\n- `$state` creates deeply reactive proxies that allow mutation of nested properties and array methods like push(). Changes to any level will trigger UI updates:\n```js\nlet todos = $state([{ done: false, text: 'task' }]);\ntodos[0].done = true; // This works and triggers updates\ntodos.push({ done: false, text: 'new task' }); // This also works\n```\n\n- `$state.raw` creates non-deep reactive state that can only be updated through reassignment:\n```js\nlet person = $state.raw({ name: 'John', age: 30 });\nperson.age = 31; // This won't work\nperson = { ...person, age: 31 }; // This works by creating new object\n```\n\nUse `$state.raw` when:\n1. You're working with large objects/arrays you don't plan to mutate\n2. You want better performance by avoiding proxy creation\n3. You prefer immutable update patterns\n\nUse regular `$state` when you need deep reactivity or want to mutate nested properties."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"\"How does destructuring work with $state proxies, and what potential pitfalls should developers be aware of?\"","answer":"When destructuring values from a $state proxy, the destructured values lose their reactivity. This is a common gotcha that developers need to understand:\n\n```js\nlet user = $state({\n    name: 'Alice',\n    settings: { theme: 'dark' }\n});\n\n// This destructuring breaks reactivity\nlet { name, settings } = user;\n\n// If user.name changes, this destructured 'name' won't update\nuser.name = 'Bob'; // The original 'name' variable still contains 'Alice'\n\n// To maintain reactivity, you should:\n// 1. Access properties directly\n<h1>{user.name}</h1>\n\n// 2. Or use a function/getter if you need to access it multiple times\nconst getName = () => user.name;\n```\n\nThis behavior is consistent with JavaScript's evaluation rules, where destructuring creates new variables with the values at the time of destructuring."}
{"source":"docs/svelte/02-runes/02-$state.md","question":"\"Explain how to properly handle 'this' binding when using $state in classes with event handlers in Svelte 5. Provide examples of both correct and incorrect approaches.\"","answer":"When using classes with $state in Svelte 5, proper 'this' binding is crucial for event handlers. Here are the key approaches:\n\nIncorrect approach (this will fail):\n```js\nclass Todo {\n    done = $state(false);\n    \n    reset() {\n        this.done = false;\n    }\n}\n\n// In component:\n<button onclick={todo.reset}>Reset</button> // 'this' will be the button\n```\n\nCorrect approaches:\n\n1. Using an inline arrow function:\n```js\n<button onclick={() => todo.reset()}>Reset</button>\n```\n\n2. Using arrow functions in the class definition:\n```js\nclass Todo {\n    done = $state(false);\n    \n    reset = () => {\n        this.done = false;\n    }\n}\n\n// Now this works:\n<button onclick={todo.reset}>Reset</button>\n```\n\nThe second approach is often preferred as it:\n- Maintains proper 'this' binding\n- Allows direct method references in event handlers\n- Prevents creating new functions on each render\n- Works consistently with both event handlers and callbacks"}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How does Svelte's push-pull reactivity system work with $derived values, and what are the performance implications?","answer":"Svelte uses a push-pull reactivity system that optimizes when derived values are recalculated. When state changes, all dependencies are immediately notified (push), but derived values are only re-evaluated when they're actually read (pull). Additionally, if a derived value is referentially identical to its previous value, downstream updates are skipped. Here's an example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let isLarge = $derived(count > 10);\n</script>\n\n<button onclick={() => count++}>\n  {isLarge} // Only updates when isLarge actually changes (true/false),\n           // not on every count increment\n</button>\n```\n\nThis system provides automatic performance optimization by avoiding unnecessary recalculations."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"What's the difference between $derived and $derived.by, and when should you use each one?","answer":"$derived and $derived.by serve the same purpose but are used in different scenarios:\n\n- $derived is used for simple, single-expression derivations:\n```svelte\nlet doubled = $derived(count * 2);\n```\n\n- $derived.by is used for complex derivations that require multiple statements or more complex logic:\n```svelte\nlet total = $derived.by(() => {\n  let sum = 0;\n  for (const n of numbers) {\n    sum += n;\n  }\n  return sum;\n});\n```\n\nUnder the hood, $derived(expression) is equivalent to $derived.by(() => expression). Choose $derived for simple, readable expressions and $derived.by when you need more complex logic or multiple statements."}
{"source":"docs/svelte/02-runes/03-$derived.md","question":"How does dependency tracking work with $derived, and what happens if you try to modify state within a derived expression?","answer":"In Svelte 5, $derived automatically tracks any state that is read synchronously within its expression or function body as dependencies. When any of these dependencies change, the derived value is marked as dirty and will be recalculated when next read. However, there are important rules and limitations:\n\n1. Side effects are not allowed in derived expressions - you cannot modify state (e.g., count++) inside a derived expression\n2. Dependencies are tracked automatically for any state accessed within the derived expression\n3. You can exclude state from dependency tracking using the untrack function\n\nExample of proper and improper usage:\n```svelte\n<script>\n  let count = $state(0);\n  \n  // ❌ This would throw an error - no side effects allowed\n  let bad = $derived(count++);\n  \n  // ✅ This is correct\n  let good = $derived(count + 1);\n  \n  // ✅ Using untrack to exclude from dependency tracking\n  let partial = $derived(untrack(() => count) + otherValue);\n</script>\n```"}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"\"Explain the key differences between $effect and $effect.pre in Svelte 5, and provide an example of when you would use $effect.pre instead of regular $effect.\"","answer":"The main difference between $effect and $effect.pre is their timing in relation to DOM updates:\n- $effect runs after DOM updates in a microtask\n- $effect.pre runs before DOM updates\n\n$effect.pre is particularly useful when you need to capture DOM measurements or perform actions before the DOM updates. Here's a practical example:\n\n```svelte\n<script>\n  let messages = $state([]);\n  let chatDiv = $state();\n\n  // Wrong way - might miss some scrolling because DOM isn't updated yet\n  $effect(() => {\n    messages.length; // track changes to messages\n    chatDiv?.scrollTo(0, chatDiv.scrollHeight);\n  });\n\n  // Correct way - ensures proper auto-scrolling\n  $effect.pre(() => {\n    if (!chatDiv) return;\n    messages.length; // track changes to messages\n    \n    if (chatDiv.offsetHeight + chatDiv.scrollTop > chatDiv.scrollHeight - 20) {\n      tick().then(() => {\n        chatDiv.scrollTo(0, chatDiv.scrollHeight);\n      });\n    }\n  });\n</script>\n\n<div bind:this={chatDiv}>\n  {#each messages as message}\n    <p>{message}</p>\n  {/each}\n</div>\n```\n\nThe $effect.pre version is better for this auto-scrolling chat example because it can check the scroll position before the DOM updates, making a more informed decision about whether to auto-scroll."}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"\"How does dependency tracking work in $effect, and what are the limitations when working with asynchronous code? Include an example demonstrating this behavior.\"","answer":"$effect automatically tracks reactive values ($state, $derived, $props) that are read synchronously within its function body. However, values read asynchronously (after await or in setTimeout/setInterval) are not tracked. Here's an example demonstrating this:\n\n```svelte\n<script>\n  let color = $state('#ff3e00');\n  let size = $state(50);\n  let canvas;\n\n  // This effect demonstrates tracking limitations\n  $effect(async () => {\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // color changes will trigger a re-run\n    ctx.fillStyle = color;\n    \n    // size changes will NOT trigger a re-run because it's read asynchronously\n    await new Promise(resolve => setTimeout(resolve, 100));\n    ctx.fillRect(0, 0, size, size);\n  });\n\n  // To fix this, we need to read size synchronously\n  $effect(async () => {\n    const ctx = canvas.getContext('2d');\n    const currentSize = size; // Track size by reading it synchronously\n    \n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = color;\n    \n    await new Promise(resolve => setTimeout(resolve, 100));\n    ctx.fillRect(0, 0, currentSize, currentSize);\n  });\n</script>\n\n<canvas bind:this={canvas} width=\"100\" height=\"100\" />\n```"}
{"source":"docs/svelte/02-runes/04-$effect.md","question":"\"What are the best practices for state synchronization in Svelte 5, and why should you avoid using $effect for this purpose? Provide examples of both anti-patterns and recommended approaches.\"","answer":"You should avoid using $effect for state synchronization because it can lead to more complex and less maintainable code. Here are the recommended approaches:\n\nAnti-pattern (Don't do this):\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $state(0);\n  \n  // Bad: Using effect for state synchronization\n  $effect(() => {\n    doubled = count * 2;\n  });\n</script>\n```\n\nRecommended approaches:\n\n1. Use $derived for computed values:\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n```\n\n2. Use callbacks for two-way synchronization:\n```svelte\n<script>\n  let value1 = $state(0);\n  let value2 = $state(100);\n  \n  function updateValue1(e) {\n    value1 = +e.target.value;\n    value2 = 100 - value1;\n  }\n  \n  function updateValue2(e) {\n    value2 = +e.target.value;\n    value1 = 100 - value2;\n  }\n</script>\n\n<input type=\"range\" value={value1} oninput={updateValue1} />\n<input type=\"range\" value={value2} oninput={updateValue2} />\n```\n\nThe recommended approaches are:\n- More predictable\n- Easier to debug\n- More performant\n- Less likely to cause infinite loops or other side effects\n- More aligned with reactive programming principles"}